# BUG-015: EVM 트랜잭션 확인 타임아웃 시 온체인 성공 건을 FAILED로 처리

## 심각도

**HIGH** — 온체인에서 성공한 트랜잭션이 데몬 DB에 FAILED로 기록됨. AI 에이전트가 트랜잭션 성공 여부를 신뢰할 수 없고, MCP/SDK에서 조회 시 실패로 표시됨.

## 증상

Ethereum Sepolia에서 0.01 ETH 셀프 전송:
- **온체인(Etherscan)**: 성공 (Status: Success)
  - TX: `0x919818c5322bb48b08fc2580158e0d856c1a0005a99b966a66680e84d4943caa`
- **데몬 DB**: FAILED
  - 에러: "트랜잭션 확인(confirmation)을 받지 못했다"
- **Claude Desktop**: "전송이 실패한 것으로 나옵니다"

## 원인

### 1. Stage 6 — 확인 실패 = 무조건 FAILED

`packages/daemon/src/pipeline/stages.ts` 679-715행:

```typescript
export async function stage6Confirm(ctx: PipelineContext): Promise<void> {
  try {
    await ctx.adapter.waitForConfirmation(ctx.submitResult!.txHash, 30_000);
    // 성공 시: CONFIRMED 처리
  } catch (error) {
    // ★ 문제: 모든 에러를 FAILED로 처리
    await ctx.db.update(transactions)
      .set({ status: 'FAILED', error: errorMessage })
      .where(eq(transactions.id, ctx.txId));
  }
}
```

Stage 5에서 트랜잭션이 성공적으로 제출(broadcast)된 후, Stage 6에서 확인을 기다린다. 30초 내 확인이 안 되거나 RPC 에러가 발생하면 **무조건 FAILED**로 처리. 그러나 트랜잭션은 이미 온체인에 제출된 상태이므로 FAILED가 아닌 SUBMITTED가 올바른 상태.

### 2. EVM adapter — 비-타임아웃 에러가 throw됨

`packages/adapters/evm/src/adapter.ts` 401-423행:

```typescript
async waitForConfirmation(txHash: string, timeoutMs = 30_000): Promise<SubmitResult> {
  try {
    const receipt = await client.waitForTransactionReceipt({ hash, timeout: timeoutMs });
    return { txHash, status: receipt.status === 'success' ? 'confirmed' : 'submitted', ... };
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    if (msg.toLowerCase().includes('timeout') || msg.toLowerCase().includes('timed out')) {
      return { txHash, status: 'submitted' };  // ← 타임아웃: throw 안 함
    }
    throw this.mapError(error, '...');  // ← 다른 에러: throw → Stage6에서 FAILED
  }
}
```

무료 Sepolia RPC에서 rate limit, 연결 끊김 등이 발생하면 타임아웃이 아닌 다른 에러로 throw되어 Stage 6에서 FAILED 처리.

### 3. Stage 6 — waitForConfirmation 반환값 미확인

`waitForConfirmation()`이 타임아웃 시 `{ status: 'submitted' }`를 반환해도, Stage 6은 반환값을 확인하지 않고 무조건 CONFIRMED로 처리:

```typescript
try {
  await ctx.adapter.waitForConfirmation(...);  // 반환값 무시
  // ★ 항상 CONFIRMED — 'submitted' 반환 시에도 CONFIRMED
  await ctx.db.update(transactions).set({ status: 'CONFIRMED', ... });
}
```

즉, 두 가지 경로 모두 잘못됨:
- 타임아웃 → `{ status: 'submitted' }` 반환 → Stage 6이 반환값 무시 → **잘못된 CONFIRMED**
- 비-타임아웃 에러 → throw → Stage 6 catch → **잘못된 FAILED**

## 수정안

### 1. EVM adapter — fallback receipt 조회 추가

`packages/adapters/evm/src/adapter.ts` `waitForConfirmation()`:

```typescript
async waitForConfirmation(txHash: string, timeoutMs = 30_000): Promise<SubmitResult> {
  const client = this.getClient();
  try {
    const receipt = await client.waitForTransactionReceipt({
      hash: txHash as `0x${string}`,
      timeout: timeoutMs,
    });
    return {
      txHash,
      status: receipt.status === 'success' ? 'confirmed' : 'failed',
      blockNumber: receipt.blockNumber,
      fee: receipt.gasUsed * receipt.effectiveGasPrice,
    };
  } catch (error) {
    // 타임아웃 또는 RPC 에러 시: receipt 직접 조회로 온체인 상태 확인
    try {
      const receipt = await client.getTransactionReceipt({
        hash: txHash as `0x${string}`,
      });
      // 온체인에 receipt 존재 → 실제 상태 반환
      return {
        txHash,
        status: receipt.status === 'success' ? 'confirmed' : 'failed',
        blockNumber: receipt.blockNumber,
        fee: receipt.gasUsed * receipt.effectiveGasPrice,
      };
    } catch {
      // receipt 조회도 실패 → 아직 블록에 미포함 (pending)
      return { txHash, status: 'submitted' };
    }
  }
}
```

`getTransactionReceipt()`는 폴링 없이 즉시 반환되므로 추가 지연이 거의 없음.

### 2. Stage 6 — 반환값 기반 상태 분기

`packages/daemon/src/pipeline/stages.ts` `stage6Confirm()`:

```typescript
export async function stage6Confirm(ctx: PipelineContext): Promise<void> {
  const reqAmount = getRequestAmount(ctx.request);
  const reqTo = getRequestTo(ctx.request);

  const result = await ctx.adapter.waitForConfirmation(ctx.submitResult!.txHash, 30_000);

  if (result.status === 'confirmed') {
    // 온체인 확인 완료
    await ctx.db.update(transactions)
      .set({ status: 'CONFIRMED', txHash: result.txHash, executedAt: ... })
      .where(eq(transactions.id, ctx.txId));

    void ctx.notificationService?.notify('TX_CONFIRMED', ctx.walletId, { ... });

  } else if (result.status === 'failed') {
    // 온체인에서 revert됨
    await ctx.db.update(transactions)
      .set({ status: 'FAILED', error: 'Transaction reverted on-chain' })
      .where(eq(transactions.id, ctx.txId));

    void ctx.notificationService?.notify('TX_FAILED', ctx.walletId, { ... });

    throw new WAIaaSError('CHAIN_ERROR', { message: 'Transaction reverted on-chain' });

  } else {
    // status === 'submitted': 아직 블록에 미포함
    await ctx.db.update(transactions)
      .set({ status: 'SUBMITTED', txHash: result.txHash })
      .where(eq(transactions.id, ctx.txId));

    // SUBMITTED는 실패가 아니므로 throw하지 않음
    // 향후 비동기 확인 메커니즘으로 최종 상태 업데이트 가능
  }
}
```

### 3. SUBMITTED 상태 활용 (이미 존재)

현재 파이프라인 상태 흐름:
- Stage 5 성공: `PENDING → SUBMITTED` (정상 동작 중)
- Stage 6 성공: `SUBMITTED → CONFIRMED` (반환값 미확인 — 잘못된 CONFIRMED 가능)
- Stage 6 실패: `SUBMITTED → FAILED` (**버그** — SUBMITTED를 유지해야 함)

수정 후:
- Stage 6 `confirmed` 반환: `SUBMITTED → CONFIRMED`
- Stage 6 `failed` 반환: `SUBMITTED → FAILED` (온체인 revert)
- Stage 6 `submitted` 반환: `SUBMITTED` 유지 (확인 미완료, 실패 아님)

`SUBMITTED` 상태는 `packages/core/src/enums/transaction.ts`에 이미 정의되어 있고, DB CHECK 제약에도 포함되어 있으며, Stage 5에서 정상적으로 설정된다. 신규 추가가 아닌 **Stage 6의 잘못된 덮어쓰기 수정**이 핵심.

## Solana 영향

Solana adapter의 `waitForConfirmation()`도 동일한 구조이지만:
- Solana는 블록 타임 ~400ms로 30초 타임아웃이 충분
- `confirmTransaction()` RPC가 안정적

그럼에도 동일한 fallback 패턴 적용이 바람직. `getSignatureStatuses()` RPC로 receipt 직접 조회 가능.

## 영향 범위

| 항목 | 내용 |
|------|------|
| 수정 파일 | `packages/adapters/evm/src/adapter.ts` (waitForConfirmation fallback 추가), `packages/daemon/src/pipeline/stages.ts` (stage6Confirm 반환값 분기) |
| 선택 수정 | `packages/adapters/solana/src/adapter.ts` (동일 fallback 패턴 적용) |
| DB 스키마 | 변경 없음 — SUBMITTED는 이미 CHECK 제약에 포함 |
| API 영향 | 없음 — SUBMITTED 상태는 이미 Stage 5에서 반환 가능. Stage 6 실패 시에도 SUBMITTED 유지 |

## 기존 테스트가 감지하지 못한 이유

- EVM 파이프라인 E2E 테스트는 mock adapter 사용 — `waitForConfirmation`이 항상 `{ status: 'confirmed' }` 반환
- 실제 Sepolia RPC 호출 테스트 없음
- Stage 6의 에러 처리 로직이 "확인 실패 = 트랜잭션 실패"라는 잘못된 전제

## 재발 방지 테스트

```typescript
it('waitForConfirmation 타임아웃 시 receipt fallback으로 온체인 상태를 확인한다', async () => {
  // waitForTransactionReceipt → 타임아웃 throw
  // getTransactionReceipt → { status: 'success' } 반환
  // 결과: { status: 'confirmed' }
});

it('waitForConfirmation RPC 에러 시 receipt 없으면 submitted를 반환한다', async () => {
  // waitForTransactionReceipt → RPC 에러 throw
  // getTransactionReceipt → 에러 throw (receipt 없음)
  // 결과: { status: 'submitted' }
});

it('stage6Confirm이 submitted 상태를 FAILED가 아닌 SUBMITTED로 기록한다', async () => {
  // adapter.waitForConfirmation → { status: 'submitted' }
  // DB 상태: SUBMITTED (FAILED 아님)
});

it('stage6Confirm이 confirmed 상태를 CONFIRMED로 기록한다', async () => {
  // adapter.waitForConfirmation → { status: 'confirmed' }
  // DB 상태: CONFIRMED
});

it('stage6Confirm이 failed 상태를 FAILED로 기록한다', async () => {
  // adapter.waitForConfirmation → { status: 'failed' } (온체인 revert)
  // DB 상태: FAILED
});
```

---

*발견일: 2026-02-13*
*마일스톤: v1.4.1*
*상태: OPEN*
*관련: 설계 문서 32(pipeline), Stage 6 확인 대기*
