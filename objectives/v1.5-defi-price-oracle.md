# 마일스톤 v1.5: DeFi + 가격 오라클

## 목표

USD 기준 정책 평가가 동작하고, Action Provider로 Jupiter Swap 등 DeFi 프로토콜을 에이전트가 사용할 수 있는 상태.

---

## 구현 대상 설계 문서

이 마일스톤에서 구현하는 설계 문서 목록과 각 문서에서 구현할 범위를 명시한다.

| 문서 | 이름 | 구현 범위 | 전체/부분 |
|------|------|----------|----------|
| 61 | price-oracle-spec | IPriceOracle 인터페이스(4개 메서드: getPrice, getPrices, getNativePrice, getCacheStats), CoinGeckoOracle 구현체(Demo API, platformId 매핑), PythOracle 구현체(Hermes REST API, 서브초 갱신), ChainlinkOracle 구현체(EVM onlyRPC), OracleChain fallback 체인(CoinGecko->Pyth->Chainlink), 5분 TTL InMemoryPriceCache(LRU 128항목), 가격 나이 3단계(FRESH<5분/AGING 5~30분/STALE>30분), 교차 검증 인라인(편차>5%->STALE 격하), resolveEffectiveAmountUsd() 함수, SpendingLimitRuleSchema USD 필드 확장, GET /v1/admin/oracle-status 헬스체크 엔드포인트 | 전체 |
| 62 | action-provider-architecture | IActionProvider 인터페이스(metadata/actions/resolve), ActionProviderMetadata Zod 스키마, ActionDefinition Zod 스키마(name/description/inputSchema/chain/riskLevel/defaultTier), ActionContext 타입, resolve-then-execute 패턴 전체 흐름, ActionProviderRegistry(플러그인 발견/로드/검증, ~/.waiaas/actions/ 디렉토리 스캔, ESM dynamic import), validate-then-trust 보안 경계(IActionProvider 인터페이스 준수 + resolve() 반환값 Zod 검증), ActionDefinition->MCP Tool 자동 매핑(zodToJsonSchema 변환, server.tool() 등록), 16개 도구 상한(기존 6개 + Action 최대 10개), REST API POST /v1/actions/:provider/:action 엔드포인트 | 전체 |
| 63 | swap-action-spec | JupiterSwapActionProvider 구현체, JupiterSwapConfig 설정 인터페이스(apiBaseUrl/apiKey/defaultSlippageBps/maxSlippageBps/maxPriceImpactPct/jitoTipLamports), JupiterSwapInputSchema Zod 스키마, Quote API v1 호출(https://api.jup.ag/swap/v1/quote), /swap-instructions API 호출->개별 instruction 획득, ContractCallRequest 변환(Solana programId/instructionData/accounts 매핑), 슬리피지 50bps 기본/500bps 상한, priceImpact 1% 초과 시 거부, Jito MEV 보호(tip amount 설정, Jito 블록 엔진 직접 전송), CONTRACT_WHITELIST 연동(Jupiter 프로그램 주소 화이트리스트 필수) | 전체 |

### v0.10 설계 결정 반영

v0.10에서 확정된 설계 결정을 v1.5 구현에 반영한다:

| 결정 ID | 내용 | 적용 범위 |
|---------|------|----------|
| OPER-03 | Oracle 교차 검증 인라인 + 가격 나이 3단계 FRESH/AGING/STALE: 교차 검증은 백그라운드가 아닌 인라인에서 수행하며, 편차>5%이면 STALE로 격하. 가격 나이는 FRESH(<5분, 정상 평가), AGING(5~30분, 경고 로그 + 정상 평가), STALE(>30분, USD 평가 스킵 -> 네이티브 금액만으로 티어 결정) | IPriceOracle 캐시 로직, OracleChain 교차 검증, resolveEffectiveAmountUsd() 가격 나이 분기 |

### 구현 범위 상세

#### v1.4에서 이미 구현된 부분 (v1.5에서 활용)

- ContractCallRequest 인터페이스 (Solana: programId/instructionData/accounts)
- CONTRACT_WHITELIST 정책 (기본 전면 거부, opt-in 화이트리스트)
- 파이프라인 Stage 5 완전 의사코드 (build->simulate->sign->submit + 에러 분기)
- discriminatedUnion 5-type (TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE/BATCH)
- DatabasePolicyEngine Stage 3 11단계 평가
- ChainError 3-카테고리 (PERMANENT/TRANSIENT/STALE)
- MCP Server 6개 도구 + 3개 리소스 (v1.3에서 구현)

#### v1.5에서 새로 추가하는 부분

- IPriceOracle 서비스 레이어 전체 (인터페이스 + 3개 구현체 + OracleChain)
- InMemoryPriceCache (5분 TTL, LRU 128항목)
- 가격 나이 3단계 판정 로직 (FRESH/AGING/STALE)
- 교차 검증 인라인 (편차>5% -> STALE 격하)
- resolveEffectiveAmountUsd() 함수 (5개 TransactionType 모두 USD 기준 평가)
- SpendingLimitRuleSchema USD 필드 확장 (instant_max_usd, notify_max_usd, delay_max_usd)
- IActionProvider 인터페이스 + ActionProviderRegistry 전체
- ActionDefinition -> MCP Tool 자동 변환 레이어
- JupiterSwapActionProvider 구현체
- REST API: POST /v1/actions/:provider/:action, GET /v1/admin/oracle-status

---

## 산출물

### 컴포넌트

| 컴포넌트 | 내용 |
|----------|------|
| IPriceOracle | 인터페이스 4개 메서드: `getPrice(token: TokenRef): Promise<PriceInfo>`, `getPrices(tokens: TokenRef[]): Promise<Map<string, PriceInfo>>`, `getNativePrice(chain: ChainType): Promise<PriceInfo>`, `getCacheStats(): CacheStats`. TokenRef Zod 스키마(address/symbol?/decimals/chain), PriceInfo Zod 스키마(usdPrice/confidence?/source/fetchedAt/expiresAt/isStale) |
| CoinGeckoOracle | CoinGecko Demo API 구현체. platformId 매핑(solana/ethereum), /simple/token_price 엔드포인트, 무료 티어 rate limit 대응(10-30 req/min). 배치 조회 최적화(getPrices에서 단일 HTTP 요청으로 다수 토큰 조회) |
| PythOracle | Pyth Hermes REST API 구현체. Solana 토큰 대안 소스, 서브초 갱신, confidence interval 활용(PriceInfo.confidence 매핑). https://hermes.pyth.network/v2/updates/price/latest |
| ChainlinkOracle | Chainlink Data Feed 구현체. EVM 전용(viem readContract로 latestRoundData 호출), Chainlink Aggregator 주소 매핑 테이블, 8 소수점 보정 |
| OracleChain | CoinGecko -> Pyth -> Chainlink fallback 체인. Primary 실패/stale 시 다음 소스로 fallback, 모든 소스 실패 시 ORACLE_UNAVAILABLE 에러 반환 -> 정책 평가 거부가 아닌 네이티브 금액만으로 티어 결정. 교차 검증 인라인: 양쪽 성공 시 편차 계산, 편차>5% -> STALE 격하 + PRICE_DEVIATION_WARNING 감사 로그 |
| InMemoryPriceCache | 5분 TTL 인메모리 캐시, LRU 128항목 상한. 캐시 키: `${chain}:${address}`. stale 30분까지 허용(AGING/STALE 구분). CacheStats 모니터링(hits/misses/staleHits/size/evictions) |
| 가격 나이 판정 | classifyPriceAge(fetchedAt): PriceAge 함수. FRESH(<5분) -> 정상 평가, AGING(5~30분) -> 정상 평가 + PRICE_STALE 경고 로그, STALE(>30분) -> USD 평가 스킵 + PRICE_UNAVAILABLE 감사 로그 |
| USD 정책 | resolveEffectiveAmountUsd(input: PipelineInput, priceOracle: IPriceOracle): Promise<bigint \| null>. 5개 TransactionType(TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE/BATCH) 모두 USD 기준 평가. TOKEN_TRANSFER: token.amount * usdPrice, CONTRACT_CALL: value(네이티브) * usdPrice, APPROVE: amount * usdPrice, BATCH: 개별 합산. SpendingLimitRuleSchema 확장: instant_max_usd/notify_max_usd/delay_max_usd 필드 추가. USD 변환 실패 시 네이티브 금액만으로 평가(graceful fallback) |
| IActionProvider | 인터페이스: metadata(ActionProviderMetadata), actions(ActionDefinition[]), resolve(actionName, params, context): Promise<ContractCallRequest>. resolve-then-execute 패턴: resolve()는 반드시 ContractCallRequest만 반환, 서명/제출 수행 금지. ActionContext 타입: agentId/chain/walletAddress 포함 |
| ActionProviderRegistry | 플러그인 발견/로드/검증 서비스. ~/.waiaas/actions/ 디렉토리 스캔, ESM dynamic import로 로드, validate-then-trust(IActionProvider 인터페이스 준수 검증 + resolve() 반환값 Zod 검증). 등록/해제 API: register(provider), unregister(name), getProvider(name), listProviders(). 이름 중복 거부, 내장 프로바이더(jupiter_swap) 우선 로드 |
| MCP Tool 변환 | ActionDefinition -> MCP Tool 자동 매핑. zodToJsonSchema로 inputSchema 변환, server.tool() 등록. 도구 이름: `waiaas_{providerName}_{actionName}` (예: waiaas_jupiter_swap). 16개 도구 상한: 기존 6개 + Action 최대 10개. mcpExpose=true인 프로바이더만 MCP 노출. 동적 도구 등록/해제: 프로바이더 등록 시 MCP 도구 자동 추가, 해제 시 자동 제거 |
| Jupiter Swap | JupiterSwapActionProvider 구현체. Quote API v1 호출(inputMint/outputMint/amount/slippageBps) -> 최적 경로 획득 -> /swap-instructions API 호출 -> 개별 instruction 획득 -> ContractCallRequest 변환(programId=JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4, instructionData/accounts 매핑). priceImpact 1% 초과 시 PRICE_IMPACT_TOO_HIGH 에러로 거부 |
| 슬리피지/MEV | 슬리피지: 기본 50bps(0.5%), 고변동 토큰 500bps(5%) 상한. config.toml [actions.jupiter_swap] 섹션에서 default_slippage_bps/max_slippage_bps 오버라이드. Jito MEV 보호: tip amount 기본 1000 lamports(max 100,000), Jito 블록 엔진 URL로 트랜잭션 직접 전송, 프론트러닝/샌드위치 공격 방지 |

### 파일/모듈 구조

```
packages/core/src/interfaces/
  price-oracle.types.ts          # TokenRef, PriceInfo, CacheStats, IPriceOracle
  action-provider.types.ts       # ActionProviderMetadata, ActionDefinition, ActionContext, IActionProvider

packages/daemon/src/services/
  oracle/
    price-cache.ts               # InMemoryPriceCache (LRU 128, 5분 TTL)
    price-age.ts                 # classifyPriceAge(), PriceAge enum
    coingecko-oracle.ts          # CoinGeckoOracle implements IPriceOracle
    pyth-oracle.ts               # PythOracle implements IPriceOracle
    chainlink-oracle.ts          # ChainlinkOracle implements IPriceOracle
    oracle-chain.ts              # OracleChain (fallback + 교차 검증 인라인)
  policy/
    resolve-effective-amount-usd.ts  # resolveEffectiveAmountUsd()
  action/
    action-provider-registry.ts  # ActionProviderRegistry
    mcp-tool-converter.ts        # ActionDefinition -> MCP Tool 변환

packages/actions/src/
  providers/
    jupiter-swap.ts              # JupiterSwapActionProvider
  index.ts                       # 내장 프로바이더 export

packages/daemon/src/routes/
  actions.ts                     # POST /v1/actions/:provider/:action
  admin.ts                       # GET /v1/admin/oracle-status (확장)
```

### REST API

| 메서드 | 경로 | 인증 | 설명 |
|--------|------|------|------|
| POST | /v1/actions/:provider/:action | sessionAuth | Action Provider resolve -> 파이프라인 실행 |
| GET | /v1/admin/oracle-status | masterAuth | 오라클 캐시 통계 + 소스별 상태 |

---

## 기술 결정 사항

| # | 결정 항목 | 선택지 | 결정 근거 |
|---|----------|--------|----------|
| 1 | CoinGecko API 티어 | 무료 Demo API (rate limit 10-30 req/min) | 5분 TTL 캐시로 요청 빈도 최소화. Pro 키는 config.toml에서 선택적 설정 가능하도록 설계하되, 무료 티어로 동작하는 것이 기본 |
| 2 | Pyth Oracle 접근 방식 | Hermes HTTP API (https://hermes.pyth.network) | 온체인 호출 대비 구현 단순성과 비용 절감. Hermes는 Pyth 공식 REST API로 서브초 갱신 제공. 온체인 Pyth는 Solana 체인 의존성 발생하므로 HTTP API 우선 |
| 3 | Chainlink 지원 범위 | EVM 전용 (Solana 미지원) | Chainlink Data Feed는 EVM 네이티브. Solana에서 Chainlink는 제한적이므로 Pyth가 대안. EVM 토큰 가격 조회에만 Chainlink 사용 |
| 4 | Jupiter API 호출 방식 | fetch 직접 호출 (SDK 미사용) | Jupiter JS SDK는 추가 의존성 + 번들 크기 증가. Quote API/swap-instructions는 단순 REST 호출이므로 native fetch로 충분. 요청 타임아웃 10초, AbortController 사용 |
| 5 | Action Provider 플러그인 포맷 | ESM dynamic import | Node.js 22 ESM 네이티브 지원. CommonJS require는 ESM 모듈 로드 불가. ~/.waiaas/actions/ 디렉토리에서 .mjs 또는 package.json type=module 파일을 import() |
| 6 | MCP Tool 16개 초과 시 우선순위 | config.toml [mcp].tool_priority 배열 | 기존 6개 도구는 항상 포함. Action 도구는 config에 지정된 순서대로 최대 10개까지 등록. 미지정 시 등록 순서 기준 |
| 7 | 슬리피지 기본값 config 위치 | [actions.jupiter_swap] 섹션 | config.toml 평탄화 원칙(v0.7) 준수. default_slippage_bps, max_slippage_bps 키로 오버라이드 |
| 8 | 가격 캐시 구현 | 인메모리 Map 기반 LRU 캐시 | 외부 LRU 라이브러리 의존성 제거. Map + doubly-linked list로 직접 구현(128항목 상한). SQLite 캐시는 불필요(가격 데이터는 휘발성, 데몬 재시작 시 새로 조회) |

---

## E2E 검증 시나리오

**자동화 비율: 95%+ -- `[HUMAN]` 1건**

### USD 정책 평가

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 1 | 5 USDC 전송 -> mock oracle USD $5 평가 -> INSTANT 티어 -> 즉시 실행 | mock IPriceOracle(USDC=$1.0 고정) + 5 USDC TOKEN_TRANSFER -> resolveEffectiveAmountUsd()=$5 -> SPENDING_LIMIT INSTANT 임계값 이내 -> CONFIRMED assert | [L0] |
| 2 | 500 USDC 전송 -> mock oracle USD $500 평가 -> APPROVAL 티어 | mock IPriceOracle(USDC=$1.0 고정) + 500 USDC TOKEN_TRANSFER -> resolveEffectiveAmountUsd()=$500 -> SPENDING_LIMIT APPROVAL 임계값 초과 -> APPROVAL 상태 assert | [L0] |
| 3 | SOL 전송 -> USD 환산 -> 금액별 정책 티어 분류 검증 | mock IPriceOracle(SOL=$150) + 0.01 SOL($1.5) -> INSTANT, 5 SOL($750) -> APPROVAL 등 4-tier 경계값 검증 | [L0] |
| 4 | TOKEN_TRANSFER USD 변환 성공 -> USD 기준 SPENDING_LIMIT 평가 | instant_max_usd=10 설정 + 5 USDC($5) -> INSTANT, 15 USDC($15) -> NOTIFY 전이 assert | [L0] |
| 5 | USD 변환 실패(오라클 장애) -> 네이티브 금액만으로 티어 결정 (graceful fallback) | mock IPriceOracle 전체 실패 + SOL 전송 -> 네이티브 금액 기준 SPENDING_LIMIT 평가 -> fallback 정상 동작 assert | [L0] |

### Oracle fallback + 가격 나이

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 6 | CoinGecko 장애 -> Pyth fallback -> 정상 가격 반환 | mock CoinGeckoOracle 에러 throw + mock PythOracle 정상 반환 -> OracleChain.getPrice() 성공 + source='pyth' assert | [L0] |
| 7 | CoinGecko + Pyth 장애 -> Chainlink fallback -> 정상 가격 반환 | CoinGecko/Pyth 실패 + Chainlink 성공 -> source='chainlink' assert | [L0] |
| 8 | 모든 소스 장애 -> ORACLE_UNAVAILABLE 에러 -> 네이티브 금액만으로 티어 결정 | 3개 소스 모두 실패 -> resolveEffectiveAmountUsd()=null -> 네이티브 fallback assert | [L0] |
| 9 | 가격 나이 FRESH(<5분) -> 정상 평가 | fetchedAt = now() - 3분 -> classifyPriceAge()='FRESH' -> 정상 USD 평가 통과 assert | [L0] |
| 10 | 가격 나이 AGING(5~30분) -> 경고 로그 + 정상 평가 | fetchedAt = now() - 15분 -> classifyPriceAge()='AGING' -> PRICE_STALE 경고 로그 기록 + 정상 USD 평가 assert | [L0] |
| 11 | 가격 나이 STALE(>30분) -> USD 평가 스킵 -> 네이티브 금액만으로 티어 결정 | fetchedAt = now() - 45분 -> classifyPriceAge()='STALE' -> resolveEffectiveAmountUsd()=null -> PRICE_UNAVAILABLE 감사 로그 + 네이티브 fallback assert | [L0] |
| 12 | 교차 검증: 두 소스 편차 <=5% -> Primary 가격 채택 | CoinGecko=$150, Pyth=$148 (편차 1.3%) -> Primary 가격 채택 + isStale=false assert | [L0] |
| 13 | 교차 검증: 두 소스 편차 >5% -> STALE 격하 + PRICE_DEVIATION_WARNING 감사 로그 | CoinGecko=$150, Pyth=$120 (편차 20%) -> isStale=true 강제 + PRICE_DEVIATION_WARNING 로그 기록 assert | [L0] |

### Action Provider

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 14 | jupiter-swap resolve -> ActionPlan(ContractCallRequest) 반환 | mock Jupiter Quote API + /swap-instructions 응답 -> JupiterSwapActionProvider.resolve() -> ContractCallRequest 반환 + programId=JUP6 assert | [L0] |
| 15 | jupiter-swap execute -> ContractCallRequest 생성 -> 파이프라인 Stage 1-5 실행 | mock Jupiter API + mock SolanaAdapter -> resolve() -> ContractCallRequest -> 파이프라인 실행 -> 상태 전이 assert | [L0] |
| 16 | ActionProviderRegistry: 커스텀 플러그인 로드 -> 도구 목록 추가 | 테스트 IActionProvider 플러그인(.mjs) 작성 -> ~/.waiaas/actions/ 배치 -> registry.loadPlugins() -> listProviders()에 포함 assert | [L0] |
| 17 | ActionProviderRegistry: 유효하지 않은 플러그인 -> 로드 거부 + 에러 로그 | metadata 누락된 잘못된 모듈 -> registry.loadPlugins() -> 로드 거부 + 에러 로그 기록 assert | [L0] |
| 18 | ActionProviderRegistry: 이름 중복 플러그인 -> 등록 거부 | 동일 name의 두 프로바이더 -> 두 번째 register() 실패 assert | [L0] |

### MCP 통합

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 19 | MCP: ActionDefinition -> waiaas_jupiter_swap 도구 자동 노출 | jupiter_swap 프로바이더(mcpExpose=true) 등록 -> MCP tool 목록에 waiaas_jupiter_swap 포함 assert | [L0] |
| 20 | MCP: mcpExpose=false 프로바이더 -> MCP 도구 미등록 | mcpExpose=false 테스트 프로바이더 등록 -> MCP tool 목록에 미포함 assert | [L0] |
| 21 | MCP: 16개 초과 Action -> 상한 적용 확인 | 기존 6개 + 11개 Action 프로바이더 등록 시도 -> 16개 상한 적용, 11번째 Action 미등록 assert | [L0] |
| 22 | MCP: 동적 도구 등록/해제 -> 프로바이더 해제 시 MCP 도구 자동 제거 | 프로바이더 register -> MCP 도구 포함 확인 -> unregister -> MCP 도구 제거 확인 assert | [L0] |

### 슬리피지/MEV

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 23 | 슬리피지: 기본 50bps 적용 확인 | JupiterSwapActionProvider 기본 설정 -> Quote API 호출 시 slippageBps=50 파라미터 assert | [L0] |
| 24 | 슬리피지: config.toml 오버라이드 적용 | [actions.jupiter_swap] default_slippage_bps=100 설정 -> slippageBps=100 적용 assert | [L0] |
| 25 | 슬리피지: max_slippage_bps 초과 요청 -> 상한 적용 | 사용자 slippageBps=1000 요청 -> max 500 적용 assert | [L0] |
| 26 | priceImpact 1% 초과 -> PRICE_IMPACT_TOO_HIGH 에러 거부 | mock Quote API priceImpactPct=2.5 반환 -> resolve() PRICE_IMPACT_TOO_HIGH 에러 assert | [L0] |
| 27 | Jito MEV 보호: tip 포함 트랜잭션 빌드 확인 | mock /swap-instructions -> ContractCallRequest에 Jito tip instruction 포함 assert | [L0] |

### 외부 API 실 호출

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 28 | Jupiter API 실 호출 Devnet 검증 | Solana Devnet에서 Jupiter Quote API v1 실 호출 -> SOL/USDC 견적 조회 성공 확인 (CI nightly 또는 수동) | [HUMAN] |

---

## 의존

| 의존 대상 | 이유 |
|----------|------|
| v1.4 (토큰 + 컨트랙트 확장) | ContractCallRequest 인터페이스, CONTRACT_WHITELIST 정책, 파이프라인 Stage 5 의사코드, discriminatedUnion 5-type, DatabasePolicyEngine 11단계 평가가 v1.4에서 구현됨. Action Provider의 resolve()가 ContractCallRequest를 반환하여 기존 파이프라인에 주입하므로, v1.4 파이프라인이 완성되어야 v1.5 Action이 동작한다 |

---

## 리스크

| # | 리스크 | 영향 | 대응 방안 |
|---|--------|------|----------|
| 1 | CoinGecko API rate limit (무료 티어 10-30 req/min) | 다수 토큰 가격 동시 조회 시 rate limit 도달 가능 | 5분 TTL 캐시로 완화. getPrices() 배치 조회로 요청 최소화. Pro 키 선택적 지원(config.toml) |
| 2 | Jupiter API 버전 변경 (v6 -> v7 마이그레이션 가능성) | API 엔드포인트/응답 포맷 변경 시 Swap Action 파손 | Jupiter API 래퍼로 추상화(JupiterApiClient 클래스). 버전 변경 시 래퍼만 수정. Quote/swap-instructions 응답 Zod 스키마로 런타임 검증 |
| 3 | Pyth/Chainlink 온체인 데이터 접근 비용 | Pyth 온체인 호출 시 Solana 트랜잭션 비용, Chainlink EVM readContract 비용 | Hermes HTTP API 우선(무료, 온체인 불필요). Chainlink는 RPC readContract(view 함수, 가스 비용 0)로 비용 없음 |
| 4 | Action Provider 플러그인 보안 (임의 코드 실행) | 악의적 플러그인이 시스템 리소스 접근 가능 | 샌드박스 없이 validate-then-trust: IActionProvider 인터페이스 준수 검증 + resolve() 반환값 Zod 검증. 플러그인은 Owner가 직접 설치하므로 신뢰 경계는 Owner 책임. v1.5 범위 외: 향후 VM 격리 검토(MEDIUM M2) |
| 5 | MCP Tool 16개 상한 시 우선순위 충돌 | 다수 Action Provider 등록 시 어떤 도구가 MCP에 노출되는지 예측 어려움 | config.toml [mcp].tool_priority 배열로 명시적 우선순위. 미지정 시 등록 순서. 기존 6개 도구는 항상 보장 |
| 6 | 교차 검증 인라인 편차 임계값 튜닝 | 5% 임계값이 특정 토큰(저유동성)에서 오탐 발생 가능 | 5% 기본값, config.toml [oracle].cross_validation_threshold_pct로 오버라이드 가능. 토큰별 임계값은 v1.5 범위 외 |
| 7 | Jupiter /swap-instructions 응답 포맷 변경 | instruction 구조 변경 시 ContractCallRequest 변환 실패 | 응답 Zod 스키마 검증으로 런타임 감지. 파싱 실패 시 ACTION_API_ERROR 에러 코드 반환 + 감사 로그 |

---

*최종 업데이트: 2026-02-09 v1.0 구현 계획 기반 생성, v0.10 설계 결정(OPER-03 Oracle 교차 검증 인라인 + 가격 나이 3단계) 반영, 설계 문서 61/62/63 참조*
