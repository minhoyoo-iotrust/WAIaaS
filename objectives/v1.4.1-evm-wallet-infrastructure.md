# 마일스톤 v1.4.1: EVM 지갑 인프라

## 목표

EVM 체인용 에이전트 생성(secp256k1 키 생성 + 0x 주소 파생)이 동작하고, 데몬이 에이전트의 chain 필드에 따라 적절한 체인 어댑터를 선택하여 EVM 네이티브 전송(ETH, MATIC 등)이 가능한 상태. v1.4에서 구현한 `@waiaas/adapter-evm`과 결합하여 EVM 지갑의 풀 라이프사이클을 완성한다.

---

## 배경

v1.4에서 `@waiaas/adapter-evm` 패키지(viem 2.x 기반 체인 어댑터)를 구현하지만, 실제 EVM 지갑을 운용하려면 어댑터 외에 3개 인프라 계층의 변경이 필요하다:

| 계층 | 현재 상태 | 문제 |
|------|----------|------|
| Keystore | Ed25519만 생성, `chain !== 'solana'` 하드코딩 거부 | secp256k1 키 생성 불가 → EVM 에이전트 생성 자체가 불가 |
| Daemon | `new SolanaAdapter('devnet')` 하드코딩 | agent.chain 기반 어댑터 분기 없음 → EVM 트랜잭션 실행 불가 |
| Config | `rpc_solana_*` 3개 + `ethereum_mainnet`/`ethereum_sepolia` 2개(빈 기본값) 존재 | EVM RPC 기본값 미제공 + Tier 1 5체인 네이밍 규칙(`rpc_evm_{chain}_{net}`) 미반영 |

이 3건은 설계 단계(v0.2~v0.8)에서 멀티체인을 전제로 설계했으나 구현 계획에서 누락된 항목이다.

---

## 지원 EVM 체인

### 설계 원칙

모든 EVM 호환 체인은 동일한 암호학적 기반(secp256k1 + keccak256 주소 파생)을 공유한다. 따라서:

- **하나의 secp256k1 키 = 모든 EVM 체인에서 동일한 0x 주소**
- `chain: 'ethereum'`은 "EVM 호환 체인"을 의미 (Ethereum에 한정하지 않음)
- 구체적인 EVM 체인은 `network` 필드 + RPC 엔드포인트 + chainId로 구분
- `@waiaas/adapter-evm`는 viem의 `Chain` 정의를 사용하여 모든 EVM 체인을 단일 어댑터로 지원

### EVM 체인 목록

#### Tier 1: 기본 지원 (config.toml에 기본 RPC 포함)

| 체인 | chainId | 네이티브 토큰 | viem chain | network 값 | 테스트넷 |
|------|---------|-------------|------------|-----------|---------|
| Ethereum | 1 | ETH | `mainnet` | `ethereum-mainnet` | Sepolia (11155111) |
| Polygon | 137 | POL | `polygon` | `polygon-mainnet` | Amoy (80002) |
| Arbitrum One | 42161 | ETH | `arbitrum` | `arbitrum-mainnet` | Sepolia (421614) |
| Optimism | 10 | ETH | `optimism` | `optimism-mainnet` | Sepolia (11155420) |
| Base | 8453 | ETH | `base` | `base-mainnet` | Sepolia (84532) |

#### Tier 2: 확장 지원 (사용자가 config.toml에 RPC 직접 설정)

| 체인 | chainId | 네이티브 토큰 | viem chain | 비고 |
|------|---------|-------------|------------|------|
| BNB Smart Chain | 56 | BNB | `bsc` | 높은 TVL, DeFi 활성 |
| Avalanche C-Chain | 43114 | AVAX | `avalanche` | 서브넷 생태계 |
| zkSync Era | 324 | ETH | `zkSync` | ZK Rollup, EIP-4337 네이티브 |
| Linea | 59144 | ETH | `linea` | Consensys ZK Rollup |
| Scroll | 534352 | ETH | `scroll` | ZK Rollup |
| Blast | 81457 | ETH | `blast` | 네이티브 수익률 |

#### 커스텀 체인 지원

Tier 1/2에 없는 EVM 체인도 `config.toml`에 RPC URL + chainId를 직접 설정하여 사용 가능:

```toml
# 커스텀 EVM 체인 예시
rpc_evm_custom_42170 = "https://nova.arbitrum.io/rpc"  # Arbitrum Nova (chainId 42170)
```

---

## 구현 대상

이 마일스톤에서 변경하는 컴포넌트:

| 컴포넌트 | 패키지 | 변경 유형 | 내용 |
|----------|--------|----------|------|
| LocalKeyStore | `@waiaas/daemon` | 확장 | secp256k1 키 생성 + keccak256 주소 파생 분기 추가 |
| KeystoreFileV1 | `@waiaas/daemon` | 확장 | `curve` 필드 추가 (`ed25519` \| `secp256k1`) |
| Daemon lifecycle | `@waiaas/daemon` | 수정 | 어댑터 팩토리 패턴으로 전환 (agent.chain 기반 동적 선택) |
| ConfigSchema | `@waiaas/core` | 확장 | EVM RPC 엔드포인트 + EVM 기본 체인 설정 |
| NetworkType enum | `@waiaas/core` | 확장 | EVM 네트워크 값 추가 |
| DB migration v2 | `@waiaas/daemon` | 신규 | schema_version 2: 기존 데이터 호환 (변경 없는 증분) |

### 변경하지 않는 것

| 컴포넌트 | 이유 |
|----------|------|
| ChainType enum | `['solana', 'ethereum']` 유지. 'ethereum'이 전체 EVM 체인을 포괄 |
| agents 테이블 스키마 | `chain`, `network` 컬럼 이미 존재, CHECK 제약에 'ethereum' 포함 |
| IChainAdapter 인터페이스 | 체인 무관 설계, 변경 불필요 |
| 파이프라인 6-stage | 체인 무관 설계, 어댑터만 교체하면 동작 |
| PolicyEngine | 체인 무관 설계, 변경 불필요 |
| REST API 스키마 | CreateAgentRequest에 `chain: 'ethereum'` 이미 허용 |

---

## 산출물

### 1. Keystore 멀티커브 지원

현재 `LocalKeyStore.generateKeyPair()`는 Ed25519만 지원하고 `chain !== 'solana'`이면 하드코딩 거부한다. EVM 분기를 추가한다.

#### 키 생성 분기

| chain | 암호 커브 | 키 크기 | 주소 파생 | 라이브러리 |
|-------|----------|---------|----------|-----------|
| `solana` | Ed25519 | 공개 32B, 비밀 64B | Base58(publicKey) | sodium-native (기존) |
| `ethereum` | secp256k1 | 공개 65B (비압축), 비밀 32B | `0x` + keccak256(publicKey[1:])[12:] + EIP-55 체크섬 | viem (`privateKeyToAccount`) |

#### 구현 방식

```
generateKeyPair(agentId, chain, masterPassword):
  if chain === 'solana':
    // 기존 Ed25519 로직 (변경 없음)
    sodium.crypto_sign_keypair() → base58 주소

  if chain === 'ethereum':
    // 1. 32바이트 랜덤 비밀키 생성
    privateKey = crypto.getRandomValues(32)

    // 2. viem으로 주소 파생
    account = privateKeyToAccount(privateKey)
    address = account.address  // 0x + EIP-55 체크섬

    // 3. 비밀키 암호화 (기존 AES-256-GCM + Argon2id 동일)
    encrypted = encrypt(privateKey, masterPassword)

    // 4. 평문 즉시 제로화
    privateKey.fill(0)

    return { publicKey: address, encryptedPrivateKey }
```

#### KeystoreFileV1 확장

```typescript
interface KeystoreFileV1 {
  version: 1;
  id: string;
  chain: string;
  network: string;
  curve: 'ed25519' | 'secp256k1';  // ← 신규 필드
  publicKey: string;                // Solana: base58, EVM: 0x-checksummed
  crypto: { /* 기존 동일 */ };
  metadata: { /* 기존 동일 */ };
}
```

**하위 호환:** 기존 Solana 키스토어 파일에 `curve` 필드가 없으면 `'ed25519'`로 간주. `readKeystoreFile()` 시 기본값 적용.

#### 보안 고려사항

| 항목 | 대응 |
|------|------|
| secp256k1 비밀키 노출 | 32바이트 비밀키만 암호화 저장 (Ed25519과 동일 패턴). 복호화 후 sodium guarded memory 사용 |
| 주소 파생 정확성 | viem `privateKeyToAccount` 사용으로 EIP-55 체크섬 보장. 자체 구현 금지 |
| 엔트로피 품질 | `crypto.getRandomValues()` (Node.js CSPRNG) 사용. sodium의 `randombytes_buf`도 허용 |

### 2. 어댑터 팩토리

현재 데몬 시작 시 `new SolanaAdapter('devnet')` 하드코딩을 어댑터 팩토리 패턴으로 전환한다.

#### 설계

```
// daemon.ts Step 4 변경

createChainAdapter(chain, network, config):
  if chain === 'solana':
    adapter = new SolanaAdapter(network)
    rpcUrl = config.rpc[`solana_${network}`]

  if chain === 'ethereum':
    adapter = new EvmAdapter(network)
    rpcUrl = config.rpc[`evm_${network}`] ?? config.rpc.evm_default

  adapter.connect(rpcUrl)
  return adapter
```

#### 멀티 어댑터 관리

하나의 데몬이 여러 체인의 에이전트를 동시에 관리할 수 있어야 한다:

| 전략 | 설명 |
|------|------|
| **어댑터 풀** | `Map<string, IChainAdapter>` — `${chain}:${network}` 키로 어댑터 인스턴스 캐싱 |
| **지연 초기화** | 데몬 시작 시 전체 초기화 대신, 에이전트 요청 시 해당 체인 어댑터 lazy init |
| **정리** | `daemon.shutdown()` 시 모든 어댑터 `disconnect()` 호출 |

```
// AdapterPool
class AdapterPool {
  private adapters: Map<string, IChainAdapter> = new Map();

  async getAdapter(chain, network, config): Promise<IChainAdapter>
    key = `${chain}:${network}`
    if adapters.has(key): return adapters.get(key)

    adapter = createChainAdapter(chain, network, config)
    adapters.set(key, adapter)
    return adapter

  async disconnectAll(): void
    for adapter of adapters.values():
      await adapter.disconnect()
    adapters.clear()
}
```

#### 트랜잭션 파이프라인 연동

현재 파이프라인은 단일 `adapter: IChainAdapter`를 주입받는다. 변경 후:

```
// 트랜잭션 처리 시
agent = db.getAgent(agentId)
adapter = adapterPool.getAdapter(agent.chain, agent.network, config)
pipeline.execute(tx, adapter)  // 기존 파이프라인 코드 변경 없음
```

파이프라인 자체는 `IChainAdapter` 인터페이스에만 의존하므로 코드 변경 불필요.

### 3. Config 확장

#### 신규 config.toml 키

```toml
# === 기존 Solana RPC (변경 없음) ===
rpc_solana_mainnet = "https://api.mainnet-beta.solana.com"
rpc_solana_devnet  = "https://api.devnet.solana.com"
rpc_solana_testnet = "https://api.testnet.solana.com"

# === EVM RPC (신규 추가) ===
# Tier 1 체인 기본값 제공 (공용 RPC, 프로덕션에서는 전용 RPC 권장)
rpc_evm_ethereum_mainnet  = "https://eth.drpc.org"
rpc_evm_ethereum_sepolia  = "https://sepolia.drpc.org"
rpc_evm_polygon_mainnet   = "https://polygon.drpc.org"
rpc_evm_polygon_amoy      = "https://polygon-amoy.drpc.org"
rpc_evm_arbitrum_mainnet  = "https://arbitrum.drpc.org"
rpc_evm_arbitrum_sepolia  = "https://arbitrum-sepolia.drpc.org"
rpc_evm_optimism_mainnet  = "https://optimism.drpc.org"
rpc_evm_optimism_sepolia  = "https://optimism-sepolia.drpc.org"
rpc_evm_base_mainnet      = "https://base.drpc.org"
rpc_evm_base_sepolia      = "https://base-sepolia.drpc.org"

# EVM 기본 네트워크 (에이전트 생성 시 network 미지정 시 사용)
evm_default_network = "ethereum-sepolia"
```

#### ConfigSchema 변경

```typescript
// 기존 17키 → 28키 (rpc_evm_* 10개 + evm_default_network 1개 순수 추가, 순증 11개)
export const ConfigSchema = z.object({
  // ... 기존 17키 ...

  // EVM RPC endpoints (Tier 1)
  rpc_evm_ethereum_mainnet: z.string().url().default('https://eth.drpc.org'),
  rpc_evm_ethereum_sepolia: z.string().url().default('https://sepolia.drpc.org'),
  rpc_evm_polygon_mainnet: z.string().url().default('https://polygon.drpc.org'),
  rpc_evm_polygon_amoy: z.string().url().default('https://polygon-amoy.drpc.org'),
  rpc_evm_arbitrum_mainnet: z.string().url().default('https://arbitrum.drpc.org'),
  rpc_evm_arbitrum_sepolia: z.string().url().default('https://arbitrum-sepolia.drpc.org'),
  rpc_evm_optimism_mainnet: z.string().url().default('https://optimism.drpc.org'),
  rpc_evm_optimism_sepolia: z.string().url().default('https://optimism-sepolia.drpc.org'),
  rpc_evm_base_mainnet: z.string().url().default('https://base.drpc.org'),
  rpc_evm_base_sepolia: z.string().url().default('https://base-sepolia.drpc.org'),
  evm_default_network: z.string().default('ethereum-sepolia'),
});
```

#### 환경변수 매핑

config.toml 평탄화 규칙(v0.7 Phase 30) 적용:

```
WAIAAS_RPC_EVM_ETHEREUM_MAINNET=https://eth.llamarpc.com
WAIAAS_RPC_EVM_POLYGON_MAINNET=https://polygon-rpc.com
WAIAAS_EVM_DEFAULT_NETWORK=ethereum-mainnet
```

### 4. NetworkType 확장

#### 현재

```typescript
export const NETWORK_TYPES = ['mainnet', 'devnet', 'testnet'] as const;
```

#### 변경

```typescript
export const NETWORK_TYPES = [
  // Solana
  'mainnet', 'devnet', 'testnet',
  // EVM Tier 1
  'ethereum-mainnet', 'ethereum-sepolia',
  'polygon-mainnet', 'polygon-amoy',
  'arbitrum-mainnet', 'arbitrum-sepolia',
  'optimism-mainnet', 'optimism-sepolia',
  'base-mainnet', 'base-sepolia',
] as const;
```

#### DB CHECK 제약 마이그레이션

agents 테이블의 `CHECK (network IN (...))` 제약 갱신 필요. SQLite는 ALTER TABLE로 CHECK 변경 불가하므로 다음 전략 사용:

| 방법 | 설명 |
|------|------|
| **테이블 재생성** | schema_version 2 마이그레이션에서 agents 테이블을 새 CHECK 제약으로 재생성 (CREATE → INSERT SELECT → DROP → RENAME). 기존 데이터 100% 보존 |
| **기존 데이터 호환** | Solana 에이전트의 network ('mainnet'/'devnet'/'testnet')는 새 enum에도 포함되어 마이그레이션 영향 없음 |

### 5. EVM chainId 매핑 테이블

어댑터가 network 값으로부터 viem Chain + chainId를 결정하는 매핑:

```typescript
// packages/adapter-evm/src/chains.ts
import { mainnet, sepolia, polygon, polygonAmoy, arbitrum,
         arbitrumSepolia, optimism, optimismSepolia, base,
         baseSepolia } from 'viem/chains';

export const EVM_CHAIN_MAP = {
  'ethereum-mainnet':  { chain: mainnet,          chainId: 1 },
  'ethereum-sepolia':  { chain: sepolia,          chainId: 11155111 },
  'polygon-mainnet':   { chain: polygon,          chainId: 137 },
  'polygon-amoy':      { chain: polygonAmoy,      chainId: 80002 },
  'arbitrum-mainnet':  { chain: arbitrum,          chainId: 42161 },
  'arbitrum-sepolia':  { chain: arbitrumSepolia,   chainId: 421614 },
  'optimism-mainnet':  { chain: optimism,          chainId: 10 },
  'optimism-sepolia':  { chain: optimismSepolia,   chainId: 11155420 },
  'base-mainnet':      { chain: base,              chainId: 8453 },
  'base-sepolia':      { chain: baseSepolia,       chainId: 84532 },
} as const;

export type EvmNetwork = keyof typeof EVM_CHAIN_MAP;
```

---

## 기술 결정 사항

| # | 결정 항목 | 선택지 | 결정 근거 |
|---|----------|--------|----------|
| 1 | secp256k1 키 생성 라이브러리 | viem (`privateKeyToAccount`) | 이미 v1.4에서 `@waiaas/adapter-evm` 의존성으로 설치. 별도 crypto 라이브러리(@noble/secp256k1 등) 추가 불필요. viem 내부에서 @noble/curves 사용 |
| 2 | EVM 주소 파생 | viem `privateKeyToAccount().address` | EIP-55 체크섬 자동 적용. 자체 keccak256 구현 금지 |
| 3 | 'ethereum' ChainType의 의미 | EVM 호환 체인 전체를 포괄 | ChainType을 체인마다 추가('polygon', 'arbitrum' 등)하면 enum 폭발. 암호 커브 기준으로 'solana'(Ed25519) vs 'ethereum'(secp256k1) 2종 유지 |
| 4 | 어댑터 인스턴스 관리 | AdapterPool (lazy init + 캐싱) | 데몬 시작 시 모든 체인 연결은 비효율. 에이전트 요청 시 해당 체인만 초기화 |
| 5 | EVM 기본 RPC | drpc.org 공용 엔드포인트 | 무료, 멀티체인 지원, rate limit 관대. 프로덕션에서는 Alchemy/Infura/QuickNode 권장 (config.toml 오버라이드) |
| 6 | Solana network 값 유지 | 'mainnet'/'devnet'/'testnet' 그대로 | 기존 에이전트 데이터 호환. EVM만 `{chain}-{net}` 형식 사용 |
| 7 | KeystoreFileV1 curve 필드 | 하위 호환 (없으면 ed25519 기본) | 기존 키스토어 파일 무변경. 신규 생성 시에만 curve 필드 추가 |
| 8 | DB 마이그레이션 | schema_version 2, 테이블 재생성 | SQLite CHECK 제약 변경은 ALTER TABLE 불가. 테이블 재생성으로 NetworkType 확장 반영 |

---

## E2E 검증 시나리오

**자동화 비율: 100% -- `[HUMAN]` 0건**

### Keystore 멀티커브

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 1 | EVM 에이전트 생성 → secp256k1 키 생성 + 0x 주소 반환 | `POST /v1/agents { chain: 'ethereum', network: 'ethereum-sepolia' }` → 201 + address 0x 형식 assert | [L0] |
| 2 | EVM 키스토어 파일 → curve: 'secp256k1' 포함 | 키스토어 JSON 파일 읽기 → curve 필드 assert | [L0] |
| 3 | EVM 키 복호화 → 유효한 32바이트 비밀키 | `decryptPrivateKey()` → 32바이트 Uint8Array + viem `privateKeyToAccount` 검증 → 동일 주소 파생 assert | [L0] |
| 4 | 기존 Solana 키스토어 파일 (curve 필드 없음) → ed25519 기본값 | curve 미포함 v1 파일 로드 → chain 'solana' + 정상 복호화 assert | [L0] |
| 5 | chain='ethereum' 에이전트의 주소가 EIP-55 체크섬 준수 | 생성된 주소 → `getAddress(address) === address` (viem) assert | [L0] |
| 6 | secp256k1 비밀키 제로화 확인 | 키 생성 후 평문 버퍼 → all zeros assert | [L0] |

### 어댑터 팩토리

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 7 | Solana 에이전트 트랜잭션 → SolanaAdapter 선택 | agent.chain='solana' → AdapterPool이 SolanaAdapter 반환 assert | [L0] |
| 8 | EVM 에이전트 트랜잭션 → EvmAdapter 선택 | agent.chain='ethereum' → AdapterPool이 EvmAdapter 반환 assert | [L0] |
| 9 | 동일 네트워크 어댑터 재사용 (캐싱) | 2개 ethereum-sepolia 에이전트 → 동일 어댑터 인스턴스 assert | [L0] |
| 10 | 다른 네트워크 어댑터 독립 | ethereum-mainnet + polygon-mainnet → 별도 어댑터 인스턴스 assert | [L0] |
| 11 | 데몬 shutdown → 모든 어댑터 disconnect | `disconnectAll()` → 풀 내 모든 어댑터 `isConnected() === false` assert | [L0] |

### Config EVM RPC

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 12 | config.toml에 EVM RPC 미설정 → 기본값 사용 | ConfigSchema parse({}) → `rpc_evm_ethereum_sepolia` 기본 URL 존재 assert | [L0] |
| 13 | 환경변수 오버라이드 → config 반영 | `WAIAAS_RPC_EVM_ETHEREUM_MAINNET=custom` → config 파싱 후 custom URL assert | [L0] |
| 14 | evm_default_network → 에이전트 생성 시 적용 | `POST /v1/agents { chain: 'ethereum' }` (network 미지정) → evm_default_network 값 사용 assert | [L0] |

### EVM 네이티브 전송 (v1.4 어댑터와 통합)

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 15 | EVM 에이전트 생성 → 잔액 조회 → ETH 전송 → CONFIRMED | Anvil에서 에이전트 생성 → 펀딩 → 전송 → 파이프라인 전체 통과 assert | [L1] |
| 16 | EVM + Solana 에이전트 동시 운용 | 2개 에이전트(chain 각각 다름) → 각각 전송 → 모두 CONFIRMED assert | [L1] |
| 17 | 미지원 network → 에러 | `POST /v1/agents { chain: 'ethereum', network: 'invalid' }` → 400 VALIDATION_ERROR assert | [L0] |

### DB 마이그레이션

| # | 시나리오 | 검증 방법 | 태그 |
|---|---------|----------|------|
| 18 | schema_version 1 → 2 자동 마이그레이션 | v1 DB로 데몬 시작 → schema_version 2 기록 + 기존 에이전트 데이터 유지 assert | [L0] |
| 19 | 이미 v2인 DB → 마이그레이션 스킵 | v2 DB로 데몬 시작 → schema_version 변경 없음 assert | [L0] |

---

## 의존

| 의존 대상 | 이유 |
|----------|------|
| v1.4 (토큰 + 컨트랙트 확장) | `@waiaas/adapter-evm` 패키지가 v1.4에서 구현됨. v1.4.1은 이 어댑터를 데몬에 연결하는 인프라 |
| v1.4 P-2 (DB 마이그레이션 러너) | v1.4 선행 과제로 마이그레이션 러너 구현. v1.4.1은 schema_version 2 마이그레이션 추가 |

---

## 리스크

| # | 리스크 | 영향 | 대응 방안 |
|---|--------|------|----------|
| 1 | secp256k1 키 생성 보안 | 비밀키 노출 시 전 체인 자산 탈취 | viem 검증된 구현 사용. 자체 crypto 코드 금지. 기존 AES-256-GCM + Argon2id + guarded memory 보안 스택 그대로 적용 |
| 2 | 공용 RPC 기본값 신뢰성 | drpc.org 장애 시 EVM 트랜잭션 실패 | fail-soft: 어댑터 연결 실패 시 데몬은 계속 동작 (Solana 에이전트 정상 운영). 프로덕션 전용 RPC 설정 권장 문서화 |
| 3 | NetworkType enum 확장에 따른 DB CHECK 변경 | SQLite CHECK 제약 변경은 테이블 재생성 필요 | 마이그레이션에서 안전한 테이블 재생성 (트랜잭션 내 CREATE→INSERT→DROP→RENAME). 기존 데이터 100% 보존 |
| 4 | 어댑터 풀 메모리 | 다수 EVM 체인 동시 사용 시 메모리 증가 | viem PublicClient는 경량 (HTTP 전용, WebSocket 미사용). 실측 후 최대 풀 크기 제한 검토 |
| 5 | 기존 Solana 전용 코드 잔존 | daemon.ts 외에도 Solana 하드코딩이 있을 수 있음 | 구현 전 `grep -r 'solana' packages/daemon/src/` 전수 점검. 하드코딩 발견 시 chain-agnostic으로 수정 |

---

## 구현 순서

```
v1.4 완료 (@waiaas/adapter-evm + DB 마이그레이션 러너)
  │
  ▼
v1.4.1-Phase A: Config 확장 + NetworkType enum
  │  - ConfigSchema에 EVM RPC 11키 추가
  │  - NetworkType에 EVM 네트워크 10개 추가
  │  - EVM chainId 매핑 테이블
  │
  ▼
v1.4.1-Phase B: Keystore 멀티커브
  │  - generateKeyPair() secp256k1 분기
  │  - KeystoreFileV1 curve 필드 (하위 호환)
  │  - 주소 파생 (viem privateKeyToAccount)
  │  - 기존 Ed25519 경로 무변경 확인
  │
  ▼
v1.4.1-Phase C: 어댑터 팩토리 + DB 마이그레이션
  │  - AdapterPool 구현
  │  - daemon.ts Step 4 교체
  │  - schema_version 2 마이그레이션 (agents CHECK 확장)
  │
  ▼
v1.4.1-Phase D: 통합 검증
     - EVM 에이전트 생성 → 잔액 조회 → 전송 E2E
     - Solana + EVM 동시 운용
     - 기존 테스트 전수 통과 확인 (회귀 없음)
```

---

*최종 업데이트: 2026-02-12 코드베이스 재검증 — ConfigSchema에 기존 EVM 키(ethereum_mainnet/ethereum_sepolia) 미존재 확인, "교체" → "순수 추가"로 정정, 키 수 17→28(순증 11개). 2026-02-12 신규 작성. v1.4 코드베이스 대조 분석에서 식별된 EVM 인프라 갭 3건(Keystore/Daemon/Config)을 독립 마일스톤으로 분리*
