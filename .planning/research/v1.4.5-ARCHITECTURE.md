# Architecture Patterns: Multichain Wallet Environment Model

**Domain:** Multichain wallet management for AI agent WaaS
**Researched:** 2026-02-14

---

## Recommended Architecture

### High-Level Data Flow Change

```
현재:
  Wallet (chain + network) -> AdapterPool.resolve(chain, network) -> Adapter -> RPC

변경 후:
  Wallet (chain + environment + default_network)
    -> Transaction request (optional network param)
      -> resolveNetwork(wallet, request) -> actual network
        -> validateEnvironment(wallet.environment, network)
          -> checkAllowedNetworks(wallet, network)
            -> AdapterPool.resolve(chain, network) -> Adapter -> RPC
```

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| @waiaas/core (enums) | EnvironmentType, ENVIRONMENT_TYPES, 매핑 함수 정의 | 모든 패키지가 import |
| @waiaas/core (schemas) | WalletSchema.environment, SendTxRequest.network | daemon routes, SDK, MCP |
| daemon/migrate.ts | DB 마이그레이션 v6~v7 실행 | better-sqlite3 직접 |
| daemon/schema.ts | Drizzle ORM 테이블 정의 (environment 컬럼) | daemon 서비스 레이어 |
| daemon/network-resolver | 네트워크 해결 로직 (요청 -> 실제 네트워크) | pipeline Stage 1, API routes |
| daemon/adapter-pool.ts | 어댑터 캐싱 (변경 없음) | EvmAdapter, SolanaAdapter |
| daemon/pipeline Stage 1 | 환경 일치 검증 + ALLOWED_NETWORKS 정책 | network-resolver, PolicyEngine |
| daemon/pipeline Stage 3 | 네트워크 스코프 정책 매칭 | PolicyEngine |

### Network Resolution Flow

```typescript
// 새 모듈: packages/daemon/src/domain/network-resolver.ts

interface NetworkResolutionResult {
  network: NetworkType;     // 해결된 네트워크
  source: 'explicit' | 'wallet_default' | 'environment_default';
}

function resolveNetwork(
  wallet: { chain: ChainType; environment: EnvironmentType; defaultNetwork: NetworkType | null },
  requestNetwork: NetworkType | undefined,
): NetworkResolutionResult {
  if (requestNetwork) {
    // 1. 명시적 네트워크 -> 환경 일치 검증
    validateNetworkEnvironment(wallet.chain, wallet.environment, requestNetwork);
    return { network: requestNetwork, source: 'explicit' };
  }

  if (wallet.defaultNetwork) {
    // 2. 월렛 기본 네트워크
    return { network: wallet.defaultNetwork, source: 'wallet_default' };
  }

  // 3. 환경 기본값
  return {
    network: getDefaultNetwork(wallet.chain, wallet.environment),
    source: 'environment_default',
  };
}
```

### Pipeline Integration

```
Stage 1 (검증) -- 변경됨:
  1. 요청 파싱
  2. 월렛 조회 (chain, environment, defaultNetwork)
  3. resolveNetwork() -> 실제 네트워크
  4. validateNetworkEnvironment() -- 환경 불일치 시 400
  5. checkAllowedNetworks() -- 정책 위반 시 403
  6. RPC URL 해결 (config.rpc[`evm_${network}`])
  7. 기존 검증 계속...

Stage 3 (정책) -- 변경됨:
  정책 매칭 시 policy.network 조건 추가:
    WHERE (policy.network = tx.network OR policy.network IS NULL)

Stage 4 (빌드) -- 호출 변경:
  AdapterPool.resolve(wallet.chain, resolvedNetwork, rpcUrl)
  // 기존: wallet.network 사용
  // 변경: 해결된 네트워크 사용
```

### DB Schema Before/After

```
BEFORE (v5):
  wallets: id, name, chain, network, public_key, status, ...
  transactions: id, wallet_id, chain, tx_hash, type, ...
  policies: id, wallet_id, type, rules, ...

AFTER (v7):
  wallets: id, name, chain, environment, default_network, public_key, status, ...
  transactions: id, wallet_id, chain, network, tx_hash, type, ...
  policies: id, wallet_id, network, type, rules, ...
```

---

## Patterns to Follow

### Pattern 1: Environment-Network Duality

**What:** 월렛 레벨은 `environment` (testnet/mainnet), 트랜잭션 레벨은 `network` (ethereum-sepolia 등)

**When:** 모든 API 호출, 데이터 저장, 정책 평가에서 이 이중 레벨 일관 적용

**Example:**
```typescript
// 월렛 생성 -- environment 레벨
POST /v1/wallets { name: "main", chain: "ethereum", environment: "mainnet" }
// -> wallets.environment = 'mainnet', wallets.default_network = 'ethereum-mainnet'

// 트랜잭션 -- network 레벨
POST /v1/transactions/send { walletId: "...", to: "0x...", amount: "0.01", network: "polygon-mainnet" }
// -> transactions.network = 'polygon-mainnet'
// -> AdapterPool resolves 'ethereum:polygon-mainnet'
```

### Pattern 2: Per-Network Adapter Instance (existing)

**What:** viem PublicClient는 chain당 하나. AdapterPool이 `chain:network` 키로 인스턴스를 캐싱.

**When:** 동일 네트워크로 여러 트랜잭션이 들어올 때 어댑터를 재사용. 새 네트워크 요청 시 lazy-create.

**Example:**
```typescript
// 메인넷 월렛이 Ethereum, Polygon, Arbitrum에서 각각 tx 실행
// -> AdapterPool에 3개 어댑터 인스턴스 생성:
//    "ethereum:ethereum-mainnet" -> EvmAdapter(mainnet)
//    "ethereum:polygon-mainnet" -> EvmAdapter(polygon)
//    "ethereum:arbitrum-mainnet" -> EvmAdapter(arbitrum)
```

### Pattern 3: SSoT Cascade for New Enum

**What:** Zod enum -> TypeScript type -> DB CHECK -> Drizzle schema -> API validation 순서로 파생

**When:** EnvironmentType 추가 시 이 체인을 따라야 함

**Example:**
```typescript
// 1. Zod SSoT (packages/core/src/enums/chain.ts)
export const ENVIRONMENT_TYPES = ['testnet', 'mainnet'] as const;
export type EnvironmentType = (typeof ENVIRONMENT_TYPES)[number];
export const EnvironmentTypeEnum = z.enum(ENVIRONMENT_TYPES);

// 2. DB CHECK (migrate.ts)
CHECK (environment IN ('testnet', 'mainnet'))

// 3. Drizzle schema (schema.ts)
check('check_environment', buildCheckSql('environment', ENVIRONMENT_TYPES)),

// 4. Zod request schema
export const CreateWalletRequestSchema = z.object({
  environment: EnvironmentTypeEnum.default('testnet'),
});
```

### Pattern 4: 12-Step Table Recreation for CHECK Changes

**What:** SQLite CHECK 제약을 변경할 때는 테이블을 재생성해야 함

**When:** wallets.network CHECK -> wallets.environment CHECK, policies.type CHECK 확장

**Example:** (v2, v3 마이그레이션에서 이미 검증된 패턴)
```typescript
MIGRATIONS.push({
  version: 6,
  description: 'Convert wallets.network to environment model',
  managesOwnTransaction: true,
  up: (sqlite) => {
    sqlite.exec('BEGIN');
    try {
      sqlite.exec(`CREATE TABLE wallets_new (...)`);
      sqlite.exec(`INSERT INTO wallets_new SELECT ... CASE ... FROM wallets`);
      sqlite.exec('DROP TABLE wallets');
      sqlite.exec('ALTER TABLE wallets_new RENAME TO wallets');
      // Recreate indexes...
      sqlite.exec('COMMIT');
    } catch (err) {
      sqlite.exec('ROLLBACK');
      throw err;
    }
    sqlite.pragma('foreign_keys = ON');
    // FK integrity check...
  },
});
```

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: AdapterPool 구조 변경

**What:** AdapterPool의 캐시 키나 resolve() 시그니처를 변경하려는 유혹
**Why bad:** 기존의 `chain:network` 키가 이미 정확한 추상화. 변경 시 모든 호출 사이트에 cascading 영향
**Instead:** 호출자만 변경 (wallet.network -> resolvedNetwork). AdapterPool은 그대로.

### Anti-Pattern 2: 단일 마이그레이션에 모든 변경 집중

**What:** v6 하나에 wallets 재생성 + transactions ADD + policies 재생성 모두 넣기
**Why bad:** 마이그레이션 실패 시 롤백 범위 과대. 디버깅 어려움
**Instead:** 논리 단위로 분리. v6(wallets 중심), v7(transactions + policies)

### Anti-Pattern 3: 기존 네트워크 값 삭제

**What:** wallets.default_network 없이 environment만 저장
**Why bad:** 기존 1:1 모델의 하위호환 깨짐. "ethereum-sepolia" 월렛이 "ethereum-sepolia"를 기본으로 사용해야 함
**Instead:** 기존 network 값을 default_network에 보존

### Anti-Pattern 4: ALLOWED_NETWORKS 기본 거부

**What:** ALLOWED_NETWORKS 미설정 시 모든 네트워크 차단
**Why bad:** 기존 월렛이 새 모델에서 즉시 동작 불가. 관리자가 일일이 정책 추가해야 함
**Instead:** 미설정 = 환경 내 전체 허용 (하위호환 우선)

---

## Scalability Considerations

| Concern | 100 wallets | 10K wallets | 1M wallets |
|---------|------------|-------------|-------------|
| Adapter 인스턴스 수 | 최대 13개 (10 EVM + 3 Solana) | 동일 13개 (네트워크 수에 비례, 월렛 수에 무관) | 동일 13개 |
| 마이그레이션 시간 | < 1초 | 수 초 (O(n) 데이터 복사) | 수 분 (대량 INSERT SELECT) |
| Policy 매칭 | 추가 WHERE 조건 1개 | 인덱스로 해결 | policies.network 인덱스 추가 고려 |
| RPC 연결 수 | 요청된 네트워크만 연결 (lazy) | 동일 | 동일 (네트워크 수가 고정) |

AdapterPool의 인스턴스 수는 **지원 네트워크 수에 비례**하며, 월렛 수에는 무관하다. 현재 10 EVM + 3 Solana = 최대 13개 어댑터 인스턴스. 이는 월렛이 백만 개여도 변하지 않는다.

---

## Sources

- AdapterPool 구조: `packages/daemon/src/infrastructure/adapter-pool.ts`
- Pipeline 6-stage: `docs/32-transaction-pipeline-api.md`
- 12-step migration 선례: `packages/daemon/src/infrastructure/database/migrate.ts` (v2, v3)
- SSoT cascade: `CLAUDE.md` Zod SSoT 규칙
- [viem PublicClient Map pattern](https://github.com/wevm/viem/discussions/986)
