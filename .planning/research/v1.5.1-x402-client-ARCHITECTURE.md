# Architecture Patterns: v1.5.1 x402 Client Support

**Domain:** x402 프로토콜 클라이언트 -- HTTP 402 자동 결제 프록시
**Researched:** 2026-02-15

---

## Recommended Architecture

### x402 요청 흐름

```
에이전트/SDK/MCP
    │
    ▼
POST /v1/x402/fetch (sessionAuth)
    │
    ▼
┌──────────────────────────────────────────┐
│ x402 Handler                              │
│                                           │
│  1. URL 검증 (X402_ALLOWED_DOMAINS)       │
│  2. SSRF 가드 (DNS 해석 + IP 검증)         │
│  3. 외부 HTTP 요청 (native fetch)          │
│     ├── 200: 응답 패스스루 → 종료          │
│     └── 402: PaymentRequired 파싱          │
│  4. (scheme, network) 선택                 │
│     └── CAIP-2 → NetworkType 변환          │
│  5. 금액 USD 환산                          │
│     └── USDC: $1 직접, 기타: IPriceOracle  │
│  6. 정책 평가 (기존 파이프라인 재사용)       │
│     └── SPENDING_LIMIT 4-tier 평가          │
│     ├── INSTANT: 계속                      │
│     ├── NOTIFY: 계속 + 알림                │
│     ├── DELAY: timeout 내 대기 또는 거부    │
│     └── APPROVAL: 즉시 거부                │
│  7. 결제 서명 생성                          │
│     ├── EVM: EIP-3009 signTypedData        │
│     └── Solana: TransferChecked 부분 서명    │
│  8. X-PAYMENT 헤더 인코딩                   │
│  9. 재요청 (결제 헤더 포함)                  │
│     ├── 200: 리소스 반환                    │
│     ├── 402: X402_PAYMENT_REJECTED          │
│     └── 5xx: X402_SERVER_ERROR              │
│  10. 감사 로그 기록 (transactions 테이블)    │
│  11. 응답 반환                              │
└──────────────────────────────────────────┘
```

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| `x402-handler.ts` | 전체 x402 흐름 오케스트레이션. 402 파싱, (scheme, network) 선택, 재요청, 에러 처리 | payment-signer, ssrf-guard, PolicyEngine, TransactionService, PriceOracle |
| `payment-signer.ts` | 체인별 결제 서명 생성. EVM EIP-3009 / Solana TransferChecked | viem (signTypedData), @solana/kit (signBytes, compileTransaction), KeyStore |
| `ssrf-guard.ts` | URL 안전성 검증. DNS 해석 + 사설 IP 차단 + 리다이렉트 검증 | node:dns, node:net (외부 의존성 없음) |
| `routes/x402.ts` | REST API 라우트. 요청 파싱, 인증, 응답 매핑 | x402-handler, sessionAuth middleware |
| `x402.types.ts` | Zod 스키마, CAIP-2 매핑 테이블, x402 전용 타입 | @x402/core (types, schemas) |

### Data Flow

```
[Request Body]
  url, method, headers?, body?
       │
       ▼
[X402_ALLOWED_DOMAINS 검증]
  policies 테이블에서 월렛의 허용 도메인 조회
  URL 호스트가 도메인 목록에 포함되는지 확인 (와일드카드 지원)
       │
       ▼
[SSRF Guard]
  URL → hostname 추출 → DNS lookup → IP 검증
  사설 IP → 즉시 거부
       │
       ▼
[External HTTP Request]
  native fetch → 외부 서버
  redirect: 'manual' (리다이렉트 SSRF 방지)
       │
       ├── 200-399: 응답 패스스루
       │
       └── 402: PaymentRequired JSON body 파싱
              │
              ▼
         [PaymentRequirements 선택]
           accepts[] → (scheme, network) 필터링
           CAIP-2 → NetworkType → 현재 어댑터 풀에서 지원 여부 확인
              │
              ▼
         [USD 환산]
           USDC → $1 직접 환산
           기타 → IPriceOracle.getPrice(asset) → USD
              │
              ▼
         [정책 평가]
           SPENDING_LIMIT 4-tier 평가
           reserved_amount에 x402 결제 금액 누적
           rate limiter (tx_rpm) 검증
              │
              ├── APPROVAL: 즉시 거부
              ├── DELAY timeout 초과: 거부
              │
              ▼
         [결제 서명 생성]
           KeyStore에서 개인키 복호화
           ├── EVM: privateKeyToAccount → signTypedData (EIP-712)
           └── Solana: createKeyPair → buildTx(noopSigner feePayer) → signBytes
              │
              ▼
         [재요청]
           X-PAYMENT: base64(JSON(PaymentPayload))
           → 외부 서버 (SSRF 재검증 없음 -- 동일 URL)
              │
              ├── 200: 리소스 + payment_info 반환
              ├── 402: X402_PAYMENT_REJECTED (1회만 재시도)
              └── 5xx: X402_SERVER_ERROR + 결제 정보 로그
```

---

## Patterns to Follow

### Pattern 1: 기존 파이프라인 정책 엔진 재사용

**What:** x402 결제의 정책 평가를 기존 `DatabasePolicyEngine.evaluate()`에 위임한다. 별도 x402 전용 정책 평가 로직을 만들지 않는다.

**When:** x402 결제 금액을 USD로 환산한 후.

**Example:**

```typescript
// x402-handler.ts
import { DatabasePolicyEngine } from '../pipeline/database-policy-engine.js';

async function evaluateX402Payment(
  walletId: string,
  amountUsd: number,
  tokenAddress: string,
  policyEngine: DatabasePolicyEngine,
) {
  // 기존 정책 평가 재사용
  // TransactionParam 형태로 변환하여 evaluate() 호출
  const result = await policyEngine.evaluate(walletId, {
    type: 'TOKEN_TRANSFER',
    to: payTo,
    tokenAddress,
    amount: amountRaw,
    amountUsd,
  });

  // 4-tier 결과 처리
  switch (result.tier) {
    case 'INSTANT': return { proceed: true };
    case 'NOTIFY':  return { proceed: true, notify: true };
    case 'DELAY':   return { proceed: true, delayMs: result.delayMs };
    case 'APPROVAL': return { proceed: false, error: 'X402_APPROVAL_REQUIRED' };
  }
}
```

### Pattern 2: 체인별 결제 서명 전략 패턴

**What:** `PaymentSigner`가 (scheme, chain) 조합에 따라 적절한 서명 전략을 선택한다.

**When:** PaymentRequirements에서 scheme과 network을 파악한 후.

**Example:**

```typescript
// payment-signer.ts
type SigningStrategy = (
  requirements: PaymentRequirements,
  privateKey: Uint8Array,
  walletAddress: string,
  rpc: unknown,  // Solana RPC (EVM은 불필요)
) => Promise<Record<string, unknown>>;

const SIGNING_STRATEGIES: Record<string, Record<string, SigningStrategy>> = {
  exact: {
    evm: signEip3009,
    solana: signSolanaTransferChecked,
  },
};

export async function createPaymentSignature(
  requirements: PaymentRequirements,
  privateKey: Uint8Array,
  walletAddress: string,
  rpc: unknown,
): Promise<Record<string, unknown>> {
  const { namespace } = parseCaip2(requirements.network);
  const chainType = namespace === 'eip155' ? 'evm' : 'solana';

  const strategy = SIGNING_STRATEGIES[requirements.scheme]?.[chainType];
  if (!strategy) {
    throw new Error(`Unsupported scheme/chain: ${requirements.scheme}/${chainType}`);
  }

  return strategy(requirements, privateKey, walletAddress, rpc);
}
```

### Pattern 3: 1회 재시도 + 감사 로그

**What:** 결제 서명 후 재요청은 최대 1회. 성공/실패 모두 감사 로그에 기록.

**When:** 결제 서명을 X-PAYMENT 헤더에 포함하여 재요청할 때.

**Example:**

```typescript
// x402-handler.ts
// 첫 번째 요청: 402 응답
const firstResponse = await proxyRequest(url, method, headers, body);

if (firstResponse.status === 402) {
  // 결제 서명 생성 (정책 평가 포함)
  const paymentHeader = await createPayment(firstResponse, walletId, ...);

  // 재요청 (1회만)
  const retryResponse = await proxyRequest(url, method, headers, body, paymentHeader);

  // 감사 로그 기록
  await transactionService.create({
    type: 'X402_PAYMENT',
    walletId,
    status: retryResponse.ok ? 'CONFIRMED' : 'FAILED',
    metadata: {
      target_url: url.toString(),
      payment_amount: paymentRequirements.amount,
      payment_asset: paymentRequirements.asset,
      payment_network: paymentRequirements.network,
      payment_payTo: paymentRequirements.payTo,
    },
  });

  if (retryResponse.status === 402) {
    throw new WAIaaSError('X402_PAYMENT_REJECTED');
  }
  if (!retryResponse.ok) {
    throw new WAIaaSError('X402_SERVER_ERROR');
  }

  return retryResponse;
}
```

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: IChainAdapter를 통한 x402 결제 서명

**What:** EIP-3009 서명이나 Solana 부분 서명을 IChainAdapter 메서드로 구현하려는 것.

**Why bad:** IChainAdapter는 트랜잭션 서명(`signTransaction`)을 위한 인터페이스. EIP-3009은 트랜잭션이 아닌 EIP-712 typed data 서명. Solana 부분 서명은 feePayer가 다른 특수 트랜잭션. 기존 인터페이스에 맞지 않는 메서드를 억지로 추가하면 인터페이스가 오염된다.

**Instead:** `payment-signer.ts` 모듈에서 viem, @solana/kit을 직접 사용. KeyStore만 기존 서비스를 통해 접근.

### Anti-Pattern 2: x402 전용 정책 엔진

**What:** x402 결제를 위한 별도의 정책 평가 로직을 만드는 것.

**Why bad:** 정책이 이중화되어 관리 복잡도 증가. "SPENDING_LIMIT에서는 허용인데 x402 한도에서는 거부" 같은 혼란 발생.

**Instead:** 기존 DatabasePolicyEngine.evaluate()에 금액과 토큰 정보를 전달. X402_ALLOWED_DOMAINS만 신규 정책 타입으로 추가.

### Anti-Pattern 3: x402 응답 캐싱

**What:** 외부 API의 200 응답을 캐싱하여 재사용하려는 것.

**Why bad:** WAIaaS는 프록시이지 캐시 서버가 아님. 캐시 무효화 로직의 복잡도, 캐시된 데이터의 보안 문제.

**Instead:** 매 요청마다 외부 서버에 직접 요청. 캐싱은 에이전트 또는 상위 레이어의 책임.

---

## Scalability Considerations

| Concern | 100 에이전트 | 10K 에이전트 | 비고 |
|---------|-------------|-------------|------|
| 외부 HTTP 요청 동시성 | native fetch (Node.js 이벤트 루프) | Node.js 이벤트 루프 | undici 커넥션 풀이 자동 관리 |
| DNS 해석 부하 | 무시 가능 | DNS 캐싱 고려 | Node.js DNS 캐시 TTL 설정 |
| 정책 평가 부하 | SQLite 쿼리 | SQLite 충분 | 기존 정책 평가와 동일 부하 |
| 결제 서명 생성 | 즉시 (Ed25519/secp256k1 서명) | 즉시 | CPU-bound이나 매우 빠름 |
| 감사 로그 쓰기 | SQLite INSERT | SQLite WAL 모드 | 기존 transactions 테이블과 동일 패턴 |

---

## Sources

- WAIaaS `objectives/v1.5.1-x402-client.md` -- 컴포넌트 정의, 파일/모듈 구조
- WAIaaS `packages/core/src/interfaces/IChainAdapter.ts` -- 22 메서드 인터페이스
- WAIaaS `packages/daemon/src/pipeline/stages.ts` -- 6-stage 파이프라인 구조
- [x402 Specification](https://github.com/coinbase/x402/blob/main/specs/x402-specification.md) -- 프로토콜 흐름
- [x402 EVM Exact Scheme](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md) -- EIP-3009 구조
- [x402 SVM Exact Scheme](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md) -- TransferChecked 부분 서명
