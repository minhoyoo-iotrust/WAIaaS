# Feature Landscape: MCP Session Management Automation (v0.9)

**Domain:** Token lifecycle automation for MCP server processes in AI agent wallet daemon
**Researched:** 2026-02-09
**Overall Confidence:** HIGH (MCP spec well-documented, competing patterns surveyed, WAIaaS design already detailed)
**Milestone:** v0.9 MCP 세션 관리 자동화 설계

---

## Overview

v0.9은 MCP 환경에서 세션 토큰의 갱신/만료/재발급을 자동화하는 메커니즘을 설계한다. 핵심 문제는 MCP Server가 Claude Desktop의 자식 프로세스로 실행되어 환경변수가 프로세스 시작 시 1회 고정되는 구조에서, 토큰 로테이션(갱신 시 새 JWT 발급 + 이전 토큰 무효화)을 어떻게 처리할 것인가이다.

**생태계 현황:**

MCP 인증 스펙(2025-03 초판, 2025-06/11 개정)은 두 가지 경로를 명확히 분리한다:
- **HTTP 기반 transport**: OAuth 2.1 필수 (PKCE, Dynamic Client Registration, Resource Indicators)
- **stdio transport**: OAuth 2.1을 따르지 않아야 하며(SHOULD NOT), 환경에서 자격증명을 가져와야 함

WAIaaS MCP Server는 stdio transport를 사용하므로, MCP 스펙 자체가 "환경 기반 자격증명"을 권장한다. 그러나 환경변수의 프로세스 시작 후 불변성이 근본적 제약이며, 이를 파일 기반 토큰 영속화로 해결하는 것이 v0.9의 핵심이다.

**경쟁 제품 비교:**

| Product | MCP Auth 방식 | Token Lifecycle | 자동 갱신 |
|---------|--------------|-----------------|----------|
| Claude Desktop | env var 1회 주입 | 수동 (config.json 편집 + 재시작) | 없음 |
| Cursor | env var + OAuth 2.0 UI 플로우 | OAuth 토큰 자동 갱신 (원격 MCP만) | 원격만 |
| Continue.dev | env var, `${{ secrets.* }}` 참조 | 수동 (config 편집) | 없음 |
| Cline | env var, mcp_settings.json | 수동 (config 편집) | 없음 |
| VS Code Copilot | env var + OAuth 2.0 | OAuth 토큰 자동 갱신 (원격만) | 원격만 |

**핵심 발견:** stdio transport에서 토큰 자동 갱신을 내장한 MCP 서버는 사실상 존재하지 않는다. 대부분의 MCP 서버는 환경변수 기반 정적 토큰(PAT, API Key)을 사용하며, 만료 시 사용자가 수동으로 교체한다. WAIaaS의 SessionManager 패턴은 이 영역에서 독자적 차별화가 된다.

---

## 기존 설계와의 관계 (v0.5-v0.8 의존성)

v0.9 기능은 기존 설계 위에 변경/확장을 적용한다:

| 기존 설계 | v0.9 변경 | 영향 |
|-----------|----------|------|
| 세션 갱신 프로토콜 (v0.5: 53-renewal) | SessionManager가 PUT /renew를 자동 호출 | 60% 경과 시점 자동 트리거, 50% safety guard 범위 내 |
| MCP Server 6+3 (v0.5: 38-sdk-mcp) | SessionManager 클래스 내장, tool handler 토큰 참조 변경 | getToken() 단일 진입점, env var -> file 우선순위 |
| 알림 아키텍처 (v0.5: 35-notification) | SESSION_EXPIRING_SOON 이벤트 추가 (16 -> 17개) | 만료 24h 전 또는 잔여 갱신 3회 이하 시 |
| Telegram Bot (v0.5: 40-telegram-docker) | /newsession 명령어 추가 (8 -> 9개), Tier 1 | 인라인 키보드 에이전트 선택 -> 세션 생성 -> 파일 저장 |
| CLI 플로우 (v0.5: 54-cli-redesign) | mcp setup / mcp refresh-token 2개 커맨드 추가 | 세션 생성 + 파일 저장 일괄 처리 |
| 데이터 디렉토리 (v0.2: 24-monorepo) | ~/.waiaas/mcp-token 파일 사양 추가 | 0o600 권한, JWT 단일 문자열, symlink 거부 |

---

## Table Stakes (필수 기능)

SessionManager 기반 MCP 세션 자동화가 정상 동작하기 위해 반드시 구현해야 하는 기능. 하나라도 빠지면 토큰 만료 시 MCP 서비스가 중단된다.

### TS-1: 파일 기반 토큰 영속화

**What:** 토큰을 `~/.waiaas/mcp-token` 파일에 저장하여, MCP 프로세스 재시작 시에도 최신 토큰을 로드할 수 있게 한다. 환경변수의 프로세스 시작 후 불변성 제약을 우회하는 핵심 메커니즘.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | 24-monorepo (데이터 디렉토리 사양) |
| Confidence | HIGH |

**Why Table Stakes:** MCP 스펙이 stdio transport에 대해 "환경에서 자격증명을 가져오라"고 명시하지만, 환경변수는 프로세스 시작 후 변경 불가능하다. Claude Desktop을 포함한 모든 MCP 호스트에서 env var는 config.json에서 1회 주입된다. 토큰 로테이션이 있는 시스템에서는 파일 기반 영속화가 유일한 현실적 대안이다.

**Ecosystem Evidence:**
- MCP CLI (apify/mcp-cli)는 `~/.mcpc/sessions.json`에 세션 메타데이터를 저장하고, 인증 토큰은 OS 키체인에 보관
- GitHub MCP Server는 PAT를 config 파일에 저장 (정적, 로테이션 없음)
- 일반적 CLI 도구(AWS CLI, gcloud, oidc-agent)는 `~/.aws/credentials`, `~/.config/gcloud/`, 등 파일 기반 토큰 저장 패턴을 사용
- 파일 권한 0o600 (owner read/write only)은 업계 표준 (SSH keys, AWS credentials 동일)

**Spec:**
- 경로: `~/.waiaas/mcp-token`
- 내용: JWT 문자열만 (개행 없음, `wai_sess_` 접두어 포함)
- 권한: `0o600`
- 인코딩: UTF-8
- Symlink 거부 (보안 시나리오 S-04)

### TS-2: 토큰 로드 우선순위 (File > Env)

**What:** MCP Server 기동 시 토큰 소스의 우선순위를 정의한다. 파일이 존재하면 파일에서, 없으면 환경변수에서 로드한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | TS-1 (파일 영속화) |
| Confidence | HIGH |

**Why Table Stakes:** 파일 기반 토큰이 갱신/재발급된 후에도, 초기 부트스트랩은 환경변수로 시작해야 한다 (Claude Desktop config.json의 env 섹션이 유일한 초기 토큰 전달 경로). 두 소스의 우선순위가 명확하지 않으면 갱신된 토큰이 무시되거나, 초기 설정이 불가능해진다.

**Ecosystem Evidence:**
- AWS SDK의 credential chain 패턴: Environment > Config File > Instance Metadata
- Docker credential helper: config.json > env var > helper binary
- Kubernetes: Projected Volume > ConfigMap > Default

**Spec:**
```
1. ~/.waiaas/mcp-token 파일 존재? -> Yes: 파일에서 로드 / No: 다음 단계
2. WAIAAS_SESSION_TOKEN 환경변수 존재? -> Yes: env에서 로드 / No: 에러
3. JWT payload 디코딩 (서명 검증 없이, base64url)
4. 만료 여부 확인 -> 유효: 갱신 스케줄링 / 만료: 에러 상태
```

### TS-3: SessionManager 자동 갱신

**What:** MCP Server 프로세스 내부에서 토큰 갱신을 자동으로 수행한다. expiresIn의 60% 경과 시점에 PUT /v1/sessions/:id/renew를 호출하고, 새 토큰을 메모리 + 파일에 저장한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Medium |
| Dependencies | 53-renewal (갱신 프로토콜), TS-1 (파일 영속화), 38-sdk-mcp (MCP Server) |
| Confidence | HIGH |

**Why Table Stakes:** 세션 만료는 MCP 서비스 중단을 의미한다. AI 에이전트가 작업 중 401을 받으면 사용자가 수동으로 토큰을 교체해야 한다. 이는 v0.5에서 설계한 "에이전트 자율 갱신" 원칙에 위배된다. 자동 갱신 없이는 MCP 경로의 DX가 SDK 경로 대비 현저히 열악하다.

**Ecosystem Evidence:**
- SDK 패턴에서 자동 갱신은 표준: AWS SDK는 credential provider가 자동으로 토큰을 refresh, Azure SDK는 TokenCredential이 만료 전 자동 갱신
- OAuth 2.1 MCP 스펙은 HTTP transport에서 refresh token을 통한 자동 갱신을 권장 (access token 1h + refresh token 30d 패턴)
- MintMCP Gateway는 "1-hour access tokens with 30-day refresh tokens" 자동 로테이션을 구현
- 그러나 stdio transport에서 이를 구현한 MCP 서버는 발견되지 않음 -- WAIaaS가 선구적

**Spec:**
- 갱신 시점: expiresIn * 0.6 경과 (잔여 40%, 서버 safety guard 50% 이하 충족)
- 갱신 성공: 메모리 내 token/expiresAt/renewalCount 교체 + ~/.waiaas/mcp-token 파일 저장
- 갱신 실패 처리: RENEWAL_TOO_EARLY(30초 후 1회 재시도), RENEWAL_LIMIT_REACHED(포기 + 알림), 네트워크 에러(60초 후 3회 재시도)

### TS-4: 갱신 실패 시 에러 상태 진입 및 알림

**What:** 갱신 불가 상태(한도 도달, 절대 수명 만료)에서 SessionManager가 에러 상태로 전환하고, SESSION_EXPIRING_SOON 알림을 트리거한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low-Medium |
| Dependencies | 35-notification (알림 아키텍처), 53-renewal (안전 장치) |
| Confidence | HIGH |

**Why Table Stakes:** 갱신 불가 시 사용자에게 알리지 않으면, 토큰이 조용히 만료되어 에이전트가 중단된다. 사전 경고 없는 서비스 중단은 어떤 프로덕션 시스템에서도 용납되지 않는다.

**Ecosystem Evidence:**
- 인증서 만료 알림 패턴: 30일/15일/7일/3일 전 단계별 알림이 표준 (Let's Encrypt, Fleet, AWS Certificate Manager)
- Expiration Reminder 서비스는 SMS/이메일/push 3채널 동시 발송 권장
- MCP 생태계에는 아직 세션 만료 사전 알림이 존재하지 않음 (대부분 정적 PAT)

**Spec:**
- 발생 조건: 절대 수명 만료 24시간 전 OR 잔여 갱신 3회 이하
- 심각도: WARNING
- 알림 내용: 세션 ID, 에이전트 이름, 만료 시각, 남은 갱신 횟수
- 알림 채널: 기존 INotificationChannel (Telegram, Discord, ntfy.sh)

### TS-5: 401 Lazy Reload (외부 토큰 전환)

**What:** SessionManager의 현재 토큰으로 API 호출 시 401을 수신하면, `~/.waiaas/mcp-token` 파일을 재로드하여 외부에서 생성된 새 토큰을 자동 적용한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Medium |
| Dependencies | TS-1 (파일 영속화), TS-2 (로드 우선순위) |
| Confidence | HIGH |

**Why Table Stakes:** Telegram /newsession이나 CLI mcp refresh-token으로 새 세션을 생성하면, 해당 토큰이 파일에 저장되지만 현재 SessionManager는 이전 토큰을 메모리에 보유하고 있다. Lazy reload 없이는 MCP 프로세스를 재시작해야만 새 토큰이 적용된다. 이는 v0.9의 핵심 목표인 "에이전트 서비스 연속성"을 위반한다.

**Ecosystem Evidence:**
- fs.watch vs lazy reload: Node.js fs.watch는 OS별 동작 불안정 (macOS FSEvents race condition). Kubernetes의 ConfigMap reload도 inotify 대신 폴링 패턴 사용
- AWS SDK credential chain은 만료 시 자동으로 다음 provider를 시도하는 lazy chain 패턴
- 401 수신 시 1회 파일 확인은 HTTP 클라이언트의 표준 retry 패턴과 일치

**Spec:**
```
401 수신 -> ~/.waiaas/mcp-token 파일 재로드
  -> 파일 토큰 != 현재 토큰: 새 토큰으로 교체, API 재시도
  -> 파일 토큰 == 현재 토큰: 진짜 만료, 에러 상태
  -> 파일 없음: 에러 상태
```

### TS-6: CLI `mcp setup` 커맨드

**What:** 세션 발급 + 토큰 파일 생성을 한 번에 수행하는 CLI 커맨드. Claude Desktop config.json 설정 안내를 포함한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | 54-cli-redesign (CLI 구조), TS-1 (파일 영속화) |
| Confidence | HIGH |

**Why Table Stakes:** 현재 MCP 토큰 설정 플로우는 `waiaas session create` -> 토큰 수동 복사 -> config.json 편집 -> Claude Desktop 재시작의 4단계. 이를 1단계(`waiaas mcp setup`)로 줄이는 것은 최소한의 DX 요구사항이다.

**Ecosystem Evidence:**
- `gh auth login`: GitHub CLI의 인증 설정을 한 번에 수행하고 토큰을 로컬에 저장
- `aws configure`: AWS CLI 자격증명 설정을 대화형으로 진행하고 ~/.aws/credentials에 저장
- `gcloud auth login`: Google Cloud CLI가 브라우저 인증 후 토큰을 로컬에 저장
- 모든 주요 CLI 도구는 "setup/login" 원커맨드 패턴을 제공

**Spec:**
```bash
waiaas mcp setup --agent-id <agent-id> [--expires-in 604800] [--constraints '...']
# 1. masterAuth(implicit)로 세션 생성
# 2. ~/.waiaas/mcp-token에 토큰 저장 (mode 0o600)
# 3. Claude Desktop config.json 설정 안내 출력
```

### TS-7: CLI `mcp refresh-token` 커맨드

**What:** 절대 수명 만료 후 새 세션을 발급하고 토큰 파일을 교체하는 CLI 커맨드. 이전 세션의 constraints를 계승한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | TS-6 (mcp setup), 53-renewal (세션 수명) |
| Confidence | HIGH |

**Why Table Stakes:** 30일 절대 수명 만료 시 자동 갱신으로는 해결할 수 없다. 새 세션을 CLI에서 생성하고 파일을 교체하는 명시적 커맨드가 필요하다.

**Ecosystem Evidence:**
- `aws sso login --profile xxx`: 만료된 SSO 세션을 갱신하는 전용 커맨드
- `oidc-agent`: 만료된 토큰을 refresh token으로 자동 갱신하되, refresh token 만료 시 수동 재인증 필요
- AWS CodeArtifact: `login` 명령어를 주기적으로 호출하여 12시간 토큰 갱신

**Spec:**
```bash
waiaas mcp refresh-token --agent-id <agent-id>
# 1. 기존 세션 폐기 (만료됐으면 건너뜀)
# 2. 이전 세션과 동일한 constraints로 새 세션 생성
# 3. ~/.waiaas/mcp-token 교체
# 4. "config.json 수정 불필요" 안내
```

---

## Differentiators (차별화 기능)

경쟁 제품 대비 WAIaaS MCP 세션 관리를 차별화하는 기능. 없어도 동작하지만, 있으면 경쟁 우위를 제공한다.

### DF-1: Telegram /newsession 원클릭 세션 재생성

**What:** SSH 없이 Telegram에서 에이전트를 선택하고 인라인 키보드로 새 세션을 생성한다. 토큰 파일이 자동 갱신되어 MCP Server가 다음 API 호출 시 새 토큰을 사용한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Medium |
| Dependencies | 40-telegram-docker (봇 아키텍처), TS-1 (파일 영속화), TS-5 (lazy reload) |
| Confidence | HIGH |

**Why Differentiator:** 현재 MCP 생태계에서 세션 만료 시 메신저 봇을 통한 원클릭 재생성을 제공하는 제품은 없다. Claude Desktop, Cursor, Cline 모두 토큰 만료 시 사용자가 직접 설정 파일을 편집해야 한다. 모바일에서 어디서든 세션을 재생성할 수 있는 것은 Self-Hosted 데몬의 원격 관리에서 강력한 차별화이다.

**Ecosystem Evidence:**
- n8n의 Telegram UserBot session monitoring & recovery: 세션 모니터링 + 자동 복구 워크플로우
- Telegram Bot OAuth 패턴: chatId를 KV store에 저장하고, OAuth 콜백으로 토큰을 챗에 연결하는 패턴은 확립됨
- 그러나 MCP 서버 세션 관리를 Telegram으로 하는 사례는 없음 -- WAIaaS 고유

**Spec:**
- 명령어: `/newsession`
- 인증: chatId (Tier 1, 자금 이동 아님)
- 플로우: 에이전트 목록 -> 인라인 키보드 선택 -> 기본 constraints 적용 세션 생성 -> 파일 저장 -> 완료 메시지
- 기본 constraints 우선순위: agents.default_constraints (DB) > config.toml [session].default_constraints > 하드코딩

### DF-2: 투명한 세션 관리 (에이전트 무인지)

**What:** AI 에이전트(LLM)가 세션 수명을 전혀 인지하지 않는다. 갱신, 토큰 교체, 파일 영속화가 MCP Server 내부에서 투명하게 처리된다.

| Attribute | Value |
|-----------|-------|
| Complexity | Medium |
| Dependencies | TS-3 (자동 갱신), TS-5 (lazy reload) |
| Confidence | HIGH |

**Why Differentiator:** 대부분의 MCP 서버는 토큰 만료 시 에이전트에게 오류를 노출한다. WAIaaS에서는 SessionManager가 모든 token lifecycle을 캡슐화하여, tool handler는 `sessionManager.getToken()`만 호출하면 항상 유효한 토큰을 받는다. 에이전트 개발자가 구현할 것: 없음.

**Ecosystem Evidence:**
- AWS SDK의 credential provider는 개발자에게 투명: `S3Client()`만 생성하면 자동으로 credential chain 동작
- MCP 생태계에서 이 수준의 세션 투명성을 제공하는 서버는 없음
- MintMCP Gateway는 gateway 레벨에서 OAuth 토큰을 관리하지만, 개별 MCP 서버 내부에서 이를 처리하는 패턴은 다름

### DF-3: 에이전트별 기본 Constraints 프리셋

**What:** /newsession으로 생성되는 세션에 에이전트별 사전 설정된 constraints를 자동 적용한다. Owner가 Telegram에서 세부 constraints를 입력할 필요 없이, 에이전트의 역할에 맞는 적절한 제한이 자동으로 적용된다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | DF-1 (/newsession), 25-sqlite (agents 테이블) |
| Confidence | MEDIUM |

**Why Differentiator:** agents 테이블에 default_constraints 컬럼을 추가하면, 반복적인 세션 생성 시 동일한 constraints를 매번 지정하지 않아도 된다. "trading-bot"은 항상 USDC 전용 + 10 USD 한도, "monitoring-bot"은 읽기 전용 등 역할 기반 프리셋이 가능해진다.

### DF-4: SESSION_EXPIRING_SOON 사전 알림

**What:** 세션이 갱신 불가 상태에 임박하면 Owner에게 사전 알림을 보내, SSH 없이 Telegram에서 미리 새 세션을 준비할 수 있게 한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | TS-4 (에러 상태 + 알림), DF-1 (/newsession) |
| Confidence | HIGH |

**Why Differentiator:** 인증서/토큰 만료 사전 알림은 인프라 관리에서 확립된 패턴이지만, MCP 서버 세션에 적용한 사례는 없다. 알림과 /newsession을 결합하면 "알림 수신 -> 버튼 클릭 -> 세션 재생성" 원스텝 플로우가 가능하다.

**Spec:**
```
Telegram 알림 메시지:
  ⚠ Session Expiring Soon
  Agent: trading-bot
  Expires: 2026-03-07 14:00:00 UTC
  Remaining Renewals: 2
  [Create New Session] [Details]
```

### DF-5: 동시 갱신 방지 (Race Condition Guard)

**What:** 갱신 진행 중에 tool 호출이 발생해도 중복 갱신이 발생하지 않는다. 갱신 중에는 현재(이전) 토큰을 사용하고, 완료 후 다음 호출부터 새 토큰을 사용한다.

| Attribute | Value |
|-----------|-------|
| Complexity | Low |
| Dependencies | TS-3 (자동 갱신) |
| Confidence | HIGH |

**Why Differentiator:** 단순한 setInterval 기반 갱신은 race condition에 취약하다. SessionManager가 갱신 상태를 추적하여 중복 호출을 방지하는 것은 프로덕션 품질의 핵심이다.

---

## Anti-Features (의도적으로 구현하지 않는 기능)

구현하면 복잡성을 높이거나 보안을 약화시키는 기능. 명시적으로 범위에서 제외한다.

### AF-1: fs.watch 기반 파일 감시

**What:** ~/.waiaas/mcp-token 파일의 변경을 fs.watch로 실시간 감시하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| Node.js fs.watch는 OS별 동작이 불안정. macOS FSEvents는 race condition이 있고, Linux inotify는 rename 시 이벤트가 두 번 발생. Docker bind mount에서는 완전히 동작하지 않을 수 있음. MCP Server의 API 호출 빈도가 높지 않아 실시간 감시의 이점이 크지 않음. | 401 수신 시 lazy reload (TS-5). 요청 기반 감지가 더 안정적이고 예측 가능. |

### AF-2: Claude Desktop config.json 자동 수정

**What:** `waiaas mcp setup`이 Claude Desktop의 config.json을 자동으로 수정하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| config.json의 경로와 형식이 호스트 앱(Claude Desktop, Cursor, Cline)마다 다름. 자동 수정 실패 시 호스트 앱이 시작되지 않을 수 있음. 사용자의 기존 설정을 덮어쓸 위험. 버전 업데이트 시 경로/형식 변경 가능. | 설정 안내를 CLI 출력에 포함. 사용자가 복사-붙여넣기로 설정. 최초 1회만 필요하므로 자동화 대비 위험이 높음. |

### AF-3: 다중 MCP 클라이언트 동시 접속

**What:** 여러 MCP 클라이언트(Claude Desktop + Cursor 등)가 동시에 같은 토큰 파일을 사용하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| 토큰 로테이션(갱신 시 이전 토큰 무효화) 때문에 한 클라이언트가 갱신하면 다른 클라이언트의 토큰이 즉시 무효화됨. 파일 잠금(flock)으로도 해결 불가 -- 무효화된 토큰은 복구할 수 없음. | 단일 토큰 파일 전제(Self-Hosted 단일 MCP 클라이언트). 다중 클라이언트는 별도 세션으로 운영(별도 에이전트 생성). |

### AF-4: OAuth 2.1 / OIDC 기반 토큰 교환

**What:** MCP 스펙의 HTTP transport용 OAuth 2.1 플로우를 stdio transport에 적용하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| MCP 스펙이 명시적으로 "stdio transport는 OAuth 2.1을 따르지 않아야 한다(SHOULD NOT)"고 명시. Self-Hosted 단일 머신에 OAuth 인프라(Authorization Server)를 운영하는 것은 과도한 복잡성. JWT 세션 + masterAuth implicit가 Self-Hosted 환경에 더 적합. | 기존 JWT 세션 인증 체계 유지. 클라우드 전환 시 OAuth/mTLS 도입 (별도 마일스톤). |

### AF-5: MCP Streamable HTTP Transport 세션 관리

**What:** MCP의 Streamable HTTP transport에서의 세션 관리를 v0.9에서 설계하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| Claude Desktop은 현재 stdio만 지원. Streamable HTTP는 원격 MCP 서버용이며, WAIaaS의 Self-Hosted 전제와 맞지 않음. Streamable HTTP 도입 시 인증 모델이 근본적으로 변경됨 (OAuth 2.1 필수). | v0.9는 stdio 전제. Streamable HTTP는 클라우드 전환 마일스톤에서 검토. |

### AF-6: 자동 토큰 갱신 무한 연장

**What:** 30일 절대 수명이나 30회 갱신 한도를 우회하여 세션을 무한정 유지하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| 5종 안전 장치(v0.5: 53-renewal)의 존재 이유를 무효화함. 토큰이 탈취되었을 때 피해를 제한하는 핵심 메커니즘. 무한 세션은 보안 감사에서 반드시 문제로 지적됨. | 절대 수명 만료 시 /newsession 또는 mcp refresh-token으로 명시적 재발급. Owner의 인지와 개입이 필요한 보안 경계를 유지. |

### AF-7: 토큰 파일에 메타데이터 포함

**What:** 토큰 파일에 JWT 외에 세션 메타데이터(만료 시각, 갱신 횟수, 에이전트 이름 등)를 JSON 형태로 저장하는 것.

| Why Avoid | What To Do Instead |
|-----------|--------------------|
| JWT 자체에 이미 모든 메타데이터(exp, iat, sessionId)가 인코딩되어 있음. 파일 형식을 복잡하게 하면 파싱 실패 가능성 증가. 단순 문자열 파일은 `cat`으로 즉시 확인 가능하고, 다른 도구에서 읽기 쉬움. | JWT 단일 문자열만 저장. 메타데이터는 JWT payload에서 base64url 디코딩으로 추출. |

---

## Competitor Analysis: MCP 인증 상세 비교

### Claude Desktop

| 항목 | 현황 |
|------|------|
| Transport | stdio only |
| Auth 전달 | config.json env 섹션에서 환경변수 주입 |
| Token Lifecycle | 정적 (프로세스 시작 시 1회 고정) |
| 갱신 | 수동 (config.json 편집 -> 앱 재시작) |
| 알려진 문제 | env 섹션의 변수가 MCP 프로세스에 전달되지 않는 버그 보고 (Issue #1254, #23216) |
| Custom Connectors | Remote MCP 서버용 OAuth UI 플로우 (Team/Enterprise 전용 베타) |

**시사점:** Claude Desktop의 env var 한계가 WAIaaS v0.9의 파일 기반 토큰 접근을 더욱 정당화한다. env var 전달 자체가 불안정한 상황에서, 파일 기반이 더 신뢰할 수 있는 토큰 소스이다.

### Cursor

| 항목 | 현황 |
|------|------|
| Transport | stdio + SSE (원격) |
| Auth 전달 | env var (stdio), OAuth 2.0 UI 플로우 (원격) |
| Token Lifecycle | 정적 (stdio), OAuth 자동 갱신 (원격) |
| 갱신 | 수동 (stdio), 자동 (원격 OAuth) |
| 알려진 문제 | OAuth 플로우에서 public client가 Authorization Basic을 전송하는 버그 (Issue #3734) |
| YOLO 모드 | yoloDotFilesDisabled 옵션으로 .env/.ssh 접근 차단 가능 |

**시사점:** Cursor는 원격 MCP에서만 자동 갱신을 지원한다. stdio에서의 토큰 자동 관리는 미지원이며, 이는 WAIaaS SessionManager의 포지셔닝을 확인한다.

### Continue.dev

| 항목 | 현황 |
|------|------|
| Transport | stdio |
| Auth 전달 | env var, `${{ secrets.* }}` 암호화 참조 |
| Token Lifecycle | 정적 |
| 갱신 | 수동 (설정 파일 편집) |
| OAuth 지원 | Issue #6282로 요청됨 (미구현) |
| 설정 호환 | Claude Desktop/Cursor/Cline의 JSON config를 .continue/mcpServers/에 복사하면 자동 인식 |

**시사점:** Continue.dev는 secrets 참조 시스템으로 하드코딩을 회피하지만, 토큰 자동 갱신은 미지원.

### Cline

| 항목 | 현황 |
|------|------|
| Transport | stdio + SSE (원격 Bearer 토큰) |
| Auth 전달 | env var (mcp_settings.json) |
| Token Lifecycle | 정적 |
| 갱신 | 수동 |
| SSE Auth | Authorization: Bearer 헤더 지원 (원격) |

**시사점:** Cline은 stdio에서 env var 기반 정적 토큰만 지원. 원격 SSE에서 Bearer 토큰을 지원하지만 자동 갱신은 없음.

### Apify MCP CLI (mcpc)

| 항목 | 현황 |
|------|------|
| Transport | stdio + HTTP |
| Auth 전달 | CLI 프로파일 기반 |
| Token Lifecycle | OAuth 프로파일에서 관리 |
| Credential 저장 | ~/.mcpc/profiles.json (메타데이터) + OS keychain (토큰) |
| 세션 관리 | ~/.mcpc/sessions.json에 세션 메타데이터 영속화 |

**시사점:** Apify mcpc는 가장 진보된 credential 관리를 보여준다. OS keychain + 세션 파일 영속화 패턴은 WAIaaS의 파일 기반 접근과 유사하지만, OAuth 플로우에 의존하며 자동 갱신은 다름.

---

## Feature Dependencies

```
TS-1 (파일 영속화)
  |
  +-- TS-2 (로드 우선순위) -- File > Env
  |     |
  |     +-- TS-3 (자동 갱신) -- 60% 경과 시점 renew
  |     |     |
  |     |     +-- TS-4 (에러 상태 + 알림) -- SESSION_EXPIRING_SOON
  |     |     |     |
  |     |     |     +-- DF-4 (사전 알림) -- Telegram/Discord
  |     |     |
  |     |     +-- DF-2 (투명 세션 관리) -- getToken() 추상화
  |     |     |
  |     |     +-- DF-5 (동시 갱신 방지)
  |     |
  |     +-- TS-5 (401 lazy reload) -- 외부 토큰 전환
  |           |
  |           +-- DF-1 (/newsession) -- Telegram 원클릭
  |                 |
  |                 +-- DF-3 (기본 constraints 프리셋)
  |
  +-- TS-6 (mcp setup) -- CLI 원커맨드 설정
  |
  +-- TS-7 (mcp refresh-token) -- CLI 세션 재발급
```

**Critical Path:** TS-1 -> TS-2 -> TS-3 -> TS-5 -> DF-1
이 경로가 "토큰 파일 저장 -> 자동 갱신 -> 외부 토큰 전환 -> Telegram 재생성"의 전체 세션 자동화 흐름을 완성한다.

---

## MVP Recommendation

v0.9는 설계 마일스톤이므로, 모든 Table Stakes와 Differentiators를 설계에 포함하되, 구현 마일스톤(v1.3)에서의 우선순위를 제안한다.

### Phase 1 (v1.3 핵심): Table Stakes 전체

모든 TS-1 ~ TS-7을 구현한다. 이것이 없으면 MCP 세션이 수동 관리로 남는다.

1. **TS-1** (파일 영속화) + **TS-2** (로드 우선순위) -- 토큰 저장/로드 기반
2. **TS-3** (자동 갱신) -- SessionManager 핵심 기능
3. **TS-4** (에러 상태 + 알림) -- 실패 시 알림
4. **TS-5** (401 lazy reload) -- 외부 토큰 전환
5. **TS-6** (mcp setup) + **TS-7** (mcp refresh-token) -- CLI 커맨드

### Phase 2 (v1.3 확장): Differentiators

1. **DF-2** (투명 세션 관리) -- SessionManager getToken() 추상화 (TS-3과 동시 구현)
2. **DF-5** (동시 갱신 방지) -- Race condition guard (TS-3과 동시 구현)
3. **DF-4** (SESSION_EXPIRING_SOON 알림) -- TS-4와 동시 구현

### Phase 3 (v1.6 Telegram): 원격 관리

1. **DF-1** (/newsession) -- Telegram Bot에 종속, v1.6에서 구현
2. **DF-3** (기본 constraints 프리셋) -- DF-1과 동시 구현

### Defer (범위 외)

- AF-1 ~ AF-7의 모든 Anti-Features는 명시적으로 제외

---

## Sources

### MCP Specification (HIGH Confidence)
- [MCP Authorization Specification (Draft)](https://modelcontextprotocol.io/specification/draft/basic/authorization) -- stdio transport에서 OAuth 2.1을 따르지 말아야 한다는 명시적 규정 확인
- [MCP Authorization Specification (2025-03-26)](https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization) -- 원본 스펙
- [MCP Authorization Tutorial](https://modelcontextprotocol.io/docs/tutorials/security/authorization) -- 보안 가이드

### MCP Spec Evolution (HIGH Confidence)
- [MCP Spec Updates June 2025 - Auth0](https://auth0.com/blog/mcp-specs-update-all-about-auth/) -- Resource Server/Authorization Server 분리
- [November 2025 MCP Authorization Spec Update - Aaron Parecki](https://aaronparecki.com/2025/11/25/1/mcp-authorization-spec-update) -- CIMD, Enterprise-Managed Authorization

### Security Research (MEDIUM Confidence)
- [MCP Credential Weakness - ReversingLabs](https://www.reversinglabs.com/blog/mcp-server-credential-weakness) -- 53% PAT 의존, 79% env var 저장
- [Security Proposal: Credential Management in MCP Server - GitHub Issue #754](https://github.com/modelcontextprotocol/servers/issues/754) -- 임시/영구 credential 관리 제안
- [Securing MCP Servers in Cursor - MintMCP](https://www.mintmcp.com/blog/securing-servers-with-mcp) -- OAuth 2.0 기반 credential 로테이션 권장

### Competitor Documentation (MEDIUM Confidence)
- [Cursor MCP Docs](https://cursor.com/docs/context/mcp) -- env var + OAuth UI
- [Continue.dev MCP Setup](https://docs.continue.dev/customize/deep-dives/mcp) -- secrets 참조
- [Cline MCP Configuration](https://docs.cline.bot/mcp/configuring-mcp-servers) -- mcp_settings.json
- [Apify MCP CLI](https://github.com/apify/mcp-cli) -- profiles.json + OS keychain

### Industry Patterns (MEDIUM Confidence)
- [Stack Overflow: MCP Authentication and Authorization](https://stackoverflow.blog/2026/01/21/is-that-allowed-authentication-and-authorization-in-model-context-protocol/) -- 생태계 현황 분석
- [MCP Authentication Guide - Stytch](https://stytch.com/blog/MCP-authentication-and-authorization-guide/) -- 구현 가이드
- [Infisign MCP Auth Guide](https://www.infisign.ai/blog/what-is-mcp-authentication-authorization) -- 2026 최신 현황

### Claude Desktop Issues (MEDIUM Confidence)
- [Claude Code env var Bug #1254](https://github.com/anthropics/claude-code/issues/1254) -- env 섹션 변수 미전달 버그
- [Claude Code env var Bug #23216](https://github.com/anthropics/claude-code/issues/23216) -- mcp_settings.json env 미전달
- [Claude Custom Connectors](https://support.claude.com/en/articles/11503834-building-custom-connectors-via-remote-mcp-servers) -- Remote MCP OAuth UI (Team/Enterprise)
