# Domain Pitfalls: x402 클라이언트 지원 -- Self-Hosted Wallet Daemon에 HTTP 결제 프로토콜 추가

**Domain:** Self-hosted AI agent wallet daemon -- x402 HTTP payment protocol client, SSRF prevention, EIP-3009 signing, Solana partial signing, synchronous HTTP proxy pattern
**Project:** WAIaaS v1.5.1 (x402 클라이언트)
**Researched:** 2026-02-15
**Overall Confidence:** MEDIUM-HIGH (x402 공식 스펙, EIP-3009 표준, OWASP SSRF 가이드, 기존 코드베이스 직접 분석 교차 검증)

---

## Overview

이 문서는 **기존 6-stage 트랜잭션 파이프라인과 4-tier 정책 엔진을 가진 self-hosted wallet daemon에 x402 프로토콜 클라이언트를 추가할 때** 발생하는 함정을 다룬다. 기존 PITFALLS.md(v1.7 sign-only)가 외부 unsigned transaction 파싱과 정책 매핑에 집중했다면, 이 문서는 **데몬이 사용자 지정 외부 URL로 HTTP 요청을 보내는 새로운 공격 표면**과 **x402 결제 프로토콜 특유의 보안 모델**에 집중한다.

핵심 위험: x402 클라이언트 지원은 WAIaaS 데몬을 **HTTP 프록시**로 전환한다. 에이전트가 제공한 임의의 URL로 outbound HTTP 요청을 보내고, 402 응답 시 결제 서명을 생성하여 재요청한다. 이는 기존 "내부에서 빌드한 트랜잭션만 처리"하는 보안 경계를 근본적으로 확장한다.

각 함정은 **Critical(보안 구멍 또는 자금 손실)**, **High(정책 우회 또는 주요 재작업)**, **Moderate(기술 부채 또는 UX 혼란)** 3단계로 분류한다.

---

## Critical Pitfalls

보안 구멍, 자금 손실, 또는 시스템 침해를 야기하는 실수.

---

### C-01: SSRF -- DNS Rebinding으로 TOCTOU 공격하여 내부 네트워크 접근

**Severity:** CRITICAL
**Confidence:** HIGH (OWASP SSRF Prevention Cheat Sheet, agent-fetch 라이브러리 분석, DNS rebinding 공격 연구 교차 검증)

**What goes wrong:**
에이전트가 `POST /v1/x402/fetch`로 외부 URL을 요청할 때, 데몬이 URL을 검증한 뒤 실제 HTTP 요청을 보내는 사이에 DNS 응답이 변경되는 TOCTOU(Time-Of-Check-To-Time-Of-Use) 공격이다.

**공격 시나리오:**
```
1. 에이전트가 URL "https://evil-api.attacker.com/data" 요청
2. ssrf-guard.ts가 DNS resolve -> 공격자의 public IP 93.184.216.34 -> 통과
3. Node.js fetch()가 실제 요청을 보낼 때 DNS 재조회 -> 공격자 DNS가 127.0.0.1 반환
4. 데몬이 localhost의 내부 서비스에 요청 전송
5. 내부 서비스 응답이 에이전트에게 반환 -> 내부 네트워크 정보 유출
```

**공격 변형:**
- **클라우드 메타데이터:** DNS를 `169.254.169.254`로 rebind하여 AWS/GCP 메타데이터 서비스 접근 -> IAM 토큰 탈취
- **데몬 자체 접근:** `127.0.0.1:3000`으로 rebind하여 WAIaaS의 owner/admin API 호출 -> 정책 변경, Kill Switch 비활성화
- **내부 서비스 스캔:** 다양한 내부 IP로 rebind하여 네트워크 토폴로지 탐색

**현재 코드의 문제:**
목표 파일 구조에 `ssrf-guard.ts`가 명시되어 있지만, 단순 IP 블록리스트(127.x, 10.x, 172.16-31.x, 192.168.x, ::1)만으로는 DNS rebinding을 방어할 수 없다. Node.js의 `fetch()`/`undici`는 DNS resolve와 connection을 별도 단계로 수행하므로, resolve 시점과 connect 시점 사이에 DNS 응답이 변경될 수 있다.

**Why it happens:**
- URL 검증과 HTTP 요청이 2단계로 분리되어 DNS 캐시 갱신 타이밍에 취약
- Node.js 기본 HTTP 클라이언트가 DNS pinning을 지원하지 않음
- 개발 시 "사설 IP 차단"만으로 SSRF 방어가 충분하다고 오인

**Warning signs:**
- `ssrf-guard.ts`가 URL 파싱 후 IP 비교만 수행하고 실제 연결에는 관여하지 않음
- DNS resolve 결과를 HTTP 요청에 강제 적용하는 로직 없음
- DNS rebinding에 대한 테스트 케이스 없음

**Prevention:**
1. **DNS resolve + IP 검증 + 연결을 원자적으로 수행:** DNS를 직접 resolve한 뒤 반환된 IP를 검증하고, 검증된 IP로 직접 연결. Node.js undici의 `connect` 옵션 또는 `lookup` 콜백을 사용하여 런타임 DNS 재조회를 방지.
```typescript
// 올바른 접근: DNS resolve -> IP 검증 -> 검증된 IP로 직접 연결
import { lookup } from 'dns/promises';

async function safeFetch(url: string, options: RequestInit): Promise<Response> {
  const parsed = new URL(url);
  const addresses = await lookup(parsed.hostname, { all: true });

  // A + AAAA 레코드 모두 검증
  for (const addr of addresses) {
    if (isPrivateIP(addr.address)) {
      throw new WAIaaSError('X402_SSRF_BLOCKED', {
        message: `Resolved IP ${addr.address} is private`,
      });
    }
  }

  // 검증된 첫 번째 IP로 직접 연결 (DNS 재조회 방지)
  const agent = new Agent({
    connect: {
      hostname: addresses[0].address,
      servername: parsed.hostname, // TLS SNI용
    },
  });

  return fetch(url, { ...options, dispatcher: agent });
}
```
2. **IPv6 매핑 주소 완전 차단:** `::ffff:127.0.0.1` (IPv4-mapped IPv6), `::1` (IPv6 loopback), `fe80::/10` (link-local), `fc00::/7` (ULA) 모두 차단. 10진수(`2130706433` = `127.0.0.1`), 8진수(`0177.0.0.1`), 16진수(`0x7f000001`) 표현도 정규화 후 차단.
3. **리다이렉트 추적 시 매 hop마다 재검증:** HTTP 301/302/307/308 리다이렉트 시 새 URL에 대해 동일한 DNS resolve + IP 검증 + 도메인 정책 검증 반복. 최대 리다이렉트 횟수 제한(예: 3회).
4. **agent-fetch 라이브러리 평가:** `agent-fetch`는 Rust로 구현된 SSRF-safe HTTP 클라이언트로, DNS resolution + IP validation + TCP connection을 원자적으로 수행. npm 패키지로 사용 가능. 다만 외부 의존성 추가이므로 직접 구현 vs 라이브러리 사용 결정 필요.

**테스트 시나리오:**
```
T-01: url=http://127.0.0.1/admin -> SSRF 차단 assert
T-02: url=http://[::1]/admin -> IPv6 loopback 차단 assert
T-03: url=http://[::ffff:127.0.0.1]/admin -> IPv4-mapped IPv6 차단 assert
T-04: url=http://169.254.169.254/latest/meta-data/ -> 클라우드 메타데이터 차단 assert
T-05: url=http://2130706433/ -> 10진수 IP(127.0.0.1) 차단 assert
T-06: url=http://0x7f000001/ -> 16진수 IP 차단 assert
T-07: DNS rebinding mock (첫 resolve = public IP, 두 번째 = 127.0.0.1) -> 차단 assert
T-08: url=http://evil.com -> 301 -> http://127.0.0.1 -> 리다이렉트 후 차단 assert
T-09: url=http://10.0.0.1:8080/internal -> 사설 IP 차단 assert
T-10: url=http://localhost:3000/v1/owner/policies -> localhost 차단 assert
```

**Phase:** SSRF 방어 레이어 구현 시 (x402 파이프라인 이전에 완료 필수)

---

### C-02: 결제 서명 후 리소스 서버 실패 -- 자금 손실 위험 (Signed-But-Not-Delivered)

**Severity:** CRITICAL
**Confidence:** HIGH (x402 프로토콜 스펙 + 기존 결제 시스템 패턴 분석)

**What goes wrong:**
x402 결제 흐름에서 "서명한 결제가 정산되었지만 리소스를 받지 못하는" 시나리오가 존재한다.

**시나리오 1: 네트워크 타이밍 문제**
```
1. 에이전트 -> 데몬: POST /v1/x402/fetch {url: "https://api.example.com/data"}
2. 데몬 -> api.example.com: GET /data
3. api.example.com -> 데몬: HTTP 402 + PaymentRequirements
4. 데몬: EIP-3009 서명 생성 (USDC $5.00 transferWithAuthorization)
5. 데몬 -> api.example.com: GET /data + X-PAYMENT header (서명 포함)
6. api.example.com -> facilitator: 결제 검증 + 온체인 정산 (USDC $5.00 전송 완료)
7. api.example.com -> 데몬: 응답 전송 중 네트워크 타임아웃/연결 끊김
8. 데몬 -> 에이전트: 에러 반환 (리소스 미수신)
9. 결과: $5.00 지불했지만 리소스 미수신. 서명은 사용됨(nonce 소진). 재시도 불가.
```

**시나리오 2: 리소스 서버의 악의적 행동**
```
1-6. 동일 흐름
7. api.example.com: 결제 정산 완료 확인 -> 의도적으로 빈 응답 또는 에러 반환
8. 결과: 자금 탈취. x402 프로토콜에 분쟁 해결 메커니즘 없음.
```

**시나리오 3: facilitator 정산 실패 후 재시도**
```
1-5. 동일 흐름
6. api.example.com -> facilitator: 정산 시도 -> 실패 (네트워크 혼잡, 잔액 부족 등)
7. api.example.com -> 데몬: HTTP 402 재반환 (결제 미완료)
8. 데몬: 같은 nonce로 재시도? -> 새 nonce로 재서명? -> 이중 결제 위험
```

**핵심 문제:** x402 클라이언트(WAIaaS)는 결제 서명을 리소스 서버에 위임하고, facilitator 정산은 리소스 서버 측에서 수행된다. 클라이언트는 정산이 실제로 온체인에서 완료되었는지 직접 확인할 수 없다. "서명 = 자금 이동 가능성"이지만 "서명 제출 = 자금 이동 확정"은 아니다(EIP-3009). 그러나 서명이 facilitator에 전달된 순간 클라이언트가 이를 취소할 방법이 없다.

**Why it happens:**
- x402 프로토콜이 "optimistic execution" 모델 -- 결제 후 리소스 제공을 서버의 선의에 의존
- 환불/분쟁 해결 메커니즘이 프로토콜 스펙에 없음
- 클라이언트가 facilitator의 정산 상태를 직접 조회하는 표준 인터페이스 없음

**Warning signs:**
- x402 재요청 시 에러 응답에 대한 처리가 "에러 반환"으로 끝남
- 결제 서명 정보(nonce, amount, recipient)를 감사 로그에 기록하지 않음
- 리소스 서버 응답 실패 시 결제 상태를 추적할 방법 없음

**Prevention:**
1. **결제 서명 전 온체인 잔액 확인:** 서명 생성 전에 USDC 잔액이 결제 금액 이상인지 확인. 잔액 부족 시 서명 거부(facilitator 정산 실패를 사전 방지).
2. **결제 서명 즉시 감사 로그 기록:** 서명 생성 시점에 `{nonce, amount, recipient(payTo), validBefore, targetUrl, walletId, timestamp}` 를 audit_log에 기록. 온체인 정산 여부와 무관하게 추적 가능.
3. **재요청 제한: 1회만 재시도, 동일 nonce 재사용 금지:**
```typescript
// 402 응답 -> 결제 서명 -> 재요청 -> 결과
// 재요청 결과가 다시 402면 -> X402_PAYMENT_REJECTED 에러 반환
// 절대로 자동 재시도하지 않음
// 새 nonce로 재서명하는 것은 이중 결제 위험
if (retryResponse.status === 402) {
  throw new WAIaaSError('X402_PAYMENT_REJECTED', {
    message: 'Payment was rejected by resource server after signing',
    metadata: { nonce, amount, payTo }, // 감사 추적용
  });
}
```
4. **EIP-3009 validBefore를 짧게 설정:** `validBefore = now + 5분` (현재 권장은 1시간이지만, WAIaaS 보안 모델에서는 짧게). 만료된 서명은 정산 불가하므로 자금 손실 창구를 최소화.
5. **결제 완료 알림 + 트랜잭션 해시 기록:** 리소스 서버가 `X-PAYMENT-RESPONSE` 헤더로 settlement 결과를 반환하면, txHash를 transactions 테이블에 기록. 반환하지 않으면 "정산 미확인" 상태로 표시.
6. **운영자 대시보드에 "미확인 결제" 섹션:** 서명은 생성되었지만 정산 확인이 없는 결제를 운영자가 직접 확인할 수 있는 UI.

**Phase:** x402 핸들러 결제 흐름 구현 시 (결제 서명 생성 전에 방어 로직 선행)

---

### C-03: 동시 x402 요청의 Race Condition -- SPENDING_LIMIT reserved_amount 우회

**Severity:** CRITICAL
**Confidence:** HIGH (기존 evaluateAndReserve() 코드 직접 분석 + x402 동기 HTTP 프록시 패턴 분석)

**What goes wrong:**
두 에이전트 세션이 동시에 x402 결제를 요청할 때, x402의 "금액 지연 확인" 특성 때문에 기존 TOCTOU 방지 메커니즘인 `evaluateAndReserve()`에 구조적 gap이 생긴다.

**기존 파이프라인 (안전):**
```
요청(금액 확정) -> Stage 1 (INSERT PENDING) -> Stage 3 (evaluateAndReserve -- BEGIN IMMEDIATE로 직렬화)
-> Stage 5 (실행) -> 완료
```

**x402 파이프라인 (gap 존재):**
```
요청(금액 불명) -> 외부 HTTP 요청(수백ms~수초) -> 402 응답(금액 확인)
-> evaluateAndReserve() -> 서명 생성 -> 재요청 -> 응답 반환
```

**Race condition 위험 구간:**
x402에서는 "외부 HTTP 요청 수행 중"에는 결제 금액을 알 수 없으므로 reservation을 설정할 수 없다. 이 구간이 기존 파이프라인에는 존재하지 않는다.

```
t=0ms: 세션 A -> POST /v1/x402/fetch -> 외부 HTTP 요청 시작 (금액 불명, 예약 불가)
t=0ms: 세션 B -> POST /v1/wallets/:id/send ($90) -> evaluateAndReserve -> reserved=$0 -> INSTANT 통과
       (A의 x402 결제가 아직 reservation 안 됨 - 금액 자체를 모르므로)
t=500ms: A의 402 응답 ($30) -> evaluateAndReserve -> reserved=$90 -> $120 > $100 -> DELAY
```

위 시나리오에서 A는 B 이후에 차단되므로 자체는 안전하다. 그러나 **순서가 반전되면:**
```
t=0ms: 세션 A -> POST /v1/x402/fetch -> 외부 HTTP 요청 시작
t=0ms: 세션 B -> POST /v1/x402/fetch -> 외부 HTTP 요청 시작
t=100ms: A 402 응답 ($60) -> evaluateAndReserve -> reserved=$0 -> INSTANT
t=100ms: B 402 응답 ($60) -> evaluateAndReserve -> reserved=$60 -> $120 > $100 -> DELAY (차단)
```

`BEGIN IMMEDIATE` 직렬화 덕분에 B는 A의 reservation을 확인하므로 안전하다. **핵심: evaluateAndReserve()의 기존 직렬화 메커니즘은 x402에서도 유효하다.** 그러나 "외부 HTTP 요청 중" 수 초간 reservation이 없는 구간이 존재하므로, 이 구간에 기존 파이프라인 요청이 들어오면 x402 결제 금액을 고려하지 못한다.

**Why it happens:**
- x402 결제 금액은 402 응답에서만 알 수 있어, 요청 시점에 사전 reservation 불가
- 외부 HTTP 요청 시간(수백 ms ~ 수 초)이 reservation 미적용 구간
- 기존 파이프라인에서는 요청 = 금액 확정이므로 이 문제 없음

**Prevention:**
1. **x402 전용 pre-reservation:** 외부 HTTP 요청 전에 설정 가능한 최소 reservation을 설정하고, 402 응답 후 실제 금액으로 갱신하는 2단계 reservation. 비-402 응답(200) 시 즉시 해제.
```typescript
// Step 1: pre-reserve (config.x402.pre_reserve_amount_usd = $10 기본값)
const preReserveAmount = config.x402.pre_reserve_amount_usd;
preReserve(walletId, txId, preReserveAmount);

// Step 2: 외부 HTTP 요청
const response = await safeFetch(url, options);

// Step 3a: 비-402 -> 즉시 해제
if (response.status !== 402) {
  releaseReservation(txId);
  return proxyResponse(response);
}

// Step 3b: 402 -> 실제 금액으로 reservation 갱신
const paymentReq = parsePaymentRequirements(response);
updateReservation(walletId, txId, paymentReq.amount);
```
2. **wallet별 x402 동시 요청 제한:** 같은 wallet에서 동시에 처리 중인 x402 요청 수를 제한(기본 1). 두 번째 요청은 첫 번째가 완료될 때까지 큐잉 또는 거부.
3. **테스트: 동시 x402 + 기존 파이프라인 혼합 시나리오 필수.**

**Phase:** x402 정책 통합 시 (evaluateAndReserve 연동 설계)

---

### C-04: EIP-3009 Nonce 관리 실패 -- 이중 결제 또는 Frontrunning

**Severity:** CRITICAL
**Confidence:** HIGH (EIP-3009 표준 스펙 + CoinBase USDC 구현체 + x402 EVM exact scheme 분석)

**What goes wrong:**
EIP-3009 `transferWithAuthorization`은 랜덤 32-byte nonce를 사용하며, 한 번 사용된 nonce는 온체인에서 재사용 불가하다. x402 클라이언트에서 nonce 관리 실패 시:

**시나리오 1: Frontrunning (transferWithAuthorization)**
```
1. 데몬이 EIP-3009 서명 생성: transferWithAuthorization(from, payTo, $5, ...)
2. 데몬 -> 리소스 서버: X-PAYMENT 헤더에 서명 포함하여 재요청
3. 리소스 서버 -> facilitator: 서명 전달
4. 그런데: 리소스 서버가 악의적이라면?
   - 서명을 facilitator에 전달하지 않고 직접 온체인에 제출
   - 또는 다른 facilitator에 전달하여 정산
   - 또는 서명을 저장해두었다가 validBefore 이전에 나중에 정산
5. 결과: 결제는 정산되지만 리소스 미제공
```

EIP-3009의 `transferWithAuthorization`은 **누구나** 제출 가능하다. `receiveWithAuthorization`은 caller = payee를 강제하지만, x402에서 facilitator가 호출하므로 `receiveWithAuthorization` 사용 불가(facilitator != payee).

**시나리오 2: Authorization Expiration Window 과다 설정**
```
1. 데몬이 validBefore = now + 1시간으로 서명 생성
2. 리소스 서버가 즉시 정산하지 않고 서명을 보관
3. 59분 후 정산 실행 -> 데몬 입장에서는 "이미 잊은" 결제가 갑자기 실행
4. SPENDING_LIMIT의 reserved_amount는 이미 TTL로 해제됨
5. 결과: 정책 한도를 초과하는 결제가 실행됨
```

**Why it happens:**
- EIP-3009의 `transferWithAuthorization`은 누구나 제출 가능 (caller 제한 없음)
- 서명이 리소스 서버에 전달되는 순간 클라이언트가 통제력을 상실
- validBefore가 길수록 공격 창구가 넓어짐

**Warning signs:**
- nonce 생성에 `crypto.randomBytes(32)` 대신 순차적 카운터 사용
- validBefore가 1시간 이상으로 설정
- 서명 생성 후 nonce를 DB에 기록하지 않음
- 동일 payTo + amount에 대한 중복 서명 방지 없음

**Prevention:**
1. **validBefore를 최소화:** `validBefore = now + 5분` (x402 권장의 1시간 대신). WAIaaS 보안 모델에서는 최소 유효 기간을 사용. 5분이면 x402 재요청 + facilitator 정산에 충분.
2. **nonce를 DB에 기록:** 생성된 nonce를 transactions 테이블의 metadata에 기록. 동일 nonce로의 중복 서명 요청 거부(이론상 불필요하지만 방어적 프로그래밍).
3. **reserved_amount TTL을 validBefore와 동기화:** EIP-3009 서명의 reservation은 `validBefore` 시점까지 유지. validBefore 경과 후 reservation 해제. 이렇게 하면 "만료된 서명 + 해제된 reservation -> 초과 결제" 시나리오 방지.
4. **결제 금액을 amount 필드에 정확히 기록:** EIP-3009의 value는 토큰 최소 단위(USDC 6-decimal)이므로, $5.00 = 5000000. 이를 USD로 환산하여 SPENDING_LIMIT 평가에 사용. USDC/USDT는 $1 직접 환산, 기타 토큰은 IPriceOracle.
5. **nonce 생성은 반드시 `crypto.randomBytes(32)` 사용:** EIP-3009 표준이 요구하는 랜덤 bytes32 nonce. 순차 카운터, 타임스탬프 기반 nonce는 보안적으로 부적절.

**Phase:** EVM 결제 서명 생성기 구현 시

---

### C-05: 도메인 검증 우회 -- URL 파싱 공격으로 X402_ALLOWED_DOMAINS 정책 무효화

**Severity:** CRITICAL
**Confidence:** HIGH (OWASP URL parsing cheat sheet, PortSwigger URL validation bypass 연구, 기존 X402_ALLOWED_DOMAINS 설계 분석)

**What goes wrong:**
X402_ALLOWED_DOMAINS 정책이 `rules.domains = ["api.example.com"]`으로 설정되었을 때, 공격자가 URL 파싱의 모호성을 이용하여 정책을 우회한다.

**공격 벡터 목록:**

| # | 공격 | URL | 추출되는 hostname | 실제 연결 대상 |
|---|------|-----|-------------------|--------------|
| 1 | Userinfo 속임 | `https://api.example.com@evil.com/data` | `evil.com` (정상 파서) 또는 `api.example.com` (취약 파서) | `evil.com` |
| 2 | 서브도메인 위장 | `https://api.example.com.evil.com/data` | `api.example.com.evil.com` | 공격자 서버 |
| 3 | 백슬래시 혼동 | `https://api.example.com\@evil.com/data` | 파서마다 다름 | 파서 의존 |
| 4 | URL encoding | `https://api.example%2Ecom@evil.com/data` | 파서마다 다름 | 파서 의존 |
| 5 | Unicode 정규화 | `https://api.example.com\u2028evil.com/data` | line separator가 포함된 hostname | 파서 의존 |
| 6 | 와일드카드 우회 | 정책 `*.example.com` + URL `https://evil-example.com/` | `evil-example.com` | 공격자 (dot-boundary 미검증 시) |
| 7 | 리다이렉트 탈출 | `https://api.example.com/redirect?to=https://evil.com` | `api.example.com` (초기) | `evil.com` (리다이렉트 후) |

**Why it happens:**
- URL 파싱과 도메인 비교가 2단계로 분리 (파싱 결과와 비교 로직의 불일치)
- `new URL()`의 hostname 추출과 실제 HTTP 요청의 대상이 다를 수 있음
- 와일드카드 매칭에서 dot-boundary를 명시적으로 검증하지 않음
- Unicode 정규화, URL encoding, 특수 문자 처리의 미비

**Prevention:**
1. **URL 파싱은 반드시 `new URL()` 한 번만:** Node.js `URL` constructor로 파싱 후 `url.hostname`만 사용. 원본 문자열에 대한 regex/string matching 금지.
2. **hostname 정규화 후 비교:**
```typescript
function isDomainAllowed(hostname: string, allowedDomains: string[]): boolean {
  // 정규화: lowercase + trailing dot 제거 + punycode 변환
  const normalized = hostname.toLowerCase().replace(/\.$/, '');

  for (const pattern of allowedDomains) {
    if (pattern.startsWith('*.')) {
      // 와일드카드: dot-boundary 엄격 검증
      const suffix = pattern.slice(1).toLowerCase(); // ".example.com"
      if (normalized === suffix.slice(1)) return true; // 정확히 "example.com"
      if (normalized.endsWith(suffix)) return true;
      // "api.example.com".endsWith(".example.com") = true (OK)
      // "evil-example.com".endsWith(".example.com") = false (차단)
    } else {
      // 정확 매칭
      if (normalized === pattern.toLowerCase()) return true;
    }
  }
  return false;
}
```
3. **Userinfo(@) 포함 URL 거부:** `url.username` 또는 `url.password`가 비어있지 않으면 즉시 거부.
4. **포트 제한:** 80, 443만 허용. 비표준 포트(8080, 3000 등)를 통한 내부 서비스 접근 차단.
5. **리다이렉트 후 도메인 재검증:** 리다이렉트 대상의 hostname이 X402_ALLOWED_DOMAINS에 포함되지 않으면 거부. 리다이렉트 체인의 모든 hop에서 검증.

**테스트 시나리오:**
```
T-01: url=https://api.example.com@evil.com -> userinfo 거부 assert
T-02: url=https://api.example.com.evil.com -> 서브도메인 위장 거부 assert
T-03: domains=["*.example.com"] + url=https://evil-example.com -> dot-boundary 거부 assert
T-04: domains=["*.example.com"] + url=https://sub.example.com -> 허용 assert
T-05: domains=["*.example.com"] + url=https://example.com -> 허용 assert (bare domain)
T-06: url=https://api.example.com:8080/ -> 비표준 포트 거부 assert
T-07: url=https://api.example.com -> 301 -> https://evil.com -> 리다이렉트 후 거부 assert
T-08: url=https://api.example%2Ecom -> URL encoding 정규화 후 올바른 비교 assert
```

**Phase:** 도메인 검증 로직 구현 시 (SSRF 방어와 함께 구현)

---

## High Pitfalls

정책 우회, 기능 재작업, 또는 심각한 UX 문제를 야기하는 실수.

---

### H-01: 타임아웃 캐스케이드 -- 3단계 타임아웃의 충돌

**Severity:** HIGH
**Confidence:** HIGH (기존 파이프라인 타임아웃 패턴 + x402 동기 HTTP 흐름 분석)

**What goes wrong:**
x402 fetch 흐름에는 최소 3단계의 타임아웃이 중첩된다:

```
L1: 에이전트 -> 데몬 HTTP 요청 타임아웃 (SDK client timeout, 기본 30s)
  L2: 데몬 -> 외부 API 요청 타임아웃 (config.x402.request_timeout, 기본 30s)
    L3: DELAY 티어 대기 시간 (policy_defaults_delay_seconds, 기본 60s)
```

**시나리오 1: L3 > L1 (가장 흔한 실수)**
```
DELAY 대기 = 60초, 에이전트 SDK 타임아웃 = 30초
1. 에이전트 -> 데몬: POST /v1/x402/fetch
2. 데몬 -> 외부 API -> 402 응답 (200ms)
3. 데몬: 정책 평가 -> DELAY(60초)
4. 데몬: 60초 대기 시작
5. t=30초: 에이전트 SDK 타임아웃 -> 에이전트 연결 끊김
6. t=60초: 데몬 대기 완료 -> 서명 생성 -> 재요청 -> 에이전트 없음
7. 결과: 결제 서명은 생성되었지만 에이전트에게 전달 안 됨
         서명은 유효(facilitator가 정산 가능) -> 자금 손실 위험
```

**시나리오 2: 외부 API 2회 요청 + DELAY**
```
DELAY = 15초, 외부 요청 = 10초, 에이전트 타임아웃 = 30초
총 소요: 10초(첫 요청) + 15초(DELAY) + 10초(재요청) = 35초 > 30초
결과: 에이전트 타임아웃으로 실패
```

**Why it happens:**
- 3단계 타임아웃이 독립적으로 설정되어 총합이 상위 타임아웃을 초과
- DELAY 대기 시간이 x402의 동기 HTTP 모델과 비호환
- "외부 HTTP 요청 2회(첫 요청 + 재요청)"의 시간을 고려하지 않은 타임아웃 설정

**Prevention:**
1. **x402 전용 타임아웃 budget 패턴:**
```typescript
const totalBudget = config.x402.request_timeout; // 30초
const startTime = Date.now();

// Step 1: 외부 첫 요청 (budget의 40%)
const fetchTimeout = totalBudget * 0.4; // 12초
const response = await safeFetch(url, { signal: AbortSignal.timeout(fetchTimeout * 1000) });

// Step 2: DELAY 처리 (남은 시간 계산)
const elapsed = Date.now() - startTime;
const remaining = totalBudget * 1000 - elapsed;
if (tier === 'DELAY' && delaySeconds * 1000 > remaining) {
  throw new WAIaaSError('X402_DELAY_TIMEOUT', {
    message: `DELAY ${delaySeconds}s exceeds remaining budget ${remaining / 1000}s`,
  });
}
await sleep(delaySeconds * 1000);

// Step 3: 재요청 (남은 시간 전부)
const retryElapsed = Date.now() - startTime;
const retryTimeout = totalBudget * 1000 - retryElapsed;
const retryResponse = await safeFetch(url, {
  signal: AbortSignal.timeout(retryTimeout)
});
```
2. **DELAY 대기가 remaining budget을 초과하면 서명 생성 전 즉시 거부:** 서명을 생성하지 않으므로 자금 보호.
3. **APPROVAL 티어는 무조건 즉시 거부:** x402는 동기 HTTP이므로 Owner 승인 대기 불가. `X402_APPROVAL_REQUIRED` 에러 + 금액 조정 hint 반환.
4. **에이전트 SDK에 x402 전용 타임아웃 설정:** `WAIaaSClient.x402Fetch(url, { timeout: 60000 })` -- x402 fetch는 기본 타임아웃보다 길게 설정 가능하도록.

**Phase:** x402 핸들러 타임아웃 처리 시

---

### H-02: Solana x402 결제 -- Blockhash Freshness와 서명 시맨틱

**Severity:** HIGH
**Confidence:** MEDIUM (x402 Solana SVM exact scheme 분석 + Solana blockhash lifetime 연구. Solana x402 exact scheme의 상세 스펙은 완전히 확인되지 않음)

**What goes wrong:**
Solana x402 exact scheme에서 클라이언트는 SPL `TransferChecked` instruction이 포함된 트랜잭션을 서명하고, facilitator가 제출한다.

**Blockhash 문제:**
```
1. 데몬: 402 응답 수신 -> Solana 트랜잭션 구성 시작
2. 데몬: getLatestBlockhash() -> blockhash 획득 (유효 기간 ~60초 = 약 150 slot)
3. 데몬: TransferChecked instruction 구성 -> 트랜잭션 서명 (payer)
4. 데몬 -> 리소스 서버: X-PAYMENT 헤더에 서명 트랜잭션 포함
5. 리소스 서버 -> facilitator: 검증 + 제출
6. 문제: Step 2부터 Step 5까지 수 초 소요
   - 네트워크 지연, facilitator 처리 시간
   - blockhash가 이미 만료에 가까울 수 있음
   - facilitator가 제출할 때 blockhash expired -> 결제 실패
```

**EVM과의 근본적 차이:**
- EVM(EIP-3009): 서명 = "나는 이 금액을 이 주소로 보내는 것을 허가합니다" (허가만, 실행은 별도). validBefore로 시간 제한.
- Solana: 서명 = "이 트랜잭션을 실행해주세요" (실행 자체를 위임). blockhash로 시간 제한.
- EVM은 validBefore를 5분으로 설정 가능. Solana는 blockhash lifetime이 ~60초로 고정.
- Solana 서명된 tx가 제출되면 자금이 즉시 이동. 취소 불가.

**Why it happens:**
- EVM과 Solana의 서명 모델이 근본적으로 다른데 동일한 인터페이스로 추상화하려는 시도
- Solana blockhash의 짧은 유효 기간이 x402의 multi-hop 흐름(클라이언트 -> 서버 -> facilitator)과 충돌

**Prevention:**
1. **blockhash 여유 계산:** `getLatestBlockhash()`의 `lastValidBlockHeight`를 확인하고, 현재 slot과의 차이가 50 slot(~20초) 미만이면 재획득.
2. **트랜잭션 구성과 서명을 최대한 늦추기:** 402 응답 파싱 -> 정책 평가 -> 정책 통과 확인 후에야 `getLatestBlockhash()` + 트랜잭션 구성 + 서명. 정책에서 거부되면 blockhash 불필요.
3. **체인별 PaymentSigner 인터페이스 분리:**
```typescript
interface IPaymentSigner {
  // EVM: EIP-3009 서명 (transferWithAuthorization)
  // Solana: 완전 서명 트랜잭션 (TransferChecked)
  sign(paymentReq: PaymentRequirements, walletKey: Uint8Array): Promise<PaymentPayload>;
}
```
4. **Solana 서명 시 TTL 경고:** 서명된 트랜잭션의 blockhash 유효 기간이 30초 미만이면 audit_log에 경고 기록.
5. **Solana x402 결제의 DELAY 티어 호환성:** Solana에서 DELAY 대기 시간이 있으면 blockhash가 확실히 만료. 따라서 **Solana x402에서 DELAY 티어는 항상 거부**해야 한다(INSTANT/NOTIFY만 허용).

**Phase:** Solana 결제 서명 생성기 구현 시

---

### H-03: USD 금액 조작 -- 악의적 리소스 서버의 PaymentRequirements 조작

**Severity:** HIGH
**Confidence:** HIGH (x402 프로토콜 분석 + 기존 SPENDING_LIMIT USD 평가 로직 분석)

**What goes wrong:**
x402에서 리소스 서버는 PaymentRequirements에 결제 금액을 명시한다. 클라이언트가 이를 무조건 신뢰하면 문제가 된다.

**시나리오 1: 과대 청구**
```
1. 리소스 서버가 "$0.01/요청" API를 광고
2. 402 응답의 PaymentRequirements: amount = 10000000 (USDC 6-decimal = $10.00)
3. 데몬: $10.00에 대해 SPENDING_LIMIT 평가 -> NOTIFY 통과
4. 결제 서명 생성 -> 리소스 서버에 전달
5. 결과: 광고 금액의 1000배 지불
```

**시나리오 2: 토큰 주소 위변조**
```
1. 402 응답: payTo = 정상 주소, token = 악의적 토큰 컨트랙트 주소
2. 악의적 토큰 컨트랙트가 EIP-3009를 구현하지만, transferWithAuthorization이
   실제로는 다른 동작 수행 (추가 approve 설정, 다른 금액 전송 등)
3. 데몬이 토큰 주소를 검증하지 않으면 악의적 토큰에 서명
```

**시나리오 3: 다중 PaymentRequirements에서 비싼 옵션 우선 배치**
```
1. 402 응답에 여러 PaymentRequirements 포함
2. 데몬이 첫 번째를 선택하는 로직 -> 공격자가 비싼 옵션을 첫 번째에 배치
```

**Why it happens:**
- x402는 리소스 서버가 결제 조건을 일방적으로 제시하는 구조
- 클라이언트(WAIaaS)가 결제 조건의 합리성을 검증하는 표준 메커니즘 없음
- "에이전트가 자율적으로 결제"하는 모델에서 인간의 가격 확인이 없음

**Prevention:**
1. **토큰 주소 하드코딩 검증:** x402 결제에 사용 가능한 토큰을 데몬 설정에 하드코딩. 초기에는 USDC만 허용.
```typescript
const ALLOWED_X402_TOKENS: Record<string, Record<string, string>> = {
  'eip155:8453': { // Base
    'USDC': '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
  },
  'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': { // Solana mainnet
    'USDC': 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
  },
};
```
2. **결제 금액 상한 설정:** `config.x402.max_payment_per_request_usd = 10.00` -- 단일 x402 요청의 최대 결제 금액. PaymentRequirements의 금액이 이를 초과하면 거부.
3. **다중 PaymentRequirements 선택 전략:** WAIaaS가 지원하는 (scheme, network) 필터 -> 허용된 토큰 필터 -> 남은 것 중 최저 금액 선택.
4. **도메인별 누적 결제 통계:** admin 대시보드에서 "이 도메인에 지금까지 총 $X.XX 결제" 집계 표시. 이상 패턴 감지.

**Phase:** PaymentRequirements 파싱 + 결제 대상 선택 로직 구현 시

---

### H-04: EIP-712 Domain Separator 체인별 차이 -- 서명 항상 실패 또는 Replay

**Severity:** HIGH
**Confidence:** HIGH (EIP-3009 스펙 + USDC 컨트랙트 분석)

**What goes wrong:**
EIP-3009 `transferWithAuthorization`은 EIP-712 structured data signing을 사용한다. domain separator에는 `name`, `version`, `chainId`, `verifyingContract`가 포함되며, 이 값들은 **체인별, 토큰별로 다르다.**

**시나리오 1: Domain separator 불일치**
```
1. Base의 USDC 컨트랙트: name="USD Coin", version="2", chainId=8453, address=0x8335...
2. Ethereum의 USDC 컨트랙트: name="USD Coin", version="2", chainId=1, address=0xA0b8...
3. 데몬이 Base용 서명을 생성하면서 Ethereum USDC의 domain을 사용
4. 결과: 서명이 facilitator/온체인에서 검증 실패 -> 결제 항상 실패
```

**시나리오 2: Testnet domain 차이**
```
1. Base Sepolia USDC: chainId=84532, address가 mainnet과 다름
2. 데몬이 testnet에서 개발하면서 mainnet domain을 하드코딩
3. testnet에서는 동작하지만 mainnet 배포 시 실패
4. 또는 그 반대
```

**Prevention:**
1. **체인별 USDC EIP-712 domain 상수 테이블:**
```typescript
const USDC_DOMAINS: Record<string, { name: string; version: string; chainId: number; verifyingContract: string }> = {
  'eip155:8453': { name: 'USD Coin', version: '2', chainId: 8453, verifyingContract: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },
  'eip155:84532': { name: 'USD Coin', version: '2', chainId: 84532, verifyingContract: '0x036CbD53842c5426634e7929541eC2318f3dCF7e' },
  // ... 추가 체인
};
```
2. **가능하면 온체인에서 DOMAIN_SEPARATOR 조회:** `USDC.DOMAIN_SEPARATOR()` view function 호출로 동적 검증. 하드코딩 값과 일치하는지 확인.
3. **통합 테스트에서 testnet USDC 실제 검증:** mock이 아닌 실제 Base Sepolia USDC 컨트랙트로 EIP-3009 서명 생성 후 `authorizationState(from, nonce)` 조회로 서명 유효성 검증.

**Phase:** EVM 결제 서명 생성기 구현 시

---

### H-05: x402 비활성화 상태에서의 공격 표면 관리

**Severity:** HIGH
**Confidence:** HIGH (기존 config.toml 패턴 + 엔드포인트 등록 분석)

**What goes wrong:**
`config.toml`에 `x402.enabled = false`로 설정했을 때:

1. Hono 라우터에 POST /v1/x402/fetch가 등록된 상태 -> 기능은 비활성이지만 엔드포인트 존재 노출
2. MCP tools/list에 x402_fetch 도구가 노출
3. OpenAPI spec에 엔드포인트가 포함
4. 재활성화 시 X402_ALLOWED_DOMAINS 미설정 -> 운영자가 서둘러 `*` 와일드카드 설정 -> 모든 도메인 허용

**Prevention:**
1. **x402.enabled = false일 때 라우트 자체를 등록하지 않음:** 미들웨어 체크가 아닌 라우터 등록 단계에서 분기.
2. **MCP tools/list에서도 제외:** x402_fetch 도구를 동적으로 등록/해제.
3. **와일드카드 도메인 차단:** `X402_ALLOWED_DOMAINS`에 `*` 또는 빈 패턴 설정 불가. 최소 1개의 명시적 도메인 필요.
4. **첫 활성화 시 가이드 제공:** x402 활성화 시 admin UI에 "X402_ALLOWED_DOMAINS 정책을 먼저 설정하세요" 안내.

**Phase:** x402 엔드포인트 등록 + config 통합 시

---

## Moderate Pitfalls

기술 부채, UX 혼란, 또는 운영 어려움을 야기하는 실수.

---

### M-01: 외부 HTTP 응답 프록시 시 헤더/바디 변환 누락

**Severity:** MEDIUM
**Confidence:** MEDIUM (HTTP 프록시 패턴 분석)

**What goes wrong:**
`POST /v1/x402/fetch`가 외부 API 응답을 에이전트에게 프록시할 때:

1. **Content-Encoding 처리:** 외부 서버가 gzip/brotli로 압축 응답 -> 데몬이 압축 해제 없이 그대로 프록시 -> 에이전트가 디코딩 실패
2. **Content-Type 불일치:** 외부 응답 Content-Type을 프록시 응답에 전달하지 않으면 JSON을 text로 처리
3. **Set-Cookie/CORS 헤더 노출:** 외부 서버의 응답 헤더를 그대로 전달하면 보안 헤더 충돌
4. **대용량 응답:** 외부 API가 수 MB 응답을 반환하면 데몬 메모리 문제

**Prevention:**
1. **응답 압축 자동 해제:** `fetch()`에 `Accept-Encoding` 헤더를 포함하여 기본 압축 처리 위임.
2. **프록시 응답 구조화:** 외부 응답을 그대로 프록시하지 말고, `{ status, headers: {content-type}, body, payment?: {txHash, amount} }` 형태로 래핑.
3. **응답 크기 제한:** `config.x402.max_response_size = 5242880` (5MB). 초과 시 `X402_RESPONSE_TOO_LARGE`.
4. **위험 헤더 필터링:** Set-Cookie, Access-Control-*, X-Frame-Options 등 보안 관련 헤더 제거.

**Phase:** x402 응답 프록시 구현 시

---

### M-02: TransactionType에 X402_PAYMENT 추가 시 기존 코드 영향

**Severity:** MEDIUM
**Confidence:** HIGH (기존 discriminatedUnion 5-type 분석)

**What goes wrong:**
현재 `TransactionType = 'TRANSFER' | 'TOKEN_TRANSFER' | 'CONTRACT_CALL' | 'APPROVE' | 'BATCH'`에 `X402_PAYMENT`를 6번째 타입으로 추가하면:

1. **switch/case exhaustive check:** TypeScript의 discriminatedUnion switch에서 `X402_PAYMENT` case가 누락된 모든 위치에서 타입 에러 발생. 의도적이고 안전하지만, 영향 범위가 넓음.
2. **정책 엔진:** `buildTransactionParam()`의 switch에 X402_PAYMENT case 추가 필요. 누락 시 `default: TRANSFER`로 fallback -> 정책 오평가.
3. **Admin UI:** 트랜잭션 목록의 type badge에 X402_PAYMENT 표시 추가 필요.
4. **DB CHECK 제약:** `transactions.type`의 CHECK 제약에 X402_PAYMENT 추가 -> DB 마이그레이션 필요.

**Prevention:**
1. **@waiaas/core의 TransactionType enum에 추가 후 전체 빌드:** 타입 에러가 발생하는 모든 위치를 TypeScript 컴파일러가 자동 감지.
2. **DB 마이그레이션 선행:** CHECK 제약 변경은 SQLite에서 테이블 재생성이 필요하므로, 마이그레이션 스크립트를 먼저 작성.
3. **Admin UI에 unknown type fallback:** 알 수 없는 type은 "기타"로 표시 (향후 추가 type에도 대응).

**Phase:** 스키마 확장 + DB 마이그레이션 시 (첫 phase)

---

### M-03: x402 결제 + 기존 알림의 의미론적 불일치

**Severity:** MEDIUM
**Confidence:** MEDIUM (기존 알림 이벤트 분석)

**What goes wrong:**
기존 알림 이벤트(TX_REQUESTED, TX_SUBMITTED, TX_CONFIRMED, TX_FAILED)를 x402 결제에 재사용할 때:

1. **TX_SUBMITTED:** 기존 = "데몬이 온체인에 제출". x402 = "데몬이 리소스 서버에 서명 전달". 온체인 제출은 facilitator가 수행.
2. **TX_CONFIRMED:** 기존 = "온체인 확인됨". x402 = "리소스 서버가 200 응답 반환". 온체인 확인과 HTTP 응답 성공은 다른 개념.
3. **알림 메시지 내용:** "10 SOL이 전송되었습니다" vs "api.example.com에 $5.00 USDC 결제" -- 문맥이 다름.

**Prevention:**
1. **x402 전용 알림 이벤트 타입 추가:** `X402_PAYMENT_SENT`, `X402_PAYMENT_CONFIRMED`, `X402_PAYMENT_FAILED`. 기존 TX_ 이벤트와 분리.
2. **알림 변수에 x402 컨텍스트 추가:** `{target_url, domain, payment_amount_usd, token, network}`.
3. **알림 메시지 템플릿:** "x402 결제: api.example.com에 $5.00 USDC (Base) 결제 완료".

**Phase:** x402 알림 통합 시

---

### M-04: CAIP-2 네트워크 식별자 매핑 오류

**Severity:** MEDIUM
**Confidence:** MEDIUM (x402 v2 스펙의 CAIP-2 사용 확인)

**What goes wrong:**
x402 v2는 CAIP-2 네트워크 식별자(예: `eip155:8453`, `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`)를 사용한다. WAIaaS의 내부 NetworkType(예: `base-mainnet`, `solana-mainnet`)과 매핑이 필요하다.

1. CAIP-2 -> NetworkType 매핑 테이블에 누락된 네트워크 -> `X402_UNSUPPORTED_NETWORK`
2. CAIP-2 파싱 오류 (형식이 `namespace:reference`) -> 결제 불가
3. testnet/mainnet EnvironmentType 불일치 -> 잘못된 네트워크에서 결제

**Prevention:**
1. **CAIP-2 -> NetworkType 매핑 상수 테이블:** `evm-chain-map.ts`의 기존 chainId 매핑을 확장.
2. **EnvironmentType 교차 검증:** wallet의 environment(testnet/mainnet)와 CAIP-2 네트워크의 environment가 일치하는지 확인.
3. **지원하지 않는 네트워크 명확한 에러:** `X402_UNSUPPORTED_NETWORK` + 지원 네트워크 목록 반환.

**Phase:** PaymentRequirements 파싱 시

---

### M-05: x402 결제 이력 조회 API 부재

**Severity:** MEDIUM
**Confidence:** HIGH (현재 transactions API 분석)

**What goes wrong:**
x402 결제가 transactions 테이블에 `type='X402_PAYMENT'`로 기록되지만:

1. 기존 `GET /v1/wallets/:id/transactions`에 x402 결제가 혼합 표시
2. "어떤 도메인에 얼마나 결제했는지" 집계 불가 (target_url이 metadata에만 있음)
3. admin UI에서 x402 결제만 필터링하는 기능 부재

**Prevention:**
1. **transactions API에 type 필터 추가:** `GET /v1/wallets/:id/transactions?type=X402_PAYMENT`.
2. **x402 결제 메타데이터 구조화:** metadata JSON에 `{target_url, domain, payment_amount_usd, token, network, settlement_txHash}` 표준 구조.
3. **Admin UI에 x402 결제 대시보드:** 도메인별 결제 현황, 누적 금액, 최근 결제 목록.

**Phase:** x402 감사 로그 + Admin UI 확장 시

---

## Phase-Specific Warning Summary

| Phase Topic | Likely Pitfall | Severity | Mitigation Key |
|-------------|---------------|----------|---------------|
| **SSRF 방어 레이어** | C-01: DNS rebinding TOCTOU | CRITICAL | DNS resolve + IP 검증 + 연결 원자화, IPv6/encoding 완전 차단 |
| **SSRF 방어 레이어** | C-05: 도메인 검증 우회 | CRITICAL | URL 파싱 정규화, userinfo 거부, dot-boundary 와일드카드, 리다이렉트 재검증 |
| **x402 핸들러 결제 흐름** | C-02: Signed-But-Not-Delivered | CRITICAL | validBefore 최소화, 재시도 제한, 감사 로그, 미확인 결제 추적 |
| **x402 정책 통합** | C-03: Race condition reserved_amount | CRITICAL | pre-reservation, 동시 요청 제한, evaluateAndReserve 연동 |
| **EVM 결제 서명** | C-04: EIP-3009 nonce/frontrunning | CRITICAL | validBefore 5분, nonce DB 기록, reservation TTL 동기화 |
| **EVM 결제 서명** | H-04: EIP-712 domain separator 불일치 | HIGH | 체인별 domain 상수 테이블, 온체인 DOMAIN_SEPARATOR 검증 |
| **타임아웃 처리** | H-01: 3단계 타임아웃 캐스케이드 | HIGH | budget 패턴, DELAY vs timeout 사전 비교, APPROVAL 즉시 거부 |
| **Solana 결제 서명** | H-02: Blockhash freshness | HIGH | 서명 직전 blockhash 획득, Solana DELAY 티어 항상 거부 |
| **PaymentRequirements 파싱** | H-03: USD 금액 조작 | HIGH | 토큰 주소 하드코딩, 요청당 최대 금액, 최저가 자동 선택 |
| **엔드포인트 등록** | H-05: 비활성화 상태 노출 | HIGH | 라우트 미등록, MCP 도구 동적 제외, 와일드카드 도메인 차단 |
| **응답 프록시** | M-01: 헤더/바디 변환 누락 | MEDIUM | 응답 구조화, 크기 제한, 보안 헤더 필터링 |
| **스키마 확장** | M-02: TransactionType 추가 영향 | MEDIUM | 전체 빌드 타입 체크, DB 마이그레이션 선행 |
| **알림 통합** | M-03: 알림 의미론적 불일치 | MEDIUM | x402 전용 이벤트 타입, 알림 변수 확장 |
| **네트워크 매핑** | M-04: CAIP-2 매핑 오류 | MEDIUM | 매핑 상수 테이블, EnvironmentType 교차 검증 |
| **감사/Admin** | M-05: 결제 이력 조회 부재 | MEDIUM | type 필터, 도메인별 집계, x402 대시보드 |

---

## Integration Risk Matrix

기존 코드 컴포넌트별 x402 추가 시 영향도:

| 컴포넌트 | 변경 내용 | 위험도 | 주의사항 |
|----------|----------|:------:|---------|
| **신규: `ssrf-guard.ts`** | DNS resolve + IP 검증 + 안전한 fetch | CRITICAL | DNS rebinding, IPv6, encoding 모두 방어 |
| **신규: `x402-handler.ts`** | 402 파싱 + 결제 서명 + 재요청 흐름 | CRITICAL | 타임아웃 budget, 재시도 제한, 에러 핸들링 |
| **신규: `payment-signer.ts`** | EIP-3009 서명 + Solana tx 구성 | CRITICAL | nonce 관리, validBefore, blockhash freshness |
| `database-policy-engine.ts` | evaluateAndReserve에 x402 pre-reservation 연동 | HIGH | 기존 TOCTOU 방지 메커니즘 무결성 유지 |
| `@waiaas/core` enums | TransactionType에 X402_PAYMENT 추가, PolicyType에 X402_ALLOWED_DOMAINS 추가 | HIGH | 전체 패키지 리빌드, switch exhaustive check |
| `schema.ts` | transactions CHECK 제약 + policies type 확장 | HIGH | DB 마이그레이션 필수 (MIG 패턴) |
| `stages.ts` | x402 파이프라인은 기존 stages 재사용하지 않음 (별도 핸들러) | LOW | 기존 파이프라인에 영향 없어야 함 |
| `notification-service.ts` | x402 전용 이벤트 타입 추가 | LOW | 기존 이벤트에 영향 없음 |
| `mcp/server.ts` | x402_fetch 도구 등록 | LOW | x402.enabled 조건부 등록 |
| `admin UI` | x402 결제 표시 + X402_ALLOWED_DOMAINS 정책 관리 | LOW | 기존 정책 UI 패턴 재사용 |

---

## Key Architectural Decisions Derived from Pitfalls

이 PITFALLS 분석에서 도출되는 핵심 아키텍처 결정:

| # | 결정 | 권장안 | 근거 |
|---|------|-------|------|
| 1 | SSRF 방어 수준 | DNS resolve + 연결 원자화 (단순 IP 블록리스트 불충분) | C-01: DNS rebinding은 IP 블록리스트만으로 방어 불가 |
| 2 | EIP-3009 validBefore | now + 5분 (표준 권장 1시간보다 짧게) | C-04: 긴 유효 기간 = 넓은 공격 창구 |
| 3 | DELAY 티어 처리 | request_timeout budget 내에서만 대기 | H-01: 3단계 타임아웃 충돌 방지 |
| 4 | APPROVAL 티어 처리 | 즉시 거부 (동기 HTTP에서 대기 불가) | H-01: x402 = 동기적 요청-응답 |
| 5 | Solana DELAY 티어 | 항상 거부 (blockhash 60초 만료) | H-02: DELAY + blockhash = 확정적 실패 |
| 6 | 허용 토큰 | USDC만 하드코딩 (초기) | H-03: 악의적 토큰 컨트랙트 차단 |
| 7 | 도메인 검증 | URL constructor + hostname 정규화 + dot-boundary | C-05: URL 파싱 공격 방어 |
| 8 | 재시도 정책 | 402 재반환 시 재시도 없음, 자동 재서명 금지 | C-02: 이중 결제 방지 |
| 9 | 결제 기록 | 서명 생성 즉시 audit_log + transactions 기록 | C-02: 미확인 결제 추적 |
| 10 | 결제 금액 상한 | config.x402.max_payment_per_request_usd | H-03: 과대 청구 방어 |

---

## Sources

### HIGH Confidence
- WAIaaS 코드베이스 직접 분석: `stages.ts`, `database-policy-engine.ts`, `sign-only.ts`, `v1.5.1-x402-client.md` (v1.5)
- [ERC-3009: Transfer With Authorization](https://eips.ethereum.org/EIPS/eip-3009) -- EIP-3009 표준 스펙, nonce 관리, frontrunning 대응
- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html) -- SSRF 방어 체계, DNS rebinding, IPv6 차단
- [x402 Protocol](https://www.x402.org/) -- x402 프로토콜 공식 사이트
- [Coinbase x402 GitHub](https://github.com/coinbase/x402) -- x402 레퍼런스 구현, 스펙 문서
- [Coinbase x402 Documentation](https://docs.cdp.coinbase.com/x402/welcome) -- 공식 개발자 문서
- [SSRF Bypass Techniques - Defense in Depth](https://windshock.github.io/en/post/2025-06-25-ssrf-defense/) -- URL 파싱 공격, userinfo, 리다이렉트, 대체 IP 표현
- [agent-fetch: SSRF-safe HTTP client](https://github.com/Parassharmaa/agent-fetch) -- DNS resolve + IP validation + 연결 원자화 패턴
- [ERC-3009 in x402 Context](https://blog.payin.com/posts/erc-3009-x402/) -- EIP-3009와 x402의 통합, frontrunning 대응
- [x402 Solana Guide](https://solana.com/developers/guides/getstarted/intro-to-x402) -- Solana x402 구현, TransferChecked, blockhash 검증
- [OWASP SSRF Prevention in Node.js](https://owasp.org/www-community/pages/controls/SSRF_Prevention_in_Nodejs) -- Node.js 전용 SSRF 방어 가이드

### MEDIUM Confidence
- [x402 V2 Launch](https://www.x402.org/writing/x402-v2-launch) -- v2 스펙 변경사항, CAIP-2 네트워크 식별자
- [x402 Integration Security - Valkyrie Security](https://blog.valkyrisec.com/x402-integration-security/) -- x402 보안 분석
- [Bypassing SSRF Protection in nossrf](https://www.nodejs-security.com/blog/bypassing-ssrf-protection-nossrf) -- Node.js SSRF 라이브러리 우회 사례
- [URL Validation Bypass Cheat Sheet - PortSwigger](https://portswigger.net/research/introducing-the-url-validation-bypass-cheat-sheet) -- URL 파싱 모호성 연구
- [EIP-3009 Forwarder for x402](https://github.com/TheGreatAxios/eip3009-forwarder) -- EIP-3009 wrapper contracts for x402

### LOW Confidence (아키텍처적 추론 기반)
- x402 SVM exact scheme의 부분 서명 vs 완전 서명 시맨틱 -- 상세 스펙 미완전 확인, Solana 가이드와 일반적 패턴에서 추론
- x402 facilitator의 정산 실패 시 클라이언트 측 재시도 프로토콜 -- 프로토콜 스펙에 명시 없음, 방어적 설계 필요
- pre-reservation 패턴의 실효성 -- 기존 사례 미발견, 논리적 추론 기반
