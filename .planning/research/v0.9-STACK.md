# Stack Research: MCP Session Management Automation

**Project:** WAIaaS v0.9 - MCP Session Management Automation Design
**Researched:** 2026-02-09
**Scope:** Stack additions/changes for MCP SessionManager, CLI mcp commands, Telegram /newsession, SESSION_EXPIRING_SOON
**Overall Confidence:** HIGH

---

## Executive Summary

v0.9는 v0.8과 동일하게 **새로운 외부 라이브러리가 필요하지 않다.** 모든 기능을 기존 스택(Node.js 22 built-in, jose, grammy, commander.js)과 @modelcontextprotocol/sdk 기존 의존성으로 구현할 수 있다.

6가지 기술 질문에 대한 답변:

1. **파일 기반 토큰 영속화:** `fs.promises.writeFile`(mode: 0o600) + `fs.promises.mkdir`(recursive) 내장 API로 충분. `write-file-atomic` 불필요.
2. **자동 갱신 타이머:** `setTimeout` 내장 API로 충분. 단, 7일 TTL의 60% = 4.2일(362,880,000ms)은 32-bit 상한(2,147,483,647ms = 24.85일) 이내이므로 안전. 별도 스케줄러 불필요.
3. **JWT 페이로드 디코딩:** `jose`의 `decodeJwt()` 함수가 정확히 이 용도. 서명 검증 없이 base64url 디코딩만 수행.
4. **MCP SDK 세션 훅:** `@modelcontextprotocol/sdk` v1.26.0은 전용 세션 관리 hook을 제공하지 않음. SessionManager는 MCP Server 외부에서 독립 구현.
5. **파일 변경 감지:** `fs.watch` 사용하지 않음. 401 수신 시 lazy reload 패턴으로 충분 (v0.9 목표에 이미 확정됨).
6. **Telegram 인라인 키보드:** `grammy`의 `InlineKeyboard.text()` + `bot.callbackQuery()` 기존 API로 구현.

**결론:** 의존성 변경 제로(0). 기존 라이브러리의 미사용 API 활용만 필요.

---

## Question 1: File-Based Token Persistence

### 문제

`~/.waiaas/mcp-token` 파일에 JWT를 저장해야 한다. 요구사항:
- 원자적 쓰기 (partial write 방지)
- 파일 권한 `0o600` (owner read/write only)
- 디렉토리 `~/.waiaas/` 자동 생성
- 심볼릭 링크 거부

### 답변: Node.js 내장 API로 충분

**`fs.promises.writeFile`** 가 mode 옵션을 지원한다:

```typescript
import { writeFile, mkdir, lstat } from 'node:fs/promises'
import { homedir } from 'node:os'
import { join } from 'node:path'

const TOKEN_DIR = join(homedir(), '.waiaas')
const TOKEN_PATH = join(TOKEN_DIR, 'mcp-token')

async function persistToken(token: string): Promise<void> {
  // 디렉토리 생성 (이미 존재하면 no-op)
  await mkdir(TOKEN_DIR, { recursive: true, mode: 0o700 })

  // 심볼릭 링크 방어 (S-04 보안 시나리오)
  try {
    const stat = await lstat(TOKEN_PATH)
    if (stat.isSymbolicLink()) {
      throw new Error('Token file is a symbolic link — refusing to write')
    }
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code !== 'ENOENT') throw err
    // 파일 없음은 정상 (최초 생성)
  }

  // 원자적 쓰기: mode 0o600
  await writeFile(TOKEN_PATH, token, { encoding: 'utf-8', mode: 0o600 })
}
```

### write-file-atomic 불필요한 이유

| 고려 사항 | 판단 |
|-----------|------|
| 원자성 필요 수준 | JWT 문자열 1개 (< 1KB). partial write 가능성 극히 낮음 |
| 동시 쓰기 | SessionManager 단일 인스턴스에서만 쓰기. 경합 없음 |
| Telegram /newsession | 데몬 프로세스에서 쓰기 → MCP 프로세스에서 읽기. 동시 쓰기 아님 |
| mode 지원 | `fs.promises.writeFile`의 mode 옵션으로 0o600 설정 가능 |
| 추가 의존성 비용 | write-file-atomic v7.0.0은 기능 대비 과잉. 1KB 파일에 원자적 rename 불필요 |

**만약 원자성이 정말 중요하다면:** temp 파일 + rename 패턴을 직접 구현하면 된다 (10줄). 외부 라이브러리 불필요:

```typescript
import { rename } from 'node:fs/promises'

async function atomicWriteToken(token: string): Promise<void> {
  const tmpPath = `${TOKEN_PATH}.tmp.${process.pid}`
  await writeFile(tmpPath, token, { encoding: 'utf-8', mode: 0o600 })
  await rename(tmpPath, TOKEN_PATH) // POSIX rename은 원자적
}
```

### 심볼릭 링크 감지

보안 시나리오 S-04 (토큰 파일 심볼릭 링크 거부)는 `fs.lstatSync()` 또는 `fs.promises.lstat()`의 `isSymbolicLink()`로 감지한다. **`fs.stat()`이 아닌 `fs.lstat()`을 사용해야 한다** -- `stat()`은 링크를 따라가서 대상 파일의 정보를 반환하므로 심볼릭 링크를 감지하지 못한다.

### Confidence: HIGH

- `fs.promises.writeFile` mode 옵션은 [Node.js v25 공식 문서](https://nodejs.org/api/fs.html)에서 확인됨
- 현대 Node.js(22+)에서 mode 옵션이 정상 동작함 (과거 v0.10-v0.12 무시 버그는 수정됨)
- `lstat().isSymbolicLink()` 패턴은 [Node.js 공식 문서](https://nodejs.org/api/fs.html)에서 확인됨

---

## Question 2: Timer/Scheduling for Auto-Renewal

### 문제

세션 토큰의 60% 경과 시점에 자동 갱신을 트리거해야 한다. expiresIn = 7일 기준, 갱신 타이머 = 4.2일(362,880초 = 362,880,000ms).

### 답변: setTimeout 내장 API로 충분

**핵심 검증: 32-bit 정수 상한**

Node.js `setTimeout`은 내부적으로 signed 32-bit 정수를 사용한다. 최대 딜레이는 **2,147,483,647ms (약 24.85일)**이다.

| 시나리오 | 딜레이 (ms) | 32-bit 상한 대비 | 안전 |
|----------|------------|-----------------|------|
| 7일 TTL, 60% = 4.2일 | 362,880,000 | 16.9% | **안전** |
| 30일 TTL, 60% = 18일 | 1,555,200,000 | 72.4% | **안전** |
| 30일 TTL, 90% = 27일 | 2,332,800,000 | 108.6% | **오버플로** |

WAIaaS의 세션 설계:
- 기본 expiresIn = 7일 (604,800초)
- 절대 수명 = 30일 (2,592,000초)
- 갱신 시점 = expiresIn의 60%

**최악의 경우**: expiresIn = 30일(절대 수명 전체), 60% = 18일 = 1,555,200,000ms. 이는 32-bit 상한(2,147,483,647ms) 이내이므로 안전하다.

**추가 안전 장치**: 만약 expiresIn이 비정상적으로 크더라도 방어 코드를 추가한다:

```typescript
const MAX_TIMEOUT = 2_147_483_647 // setTimeout 32-bit 상한

function scheduleRenewal(expiresIn: number): NodeJS.Timeout {
  const renewalDelay = Math.min(
    Math.floor(expiresIn * 0.6),
    MAX_TIMEOUT
  )
  return setTimeout(() => renew(), renewalDelay)
}
```

### 별도 스케줄러 불필요한 이유

| 고려 사항 | 판단 |
|-----------|------|
| 정밀도 | ms 단위 정밀도 불필요. 분 단위 오차 허용 가능 (갱신은 잔여 40%에서 시도) |
| 재시작 복원 | MCP 프로세스 재시작 시 토큰 파일에서 로드 → exp 기반으로 새 타이머 설정. 별도 persistence 불필요 |
| 반복 실행 | 갱신 성공 시 새 타이머 설정 (nested setTimeout 패턴). setInterval보다 유연 |
| cron 표현식 | 불필요. 갱신 시점은 토큰 발급 시각 기준 상대 시간 |
| node-cron / agenda | 과잉. 단일 타이머 1개에 외부 스케줄러는 불필요 |

### timer.unref() 사용

SessionManager의 갱신 타이머는 `timer.unref()`를 호출하여 프로세스 종료를 막지 않도록 한다. MCP 프로세스가 stdin EOF로 종료될 때 갱신 타이머가 프로세스를 붙잡고 있으면 안 된다:

```typescript
this.timer = setTimeout(() => this.renew(), renewalDelay)
this.timer.unref() // 프로세스 종료를 막지 않음
```

### Confidence: HIGH

- setTimeout 32-bit 상한은 [Node.js Timers 문서](https://nodejs.org/api/timers.html)에서 확인됨
- 2,147,483,647ms 초과 시 딜레이가 1ms로 설정되어 즉시 실행되는 버그 동작 확인됨 ([Node.js Issue #22860](https://github.com/nodejs/node/issues/22860))
- unref() 동작은 [Node.js Timers 문서](https://nodejs.org/api/timers.html)에서 확인됨

---

## Question 3: JWT Payload Decoding Without Verification

### 문제

토큰 로드 시 JWT payload에서 `sessionId`, `exp`, `iat`을 추출해야 한다. 서명 검증은 불필요 (서버에서 검증). base64url 디코딩만 필요.

### 답변: jose의 decodeJwt() 사용 (이미 의존성에 포함)

`jose` 패키지(프로젝트에 이미 포함)의 `decodeJwt()` 함수가 정확히 이 용도:

```typescript
import { decodeJwt } from 'jose'

// 또는 서브패스 임포트:
// import { decodeJwt } from 'jose/jwt/decode'

function parseTokenPayload(token: string) {
  const payload = decodeJwt(token)
  // payload.exp → 만료 시각 (epoch seconds)
  // payload.iat → 발급 시각 (epoch seconds)
  // payload.sub → sessionId (또는 커스텀 클레임)
  // payload.jti → JWT ID
  return {
    sessionId: payload.sub ?? payload.jti,
    expiresAt: (payload.exp ?? 0) * 1000, // ms 변환
    issuedAt: (payload.iat ?? 0) * 1000,
    expiresIn: ((payload.exp ?? 0) - (payload.iat ?? 0)) * 1000,
  }
}
```

### API 확인 (jose v6.x)

```typescript
// 시그니처
function decodeJwt<PayloadType = JWTPayload>(jwt: string): PayloadType & JWTPayload

// JWTPayload 인터페이스 (표준 클레임)
interface JWTPayload {
  iss?: string    // Issuer
  sub?: string    // Subject
  aud?: string | string[]  // Audience
  jti?: string    // JWT ID
  nbf?: number    // Not Before (epoch seconds)
  exp?: number    // Expiration Time (epoch seconds)
  iat?: number    // Issued At (epoch seconds)
  [propName: string]: unknown  // 커스텀 클레임
}
```

### jwt-decode 불필요한 이유

`jwt-decode` (npm 패키지)는 jose가 없을 때 사용하는 경량 대안이다. WAIaaS는 이미 `jose`를 서버 측 JWT 생성/검증에 사용하고 있으므로, 동일 패키지의 `decodeJwt()` 유틸리티를 사용하는 것이 자연스럽다.

### jose 버전 확인

| 항목 | 값 |
|------|-----|
| 현재 최신 버전 | v6.1.3 (2024-12-02 릴리스) |
| WAIaaS 기존 사용 | jose latest (v5.x 또는 v6.x) |
| `decodeJwt` 존재 여부 | v5.x, v6.x 모두 존재 확인됨 |
| 임포트 경로 | `import { decodeJwt } from 'jose'` (v5, v6 동일) |
| 동작 | 서명 검증 없이 payload만 디코딩. v5 → v6 변경 없음 |

### Confidence: HIGH

- `decodeJwt` API는 [jose v6.x 공식 문서](https://github.com/panva/jose/blob/v6.x/docs/util/decode_jwt/functions/decodeJwt.md)에서 확인됨
- v5.x에서 v6.x로의 `decodeJwt` 시그니처 변경 없음 확인됨
- [jose GitHub main 브랜치 문서](https://github.com/panva/jose/blob/main/docs/util/decode_jwt/functions/decodeJwt.md)에서도 동일 API 확인됨

---

## Question 4: MCP SDK Session/Auth Lifecycle Hooks

### 문제

`@modelcontextprotocol/sdk`가 세션 관리 또는 인증 lifecycle hook을 제공하는지 확인. SessionManager를 MCP Server에 어떻게 통합할지 결정.

### 답변: 전용 세션 관리 hook 없음. SessionManager는 독립 구현.

**@modelcontextprotocol/sdk v1.26.0** (2026-02-05 기준 최신 stable) 분석:

| 기능 | 제공 여부 | 설명 |
|------|:---------:|------|
| `McpServer.connect(transport)` | O | Transport 연결 |
| `McpServer.close()` | O | 정리/종료 |
| Transport `onclose` 콜백 | O | Transport 연결 해제 시 호출 |
| Transport `onerror` 콜백 | O | Transport 에러 시 호출 |
| **세션 토큰 관리 hook** | **X** | 제공하지 않음 |
| **인증 lifecycle hook** | **X** | 제공하지 않음 |
| **토큰 갱신 자동화** | **X** | 제공하지 않음 |
| OAuth helpers | O | 서버 측 OAuth 구현용 (클라이언트 토큰 관리 아님) |
| Streamable HTTP 세션 | O | HTTP transport의 세션 ID 관리 (JWT 토큰과 무관) |

### 통합 패턴: Composition (래핑)

MCP SDK는 tool handler 내부에서 임의의 로직을 실행할 수 있으므로, SessionManager를 독립 클래스로 구현하고 tool handler에서 참조한다:

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'

// SessionManager는 MCP SDK와 무관한 독립 클래스
const sessionManager = new SessionManager()
await sessionManager.start()

const server = new McpServer({ name: 'waiaas-wallet', version: '1.0.0' })

server.tool('get-balance', { agentId: z.string() }, async (params) => {
  const token = sessionManager.getToken() // 최신 토큰 획득
  const res = await fetch(`${BASE_URL}/v1/agents/${params.agentId}/balance`, {
    headers: { Authorization: `Bearer ${token}` }
  })
  // ...
})

// Transport close 시 SessionManager 정리
const transport = new StdioServerTransport()
transport.onclose = () => {
  sessionManager.dispose()
  process.exit(0)
}

await server.connect(transport)
```

### v2 Pre-Alpha 참고

MCP SDK v2 (pre-alpha)가 main 브랜치에서 개발 중이나, 프로덕션 사용은 v1.x 권장. v2에서 세션 관리 hook이 추가될 가능성이 있으나, 현재 확인 불가. v0.9 설계는 v1.x 기준으로 진행하고, v2 안정화 시 마이그레이션 검토.

### Confidence: HIGH

- v1.26.0이 최신 stable임을 [npm registry](https://www.npmjs.com/package/@modelcontextprotocol/sdk)에서 확인됨
- Transport lifecycle hook (onclose, onerror)은 [TypeScript SDK GitHub](https://github.com/modelcontextprotocol/typescript-sdk)에서 확인됨
- 전용 세션 토큰 관리 API가 없음은 [server.md 문서](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/server.md)에서 확인됨

---

## Question 5: File Change Detection for Token Hot-Reload

### 문제

Telegram `/newsession` 또는 CLI `mcp refresh-token`이 토큰 파일을 외부에서 교체했을 때, MCP SessionManager가 새 토큰을 감지해야 한다.

### 답변: fs.watch 사용하지 않음. Lazy reload (401 기반) 패턴 사용.

v0.9 목표 문서에 이미 확정된 전략:

```
기존 토큰으로 API 호출
  ↓
  401 AUTH_TOKEN_EXPIRED 수신
  ↓
  ~/.waiaas/mcp-token 파일 재로드 시도
  ├─ 파일의 토큰 != 현재 토큰 → 새 토큰으로 교체, API 재시도
  ├─ 파일의 토큰 = 현재 토큰 → 진짜 만료, 에러 상태 진입
  └─ 파일 없음 → 에러 상태 진입
```

### fs.watch를 사용하지 않는 이유

| 이유 | 설명 |
|------|------|
| **OS별 불안정** | macOS FSEvents에서 race condition 발생. Linux inotify는 안정적이나 NFS/CIFS에서 미동작 |
| **과잉** | MCP Server의 API 호출 빈도가 높지 않아 실시간 감지 불필요 |
| **복잡성** | watcher 등록/해제, 중복 이벤트 필터링, 디바운싱 필요 |
| **lazy reload 충분** | 401 수신은 "토큰이 실제로 필요한 시점"이므로 가장 효율적인 감지 시점 |

### 구현 패턴

```typescript
class SessionManager {
  private async callApi(url: string, options: RequestInit): Promise<Response> {
    const res = await fetch(url, {
      ...options,
      headers: { ...options.headers, Authorization: `Bearer ${this.token}` }
    })

    if (res.status === 401) {
      const reloaded = await this.tryReloadFromFile()
      if (reloaded) {
        // 새 토큰으로 1회 재시도
        return fetch(url, {
          ...options,
          headers: { ...options.headers, Authorization: `Bearer ${this.token}` }
        })
      }
      // 진짜 만료 — 에러 상태 진입
      throw new SessionExpiredError()
    }

    return res
  }

  private async tryReloadFromFile(): Promise<boolean> {
    try {
      const fileToken = await readFile(TOKEN_PATH, 'utf-8')
      if (fileToken.trim() !== this.token) {
        this.token = fileToken.trim()
        const payload = decodeJwt(this.token)
        this.expiresAt = (payload.exp ?? 0) * 1000
        this.scheduleRenewal()
        return true
      }
      return false
    } catch {
      return false
    }
  }
}
```

### Confidence: HIGH

- v0.9 목표 문서에 lazy reload 전략이 명시적으로 확정됨
- fs.watch macOS 불안정성은 Node.js 커뮤니티에서 well-known issue

---

## Question 6: Telegram Inline Keyboard Callback Patterns

### 문제

`/newsession` 명령어에서 에이전트 목록을 인라인 키보드로 표시하고, 사용자가 선택하면 콜백을 처리해야 한다.

### 답변: grammy의 InlineKeyboard + bot.callbackQuery() 사용 (이미 의존성에 포함)

grammy v1.39.x (WAIaaS 기존 의존성)의 인라인 키보드 API:

```typescript
import { InlineKeyboard } from 'grammy'

// /newsession 핸들러
bot.command('newsession', async (ctx) => {
  // 1. chatId 인증 (Tier 1)
  if (!isAuthorizedOwner(ctx.chat?.id)) {
    await ctx.reply('Unauthorized')
    return
  }

  // 2. 에이전트 목록 조회
  const agents = await agentService.listActive()

  // 3. 인라인 키보드 생성
  const keyboard = new InlineKeyboard()
  for (const agent of agents) {
    keyboard
      .text(`${agent.name} (${agent.chain})`, `newsession:${agent.id}`)
      .row()
  }

  await ctx.reply('Select an agent for new session:', {
    reply_markup: keyboard,
  })
})

// 콜백 핸들러
bot.callbackQuery(/^newsession:(.+)$/, async (ctx) => {
  const agentId = ctx.match![1]

  // 4. 세션 생성
  const session = await sessionService.create(agentId, defaultConstraints)

  // 5. 토큰 파일 저장
  await persistToken(session.token)

  // 6. 완료 메시지
  await ctx.editMessageText(
    `New session created for ${agentId}\nExpires: ${session.expiresAt}`
  )
  await ctx.answerCallbackQuery({ text: 'Session created!' })
})
```

### 콜백 데이터 설계

| 항목 | 값 |
|------|-----|
| 콜백 데이터 포맷 | `newsession:{agentId}` |
| 최대 길이 | Telegram 제한 64 bytes. UUID v7(36자) + 접두어(11자) = 47자. 안전 |
| 정규식 매칭 | `/^newsession:(.+)$/` |
| answerCallbackQuery | 필수. 호출하지 않으면 클라이언트에 로딩 표시 유지 |

### grammy-inline-menu 불필요한 이유

`grammy-inline-menu` 라이브러리는 복잡한 다단계 메뉴(트리 구조, 페이지네이션, 상태 관리)에 유용하다. `/newsession`은 단일 레벨 선택(에이전트 목록 → 1회 선택)이므로 grammy 내장 `InlineKeyboard` + `callbackQuery`로 충분하다.

### Confidence: HIGH

- grammy InlineKeyboard API는 [grammy 공식 문서](https://grammy.dev/plugins/keyboard)에서 확인됨
- `bot.callbackQuery()` 정규식 매칭은 [grammy 공식 문서](https://grammy.dev/ref/types/callbackquery)에서 확인됨
- answerCallbackQuery 필수 호출은 [Telegram Bot API 문서](https://core.telegram.org/bots/api)에서 확인됨

---

## Recommended Stack Additions

### 신규 추가: 없음

v0.9에서 새로 설치해야 하는 패키지가 없다.

### 기존 라이브러리의 미사용 API 활용

| 라이브러리 | 기존 용도 | v0.9 추가 활용 |
|-----------|----------|--------------|
| `jose` | JWT 생성/검증 (jwtVerify, SignJWT) | `decodeJwt()` — 서명 검증 없이 payload 디코딩 |
| `grammy` | 알림 전송, 기존 봇 명령어 | `InlineKeyboard.text()` + `bot.callbackQuery()` — 인라인 키보드 콜백 |
| `commander.js` | CLI 명령어 (agent, session 등) | `mcp setup`, `mcp refresh-token` 서브커맨드 추가 |
| Node.js `fs/promises` | 데이터 디렉토리 관리 | `writeFile(mode: 0o600)`, `lstat().isSymbolicLink()` — 토큰 파일 관리 |
| Node.js `timers` | 없음 (신규) | `setTimeout` + `unref()` — 갱신 스케줄링 |
| `@modelcontextprotocol/sdk` | McpServer, StdioServerTransport, tool 등록 | Transport `onclose` 콜백 — SessionManager 정리 |

---

## Integration Points with Existing Stack

| 기존 컴포넌트 | v0.9 통합 방식 | 변경 범위 |
|--------------|--------------|----------|
| **MCP Server** (`packages/mcp`) | SessionManager 인스턴스를 MCP Server 초기화 시 생성. tool handler에서 `getToken()` 참조 | 기존 tool handler의 토큰 참조 방식 변경 (env var 직접 → SessionManager) |
| **StdioServerTransport** | `onclose` 콜백에서 `sessionManager.dispose()` 호출 | 콜백 1줄 추가 |
| **SessionService** (데몬) | Telegram `/newsession`에서 `sessionService.create()` 호출 | 기존 서비스 그대로 사용, 인터페이스 변경 없음 |
| **NotificationService** (데몬) | `SESSION_EXPIRING_SOON` 이벤트 타입 1개 추가 | 기존 16개 → 17개 이벤트. 알림 템플릿 1개 추가 |
| **TelegramBotService** | `/newsession` 핸들러 + 콜백 핸들러 추가 | 기존 8개 → 9개 명령어 |
| **CLI** | `mcp` 서브커맨드 그룹 + `setup`, `refresh-token` 2개 커맨드 | 기존 커맨드 구조에 추가 |
| **config.toml** | `[session].default_constraints` 참조 (이미 존재할 가능성) | 변경 없음 또는 키 1개 추가 |
| **24-monorepo 데이터 디렉토리** | `~/.waiaas/mcp-token` 파일 사양 추가 | 설계 문서 갱신 |

---

## What NOT to Add (and Why)

| 기술 | 추가하지 않는 이유 |
|------|-------------------|
| **write-file-atomic** | 1KB JWT 파일 1개에 원자적 rename 패턴은 과잉. `fs.writeFile`(mode: 0o600)으로 충분. 필요 시 temp+rename 10줄로 구현 |
| **node-cron / agenda / bull** | 단일 setTimeout 타이머 1개에 스케줄러 라이브러리는 과잉. 재시작 시 파일 기반 복원으로 persistence 불필요 |
| **chokidar / fs.watch** | 토큰 파일 변경 감지에 파일 watcher 불필요. 401 lazy reload 패턴이 더 안정적이고 단순 |
| **jwt-decode** | jose에 이미 `decodeJwt()` 포함. 동일 기능 중복 의존성 |
| **grammy-inline-menu** | 단일 레벨 에이전트 선택에 다단계 메뉴 라이브러리는 과잉. grammy 내장 InlineKeyboard로 충분 |
| **EventEmitter 라이브러리** (eventemitter3 등) | Node.js 내장 EventEmitter로 충분. SESSION_EXPIRING_SOON 발행에 외부 라이브러리 불필요 |
| **keytar / node-keychain** | OS 키체인 연동은 Self-Hosted 단일 머신 전제에서 과잉. 파일 권한(0o600)으로 충분 |
| **dotenv / config 라이브러리** | 토큰은 파일 또는 env var에서 직접 로드. 설정 관리 라이브러리 불필요 |

---

## Version Matrix (2026-02-09)

v0.9에서 사용하는 모든 패키지. **새로운 추가 없음.**

| Package | Version | v0.9 활용 | v0.9 변경 |
|---------|---------|----------|----------|
| `@modelcontextprotocol/sdk` | 1.26.x | McpServer, Transport onclose | 변경 없음 |
| `jose` | 6.1.x (또는 5.x) | `decodeJwt()` 신규 활용 | 변경 없음 |
| `grammy` | 1.39.x | InlineKeyboard, callbackQuery 신규 활용 | 변경 없음 |
| `commander` | 12.x | mcp 서브커맨드 추가 | 커맨드 추가만 |
| `hono` | 4.x | 세션 API 엔드포인트 | 변경 없음 |
| `drizzle-orm` | 0.45.x | sessions 테이블 쿼리 | 변경 없음 |
| `better-sqlite3` | 12.6.x | SQLite 드라이버 | 변경 없음 |
| `zod` | 3.x | CLI 인자 검증 | 변경 없음 |
| Node.js built-in | 22.x | fs/promises, timers, os, path | 기존 내장 API 활용 확대 |

---

## Roadmap Implications

### Stack Risk Assessment: ZERO

v0.9는 새로운 의존성이 0개이므로 기술 스택 위험이 없다:

- 호환성 위험 없음 (새 패키지 없음)
- 버전 충돌 없음
- 번들 크기 증가 없음
- 학습 비용 없음 (기존 라이브러리의 미사용 API만)

### Phase 구조에 대한 시사

1. **SessionManager 설계가 핵심:** 기존 라이브러리 API를 조합하는 방식이므로, 기술 조사보다 **인터페이스 설계와 에러 처리 시나리오**에 집중해야 한다.

2. **setTimeout 32-bit 상한 방어 코드 필수:** 설계 문서에 `Math.min(delay, 2_147_483_647)` 방어 코드를 명시해야 한다. 그렇지 않으면 구현자가 놓칠 수 있다.

3. **symlink 방어는 보안 시나리오 S-04에 해당:** `lstat()` 사용을 설계 문서에 명시해야 한다. `stat()`을 사용하면 symlink를 감지하지 못한다.

4. **jose decodeJwt의 에러 처리:** 잘못된 JWT 형식이 파일에 있을 경우 `decodeJwt()`는 예외를 던진다. try-catch 패턴을 설계 문서에 명시해야 한다 (보안 시나리오 S-02).

---

## Sources

### HIGH Confidence (공식 문서, GitHub)

- [Node.js v25 Timers Documentation](https://nodejs.org/api/timers.html) -- setTimeout 32-bit 상한, unref()
- [Node.js v25 File System Documentation](https://nodejs.org/api/fs.html) -- writeFile mode, lstat, isSymbolicLink
- [jose v6.x decodeJwt](https://github.com/panva/jose/blob/v6.x/docs/util/decode_jwt/functions/decodeJwt.md) -- 서명 없이 JWT payload 디코딩
- [jose GitHub main](https://github.com/panva/jose/blob/main/docs/util/decode_jwt/functions/decodeJwt.md) -- decodeJwt API 시그니처
- [jose Releases](https://github.com/panva/jose/releases) -- v6.1.3 최신 확인
- [@modelcontextprotocol/sdk npm](https://www.npmjs.com/package/@modelcontextprotocol/sdk) -- v1.26.0 최신 stable
- [MCP TypeScript SDK GitHub](https://github.com/modelcontextprotocol/typescript-sdk) -- McpServer API, Transport lifecycle
- [MCP TypeScript SDK server.md](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/server.md) -- 서버 기능 문서
- [grammy Inline Keyboard Plugin](https://grammy.dev/plugins/keyboard) -- InlineKeyboard, callbackQuery API
- [grammy CallbackQuery Reference](https://grammy.dev/ref/types/callbackquery) -- 콜백 쿼리 타입
- [write-file-atomic GitHub](https://github.com/npm/write-file-atomic) -- v7.0.0 API 확인 (사용하지 않기로 결정)

### MEDIUM Confidence (검증된 커뮤니티 소스)

- [Node.js setTimeout Max Issue #22860](https://github.com/nodejs/node/issues/22860) -- 32-bit 오버플로 시 즉시 실행 버그 동작 확인
- [Node.js setTimeout Archive Issue #3605](https://github.com/nodejs/node-v0.x-archive/issues/3605) -- MAX_TIMEOUT 문서화 요청
- [MCP SDK Lifecycle DeepWiki](https://deepwiki.com/modelcontextprotocol/typescript-sdk/6.1-oauth-server-implementation) -- Transport lifecycle hook 분석

### Project-Internal (이전 마일스톤 설계 문서)

- v0.9 목표 문서 (objectives/v0.9-session-management-automation.md) -- SessionManager 설계, lazy reload 확정
- 38-sdk-mcp-interface.md -- 기존 MCP Server 6 tools + 3 resources
- 53-session-renewal-protocol.md -- 세션 갱신 프로토콜, 50% safety guard
- 40-telegram-bot-docker.md -- 기존 Telegram Bot 8 명령어, Tier 분류
- 54-cli-flow-redesign.md -- 기존 CLI 커맨드 구조
- 35-notification-architecture.md -- 기존 16개 알림 이벤트
