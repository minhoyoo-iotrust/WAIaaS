# Technology Stack: v1.5 Price Oracle + Action Provider Framework

**Project:** WAIaaS v1.5 -- 가격 오라클 + Action Provider 프레임워크
**Researched:** 2026-02-15
**Mode:** Subsequent Milestone (stack additions only)

---

## Executive Summary

v1.5의 핵심 발견: **신규 외부 의존성 0개.** Pyth Hermes와 CoinGecko는 단순 REST API로 Node.js 22 내장 `fetch()`만으로 호출 가능하다. LRU 캐시는 목표 문서에서 이미 "인메모리 Map 기반 직접 구현"으로 결정되어 외부 라이브러리가 불필요하다. API 키 암호화는 기존 `settings-crypto.ts`의 HKDF+AES-256-GCM 패턴을 재사용하면 되며, sodium-native secretbox로 전환할 기술적 이유가 없다. ESM dynamic import는 Node.js 22 런타임 내장 기능이다.

**결론**: 기존 스택을 유지하면서 3개의 외부 REST API를 native `fetch()`로 호출하고, 기존 암호화 패턴을 확장하는 것만으로 v1.5 전체를 구현할 수 있다.

---

## Recommended Stack Additions

### 신규 npm 의존성: 없음

v1.5에서 **새로운 npm 패키지를 추가하지 않는다.** 아래 근거를 참조.

| 고려한 패키지 | 결정 | 이유 |
|-------------|------|------|
| `@pythnetwork/hermes-client` (v3.1.0) | **미사용** | Pyth Hermes REST API는 단순 GET 1개(`/v2/updates/price/latest`)와 피드 검색 1개(`/v2/price_feeds`)만 사용. Node.js 22 내장 `fetch()`로 10줄 이내 구현 가능. hermes-client는 SSE 스트리밍, WebSocket 등 불필요한 기능을 포함하며 의존성 3개를 추가로 끌어온다. WAIaaS의 zero-dependency 철학에 부합하지 않음 |
| `lru-cache` (v11.2.6) | **미사용** | 목표 문서 기술 결정 #6에서 "외부 LRU 라이브러리 의존성 제거, Map + doubly-linked list로 직접 구현(128항목 상한)"으로 이미 결정됨. 128항목 고정 상한이므로 직접 구현 복잡도가 낮고, TTL 5분 + LRU 퇴출만 필요. lru-cache v11.x는 Node.js 20+ 필수로 호환성은 문제없지만, 128항목에 이 라이브러리는 과잉 |
| `coingecko-api-v3` / `coingecko-api` | **미사용** | CoinGecko는 `/simple/token_price/{platform}` 엔드포인트 1개만 사용. native `fetch()`로 충분. 커뮤니티 래퍼 라이브러리들은 유지보수 불안정 |

---

## 외부 REST API 통합 상세

### 1. Pyth Hermes REST API (Primary Oracle)

**Base URL:** `https://hermes.pyth.network`
**인증:** 불필요 (Zero-config)
**Rate Limit:** 30 requests / 10 seconds per IP [HIGH confidence]
**Confidence:** HIGH (공식 문서 + Swagger UI 검증)

#### 사용할 엔드포인트

| 엔드포인트 | 메서드 | 용도 | 파라미터 |
|-----------|--------|------|---------|
| `/v2/updates/price/latest` | GET | 토큰 가격 조회 (1개 이상 동시) | `ids[]=<feedId>&ids[]=<feedId>&parsed=true` |
| `/v2/price_feeds` | GET | 피드 검색/발견 (토큰 매핑) | `query=<symbol>&asset_type=crypto` |

#### 응답 구조 (`/v2/updates/price/latest?parsed=true`)

```typescript
interface HermesResponse {
  binary: { encoding: string; data: string[] };
  parsed: HermesParsedPrice[];
}

interface HermesParsedPrice {
  id: string;           // 64-char hex feed ID (no 0x prefix)
  price: {
    price: string;      // e.g. "6140993501000" (정수 문자열)
    conf: string;       // confidence interval (정수 문자열)
    expo: number;       // e.g. -8 (10^expo를 곱해야 실제 가격)
    publish_time: number; // Unix timestamp (초)
  };
  ema_price: {          // EMA 가격 (동일 구조)
    price: string;
    conf: string;
    expo: number;
    publish_time: number;
  };
  metadata: {
    slot: number;
    proof_available_time: number;
    prev_publish_time: number;
  };
}
```

#### 가격 변환 로직

```typescript
// Pyth 가격 -> USD 변환
function pythPriceToUsd(price: string, expo: number): number {
  // price="6140993501000", expo=-8 -> 61409.93501000
  return Number(price) * Math.pow(10, expo);
}
```

#### 주요 토큰 Feed ID 하드코딩 맵

**전략: 하이브리드 (하드코딩 + API 폴백)**
- 주요 토큰 10~15개는 bytes32 feed ID를 하드코딩하여 즉시 조회 가능
- 미등록 토큰은 `/v2/price_feeds?query=<symbol>` API로 동적 검색
- 검색 결과는 InMemoryPriceCache와 별도의 feedId 매핑 캐시에 저장

```typescript
// 검증된 주요 토큰 Feed IDs [HIGH confidence - 공식 문서/코드 예제에서 확인]
const PYTH_FEED_IDS: Record<string, string> = {
  'SOL/USD':  'ef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d',
  'ETH/USD':  'ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace',
  'BTC/USD':  'e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43',
  // USDC, USDT 등 추가 피드 ID는 phase research에서 /v2/price_feeds API로 검증 필요
};
```

**Confidence on feed IDs:**
- SOL/USD: HIGH (공식 문서 + QuickNode 가이드 + Pyth Insights에서 동일 ID 확인)
- ETH/USD: HIGH (공식 fetch-price-updates 문서 예제에서 확인)
- BTC/USD: HIGH (공식 문서 + Pyth Insights에서 확인)
- 기타: LOW (phase research에서 `/v2/price_feeds` API로 검증 필요)

#### 구현 패턴

```typescript
// PythOracle.getPrice() 핵심 구현 (Node.js 22 native fetch)
async function fetchPythPrice(feedId: string): Promise<PriceInfo> {
  const url = `https://hermes.pyth.network/v2/updates/price/latest?ids[]=${feedId}&parsed=true`;
  const res = await fetch(url, {
    headers: { accept: 'application/json' },
    signal: AbortSignal.timeout(5000), // 5s timeout
  });

  if (!res.ok) throw new ChainError('TRANSIENT', `Pyth HTTP ${res.status}`);

  const data: HermesResponse = await res.json();
  const parsed = data.parsed[0];
  if (!parsed) throw new ChainError('TRANSIENT', 'Pyth: no price data returned');

  const usdPrice = Number(parsed.price.price) * Math.pow(10, parsed.price.expo);
  const confidence = Number(parsed.price.conf) * Math.pow(10, parsed.price.expo);

  return {
    usdPrice,
    confidence,
    source: 'pyth',
    fetchedAt: Date.now(),
    expiresAt: Date.now() + 5 * 60 * 1000, // 5분 TTL
    isStale: false,
  };
}

// 배치 조회: 다수 feedId를 단일 요청으로 조회
async function fetchPythPrices(feedIds: string[]): Promise<Map<string, PriceInfo>> {
  const params = feedIds.map(id => `ids[]=${id}`).join('&');
  const url = `https://hermes.pyth.network/v2/updates/price/latest?${params}&parsed=true`;
  // ... 단일 HTTP 요청으로 다수 가격 조회
}
```

---

### 2. CoinGecko Demo API (Fallback Oracle)

**Base URL:** `https://api.coingecko.com/api/v3`
**인증:** `x-cg-demo-api-key` 헤더 또는 `x_cg_demo_api_key` 쿼리 파라미터
**Rate Limit:** Demo 30 req/min, 10,000 req/month [HIGH confidence]
**Pro URL:** `https://pro-api.coingecko.com/api/v3` (Pro 키 사용 시 자동 전환)
**Confidence:** HIGH (공식 문서 검증)

#### 사용할 엔드포인트

| 엔드포인트 | 메서드 | 용도 | 파라미터 |
|-----------|--------|------|---------|
| `/simple/token_price/{platform_id}` | GET | 토큰 컨트랙트 주소로 가격 조회 | `contract_addresses=<addr1>,<addr2>&vs_currencies=usd&include_last_updated_at=true` |
| `/simple/price` | GET | 네이티브 토큰(SOL, ETH) 가격 조회 | `ids=solana,ethereum&vs_currencies=usd&include_last_updated_at=true` |

#### Platform ID 매핑

```typescript
// ChainType -> CoinGecko platformId 매핑
const COINGECKO_PLATFORM_IDS: Record<string, string> = {
  solana: 'solana',
  ethereum: 'ethereum',
  // 향후 체인 추가 시 확장
};

// ChainType -> CoinGecko native coin ID 매핑
const COINGECKO_NATIVE_IDS: Record<string, string> = {
  solana: 'solana',
  ethereum: 'ethereum',
};
```

#### 응답 구조 (`/simple/token_price/solana`)

```typescript
// 요청: /simple/token_price/solana?contract_addresses=<mint>&vs_currencies=usd&include_last_updated_at=true
// 응답:
interface CoinGeckoTokenPriceResponse {
  [contractAddress: string]: {
    usd: number;         // e.g. 1.001
    last_updated_at: number; // Unix timestamp (초)
  };
}

// 요청: /simple/price?ids=solana&vs_currencies=usd&include_last_updated_at=true
// 응답:
interface CoinGeckoPriceResponse {
  [coinId: string]: {
    usd: number;         // e.g. 148.52
    last_updated_at: number;
  };
}
```

#### 구현 패턴

```typescript
async function fetchCoinGeckoTokenPrice(
  platformId: string,
  contractAddresses: string[],
  apiKey: string,
): Promise<Map<string, PriceInfo>> {
  const baseUrl = 'https://api.coingecko.com/api/v3';
  const addresses = contractAddresses.join(',');
  const url = `${baseUrl}/simple/token_price/${platformId}?contract_addresses=${addresses}&vs_currencies=usd&include_last_updated_at=true`;

  const res = await fetch(url, {
    headers: {
      accept: 'application/json',
      'x-cg-demo-api-key': apiKey,
    },
    signal: AbortSignal.timeout(10000), // CoinGecko는 느릴 수 있으므로 10s
  });

  if (res.status === 429) throw new ChainError('TRANSIENT', 'CoinGecko rate limited');
  if (!res.ok) throw new ChainError('TRANSIENT', `CoinGecko HTTP ${res.status}`);

  const data: CoinGeckoTokenPriceResponse = await res.json();
  // ... 변환 로직
}
```

#### Pro 키 호환

```typescript
// Pro 키 감지 시 자동으로 Pro base URL 전환
function getCoinGeckoBaseUrl(apiKey: string): string {
  // CoinGecko Pro 키는 'CG-' 프리픽스로 시작 (Demo 키도 동일)
  // Pro 계정은 Admin Settings에서 별도 토글 또는 자동 감지
  // 기본: Demo URL, Pro 설정 시: Pro URL
  return 'https://api.coingecko.com/api/v3';
}
```

---

### 3. Pyth `/v2/price_feeds` -- Feed ID 동적 발견

**용도:** 하드코딩 맵에 없는 토큰의 Pyth feed ID를 동적으로 검색
**Rate Limit:** 동일 (30 req/10s)

```typescript
// GET /v2/price_feeds?query=BONK&asset_type=crypto
// 응답: 매칭되는 feed 목록 (id, attributes 포함)
// 검색 결과를 feedId 매핑 캐시에 저장하여 반복 조회 방지
```

---

## 기존 라이브러리의 미사용 API 활성화

### 없음

v1.5는 기존 의존성(viem, @solana/kit 등)의 새로운 API를 활용하지 않는다. 순수하게 새로운 모듈(oracle, action-provider)을 추가하며, HTTP 호출은 Node.js 22 내장 `fetch()`를 사용한다.

---

## 내부 구현 상세

### 1. LRU 캐시 직접 구현

**이유:** 목표 문서 기술 결정 #6에서 확정. 128항목 상한으로 충분히 작아 직접 구현이 합리적.

```typescript
/**
 * InMemoryPriceCache: Map + doubly-linked list 기반 LRU 캐시
 *
 * - 최대 128 항목
 * - 5분 TTL (FRESH), 30분까지 허용 (AGING/STALE)
 * - 캐시 키: `${chain}:${address}` (e.g. "solana:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")
 * - CacheStats: hits, misses, staleHits, size, evictions
 */
interface LRUNode<T> {
  key: string;
  value: T;
  prev: LRUNode<T> | null;
  next: LRUNode<T> | null;
}

class InMemoryPriceCache {
  private readonly map = new Map<string, LRUNode<PriceInfo>>();
  private readonly maxSize = 128;
  private head: LRUNode<PriceInfo> | null = null;
  private tail: LRUNode<PriceInfo> | null = null;
  // stats tracking...
}
```

**lru-cache를 사용하지 않는 이유:**
- 128항목은 매우 작은 캐시. O(1) LRU는 Map + doubly-linked list로 ~60줄에 구현 가능
- TTL 판정을 3단계(FRESH/AGING/STALE)로 커스텀해야 하므로 lru-cache의 TTL과 맞지 않음
- lru-cache의 stale-while-revalidate 패턴이 WAIaaS의 가격 나이 3단계와 의미적으로 다름
- 외부 의존성 0개 유지

### 2. API 키 암호화 -- 기존 settings-crypto 패턴 재사용

**목표 문서에서 "sodium-native secretbox"으로 명시되었으나, 기존 패턴 재사용을 권장한다.**

**이유:**
1. **일관성:** 기존 `settings-crypto.ts`가 HKDF(SHA-256) + AES-256-GCM으로 알림 봇 토큰, Discord 웹훅 등 credential을 이미 암호화하고 있다. API 키도 동일한 성격의 credential이므로 동일 패턴이 자연스럽다.
2. **보안 동등성:** AES-256-GCM과 XSalsa20-Poly1305(secretbox)는 동일한 보안 수준(256-bit key, AEAD). 둘 다 NIST/NaCl 표준.
3. **코드 재사용:** `encryptSettingValue()`/`decryptSettingValue()` 함수를 그대로 사용하면 새 암호화 코드가 0줄.
4. **타입 선언 불필요:** 현재 `sodium-native.d.ts`에 secretbox 관련 타입이 없다. 추가하려면 `crypto_secretbox_easy`, `crypto_secretbox_open_easy`, 3개 상수(`KEYBYTES`, `NONCEBYTES`, `MACBYTES`)를 선언해야 한다.

**구현 방안 2가지:**

| 방안 | 설명 | 장점 | 단점 |
|------|------|------|------|
| A. SettingsService CREDENTIAL_KEYS 확장 | `CREDENTIAL_KEYS`에 `oracle.coingecko_api_key` 추가, `api_keys` 테이블 대신 `settings` 테이블 활용 | 코드 추가 0줄, 기존 Admin Settings UI 재사용 | 테이블 구조가 목표 문서와 다름 |
| B. settings-crypto 함수 직접 호출 | `api_keys` 테이블에 저장하되 `encryptSettingValue()`/`decryptSettingValue()` 함수를 직접 호출 | 목표 문서의 DB 스키마 유지, 기존 암호화 함수 재사용 | ApiKeyStore 클래스에서 함수 import 필요 |

**권장: 방안 A (SettingsService 확장)**
- CoinGecko API 키는 `oracle.coingecko_api_key` 설정으로 SettingsService에 통합
- Action Provider별 API 키는 `api_keys` 테이블 + 방안 B로 구현 (프로바이더 수가 동적이므로 SETTING_DEFINITIONS에 사전 등록 불가)
- 최종 결정은 phase planning에서 확정

**만약 목표 문서의 sodium-native secretbox를 그대로 따를 경우:**

```typescript
// sodium-native.d.ts에 추가 필요한 타입 선언
declare module 'sodium-native' {
  export const crypto_secretbox_KEYBYTES: number;   // 32
  export const crypto_secretbox_NONCEBYTES: number; // 24
  export const crypto_secretbox_MACBYTES: number;   // 16

  export function crypto_secretbox_easy(
    c: Buffer, m: Buffer, n: Buffer, sk: Buffer
  ): void;

  export function crypto_secretbox_open_easy(
    m: Buffer, c: Buffer, n: Buffer, sk: Buffer
  ): boolean;
}

// 사용 예시
import sodium from 'sodium-native';

function encryptApiKey(plaintext: string, key: Buffer): Buffer {
  const m = Buffer.from(plaintext, 'utf8');
  const n = Buffer.alloc(sodium.crypto_secretbox_NONCEBYTES);
  sodium.randombytes_buf(n); // 또는 randomBytes(24)
  const c = Buffer.alloc(m.length + sodium.crypto_secretbox_MACBYTES);
  sodium.crypto_secretbox_easy(c, m, n, key);
  return Buffer.concat([n, c]); // nonce || ciphertext
}
```

### 3. ESM Dynamic Import 플러그인 시스템

**Node.js 22 내장 기능.** 추가 라이브러리 불필요.

```typescript
// ActionProviderRegistry: ~/.waiaas/actions/ 디렉토리 스캔 + 동적 로드
import { readdir } from 'node:fs/promises';
import { join } from 'node:path';
import { pathToFileURL } from 'node:url';

async function loadPlugin(filePath: string): Promise<IActionProvider> {
  // ESM dynamic import는 파일 URL을 요구한다
  const fileUrl = pathToFileURL(filePath).href;
  const module = await import(fileUrl);

  // default export 또는 named export 검증
  const provider = module.default ?? module.provider;
  if (!provider) throw new Error(`No default export in ${filePath}`);

  // validate-then-trust: Zod 스키마로 metadata 검증
  const metadata = ActionProviderMetadataSchema.parse(provider.metadata);
  // ... 인터페이스 준수 검증

  return provider;
}

async function discoverPlugins(actionsDir: string): Promise<IActionProvider[]> {
  const entries = await readdir(actionsDir, { withFileTypes: true });
  const providers: IActionProvider[] = [];

  for (const entry of entries) {
    if (entry.isFile() && entry.name.endsWith('.mjs')) {
      // .mjs 파일: ESM 모듈로 직접 import
      const provider = await loadPlugin(join(actionsDir, entry.name));
      providers.push(provider);
    } else if (entry.isDirectory()) {
      // 디렉토리: package.json의 main/exports 확인
      const pkgPath = join(actionsDir, entry.name, 'package.json');
      // ... package.json 파싱 후 main 엔트리 import
    }
  }
  return providers;
}
```

**주의사항:**
- `import()` URL: Node.js ESM에서 파일 경로는 `file://` URL로 변환해야 한다 (`pathToFileURL()` 사용)
- **캐시 무효화:** Node.js ESM 모듈 캐시는 URL 기반. 동일 경로의 모듈은 한 번만 로드됨. 런타임 플러그인 리로드가 필요하면 `?t=${Date.now()}` 쿼리 파라미터 추가 (단, 메모리 누수 가능)
- **에러 격리:** 플러그인 로드 실패 시 해당 플러그인만 건너뛰고 나머지 로드 계속

### 4. AbortSignal.timeout() -- HTTP 요청 타임아웃

Node.js 22에서 `AbortSignal.timeout(ms)` 사용 가능. 별도의 타임아웃 라이브러리 불필요.

```typescript
// Pyth: 5초 타임아웃 (빠른 응답 기대)
fetch(url, { signal: AbortSignal.timeout(5000) });

// CoinGecko: 10초 타임아웃 (느릴 수 있음)
fetch(url, { signal: AbortSignal.timeout(10000) });
```

---

## 기존 의존성 호환성 확인

| 패키지 | 현재 버전 | v1.5 호환성 | 변경 필요 |
|--------|----------|------------|----------|
| `sodium-native` | ^4.3.1 | v4.3.2 최신 (v5.x는 napi->libjs 전환으로 호환성 확인 필요) | **없음** (4.x 유지, secretbox 사용 시 d.ts 추가만) |
| `zod` | ^3.24.0 | SpendingLimitRuleSchema, ActionProviderMetadata 등 새 스키마 정의에 사용 | **없음** (기존 기능 충분) |
| `drizzle-orm` | ^0.45.0 | api_keys 테이블 스키마 추가, DB v11 마이그레이션 | **없음** |
| `hono` | ^4.11.9 | 신규 라우트 (actions, oracle-status, api-keys) 추가 | **없음** |
| Node.js | 22 LTS | `fetch()`, `AbortSignal.timeout()`, ESM `import()` 모두 내장 | **없음** |

### sodium-native v4 vs v5 분석

| 항목 | v4.3.x (현재) | v5.0.x (최신) |
|------|-------------|-------------|
| Native 바인딩 | N-API | libjs (새 바인딩) |
| crypto_secretbox_easy | 지원 | 지원 |
| 호환성 위험 | 없음 (안정) | 바인딩 변경으로 빌드 문제 가능 |
| **권장** | **v4.x 유지** | v1.5 범위 외에서 검토 |

---

## Alternatives Considered

### Oracle API

| 항목 | 선택 | 대안 | 미선택 이유 |
|------|------|------|------------|
| Primary Oracle | Pyth Hermes REST | Chainlink (EVM only) | EVM 전용, Solana 미지원. Aggregator 주소 관리 부담. 목표 문서 기술 결정 #3에서 제외 결정 |
| Primary Oracle | Pyth Hermes REST | Pyth on-chain 직접 조회 | 온체인 RPC 호출 비용+복잡도. REST API가 동일 데이터를 무료/단순하게 제공 |
| Fallback Oracle | CoinGecko Demo | DeFiLlama API | DeFiLlama는 TVL 특화, 개별 토큰 실시간 가격 API가 CoinGecko 대비 약함 |
| Fallback Oracle | CoinGecko Demo | CoinMarketCap API | CMC는 무료 티어 제한이 훨씬 엄격 (333 req/day). CoinGecko Demo가 30 req/min으로 우수 |

### HTTP 클라이언트

| 항목 | 선택 | 대안 | 미선택 이유 |
|------|------|------|------------|
| HTTP | Node.js `fetch()` | `@pythnetwork/hermes-client` | 의존성 3개 추가. WAIaaS에서 사용하는 기능(REST GET 1-2개)이 패키지의 5% 미만 |
| HTTP | Node.js `fetch()` | `axios` | WAIaaS에 axios 의존성 없음. fetch()로 동일 기능 구현 가능 |
| HTTP | Node.js `fetch()` | `undici` | Node.js 22 내장 fetch가 undici 기반이므로 별도 설치 불필요 |

### LRU 캐시

| 항목 | 선택 | 대안 | 미선택 이유 |
|------|------|------|------------|
| 캐시 | 직접 구현 | `lru-cache` v11 | 128항목에 과잉. TTL 3단계 커스텀 필요. 목표 문서에서 직접 구현 결정 |
| 캐시 | 직접 구현 | `quick-lru` | ESM-only로 호환성은 좋으나, 128항목에 외부 의존성 추가 불필요 |
| 캐시 | 인메모리 | SQLite 캐시 테이블 | 가격 데이터는 휘발성. 데몬 재시작 시 새로 조회가 정석. DB I/O 불필요 |

### 암호화

| 항목 | 선택 | 대안 | 미선택 이유 |
|------|------|------|------------|
| API 키 암호화 | HKDF+AES-256-GCM (기존 패턴) | sodium-native secretbox | 보안 동등. 기존 코드 재사용으로 구현 비용 0. 일관성 우수 |

---

## Installation

```bash
# 신규 패키지 설치 없음
# v1.5는 기존 의존성만으로 구현 가능
```

---

## Rate Limit 관리 전략

### Pyth Hermes

| 항목 | 값 | 대응 |
|------|-----|------|
| 제한 | 30 req / 10s per IP | 5분 TTL 캐시로 요청 최소화 |
| 배치 | `ids[]` 파라미터로 다수 토큰 단일 요청 | getPrices() 배치 최적화 |
| 429 응답 | Too Many Requests | ChainError('TRANSIENT') -> CoinGecko fallback |

### CoinGecko Demo

| 항목 | 값 | 대응 |
|------|-----|------|
| 제한 | 30 req/min, 10K req/month | 5분 TTL 캐시 + 배치 조회(comma-separated addresses) |
| 429 응답 | Rate limited | ChainError('TRANSIENT') -> graceful fallback (네이티브 금액만) |
| 월간 상한 | 10,000 req/month | 128항목 * 5분 TTL = 최대 ~8,640 req/month (24h 연속 운영 시). Pro 키로 업그레이드 권장 안내 |

---

## 통합 지점 요약

| 기존 모듈 | 신규 모듈 | 통합 방식 |
|----------|----------|----------|
| `pipeline/` (Stage 3 정책 평가) | `oracle/` (resolveEffectiveAmountUsd) | Stage 3에서 USD 평가 함수 호출, PriceResult discriminated union으로 결과 분기 |
| `infrastructure/settings/` | Oracle CoinGecko API 키 | CREDENTIAL_KEYS에 `oracle.coingecko_api_key` 추가 |
| `infrastructure/settings/` | Action Provider API 키 | `api_keys` 테이블 + settings-crypto 함수 재사용 |
| `infrastructure/database/schema.ts` | `api_keys` 테이블 | DB v11 마이그레이션, drizzle 스키마 추가 |
| `api/routes/admin.ts` | oracle-status, api-keys 엔드포인트 | 기존 admin 라우트 파일 확장 |
| `api/routes/` (신규) | actions.ts | POST /v1/actions/:provider/:action 신규 라우트 |
| MCP Server (14개 도구) | ActionDefinition -> MCP Tool 변환 | 동적 도구 등록/해제, mcpExpose 플래그 기반 필터링 |

---

## Sources

### Pyth Hermes API
- [Pyth Developer Hub - Hermes](https://docs.pyth.network/price-feeds/core/api-instances-and-providers/hermes) - PUBLIC [HIGH]
- [Pyth Developer Hub - Fetch Price Updates](https://docs.pyth.network/price-feeds/core/fetch-price-updates) - Response format [HIGH]
- [Pyth Developer Hub - API Reference](https://docs.pyth.network/price-feeds/core/api-reference) - Endpoint list [HIGH]
- [Pyth Hermes Swagger UI](https://hermes.pyth.network/docs/) - Interactive docs [HIGH]
- [Pyth Developer Hub - Price Feed IDs](https://docs.pyth.network/price-feeds/core/price-feeds) - Feed ID catalog [HIGH]

### CoinGecko API
- [CoinGecko API - Simple Price](https://docs.coingecko.com/reference/simple-price) - Endpoint spec [HIGH]
- [CoinGecko API - Token Price by Address](https://docs.coingecko.com/reference/simple-token-price) - Token price endpoint [HIGH]
- [CoinGecko API - Setting Up API Key](https://docs.coingecko.com/docs/setting-up-your-api-key) - Auth method [HIGH]
- [CoinGecko API - Rate Limits](https://docs.coingecko.com/docs/common-errors-rate-limit) - Rate limit details [HIGH]
- [CoinGecko - API Pricing](https://www.coingecko.com/en/api/pricing) - Plan comparison [HIGH]

### LRU Cache
- [lru-cache npm](https://www.npmjs.com/package/lru-cache) - v11.2.6, Node 20+ required [HIGH]
- [lru-cache GitHub CHANGELOG](https://github.com/isaacs/node-lru-cache/blob/main/CHANGELOG.md) - Version history [HIGH]

### sodium-native
- [sodium-native Secret Key Box](https://sodium-friends.github.io/docs/docs/secretkeyboxencryption) - secretbox API [HIGH]
- [sodium-native npm](https://www.npmjs.com/package/sodium-native) - v5.0.10 latest, v4.3.x current [MEDIUM]
- [sodium-native CHANGELOG](https://github.com/holepunchto/sodium-native/blob/main/CHANGELOG.md) - v4->v5 breaking changes [MEDIUM]

### Node.js ESM
- [Node.js ESM Documentation](https://nodejs.org/api/esm.html) - Dynamic import() [HIGH]
- [MDN - import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) - Dynamic import spec [HIGH]

---

## Confidence Assessment

| 영역 | 수준 | 근거 |
|------|------|------|
| Pyth Hermes API | HIGH | 공식 문서 + Swagger UI + 응답 구조 검증 완료 |
| CoinGecko API | HIGH | 공식 문서 + 엔드포인트/인증/rate limit 검증 완료 |
| LRU 직접 구현 | HIGH | 표준 알고리즘, 128항목 고정 상한, 목표 문서에서 결정 완료 |
| API 키 암호화 | HIGH | 기존 코드베이스 패턴 확인, AES-256-GCM/secretbox 보안 동등성 확인 |
| ESM dynamic import | HIGH | Node.js 22 공식 문서, 표준 패턴 |
| Pyth Feed ID (SOL/ETH/BTC) | HIGH | 다수 공식 소스에서 동일 ID 확인 |
| Pyth Feed ID (기타 토큰) | LOW | phase research에서 `/v2/price_feeds` API로 검증 필요 |
| sodium-native v4 vs v5 | MEDIUM | CHANGELOG 확인했으나 세부 호환성은 미검증 |
