# Architecture: Owner 선택적 등록 + 점진적 보안 해금

**문서 목적:** v0.8 마일스톤의 아키텍처 변경 분석. 기존 컴포넌트 수정 범위, 신규 컴포넌트, 데이터 흐름 변경, 빌드 순서 제안.
**연구일:** 2026-02-08
**전체 신뢰도:** HIGH (14개 기존 설계 문서 + v0.8 objectives 직접 분석 기반)

---

## 1. 핵심 아키텍처 변경 요약

v0.8은 **새로운 시스템을 추가하는 것이 아니라, 기존 시스템에 owner-presence 조건 분기를 주입하는 마일스톤**이다. 변경의 본질은 "Owner가 반드시 있다"는 가정을 "Owner가 있을 수도, 없을 수도 있다"로 전환하는 것이다.

**아키텍처적 영향:**
- 데이터 모델 변경: `agents.owner_address` NOT NULL 제거 + `owner_verified` 컬럼 추가
- 정책 엔진 로직 삽입: evaluate() Step 9 직후 APPROVAL 다운그레이드 분기
- Owner 생명주기 상태 머신: 신규 (없음/유예/잠금 3-state)
- IChainAdapter 확장: sweepAll 1개 메서드 추가 (19 -> 20)
- REST API 추가: withdraw 엔드포인트 1개 + set-owner/remove-owner CLI 2개
- 기존 컴포넌트 4곳에 owner-presence 조건 분기 삽입

**변경하지 않는 것:**
- 6-stage 트랜잭션 파이프라인 구조 자체
- 8-state 트랜잭션 상태 머신
- 3-tier 인증 모델 (masterAuth/ownerAuth/sessionAuth) 구조
- 10개 PolicyType 스키마
- 미들웨어 체인 8개 순서
- SQLite 7 테이블 구조 (agents 2개 컬럼 변경만)

---

## 2. 컴포넌트 변경 분류

### 2.1 수정 대상 컴포넌트 (기존)

아래 표는 기존 컴포넌트별 수정 범위를 변경 규모(대/중/소)로 분류한다.

| 컴포넌트 | 패키지 | 변경 규모 | 변경 내용 | 설계 문서 |
|----------|--------|:---------:|----------|-----------|
| **agents 테이블 스키마** | `@waiaas/core` | 중 | owner_address: NOT NULL 제거, owner_verified: INTEGER 추가 | CORE-02 (25) |
| **DatabasePolicyEngine** | `@waiaas/daemon` | 중 | evaluate() Step 9 직후 APPROVAL 다운그레이드 삽입 | LOCK-MECH (33) |
| **Owner 생명주기** | `@waiaas/daemon` | **대** | 등록/변경/해제 전면 재설계, 유예/잠금 2단계 상태 머신 | OWNR-CONN (34) |
| **KillSwitchService** | `@waiaas/daemon` | 중 | 복구 정책 Owner 유무 분기 (30min vs 24h) | KILL-AUTO-EVM (36) |
| **SessionRenewalService** | `@waiaas/daemon` | 소 | 갱신 시 Owner 유무 분기 (거부 윈도우 활성/비활성) | SESS-PROTO (30) |
| **IChainAdapter** | `@waiaas/core` | 소 | sweepAll 메서드 시그니처 1개 추가 | CORE-04 (27) |
| **SolanaAdapter** | `@waiaas/adapter-solana` | 중 | sweepAll 구현 (getAssets + buildBatch + SOL 전량 전송) | CHAIN-SOL (31) |
| **NotificationService** | `@waiaas/daemon` | 소 | 다운그레이드 알림 템플릿 + Owner 등록 안내 메시지 | NOTI-ARCH (35) |
| **REST API 라우터** | `@waiaas/daemon` | 중 | withdraw 엔드포인트 추가, 인증 맵 Owner 유무 분기 | API-SPEC (37) |
| **CLI** | `@waiaas/cli` | 중 | agent create --owner 선택화, set-owner/remove-owner 신규 | CORE-05 (28) |
| **Telegram Bot** | (future) | 소 | 다운그레이드 알림 인라인 메시지 | TGBOT-DOCKER (40) |

### 2.2 신규 컴포넌트

| 컴포넌트 | 패키지 | 설명 |
|----------|--------|------|
| **OwnerLifecycleService** | `@waiaas/daemon` | Owner 등록/변경/해제 비즈니스 로직. 유예/잠금 상태 판정. |
| **WithdrawService** | `@waiaas/daemon` | 자금 회수 오케스트레이션. sweepAll 호출 + 결과 집계. |
| **OwnerPresenceGuard** | `@waiaas/daemon` | owner-presence 조건 판정 유틸리티. 여러 서비스에서 공유. |

### 2.3 변경하지 않는 컴포넌트

| 컴포넌트 | 이유 |
|----------|------|
| Keystore (AES-256-GCM + Argon2id) | Owner 유무와 무관하게 동일 동작 |
| TransactionPipeline (6-stage) | 파이프라인 구조 자체는 변경 없음. Stage 3에서 PolicyEngine 결과만 달라짐 |
| StateMachine (8-state) | 상태 전이 규칙 변경 없음 |
| Hono 미들웨어 체인 (8개) | 순서/구조 변경 없음 |
| IPriceOracle | Owner 유무와 무관하게 동일 동작 |
| ActionProvider / IActionProvider | Owner 유무와 무관 |

---

## 3. 데이터 모델 변경

### 3.1 agents 테이블 변경

**현재 (v0.7 확정):**
```sql
owner_address TEXT NOT NULL   -- Owner 주소 필수
```

**v0.8 변경:**
```sql
owner_address   TEXT,                                  -- nullable (선택적)
owner_verified  INTEGER NOT NULL DEFAULT 0,            -- ownerAuth 사용 이력 (0/1)
```

**Drizzle ORM 변경:**
```typescript
// 변경 전
ownerAddress: text('owner_address').notNull(),

// 변경 후
ownerAddress: text('owner_address'),                               // nullable
ownerVerified: integer('owner_verified', { mode: 'boolean' })
  .notNull()
  .default(false),                                                 // 신규
```

**마이그레이션 전략:**
- `owner_address`: ALTER TABLE로 NOT NULL 제거 (SQLite 제약: ALTER TABLE 직접 NOT NULL 제거 불가 -> 테이블 재생성 마이그레이션 필요)
- `owner_verified`: ALTER TABLE ADD COLUMN (DEFAULT 0, 기존 행 자동 0)
- Drizzle-kit이 generate 시 자동 처리 가능하나, SQLite 테이블 재생성 마이그레이션이므로 데이터 손실 주의

**SQLite NOT NULL 제거 주의사항:**
SQLite는 ALTER TABLE으로 컬럼의 NOT NULL 제약을 직접 제거할 수 없다. Drizzle-kit은 이를 위해 다음 과정을 자동 생성한다:
1. 새 테이블 생성 (owner_address nullable)
2. 데이터 복사
3. 기존 테이블 삭제
4. 새 테이블 이름 변경
5. 인덱스 재생성

이 마이그레이션은 **트랜잭션 내에서 실행되어야** 데이터 안전성이 보장된다.

### 3.2 Owner 상태 판정 로직

`owner_address`와 `owner_verified` 조합으로 3가지 상태를 판정한다:

| owner_address | owner_verified | 상태 | 의미 |
|:------------:|:--------------:|------|------|
| NULL | 0 | **없음** (Base) | Owner 미등록. DELAY까지만 동작. |
| non-NULL | 0 | **유예** (Grace) | Owner 주소 등록됨, 아직 ownerAuth 미사용. masterAuth만으로 변경/해제 가능. |
| non-NULL | 1 | **잠금** (Locked) | ownerAuth 사용 이력 있음. 변경 시 ownerAuth + masterAuth 필요. 해제 불가. |

```typescript
// packages/daemon/src/domain/owner-presence.ts
type OwnerState = 'NONE' | 'GRACE' | 'LOCKED'

function resolveOwnerState(agent: { ownerAddress: string | null; ownerVerified: boolean }): OwnerState {
  if (agent.ownerAddress === null) return 'NONE'
  if (!agent.ownerVerified) return 'GRACE'
  return 'LOCKED'
}
```

이 함수는 **OwnerPresenceGuard**의 핵심이며, 다음 컴포넌트들이 공유한다:
- DatabasePolicyEngine (APPROVAL 다운그레이드 판단)
- KillSwitchService (복구 대기 시간 분기)
- SessionRenewalService (거부 윈도우 활성 분기)
- OwnerLifecycleService (변경/해제 인증 분기)
- WithdrawService (회수 가능 여부 판단)
- CLI 출력 (상태 표시)

---

## 4. 정책 엔진 통합: APPROVAL 다운그레이드

### 4.1 삽입 지점

현재 evaluate() 11단계 알고리즘에서 v0.8 다운그레이드가 삽입되는 지점:

```
Step 1:  정책 로드 (에이전트별 + 글로벌)
Step 2:  TransactionType 결정
Step 3:  ALLOWED_TOKENS 검사
Step 4:  CONTRACT_WHITELIST 검사
Step 5:  METHOD_WHITELIST 검사
Step 6:  APPROVED_SPENDERS 검사
Step 7:  APPROVE_AMOUNT_LIMIT 검사
Step 8:  WHITELIST + TIME_RESTRICTION + RATE_LIMIT
Step 9:  금액 기반 티어 결정 (SPENDING_LIMIT + USD)
                                                     <-- v0.8 삽입
   Step 9.5: APPROVAL 다운그레이드 (Owner 없으면 DELAY로)
                                                     <-- v0.8 삽입 끝
Step 10: APPROVE_TIER_OVERRIDE (APPROVE만)
Step 11: 최종 PolicyDecision 반환
```

### 4.2 구현 패턴

```typescript
// evaluate() 내부, Step 9 직후

// Step 9: 금액 기반 티어 결정
const tierResult = this.evaluateSpendingLimit(effectiveRules, request)

// [v0.8] Step 9.5: APPROVAL 다운그레이드 (Owner 없는 에이전트)
if (tierResult.allowed && tierResult.tier === 'APPROVAL') {
  const agent = await this.getAgent(agentId)
  if (!agent.ownerAddress) {
    return {
      ...tierResult,
      tier: 'DELAY',
      downgraded: true,               // 알림에서 Owner 등록 안내 포함 여부 결정
      originalTier: 'APPROVAL',       // 원래 티어 기록 (감사 로그용)
      delaySeconds: tierResult.delaySeconds ?? this.getDefaultDelaySeconds(effectiveRules),
    }
  }
}

// Step 10: APPROVE_TIER_OVERRIDE (APPROVE만)
```

### 4.3 PolicyDecision 타입 확장

```typescript
interface PolicyDecision {
  allowed: boolean
  tier: 'INSTANT' | 'NOTIFY' | 'DELAY' | 'APPROVAL'
  reason?: string
  policyId?: string
  delaySeconds?: number
  approvalTimeoutSeconds?: number
  // [v0.8 추가]
  downgraded?: boolean          // APPROVAL -> DELAY 다운그레이드 여부
  originalTier?: string         // 다운그레이드 전 원래 티어
}
```

### 4.4 Step 10 (APPROVE_TIER_OVERRIDE)과의 상호작용

APPROVE_TIER_OVERRIDE는 APPROVE 타입 트랜잭션 전용이다. 시나리오 분석:

| 트랜잭션 타입 | Step 9 결과 | Owner 유무 | Step 9.5 | Step 10 | 최종 |
|:----------:|:---------:|:--------:|:-------:|:------:|:----:|
| TRANSFER | APPROVAL | 없음 | DELAY (다운그레이드) | 스킵 (txType !== APPROVE) | DELAY |
| TRANSFER | APPROVAL | 있음 | 통과 | 스킵 | APPROVAL |
| APPROVE | APPROVAL | 없음 | DELAY (다운그레이드) | **실행되나, 이미 DELAY이므로 영향 없음** | DELAY |
| APPROVE | APPROVAL | 있음 | 통과 | TIER_OVERRIDE 적용 | OVERRIDE 결과 |

**핵심:** Step 9.5의 다운그레이드는 Step 10보다 먼저 실행되므로, Owner 없는 에이전트에서는 APPROVE_TIER_OVERRIDE가 사실상 적용되지 않는다. 이는 의도된 동작이다 -- Owner 없이는 APPROVAL 티어 자체가 비활성이므로.

### 4.5 evaluate()에 agent 조회 추가 영향

현재 evaluate()의 시그니처는 `evaluate(agentId: string, request: TxRequest)`이다. agent 객체를 가져오려면:

**방안 1: evaluate() 시그니처 변경** -- 호출자가 agent 객체를 전달
```typescript
evaluate(agentId: string, request: TxRequest, context?: { agent?: Agent }): Promise<PolicyDecision>
```

**방안 2: evaluate() 내부에서 DB 조회** -- agentId로 agents 테이블 조회
```typescript
const agent = await this.db.select().from(agents).where(eq(agents.id, agentId)).get()
```

**추천: 방안 1.** 이유:
- 파이프라인 Stage 3 호출 시점에 agent 객체는 이미 로드되어 있음 (Stage 1에서 사용)
- DB 중복 조회 방지
- IPolicyEngine 인터페이스에 optional context 추가는 하위 호환 유지

```typescript
// IPolicyEngine 인터페이스 확장 (하위 호환)
interface IPolicyEngine {
  evaluate(
    agentId: string,
    request: TxRequest,
    context?: PolicyContext,      // [v0.8 추가] optional
  ): Promise<PolicyDecision>
}

interface PolicyContext {
  agent?: { ownerAddress: string | null; ownerVerified: boolean }
}
```

---

## 5. Owner 생명주기 상태 머신

### 5.1 상태 다이어그램

```
                 ┌─────────────────────────────────┐
                 │         (없음) NONE              │
                 │  owner_address = NULL            │
                 │  owner_verified = 0              │
                 │                                  │
                 │  보안: Base (DELAY까지)           │
                 │  변경 인증: N/A                   │
                 └──────────────┬──────────────────┘
                                │
                   agent create --owner <addr>
                   또는 set-owner <addr>
                   인증: masterAuth
                                │
                                v
                 ┌─────────────────────────────────┐
                 │        (유예) GRACE              │
                 │  owner_address = <addr>          │
                 │  owner_verified = 0              │
                 │                                  │
                 │  보안: Enhanced (APPROVAL 해금)   │
                 │  변경/해제 인증: masterAuth만     │
                 └──────────┬───────────┬──────────┘
                            │           │
              ownerAuth 첫 사용         │
              (approve 또는 recover)    │
                            │    remove-owner (masterAuth)
                            v           v
                 ┌──────────────────┐  (없음) NONE 으로 복귀
                 │   (잠금) LOCKED   │
                 │  owner_address = <addr>
                 │  owner_verified = 1
                 │                  │
                 │  보안: Enhanced   │
                 │  변경: ownerAuth + masterAuth
                 │  해제: 불가       │
                 └──────────────────┘
```

### 5.2 상태 전이 조건

| 전이 | 조건 | 인증 | 부작용 |
|------|------|------|--------|
| NONE -> GRACE | set-owner 또는 agent create --owner | masterAuth | 없음 |
| GRACE -> NONE | remove-owner | masterAuth | 없음 |
| GRACE -> LOCKED | ownerAuth 첫 사용 (approve 또는 recover) | ownerAuth | owner_verified = 1 (자동) |
| GRACE -> GRACE (주소변경) | set-owner <new-addr> | masterAuth | owner_address 갱신 |
| LOCKED -> LOCKED (주소변경) | set-owner <new-addr> | ownerAuth(기존) + masterAuth | owner_address 갱신 |
| LOCKED -> NONE | **불가** | - | 보안 다운그레이드 방지 |

### 5.3 OwnerLifecycleService

```typescript
// packages/daemon/src/domain/owner-lifecycle.ts

class OwnerLifecycleService {
  constructor(
    private db: DrizzleInstance,
    private auditLog: AuditLogService,
  ) {}

  /**
   * Owner 주소 등록/변경
   * 유예 구간: masterAuth만
   * 잠금 구간: ownerAuth(기존 주소) + masterAuth
   */
  async setOwner(agentId: string, newAddress: string, auth: AuthContext): Promise<void> {
    const agent = await this.getAgent(agentId)
    const state = resolveOwnerState(agent)

    switch (state) {
      case 'NONE':
      case 'GRACE':
        // masterAuth만 필요 (이미 미들웨어에서 검증됨)
        await this.updateOwnerAddress(agentId, newAddress)
        break
      case 'LOCKED':
        // ownerAuth(기존 주소) 필수 -- auth.ownerVerified 확인
        if (!auth.ownerVerified) {
          throw new ForbiddenError('OWNER_AUTH_REQUIRED', '잠금 구간에서는 기존 Owner 서명이 필요합니다')
        }
        await this.updateOwnerAddress(agentId, newAddress)
        // 주소 변경 시 owner_verified를 0으로 리셋하지 않음
        // (기존 Owner가 서명으로 승인했으므로 새 주소도 신뢰)
        break
    }

    await this.auditLog.record('OWNER_ADDRESS_CHANGED', agentId, { newAddress, previousState: state })
  }

  /**
   * Owner 해제 (유예 구간에서만 가능)
   */
  async removeOwner(agentId: string): Promise<void> {
    const agent = await this.getAgent(agentId)
    const state = resolveOwnerState(agent)

    if (state === 'LOCKED') {
      throw new ForbiddenError('OWNER_LOCKED', '잠금 구간에서는 Owner를 해제할 수 없습니다')
    }
    if (state === 'NONE') {
      throw new NotFoundError('NO_OWNER', '등록된 Owner가 없습니다')
    }

    await this.clearOwnerAddress(agentId)
    await this.auditLog.record('OWNER_REMOVED', agentId)
  }

  /**
   * ownerAuth 사용 시 자동 호출 -- owner_verified를 1로 전환
   */
  async markOwnerVerified(agentId: string): Promise<void> {
    await this.db.update(agents)
      .set({ ownerVerified: true, updatedAt: new Date() })
      .where(eq(agents.id, agentId))
  }
}
```

### 5.4 ownerAuth 미들웨어와의 통합

ownerAuth 미들웨어(현재 approve, recover 2곳 적용)에서 서명 검증 성공 시 자동으로 `markOwnerVerified()`를 호출한다:

```typescript
// ownerAuth 미들웨어 내부 (34-owner-wallet-connection.md 섹션 5)
async function ownerAuth(c: Context, next: Next): Promise<void> {
  // ... 기존 서명 검증 로직 ...

  // [v0.8 추가] ownerAuth 첫 사용 시 자동 잠금 전환
  const agent = c.get('agent')
  if (agent && !agent.ownerVerified) {
    await ownerLifecycleService.markOwnerVerified(agent.id)
  }

  await next()
}
```

이 통합은 **GRACE -> LOCKED 전이를 자동으로** 처리한다. 별도의 명시적 전이 API는 필요하지 않다.

---

## 6. Kill Switch 복구 정책 분기

### 6.1 현재 구조 (v0.7)

```
POST /v1/admin/recover
  인증: ownerAuth + masterAuth
  동작: 즉시 복구 (대기 없음)
```

### 6.2 v0.8 변경

```
POST /v1/admin/recover
  ┌─ Owner 있음: ownerAuth + masterAuth + 30분 대기
  └─ Owner 없음: masterAuth + 24시간 강제 대기
```

### 6.3 구현 패턴

```typescript
// packages/daemon/src/domain/kill-switch.ts

async recover(agentId: string | null, auth: AuthContext): Promise<RecoverResult> {
  // Kill Switch는 시스템 전역이므로 특정 에이전트가 아닌 전체 에이전트의 Owner 상태를 확인
  // "Owner 있음"의 정의: 최소 1개 에이전트에 owner_address가 설정되어 있고 ownerAuth가 제공됨

  const hasOwnerAuth = auth.ownerVerified  // ownerAuth 서명이 요청에 포함되었는가

  if (hasOwnerAuth) {
    // Owner 서명 + masterAuth: 30분 대기
    await this.enforceRecoveryWait(30 * 60)  // 30분
  } else {
    // masterAuth만: 24시간 대기
    await this.enforceRecoveryWait(24 * 60 * 60)  // 24시간
  }

  // ... 기존 복구 로직 ...
}
```

### 6.4 enforceRecoveryWait 구현

```typescript
private async enforceRecoveryWait(waitSeconds: number): Promise<void> {
  const recoverRequestedAt = getSystemState(this.db, 'recovery_requested_at')

  if (!recoverRequestedAt) {
    // 첫 복구 요청: 타이머 시작
    setSystemState(this.db, 'recovery_requested_at', Date.now())
    setSystemState(this.db, 'recovery_wait_seconds', waitSeconds)
    throw new ConflictError('RECOVERY_WAITING', `복구 대기 중. ${waitSeconds}초 후 재시도하세요.`)
  }

  const elapsed = (Date.now() - recoverRequestedAt) / 1000
  if (elapsed < waitSeconds) {
    const remaining = Math.ceil(waitSeconds - elapsed)
    throw new ConflictError('RECOVERY_WAITING', `복구 대기 중. ${remaining}초 남았습니다.`)
  }

  // 대기 완료: 복구 진행
  clearSystemState(this.db, 'recovery_requested_at')
  clearSystemState(this.db, 'recovery_wait_seconds')
}
```

### 6.5 killSwitchGuard 허용 목록 변경

withdraw 엔드포인트의 Kill Switch 상태 접근 정책은 구현 시 결정해야 한다 (v0.8 objectives 섹션 5.5 참조). 선택지:

| 방안 | 장점 | 단점 |
|------|------|------|
| A: killSwitchGuard 허용 목록에 withdraw 추가 | API 경유로 일관성 | 비상 정지 취지에 반할 수 있음 |
| B: 데몬 내부에서 직접 실행 | Kill Switch 원칙 유지 | CLI 전용, API 미경유 |

**추천: 방안 A** -- withdraw는 owner_address로만 전송되므로 공격자 이득 없음 (v0.8 objectives 섹션 5.2 분석). killSwitchGuard 허용 목록을 4개 -> 5개로 확장:

```typescript
const KILL_SWITCH_ALLOWED_PATHS = [
  { method: 'GET',  path: '/v1/health' },
  { method: 'GET',  path: '/v1/admin/status' },
  { method: 'POST', path: '/v1/admin/recover' },
  { method: 'GET',  path: '/v1/admin/kill-switch' },
  { method: 'POST', path: '/v1/owner/agents/:agentId/withdraw' },  // [v0.8]
]
```

---

## 7. 세션 갱신 Owner 분기

### 7.1 현재 구조

세션 갱신 프로토콜(53-session-renewal-protocol.md)의 낙관적 갱신 모델:
1. 세션 갱신 요청 -> 즉시 새 토큰 발급
2. Owner에게 알림 (거부 윈도우 시작)
3. Owner가 거부 윈도우 내에 거부하면 세션 폐기

### 7.2 v0.8 변경

```typescript
// packages/daemon/src/domain/session-renewal.ts

async renewSession(sessionId: string): Promise<RenewalResult> {
  const session = await this.getSession(sessionId)
  const agent = await this.getAgent(session.agentId)
  const ownerState = resolveOwnerState(agent)

  // 기존 갱신 로직 (maxRenewals, 총 수명 30일 등 체크)
  const newToken = await this.issueRenewedToken(session)

  if (ownerState === 'NONE') {
    // Owner 없음: 즉시 확정, 거부 윈도우 없음
    return { token: newToken, confirmed: true, rejectWindowSeconds: 0 }
  } else {
    // Owner 있음: 알림 + 거부 윈도우
    await this.notifyRenewal(agent, session, newToken)
    return {
      token: newToken,
      confirmed: true,  // 낙관적 확정
      rejectWindowSeconds: session.renewalRejectWindow ?? 3600,
    }
  }
}
```

**변경 규모가 작은 이유:** 갱신 로직 자체는 동일하고, 알림 발송 여부만 분기한다. 안전 장치(maxRenewals, 총 수명 30일)는 Owner 유무와 무관하게 동일 적용.

---

## 8. 자금 회수 (Withdraw) 아키텍처

### 8.1 컴포넌트 구성

```
CLI                      REST API                    Domain
┌──────────────────┐    ┌──────────────────────────┐    ┌─────────────────┐
│ waiaas withdraw  │───>│ POST /v1/owner/agents/   │───>│ WithdrawService │
│ --agent <name>   │    │  :agentId/withdraw       │    │                 │
│ --scope all      │    │ 인증: masterAuth          │    │ 1. agent 조회    │
└──────────────────┘    └──────────────────────────┘    │ 2. Owner 확인    │
                                                        │ 3. sweepAll 호출 │
                                                        │ 4. 결과 집계     │
                                                        └────────┬────────┘
                                                                 │
                                                    ┌────────────v────────────┐
                                                    │  IChainAdapter.sweepAll │
                                                    │                         │
                                                    │  1. getAssets(address)  │
                                                    │  2. 토큰별 transfer +   │
                                                    │     closeAccount (배치) │
                                                    │  3. SOL 전량 전송       │
                                                    └─────────────────────────┘
```

### 8.2 sweepAll 구현 구조 (SolanaAdapter)

```typescript
// packages/adapter-solana/src/solana-adapter.ts

async sweepAll(from: string, to: string): Promise<SweepResult> {
  // 1. 전체 자산 조회 (v0.6 getAssets 재사용)
  const assets = await this.getAssets(from)
  const tokenAssets = assets.filter(a => a.type === 'token')

  const transactions: SweepResult['transactions'] = []
  const failed: SweepResult['failed'] = []
  let rentRecovered = BigInt(0)

  // 2. 토큰 배치 전송 (v0.6 buildBatch 활용)
  if (tokenAssets.length > 0) {
    // Solana tx 크기 제한: 배치당 min 2 / max 20 instruction
    const batches = this.chunkTokens(tokenAssets, 20)

    for (const batch of batches) {
      try {
        // 각 토큰: transfer + closeAccount (rent 회수)
        const batchResult = await this.executeSweepBatch(from, to, batch)
        transactions.push(...batchResult.transactions)
        rentRecovered += batchResult.rentRecovered
      } catch (error) {
        // 배치 실패 시 개별 토큰 fallback
        for (const token of batch) {
          try {
            const singleResult = await this.executeSingleSweep(from, to, token)
            transactions.push(singleResult)
          } catch (tokenError) {
            failed.push({ mint: token.mint, error: tokenError.message })
          }
        }
      }
    }
  }

  // 3. 네이티브 SOL 전량 전송 (마지막 -- fee 정확 계산)
  const balance = await this.getBalance(from)
  if (balance > 0n) {
    const feeEstimate = await this.estimateFee({ type: 'TRANSFER', to, amount: '0' })
    const transferAmount = balance - feeEstimate.estimatedFee
    if (transferAmount > 0n) {
      const tx = await this.buildTransaction({ type: 'TRANSFER', to, amount: transferAmount.toString() })
      const signed = await this.signTransaction(tx)
      const txHash = await this.submitTransaction(signed)
      await this.waitForConfirmation(txHash)
      transactions.push({ txHash, assets: [{ mint: 'native', amount: transferAmount.toString() }] })
    }
  }

  return {
    transactions,
    nativeRecovered: /* SOL 전송 금액 */,
    tokensRecovered: tokenAssets.map(t => ({ ...t })),
    rentRecovered: rentRecovered.toString(),
    failed,
  }
}
```

### 8.3 정책 엔진 우회

withdraw는 **정책 엔진을 우회**한다. 이유:
- 수신 주소가 `agents.owner_address`로 고정 (변경 불가)
- masterAuth 인증 완료 상태
- 공격자가 masterAuth를 탈취해도 자금은 Owner 주소로만 이동 (공격자 이득 없음)

```typescript
// WithdrawService 내부
async withdraw(agentId: string, scope: 'native' | 'all'): Promise<WithdrawResult> {
  const agent = await this.getAgent(agentId)

  if (!agent.ownerAddress) {
    throw new NotFoundError('NO_OWNER', 'Owner가 등록되지 않은 에이전트는 자금 회수 불가')
  }

  // 정책 엔진 우회 -- 직접 sweepAll 호출
  const adapter = this.adapterRegistry.get(agent.chain)
  const result = await adapter.sweepAll(agent.publicKey, agent.ownerAddress)

  await this.auditLog.record('FUND_WITHDRAWN', agentId, {
    to: agent.ownerAddress,
    nativeRecovered: result.nativeRecovered,
    tokensRecovered: result.tokensRecovered.length,
    failed: result.failed.length,
  })

  return this.mapToApiResponse(result)
}
```

---

## 9. 알림 시스템 변경

### 9.1 다운그레이드 알림 템플릿

NotificationService에 새 알림 타입 추가:

```typescript
// packages/daemon/src/domain/notification-templates.ts

const DOWNGRADE_ALERT: NotificationTemplate = {
  eventType: 'TRANSACTION_DOWNGRADED',  // 신규 이벤트 타입
  severity: 'info',
  template: {
    title: '대액 거래 대기 중 (APPROVAL -> DELAY 다운그레이드)',
    body: `에이전트: {{agentName}}
금액: {{amount}} {{symbol}} ({{amountUsd}}) -> {{toAddress}}
실행 예정: {{delayMinutes}}분 후 ({{executeAt}})
[취소하기]

Owner 지갑을 등록하면 대액 거래에
승인 정책을 적용할 수 있습니다.
waiaas agent set-owner {{agentName}} <address>`,
  },
}
```

### 9.2 이벤트 타입 추가

기존 13개 이벤트(35-notification-architecture.md)에 1개 추가:

| 이벤트 | 설명 | Owner 필요 |
|--------|------|:----------:|
| TRANSACTION_DOWNGRADED | APPROVAL -> DELAY 다운그레이드 발생 | 아니오 |

---

## 10. REST API 변경

### 10.1 신규 엔드포인트

| 메서드 | 경로 | 인증 | 설명 |
|--------|------|------|------|
| POST | `/v1/owner/agents/:agentId/withdraw` | masterAuth | 자금 전량 회수 |

### 10.2 기존 엔드포인트 변경

| 메서드 | 경로 | 변경 | 설명 |
|--------|------|------|------|
| POST | `/v1/agents` | `owner` 필드 선택적 | 에이전트 생성 시 owner 선택 |
| PATCH | `/v1/agents/:id` | owner 주소 변경 로직 추가 | set-owner 기능 |
| POST | `/v1/admin/recover` | 대기 시간 분기 | Owner 유무별 30min vs 24h |

### 10.3 CLI 명령어 변경

| 명령어 | 변경 유형 | 설명 |
|--------|:--------:|------|
| `agent create --owner` | 수정 | 필수 -> 선택 |
| `agent set-owner <agent> <addr>` | **신규** | Owner 사후 등록 |
| `agent remove-owner <agent>` | **신규** | 유예 구간에서만 동작 |
| `agent info <agent>` | 수정 | Owner 상태 표시 + 등록 안내 |
| `--quickstart` | 수정 | `--owner` 선택적 |

---

## 11. 컴포넌트 의존 관계 및 빌드 순서

### 11.1 의존 그래프

```
┌─────────────────────────────────────────────────────────┐
│  Layer 0: 데이터 모델                                     │
│                                                          │
│  agents.owner_address nullable  ←─ 모든 변경의 기반       │
│  agents.owner_verified 추가                               │
│  PolicyDecision.downgraded 추가                           │
│  OwnerState 타입 정의                                     │
│  SweepResult 타입 정의                                    │
│                                                          │
│  패키지: @waiaas/core                                     │
└────────────────────────┬────────────────────────────────┘
                         │
         ┌───────────────┼───────────────┐
         │               │               │
         v               v               v
┌────────────────┐ ┌───────────┐ ┌────────────────┐
│ Layer 1A:      │ │ Layer 1B: │ │ Layer 1C:      │
│ Owner 생명주기  │ │ sweepAll  │ │ evaluate()     │
│                │ │           │ │ 다운그레이드    │
│ OwnerLifecycle │ │ Solana    │ │                │
│ Service        │ │ Adapter   │ │ DatabasePolicy │
│                │ │           │ │ Engine         │
│ @waiaas/daemon │ │ @waiaas/  │ │ @waiaas/daemon │
│                │ │ adapter-  │ │                │
│                │ │ solana    │ │                │
└───────┬────────┘ └─────┬─────┘ └───────┬────────┘
        │                │               │
        │         ┌──────┘               │
        v         v                      v
┌────────────────────────┐  ┌───────────────────────┐
│ Layer 2A:              │  │ Layer 2B:             │
│ WithdrawService        │  │ KillSwitchService     │
│ (OwnerLifecycle +      │  │ SessionRenewalService │
│  sweepAll 조합)        │  │ (Owner 유무 분기)     │
│                        │  │                       │
│ @waiaas/daemon         │  │ @waiaas/daemon        │
└───────────┬────────────┘  └───────────┬───────────┘
            │                           │
            v                           v
┌─────────────────────────────────────────────────────┐
│ Layer 3: 외부 인터페이스                               │
│                                                      │
│  REST API (withdraw 엔드포인트)                       │
│  CLI (set-owner, remove-owner, create --owner 선택)  │
│  NotificationService (다운그레이드 알림 템플릿)        │
│                                                      │
│  @waiaas/daemon, @waiaas/cli                         │
└─────────────────────────────────────────────────────┘
```

### 11.2 추천 빌드 순서

의존 관계를 반영한 빌드 순서. 각 레이어는 독립적으로 테스트 가능한 단위.

**Phase A: 데이터 모델 + 핵심 유틸리티 (Layer 0)**
1. `@waiaas/core` 스키마 변경: agents.owner_address nullable, owner_verified 추가
2. `@waiaas/core` 타입 추가: OwnerState, PolicyDecision.downgraded, SweepResult
3. `@waiaas/core` IChainAdapter 확장: sweepAll 시그니처 추가
4. `@waiaas/daemon` OwnerPresenceGuard: resolveOwnerState() 구현
5. DB 마이그레이션 생성 및 테스트

**Phase B: 핵심 도메인 로직 (Layer 1A, 1B, 1C -- 병렬 가능)**
6. OwnerLifecycleService: 등록/변경/해제 로직 + ownerAuth 자동 잠금
7. SolanaAdapter.sweepAll: getAssets -> 배치 전송 -> SOL 전량 전송
8. DatabasePolicyEngine: evaluate() Step 9.5 다운그레이드 삽입

**Phase C: 통합 서비스 (Layer 2A, 2B)**
9. WithdrawService: sweepAll 오케스트레이션 + 정책 엔진 우회
10. KillSwitchService: 복구 대기 시간 Owner 분기
11. SessionRenewalService: 거부 윈도우 Owner 분기

**Phase D: 외부 인터페이스 (Layer 3)**
12. REST API: withdraw 엔드포인트 + agent create owner 선택적
13. CLI: set-owner / remove-owner / create --owner 선택 / info 출력
14. NotificationService: 다운그레이드 알림 템플릿 + Owner 등록 안내

### 11.3 병렬 작업 가능 영역

| 작업 그룹 | 내용 | 선행 조건 |
|----------|------|----------|
| Phase A | 스키마 + 타입 + 마이그레이션 | 없음 |
| Phase B-1 | OwnerLifecycleService | Phase A |
| Phase B-2 | sweepAll (SolanaAdapter) | Phase A (SweepResult 타입) |
| Phase B-3 | evaluate() 다운그레이드 | Phase A (PolicyDecision 확장) |
| Phase C (WithdrawService) | sweepAll + OwnerLifecycle 조합 | Phase B-1 + B-2 |
| Phase C (KS/Session 분기) | Owner 유무 분기 | Phase A |
| Phase D | API + CLI + 알림 | Phase B + C |

---

## 12. 크로스커팅 관심사

### 12.1 감사 로그 (Audit Log)

v0.8에서 추가되는 감사 이벤트:

| 이벤트 타입 | 심각도 | 기록 시점 |
|------------|:------:|----------|
| OWNER_REGISTERED | info | set-owner 실행 시 |
| OWNER_ADDRESS_CHANGED | warning | Owner 주소 변경 시 |
| OWNER_REMOVED | warning | remove-owner 실행 시 |
| OWNER_VERIFIED | info | ownerAuth 첫 사용 시 (GRACE -> LOCKED) |
| TRANSACTION_DOWNGRADED | info | APPROVAL -> DELAY 다운그레이드 시 |
| FUND_WITHDRAWN | critical | withdraw 실행 시 |
| RECOVERY_WAIT_STARTED | warning | Kill Switch 복구 대기 시작 시 |

### 12.2 에러 코드

v0.8에서 추가되는 에러 코드:

| 코드 | HTTP | 설명 |
|------|:----:|------|
| OWNER_AUTH_REQUIRED | 403 | 잠금 구간에서 ownerAuth 없이 Owner 변경 시도 |
| OWNER_LOCKED | 403 | 잠금 구간에서 Owner 해제 시도 |
| NO_OWNER | 404 | Owner 미등록 에이전트에서 withdraw 시도 |
| RECOVERY_WAITING | 409 | Kill Switch 복구 대기 중 |
| PARTIAL_SWEEP | 207 | 일부 토큰 회수 실패 |

### 12.3 Config 변경

config.toml에 추가 설정은 없다. Owner 유무는 런타임 데이터(agents 테이블)로 결정되며, 정적 설정이 아니다. Kill Switch 복구 대기 시간(30min / 24h)은 하드코딩한다 -- 설정 가능하게 하면 공격자가 시간을 단축할 수 있다.

---

## 13. v1.0 구현 로드맵과의 정합

v0.8 설계 변경은 v1.0에서 정의한 구현 마일스톤에 다음과 같이 영향을 미친다:

| 구현 마일스톤 | v0.8 영향 | 추가 작업 |
|-------------|----------|----------|
| v1.1 (코어 인프라) | agents 스키마 변경 반영 | 마이그레이션에 owner_address nullable + owner_verified 포함 |
| v1.2 (인증 + 정책) | evaluate() 다운그레이드, OwnerLifecycleService | APPROVAL 다운그레이드 + Owner 생명주기 구현 |
| v1.3 (SDK + MCP + 알림) | 다운그레이드 알림 템플릿 | TRANSACTION_DOWNGRADED 이벤트 + Owner 등록 안내 |
| v1.4 (토큰 + 컨트랙트) | sweepAll 구현, WithdrawService | SolanaAdapter.sweepAll + withdraw API |
| v1.6 (Desktop + Telegram) | 다운그레이드 알림 UI | 인라인 키보드에 등록 안내 |

v0.8 변경사항은 기존 v1.1-v1.6에 자연스럽게 통합된다. 별도 구현 마일스톤 삽입은 불필요하다.

---

## 14. 리스크 및 주의사항

### 14.1 SQLite 마이그레이션 리스크

NOT NULL 제거는 테이블 재생성이 필요하다. 프로덕션 데이터가 있는 경우 마이그레이션 실패 시 데이터 손실 위험이 있다. Drizzle-kit의 자동 생성 마이그레이션을 반드시 수동 검토해야 한다.

**완화:** v1.1에서 첫 스키마 생성 시 이미 nullable로 시작하므로, 마이그레이션 문제는 v0.8 이전에 배포된 인스턴스에서만 발생한다. v1.0이 아직 코드 구현 전이므로 실질적 리스크는 낮다.

### 14.2 evaluate() 성능 영향

Step 9.5에서 agent 조회가 추가된다. 방안 1(context 전달)을 채택하면 추가 DB 조회 없이 파이프라인에서 이미 로드된 agent 객체를 재사용하므로 성능 영향 없음.

### 14.3 GRACE -> LOCKED 자동 전이 타이밍

ownerAuth 미들웨어에서 `markOwnerVerified()`를 호출하는 시점이 서명 검증 성공 직후이므로, 동일 요청 내에서 owner_verified가 0 -> 1로 전환된다. 동시 요청이 있을 경우 race condition이 가능하나, 결과는 항상 동일(1로 설정)하므로 문제없다 (idempotent).

### 14.4 sweepAll 원자성

토큰 배치 전송이 실패하면 개별 fallback으로 시도한다. 이 과정에서 일부 토큰만 회수되는 부분 회수(partial sweep) 상태가 가능하다. HTTP 207 응답으로 failed 배열을 반환하여 호출자가 재시도할 수 있도록 한다.

---

## 15. 신뢰도 평가

| 영역 | 신뢰도 | 근거 |
|------|:------:|------|
| 데이터 모델 변경 | HIGH | v0.8 objectives에서 DDL 확정, v0.7 스키마와 정합 확인 |
| 정책 엔진 통합 | HIGH | evaluate() 11단계 코드 직접 분석, 삽입 지점 명확 |
| Owner 생명주기 | HIGH | v0.8 objectives에서 유예/잠금 규칙 완전 정의 |
| sweepAll 구현 | MEDIUM | getAssets + buildBatch 활용은 확인, 배치 크기 제한/fallback은 구현 시 검증 필요 |
| Kill Switch 분기 | HIGH | v0.7에서 recover 경로 확정, v0.8에서 대기 시간 분기만 추가 |
| 세션 갱신 분기 | HIGH | 변경 범위가 작고 단순 조건 분기 |

---

*작성: 2026-02-08*
*기반: v0.8 objectives + 14개 설계 문서 (CORE-02, CORE-04, CORE-05, SESS-PROTO, CHAIN-SOL, LOCK-MECH, OWNR-CONN, NOTI-ARCH, KILL-AUTO-EVM, API-SPEC, TGBOT-DOCKER, 57, 60, 61)*
