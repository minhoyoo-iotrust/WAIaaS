# Domain Pitfalls: Price Oracle + USD 정책 평가 + Action Provider + API 키 관리

**Domain:** Self-hosted AI agent wallet daemon -- price oracle integration, USD-based spending limits, ESM plugin architecture, encrypted API key management
**Project:** WAIaaS v1.5
**Researched:** 2026-02-15
**Overall Confidence:** HIGH (기존 코드베이스 직접 분석, Pyth/CoinGecko 공식 문서 검증, Node.js ESM/security 리서치 교차 확인)

---

## Overview

이 문서는 **기존 네이티브 금액 기반 SPENDING_LIMIT 정책 엔진에 USD 환산 레이어를 추가하고, ESM 동적 임포트 기반 Action Provider 플러그인 프레임워크를 도입하며, 외부 API 키를 암호화 저장할 때** 발생하는 함정을 다룬다.

핵심 위험 영역:
1. **보안 경계 변화**: 이전까지 자체 완결적이던 데몬에 외부 HTTP 의존성(Pyth/CoinGecko)이 추가됨
2. **정책 평가 의미론 변경**: `instant_max`(네이티브 단위)와 `instant_max_usd`(USD)가 공존하면서 평가 우선순위/합산 규칙이 복잡해짐
3. **임의 코드 실행**: ESM dynamic import로 ~/.waiaas/actions/ 디렉토리의 코드가 데몬 프로세스 권한으로 실행됨
4. **키 관리 이중화**: 기존 SettingsService의 HKDF 기반 암호화 vs 새 api_keys 테이블의 secretbox 암호화 -- 두 패턴이 공존할 위험

각 함정은 **Critical(보안 구멍 또는 자금 손실)**, **High(정책 우회 또는 주요 재작업)**, **Moderate(기술 부채 또는 UX 혼란)** 3단계로 분류한다.

---

## Critical Pitfalls

보안 구멍, 정책 우회, 또는 자금 손실을 야기하는 실수.

---

### C-01: 가격 미등록 토큰을 $0으로 처리하여 USD 한도 우회

**Severity:** CRITICAL
**Confidence:** HIGH (설계 문서 61 직접 분석 + DeFi 오라클 공격 사례 연구)
**Phase:** USD 정책 평가 구현 단계

**What goes wrong:**
Pyth와 CoinGecko 모두에 등록되지 않은 토큰(예: 새로 발행된 밈코인, 커스텀 SPL 토큰)의 가격을 가져오지 못할 때, `resolveEffectiveAmountUsd()`가 USD 금액을 `0`으로 반환하면 모든 USD 기반 한도(`instant_max_usd`, `notify_max_usd`, `delay_max_usd`)를 통과한다.

**Why it happens:**
- 오라클이 가격을 반환하지 못하는 상황과 "가격이 0인 토큰"을 구분하지 않음
- "가치를 모른다 = 가치가 없다"로 잘못 치환하는 로직 실수
- getPrices() 배치 호출에서 일부 토큰만 실패했을 때 성공한 토큰의 결과만 사용하고 실패한 토큰을 0으로 채우는 패턴

**Consequences:**
- 공격자가 USD 한도가 높게 설정된 지갑에서, 실제로는 고가치인 미등록 토큰을 $0 평가로 INSTANT 티어로 즉시 전송할 수 있음
- USD 기반 SPENDING_LIMIT의 보안 의미가 완전히 무력화됨

**Prevention:**
설계 문서에서 이미 정의한 `PriceResult.notListed()` discriminated union을 반드시 구현한다. 미등록 토큰은 최소 NOTIFY 티어로 격상하고, `UNLISTED_TOKEN_TRANSFER` 감사 로그를 기록한다. `resolveEffectiveAmountUsd()`의 반환값은 `number | null`이 아닌 `PriceResult` tagged union이어야 한다:

```typescript
type PriceResult =
  | { tag: 'success'; usdAmount: number }
  | { tag: 'oracleDown' }     // 일시 장애 -> 네이티브 fallback
  | { tag: 'notListed' }      // 가격 정보 없음 -> NOTIFY 격상
```

**Detection:**
- 단위 테스트: mock oracle에서 특정 토큰 NOT_LISTED 반환 -> NOTIFY 이상 티어 강제 검증
- 통합 테스트: E2E 시나리오 5-1, 5-2가 이 경로를 검증

---

### C-02: 교차 검증 편차를 무시하고 조작된 가격 채택

**Severity:** CRITICAL
**Confidence:** MEDIUM (DeFi 오라클 조작 공격 사례 기반 추론, 오프체인 환경에서의 실제 공격 벡터는 온체인보다 제한적)
**Phase:** OracleChain 교차 검증 구현 단계

**What goes wrong:**
Pyth와 CoinGecko 두 소스의 가격 편차가 5%를 초과하는데도, 구현 실수로 편차 검사가 건너뛰어지거나 편차 계산 공식의 분모가 잘못되어 STALE 격하가 발동하지 않는다.

**Why it happens:**
- 편차 계산에서 절대값 대신 부호 있는 값 사용: `(pythPrice - cgPrice) / pythPrice`가 음수일 때 -5% < -20%이므로 5% 초과 조건 미충족
- CoinGecko 비활성 상태(키 미설정)에서 교차 검증 스킵 분기를 잘못 작성하여, 키 설정 후에도 스킵되는 버그
- 비동기 fallback 체인에서 CoinGecko 호출 자체가 rate limit으로 실패하면 교차 검증이 건너뛰어짐

**Consequences:**
- Pyth Hermes 서버가 일시적으로 잘못된 가격을 반환했을 때(극히 드물지만 가능), 교차 검증이 이를 걸러내지 못함
- USD 한도 평가가 조작된 가격 기준으로 수행되어 실제 금액보다 낮은/높은 티어로 분류됨

**Prevention:**
```typescript
// 편차 계산은 반드시 절대값 + 평균 기준
const deviation = Math.abs(pythPrice - cgPrice) / ((pythPrice + cgPrice) / 2);
if (deviation > DEVIATION_THRESHOLD) {
  return { ...priceInfo, isStale: true }; // STALE 격하
}
```
- CoinGecko 호출 실패 시 교차 검증은 "미수행(inconclusive)"으로 처리하되, Pyth 가격을 그대로 사용한다(단일 소스 모드)
- 교차 검증 결과를 감사 로그에 항상 기록(성공/실패/스킵 모두)

**Detection:**
- 단위 테스트: 편차 계산 함수를 음수/양수/경계값/0 케이스로 철저히 검증
- E2E 시나리오 12, 13, 13-1이 교차 검증 경로를 검증

---

### C-03: ESM 플러그인의 resolve()가 ContractCallRequest 외 부수 효과 실행

**Severity:** CRITICAL
**Confidence:** HIGH (Node.js ESM dynamic import 보안 연구 직접 확인)
**Phase:** ActionProviderRegistry 구현 단계

**What goes wrong:**
IActionProvider.resolve()가 ContractCallRequest를 반환하기 전에 파일 시스템 접근, 네트워크 요청, 환경변수 읽기, 또는 프로세스 종료 등의 부수 효과를 실행한다. Node.js의 `import()` 로 로드된 ESM 모듈은 데몬 프로세스와 동일한 권한을 갖는다.

**Why it happens:**
- ESM dynamic import는 샌드박싱 없이 Node.js 메인 프로세스 컨텍스트에서 실행됨
- vm2는 2026년 1월에도 샌드박스 탈출 취약점(CVE-2026-22709, CVSS 9.8)이 발견되어 신뢰할 수 없음
- isolated-vm은 V8 Isolate 기반으로 더 안전하지만, ESM import와의 통합이 복잡하고 비동기 I/O 차단이 어려움
- "Owner가 직접 설치하므로 신뢰 경계는 Owner 책임"이라는 설계 결정이 있지만, Owner가 서드파티 플러그인을 검증 없이 설치할 수 있음

**Consequences:**
- 악의적 플러그인이 마스터 패스워드, 개인키 파일, DB 파일에 접근 가능
- 데몬 프로세스를 크래시시키거나 무한 루프로 서비스 거부 공격 가능
- 네트워크를 통해 민감 데이터 유출 가능

**Prevention:**
v1.5에서는 "validate-then-trust" 경계를 명확히 하되, 추가 완화 조치를 적용한다:

1. **resolve() 타임아웃**: `Promise.race()` + 5초 타임아웃으로 무한 루프 차단
2. **반환값 Zod 검증**: resolve()가 ContractCallRequest Zod 스키마를 통과하는지 검증 (이미 설계에 포함)
3. **플러그인 로드 시점 검증**: import() 후 IActionProvider 인터페이스 준수 검증 (metadata/actions/resolve 존재 확인)
4. **파일 권한 검증**: ~/.waiaas/actions/ 디렉토리의 파일이 Owner 소유인지 확인 (다른 사용자가 심볼릭 링크로 주입 방지)
5. **감사 로그**: 플러그인 로드/실행 이벤트를 audit_log에 기록

**Detection:**
- 단위 테스트: 타임아웃 초과 플러그인, 잘못된 반환값 플러그인, 에러 throw 플러그인 시나리오 검증
- E2E 시나리오 14, 15, 16이 로드/검증 경로를 검증

---

### C-04: api_keys 테이블과 SettingsService 암호화 패턴 불일치로 이중 키 관리

**Severity:** CRITICAL
**Confidence:** HIGH (기존 코드베이스 settings-crypto.ts 직접 분석)
**Phase:** ActionProviderApiKeyStore 구현 단계

**What goes wrong:**
설계 문서에서 api_keys 테이블에 "sodium-native secretbox"로 암호화한다고 명시했는데, 기존 SettingsService는 `HKDF(SHA-256) + AES-256-GCM`으로 자격증명을 암호화한다. 두 패턴이 공존하면:
- 마스터 패스워드 변경 시 두 개의 암호화 시스템을 모두 재암호화해야 함
- 키 파생 로직이 두 벌 존재하여 유지보수 부담 증가
- CoinGecko API 키가 SettingsService에 저장되는지 api_keys 테이블에 저장되는지 혼란

**Why it happens:**
- 설계 문서 61에서 "CoinGecko 키는 ActionProviderApiKeyStore와 동일한 DB 암호화 저장 패턴"이라고 명시
- 하지만 CoinGecko는 Action Provider가 아닌 Oracle의 fallback 소스이므로, SettingsService의 oracle 카테고리에 저장하는 것이 더 자연스러움
- Action Provider API 키(예: 0x, Jupiter)와 Oracle API 키(CoinGecko)가 다른 테이블에 저장되는 비일관성

**Consequences:**
- 마스터 패스워드 변경/로테이션 로직이 2곳을 업데이트해야 함
- 테스트가 2배로 필요 (두 암호화 경로 모두 검증)
- Admin UI에서 API 키가 "Settings > Oracle"과 "Settings > API Keys" 두 곳에 분산

**Prevention:**
**기존 SettingsService 암호화 패턴(HKDF + AES-256-GCM)을 재사용한다.** api_keys 전용 테이블 대신, SettingsService에 `oracle.coingecko_api_key`, `action.{provider_name}_api_key` 키를 추가하는 방식을 검토한다. 또는, 별도 테이블을 사용하되 암호화 로직은 settings-crypto.ts의 `encryptSettingValue`/`decryptSettingValue`를 재사용한다.

두 가지 접근법 중 하나를 선택하되, **절대로 두 개의 서로 다른 암호화 시스템을 병행하지 않는다.**

**Detection:**
- 코드 리뷰: 암호화/복호화 함수가 하나의 모듈에서만 정의되었는지 확인
- 마스터 패스워드 변경 테스트: 모든 암호화된 값이 새 패스워드로 접근 가능한지 검증

---

## High Pitfalls

정책 우회, 주요 재작업, 또는 심각한 기능 장애를 야기하는 실수.

---

### H-01: SPENDING_LIMIT 네이티브/USD 공존 시 evaluateSpendingLimit() 평가 순서 오류

**Severity:** HIGH
**Confidence:** HIGH (기존 DatabasePolicyEngine 직접 분석)
**Phase:** USD 정책 필드 확장 + resolveEffectiveAmountUsd() 통합 단계

**What goes wrong:**
기존 `evaluateSpendingLimit()`은 `instant_max`/`notify_max`/`delay_max` (네이티브 단위, BigInt 비교)만 평가한다. 새로운 `instant_max_usd`/`notify_max_usd`/`delay_max_usd` 필드를 추가할 때, 네이티브와 USD 평가 결과를 어떻게 합산할지 명확히 정의하지 않으면:

1. 네이티브 한도는 INSTANT인데 USD 한도는 DELAY -> 최종 티어는?
2. USD 평가 실패(오라클 장애) -> 네이티브만으로 평가, 이 때 USD 전용 한도는 무시?
3. 둘 다 설정된 경우 "더 제한적인 쪽"을 택해야 하는데, 로직이 누락되면 "덜 제한적인 쪽"이 적용

**Why it happens:**
현재 `evaluateSpendingLimit()`은 단일 `amount` 문자열과 단일 `SpendingLimitRules` 객체를 받아 비교한다. USD 환산을 추가하려면:
- Stage 3에서 `resolveEffectiveAmountUsd()`를 먼저 호출
- 결과를 `evaluateSpendingLimit()`에 전달하거나 별도 USD 평가 함수를 호출
- 두 결과를 `max(nativeTier, usdTier)` 또는 설정에 따라 합산

이 흐름이 `DatabasePolicyEngine` 내부에 깔끔하게 통합되지 않으면, `evaluateAndReserve()`의 BEGIN IMMEDIATE 트랜잭션 안에서 비동기 HTTP 호출(oracle)을 시도하는 등의 구조적 문제가 발생한다.

**Consequences:**
- USD 한도를 설정했는데 네이티브 한도만 적용되어 사실상 USD 한도가 무용지물
- 또는 반대로 네이티브 한도가 무시되어 기존 정책과의 하위 호환성 파괴
- `evaluateAndReserve()`에서 비동기 oracle 호출이 SQLite BEGIN IMMEDIATE 안에서 불가능

**Prevention:**
**USD 환산은 Stage 3 진입 전(또는 Stage 3 초반)에 수행하고, DatabasePolicyEngine에는 이미 계산된 USD 금액을 전달한다.** 구체적으로:

1. `stage3Policy()` 시작 시 `resolveEffectiveAmountUsd()` 호출 (비동기 HTTP 가능)
2. 결과를 `TransactionParam`에 `usdAmount?: number` 필드로 추가
3. `evaluateSpendingLimit()`이 네이티브와 USD를 각각 평가 후 `max(nativeTier, usdTier)` 반환
4. `evaluateAndReserve()` 내부에서는 이미 계산된 `usdAmount`를 사용 (HTTP 호출 불필요)

```typescript
// stage3Policy 내부
const priceResult = await resolveEffectiveAmountUsd(ctx.request, priceOracle);
const txParam = buildTransactionParam(req, txType, ctx.wallet.chain);
txParam.usdAmount = priceResult.tag === 'success' ? priceResult.usdAmount : undefined;
txParam.priceResult = priceResult; // notListed/oracleDown 처리용
```

**Detection:**
- 단위 테스트: 네이티브 INSTANT + USD DELAY -> 최종 DELAY 검증
- 단위 테스트: USD 평가 실패 + 네이티브만으로 평가 검증
- E2E 시나리오 1-5가 이 흐름을 검증

---

### H-02: Pyth 피드 ID 매핑 전략 미결 -- 하드코딩 vs 동적 조회

**Severity:** HIGH
**Confidence:** MEDIUM (Pyth 문서 검증했으나 실제 API 동작은 미검증)
**Phase:** PythOracle 구현 단계

**What goes wrong:**
Pyth Hermes API는 `feedId`(bytes32 해시)로 가격을 조회한다. 하지만 WAIaaS의 `TokenRef`는 `address`(토큰 컨트랙트 주소)를 가진다. `address -> feedId` 변환이 필요한데:

1. **하드코딩 맵**: SOL, ETH, USDC, USDT 등 주요 토큰만 매핑. 새 토큰 추가 시 코드 수정 필요.
2. **Pyth `/v2/price_feeds` API**: 전체 피드 목록을 조회하여 심볼 매칭. 하지만 심볼 충돌(같은 이름 다른 토큰) 위험.
3. **CoinGecko platformId 매핑**: CoinGecko는 `contract_addresses` 파라미터를 지원하지만 Pyth는 지원하지 않음.

**Why it happens:**
Pyth의 feedId는 "BTC/USD", "SOL/USD" 같은 가격 쌍의 해시값이며, 토큰 컨트랙트 주소와 직접 매핑되지 않는다. 같은 BTC라도 네이티브 BTC, WBTC(ERC-20), 여러 브릿지 토큰이 다른 주소를 가지지만 동일한 feedId를 사용해야 한다.

**Consequences:**
- 잘못된 feedId 매핑으로 완전히 다른 토큰의 가격이 사용됨
- 심볼 기반 매핑에서 "USDC"가 여러 체인에 다른 주소로 존재, 어떤 피드를 사용할지 모호
- 런타임에 `/v2/price_feeds` 조회 시 불필요한 HTTP 호출 증가

**Prevention:**
**2-tier 전략을 사용한다:**

1. **주요 토큰 하드코딩 맵** (30~50개): SOL, ETH, BTC, USDC, USDT, DAI 등 주요 토큰의 `address -> feedId` 직접 매핑. 체인별로 구분하여 USDC(Solana: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) != USDC(Ethereum: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)이지만 동일 feedId 사용.
2. **Fallback: CoinGecko** (미매핑 토큰): Pyth 맵에 없는 토큰은 CoinGecko의 `contract_addresses` 파라미터로 직접 조회 (platformId + address로 정확한 매핑 가능)

이 전략은 Pyth Zero-config 원칙을 유지하면서, 매핑되지 않는 롱테일 토큰을 CoinGecko로 커버한다.

**Detection:**
- 하드코딩 맵이 실제 Pyth feedId와 일치하는지 검증하는 테스트
- CoinGecko fallback에서 platformId 매핑이 올바른지 검증하는 테스트

---

### H-03: 가격 캐시 TTL 내 가격 급변 시 보안 판단 오류

**Severity:** HIGH
**Confidence:** MEDIUM (크립토 시장 변동성 기반 추론)
**Phase:** InMemoryPriceCache + classifyPriceAge() 구현 단계

**What goes wrong:**
5분 TTL 캐시에 $150으로 캐시된 SOL 가격이, 실제 시장에서 급락하여 $100이 되었지만 캐시 만료 전까지 $150 기준으로 정책 평가가 수행된다.

시나리오: 사용자가 10 SOL 전송 요청
- 캐시 가격 $150 -> USD 평가 $1,500 -> DELAY 티어 (300~2000 USD 구간)
- 실제 가격 $100 -> USD 평가 $1,000 -> NOTIFY 티어 (100~300 USD 구간)

반대 시나리오 (더 위험): SOL이 급등했을 때
- 캐시 가격 $100 -> USD 평가 $1,000 -> NOTIFY 티어
- 실제 가격 $200 -> USD 평가 $2,000 -> DELAY 티어
- 더 낮은 보안 수준(NOTIFY < DELAY)으로 더 큰 가치의 전송이 승인됨

**Why it happens:**
- 5분 TTL은 API 호출 최적화를 위한 합리적 선택이지만, 크립토 시장은 5분 내에 10% 이상 변동 가능
- FRESH 상태의 캐시 가격을 무조건 신뢰하는 로직
- 급변 감지 메커니즘이 없음

**Consequences:**
- 시장 급등 시: 실제 가치보다 낮은 USD로 평가되어 높은 보안 티어가 적용되어야 할 전송이 낮은 티어로 승인
- 시장 급락 시: 실제 가치보다 높은 USD로 평가되어 불필요하게 높은 보안 요구 (UX 불편이지만 안전한 방향)

**Prevention:**
"안전한 방향으로 실패"하는 설계를 유지한다:
1. 가격 급변의 결과는 항상 "실제보다 높거나 낮은 티어"인데, SPENDING_LIMIT은 `max(nativeTier, usdTier)` 규칙으로 두 평가 중 더 제한적인 쪽을 택한다
2. 네이티브 금액 평가는 캐시에 의존하지 않으므로, USD 평가가 과소평가해도 네이티브 한도가 안전망 역할
3. 교차 검증(CoinGecko 활성 시)이 급변 감지의 간접적 수단 -- 두 소스의 갱신 시점 차이로 편차가 5% 초과하면 STALE 격하

**추가 방어 고려사항** (v1.5 범위 외, 향후 개선):
- 이전 캐시 가격 대비 변동률이 높을 때 캐시 무효화
- SSE(Server-Sent Events) 스트리밍으로 실시간 가격 수신

**Detection:**
- 단위 테스트: 캐시된 가격과 실제 가격이 다를 때 `max(nativeTier, usdTier)` 규칙 검증
- E2E 시나리오 3, 4가 금액별 티어 분류를 검증

---

### H-04: evaluateAndReserve() 내부에서 비동기 Oracle HTTP 호출 시도

**Severity:** HIGH
**Confidence:** HIGH (기존 코드베이스 직접 분석 -- better-sqlite3 동기 트랜잭션)
**Phase:** USD 정책 평가 + TOCTOU 방지 통합 단계

**What goes wrong:**
현재 `evaluateAndReserve()`는 `sqlite.transaction(() => { ... }).immediate()` 패턴으로 동기 트랜잭션 내에서 정책 평가를 수행한다. better-sqlite3의 트랜잭션 콜백은 **동기 함수만 지원**한다. 여기에 `await resolveEffectiveAmountUsd()` (HTTP 호출)을 넣으면 트랜잭션이 비동기 컨텍스트에서 깨진다.

**Why it happens:**
- better-sqlite3의 `.transaction(() => {...})` 은 반환 함수가 동기적
- `await`를 트랜잭션 콜백 안에서 사용하면 트랜잭션이 암묵적으로 커밋되고 `IMMEDIATE` 격리가 풀림
- 개발자가 "기존 evaluateAndReserve에 USD 평가를 추가하면 되겠지"라고 생각하고 async 함수를 넣는 실수

**Consequences:**
- TOCTOU 방지가 완전히 무력화됨 -- 두 개의 동시 요청이 동일 reserved_amount로 평가됨
- SQLite IMMEDIATE 트랜잭션 격리 보장이 깨짐
- 런타임 에러가 아닌 논리적 경쟁 조건이므로 테스트에서 발견하기 어려움

**Prevention:**
**Oracle 호출은 반드시 evaluateAndReserve() 진입 전에 수행한다:**

```typescript
// stage3Policy() 내부
// 1. 비동기 Oracle 호출 (트랜잭션 외부)
const priceResult = await resolveEffectiveAmountUsd(ctx.request, priceOracle);

// 2. 동기 TOCTOU-safe 평가 (트랜잭션 내부)
txParam.usdAmount = priceResult.tag === 'success' ? priceResult.usdAmount : undefined;
evaluation = ctx.policyEngine.evaluateAndReserve(ctx.walletId, txParam, ctx.txId);
```

evaluateAndReserve() 내부에서는 이미 계산된 `txParam.usdAmount`만 참조하므로 HTTP 호출이 필요 없다.

**Detection:**
- 코드 리뷰: evaluateAndReserve() 내부에 `await`, `Promise`, `then` 키워드가 없는지 확인
- 타입 검사: 트랜잭션 콜백의 반환 타입이 `Promise`가 아닌지 확인

---

### H-05: Action Provider의 resolve()가 반환한 ContractCallRequest가 기존 파이프라인과 호환되지 않음

**Severity:** HIGH
**Confidence:** HIGH (기존 buildByType() 코드 직접 분석)
**Phase:** ActionProviderRegistry + POST /v1/actions 구현 단계

**What goes wrong:**
IActionProvider.resolve()는 ContractCallRequest를 반환하고, 이것이 기존 파이프라인(stage1Validate -> ... -> stage5Execute)에 주입된다. 하지만 기존 파이프라인은 TransactionRequestSchema.parse()로 요청을 검증하고, buildByType()에서 request.type으로 분기한다. resolve()의 반환값이 이 흐름에 정확히 맞지 않으면:

1. Zod 검증 실패로 Stage 1에서 거부됨
2. buildByType()에서 잘못된 분기로 라우팅됨
3. 체인별 필드(Solana: programId/instructionData/accounts, EVM: calldata/abi/value)가 누락됨

**Why it happens:**
- resolve()의 반환값은 순수 ContractCallRequest 타입이지만, 파이프라인 진입점은 `SendTransactionRequest | TransactionRequest` 유니언을 기대
- type 필드가 'CONTRACT_CALL'로 정확히 설정되어야 하는데 resolve()가 이를 누락
- Solana ContractCallRequest와 EVM ContractCallRequest의 필드 차이 (programId vs calldata)

**Consequences:**
- Action Provider가 올바른 트랜잭션을 생성해도 파이프라인 Stage 1에서 항상 거부
- 또는 Zod 검증을 우회하면 Stage 5에서 예상치 못한 에러 발생
- 체인별 필드 누락으로 on-chain 실행 실패

**Prevention:**
POST `/v1/actions/:provider/:action` 라우트에서 resolve() 결과를 파이프라인 호환 형태로 변환하는 어댑터 레이어를 구현한다:

```typescript
// actions route handler
const contractCallReq = await provider.resolve(actionName, params, context);

// ContractCallRequest -> TransactionRequest 변환
const pipelineReq: TransactionRequest = {
  type: 'CONTRACT_CALL',
  to: contractCallReq.to,
  calldata: contractCallReq.calldata,
  abi: contractCallReq.abi,
  value: contractCallReq.value,
  // Solana fields
  programId: contractCallReq.programId,
  instructionData: contractCallReq.instructionData,
  accounts: contractCallReq.accounts,
  // 네트워크 정보
  network: context.network,
};

// 기존 파이프라인으로 전달
const txId = await pipeline.executeSend(walletId, pipelineReq);
```

**Detection:**
- 통합 테스트: 테스트 Action Provider의 resolve() -> 파이프라인 전체 흐름 검증
- E2E 시나리오 17이 이 경로를 검증

---

### H-06: MCP 동적 도구 등록/해제 시 기존 14개 내장 도구 손실

**Severity:** HIGH
**Confidence:** MEDIUM (MCP SDK 동적 도구 등록 메커니즘 추정 기반)
**Phase:** MCP Tool 변환 레이어 구현 단계

**What goes wrong:**
ActionProvider 등록/해제 시 MCP 도구를 동적으로 추가/제거하는 과정에서, 기존 14개 내장 도구의 등록 상태가 영향을 받는다. 특히:

1. 도구 목록을 "전체 재구성"하는 방식으로 구현하면, 재구성 시점에 일시적으로 내장 도구가 사라짐
2. 도구 이름 충돌: Action Provider의 action 이름이 기존 도구 이름과 겹칠 때 덮어씀
3. unregister 시 잘못된 도구가 제거됨

**Why it happens:**
- MCP SDK의 server.tool() 등록 방식이 "추가 전용"인지 "교체 가능"인지에 따라 동작이 달라짐
- 기존 14개 도구는 서버 초기화 시 등록되고, Action 도구는 런타임에 동적 등록
- 이름 공간 충돌 방지 로직 누락

**Consequences:**
- AI 에이전트가 기본 월렛 관리 도구(create_wallet, send_transaction 등)를 잃음
- Action Provider 해제 후에도 "유령 도구"가 남아 호출 시 에러

**Prevention:**
1. **이름 공간 분리**: Action 도구는 `waiaas_{providerName}_{actionName}` 접두사를 사용하고, 기존 도구 이름과 충돌 불가능하도록 검증
2. **등록 원자성**: Action 도구 등록/해제는 기존 도구에 영향을 주지 않는 "추가/삭제만" 방식
3. **불변 내장 도구 세트**: 14개 내장 도구의 이름 목록을 상수로 관리하고, 이 이름의 도구는 절대 덮어쓰거나 제거하지 않음

**Detection:**
- 단위 테스트: Action Provider 등록/해제 후 14개 내장 도구 모두 존재 검증
- E2E 시나리오 18, 19, 21이 이 경로를 검증

---

## Moderate Pitfalls

기술 부채, UX 혼란, 또는 향후 확장 장애를 야기하는 실수.

---

### M-01: Pyth Hermes 공개 엔드포인트 rate limit 초과 시 무한 재시도

**Severity:** MODERATE
**Confidence:** HIGH (Pyth 공식 문서에서 rate limit 정책 직접 확인)
**Phase:** PythOracle 구현 단계

**What goes wrong:**
Pyth Hermes 공개 엔드포인트는 **10초당 30회** 요청 제한이 있으며, 초과 시 60초 동안 429 응답을 반환한다. PythOracle이 429를 일반 에러로 처리하고 즉시 재시도하면:
- 60초 lockout 기간 동안 모든 요청이 429로 실패
- 재시도가 lockout을 연장할 수 있음
- 대량의 토큰 가격을 동시에 조회할 때 쉽게 한도 도달

**Prevention:**
1. **429 감지 + 백오프**: 429 응답 시 Retry-After 헤더 또는 60초 대기 후 재시도
2. **배치 조회 최적화**: `getPrices(tokens[])` 에서 여러 feedId를 단일 요청의 `ids[]` 파라미터로 전달
3. **캐시 우선**: 캐시에 FRESH/AGING 가격이 있으면 HTTP 호출 자체를 스킵
4. **graceful degradation**: 429 지속 시 CoinGecko fallback 또는 STALE 캐시 가격 사용

**Detection:**
- 단위 테스트: 429 응답 시 적절한 백오프 동작 검증
- mock HTTP 서버로 rate limit 시나리오 시뮬레이션

---

### M-02: CoinGecko platformId 매핑 오류로 잘못된 토큰 가격 반환

**Severity:** MODERATE
**Confidence:** MEDIUM (CoinGecko API 문서 기반 추론)
**Phase:** CoinGeckoOracle 구현 단계

**What goes wrong:**
CoinGecko의 `/simple/token_price/{platform_id}` 엔드포인트에서 `platform_id`는 "solana", "ethereum", "polygon-pos", "arbitrum-one" 등의 문자열이다. WAIaaS의 ChainType("solana", "ethereum")과 NetworkType("ethereum-mainnet", "polygon-mainnet")에서 CoinGecko platformId로의 매핑이 잘못되면:

- Polygon 토큰을 Ethereum으로 조회하여 null 반환 또는 다른 토큰 가격 반환
- Arbitrum의 USDC.e와 네이티브 USDC가 다른 컨트랙트인데 동일 가격 반환 (이건 올바른 동작이지만 혼동 가능)
- Solana SPL 토큰의 mint address가 CoinGecko에 등록되지 않은 경우

**Prevention:**
1. 명시적 매핑 테이블: `NetworkType -> CoinGecko platformId` 상수 맵
2. 매핑 테이블 단위 테스트: 모든 WAIaaS 지원 네트워크에 대해 CoinGecko platformId가 올바른지 검증
3. 매핑 실패 시 graceful fallback (null 반환, 로그 기록)

---

### M-03: SpendingLimitRuleSchema Zod 스키마 도입 시 기존 정책과의 하위 호환성 파괴

**Severity:** MODERATE
**Confidence:** HIGH (기존 코드베이스 직접 분석 -- ruleConfig: z.record(z.unknown()))
**Phase:** SpendingLimitRuleSchema 생성 단계

**What goes wrong:**
현재 SPENDING_LIMIT 정책의 rules는 `z.record(z.unknown())`으로 비검증 상태이다. 새 SpendingLimitRuleSchema를 추가하면서 `instant_max_usd` 등 새 필드를 **필수**로 정의하면, 기존에 저장된 SPENDING_LIMIT 정책(USD 필드 없음)이 검증에 실패한다.

**Why it happens:**
- 기존 정책: `{ instant_max: "1000000", notify_max: "10000000", delay_max: "100000000", delay_seconds: 300 }`
- 새 스키마가 `instant_max_usd`를 필수로 정의하면 기존 정책이 유효하지 않음
- CreatePolicyRequestSchema의 superRefine이 SPENDING_LIMIT에도 적용되기 시작하면 기존 정책 수정 API가 깨짐

**Prevention:**
1. **USD 필드는 optional**: `instant_max_usd: z.string().regex(/^\d+(\.\d+)?$/).optional()` -- 설정되지 않으면 USD 평가를 스킵하고 네이티브만으로 평가
2. **하위 호환 스키마**: 기존 4개 필드(instant_max, notify_max, delay_max, delay_seconds)는 필수 유지, 새 3개 필드(instant_max_usd, notify_max_usd, delay_max_usd)는 optional
3. **마이그레이션 불필요**: DB의 rules JSON 컬럼에 저장된 기존 데이터는 그대로 유효해야 함

```typescript
const SpendingLimitRulesSchema = z.object({
  instant_max: z.string().regex(/^\d+$/),
  notify_max: z.string().regex(/^\d+$/),
  delay_max: z.string().regex(/^\d+$/),
  delay_seconds: z.number().int().positive(),
  // v1.5 USD 필드 (optional, 미설정 시 USD 평가 스킵)
  instant_max_usd: z.string().regex(/^\d+(\.\d+)?$/).optional(),
  notify_max_usd: z.string().regex(/^\d+(\.\d+)?$/).optional(),
  delay_max_usd: z.string().regex(/^\d+(\.\d+)?$/).optional(),
});
```

**Detection:**
- 단위 테스트: USD 필드 없는 기존 rules JSON이 새 스키마에서 유효한지 검증
- 마이그레이션 테스트: DB v10 -> v11 업그레이드 후 기존 SPENDING_LIMIT 정책이 정상 동작하는지 검증

---

### M-04: InMemoryPriceCache LRU 구현의 미묘한 버그 -- 동시 접근 문제

**Severity:** MODERATE
**Confidence:** MEDIUM (Node.js 싱글 스레드 특성상 실제 경합은 드물지만 비동기 갭에서 가능)
**Phase:** InMemoryPriceCache 구현 단계

**What goes wrong:**
직접 구현하는 Map + doubly-linked list LRU 캐시에서:
1. **TTL 만료 확인과 eviction 사이의 비동기 갭**: getPrice() 에서 TTL 만료를 확인하고 Oracle에서 새 가격을 가져오는 동안, 다른 요청이 동일 키의 만료된 캐시 항목을 읽음
2. **128항목 상한에서의 eviction 순서**: LRU eviction이 가장 오래된 "접근 시점" 기준인지, "삽입 시점" 기준인지에 따라 자주 사용되는 토큰 가격이 evict됨
3. **캐시 키 정규화**: `${chain}:${address}` 키에서 EVM 주소의 대소문자가 다르면 동일 토큰에 대해 중복 캐시 항목 생성

**Prevention:**
1. **Node.js 이벤트 루프 특성 활용**: 동기 코드 블록 내에서 TTL 확인 + 캐시 반환은 원자적 (비동기 갭 없음). Oracle 호출 후 캐시 갱신도 동기 블록에서 수행.
2. **LRU 접근 시점 기준**: get() 호출 시 노드를 리스트 앞으로 이동 (표준 LRU)
3. **캐시 키 정규화**: `${chain}:${address.toLowerCase()}` 로 항상 소문자 변환
4. **외부 LRU 라이브러리 사용 검토**: 설계에서 "외부 라이브러리 의존성 제거"로 직접 구현을 결정했지만, `lru-cache` (npm 주간 4천만 다운로드, Isaac Z. Schlueter 관리) 같은 성숙한 라이브러리가 엣지 케이스를 이미 처리하고 있음. 직접 구현 시 엣지 케이스 테스트에 충분한 시간 할당 필요.

**Detection:**
- 단위 테스트: 128항목 초과 시 LRU eviction 순서 검증
- 단위 테스트: 동일 토큰의 대/소문자 다른 주소 -> 단일 캐시 항목 검증
- 단위 테스트: TTL 만료 직후 캐시 miss 확인

---

### M-05: ~/.waiaas/actions/ 디렉토리 미존재 시 데몬 시작 실패

**Severity:** MODERATE
**Confidence:** HIGH (파일시스템 의존성 직접 추론)
**Phase:** ActionProviderRegistry 플러그인 발견 단계

**What goes wrong:**
ActionProviderRegistry.loadPlugins()가 `~/.waiaas/actions/` 디렉토리를 스캔할 때:
1. 디렉토리가 존재하지 않으면 `ENOENT` 에러로 데몬 시작 실패
2. 디렉토리가 존재하지만 권한이 없으면 `EACCES` 에러
3. 심볼릭 링크가 있으면 예상치 못한 위치의 파일이 로드됨
4. .mjs 파일이 아닌 파일(예: .md, .txt)도 import 시도

**Prevention:**
1. **디렉토리 자동 생성**: 없으면 `mkdir -p` 후 빈 상태로 진행 (플러그인 0개 = 정상 동작)
2. **에러 격리**: 개별 파일 import 실패는 해당 플러그인만 건너뛰고 에러 로그 기록
3. **파일 필터**: `.mjs` 확장자 또는 `package.json`이 있는 디렉토리만 로드 대상
4. **심볼릭 링크 경고**: symlink 감지 시 경고 로그 (보안 알림)

**Detection:**
- 단위 테스트: 디렉토리 미존재 시 graceful 동작 검증
- 단위 테스트: 잘못된 파일 확장자 무시 검증
- E2E 시나리오 15가 잘못된 플러그인 거부를 검증

---

### M-06: Oracle 헬스체크 엔드포인트가 실제 가격 조회를 테스트하지 않음

**Severity:** MODERATE
**Confidence:** MEDIUM (API 설계 패턴 기반 추론)
**Phase:** GET /v1/admin/oracle-status 구현 단계

**What goes wrong:**
`GET /v1/admin/oracle-status`가 캐시 통계(hits/misses/size)만 반환하고 실제 Oracle 연결 상태를 확인하지 않으면:
1. Pyth Hermes가 다운되었지만 캐시에 FRESH 데이터가 있어 "정상"으로 표시
2. CoinGecko API 키가 만료되었지만 캐시 hit 중이라 "활성"으로 표시
3. 관리자가 "Oracle이 정상이니 USD 정책이 작동하고 있다"고 잘못 판단

**Prevention:**
1. **라이브 프로브**: 헬스체크 호출 시 SOL/USD와 ETH/USD를 실제 조회 (캐시 우회 옵션)
2. **소스별 상태**: `{ pyth: { status: 'up'|'down'|'degraded', lastSuccessAt, lastErrorAt, errorCount }, coingecko: { status, ... } }` 형태로 소스별 상태 제공
3. **마지막 성공/실패 시간**: 각 Oracle 소스의 마지막 성공/실패 HTTP 호출 시간 기록
4. **캐시 분리**: 헬스체크용 프로브는 메인 캐시와 별도로 수행 (캐시 hit 통계를 오염시키지 않음)

**Detection:**
- 단위 테스트: Oracle 다운 시 헬스체크 응답에 정확한 상태 반영 검증

---

### M-07: Action Provider MCP 도구 입력 스키마 변환 시 정보 손실

**Severity:** MODERATE
**Confidence:** MEDIUM (zodToJsonSchema 변환 특성 기반 추론)
**Phase:** MCP Tool 변환 레이어 구현 단계

**What goes wrong:**
ActionDefinition의 `inputSchema` (Zod 스키마)를 `zodToJsonSchema()`로 JSON Schema로 변환하여 MCP server.tool()에 등록할 때:
1. Zod의 `.transform()`, `.refine()`, `.superRefine()` 등 런타임 검증 로직이 JSON Schema에 반영되지 않음
2. Zod의 `.default()` 값이 JSON Schema에 반영되지 않는 경우
3. 복잡한 discriminatedUnion이 JSON Schema의 oneOf로 정확히 변환되지 않을 수 있음
4. AI 에이전트가 JSON Schema를 보고 생성한 입력이 Zod 검증에서 실패

**Prevention:**
1. **입력 스키마 단순화 권장**: Action Provider 가이드라인에서 inputSchema는 `.object()`, `.string()`, `.number()`, `.boolean()`, `.array()`, `.enum()` 등 JSON Schema로 완벽 변환 가능한 타입만 사용하도록 권장
2. **변환 후 검증**: zodToJsonSchema() 결과를 다시 Zod로 역변환하여 round-trip 일관성 테스트 (또는 변환 결과를 사람이 검토)
3. **MCP 도구 호출 시 Zod 재검증**: MCP에서 받은 입력을 원본 Zod 스키마로 parse하여, JSON Schema 누락된 검증을 보완

**Detection:**
- 단위 테스트: 다양한 Zod 스키마 -> zodToJsonSchema() -> MCP tool 등록 -> 올바른 입력/잘못된 입력 검증

---

### M-08: DB v11 마이그레이션에서 api_keys 테이블 생성 시 인덱스/제약 조건 누락

**Severity:** MODERATE
**Confidence:** HIGH (기존 마이그레이션 패턴 직접 분석)
**Phase:** DB 마이그레이션 v11 구현 단계

**What goes wrong:**
api_keys 테이블 생성 시:
1. `provider_name` UNIQUE 제약 조건 누락 -> 동일 프로바이더에 여러 키 저장 가능 -> 어떤 키를 사용할지 모호
2. `encrypted_key` 컬럼에 NOT NULL 누락 -> NULL 키 저장 가능 -> 복호화 시 에러
3. `created_at`/`updated_at` 타임스탬프가 초 단위가 아닌 밀리초로 저장 -> 기존 테이블과 불일치
4. 마이그레이션 롤백 불가 (SQLite는 DROP COLUMN이 제한적)

**Prevention:**
1. 기존 스키마 패턴을 정확히 따른다: UUID v7 PK, 초 단위 타임스탬프, 명시적 제약 조건
2. 마이그레이션 테스트: v10 -> v11 업그레이드 후 UNIQUE/NOT NULL 제약 조건 동작 검증
3. 체인 마이그레이션 테스트: 기존 migration-chain.test.ts에 v11 추가하여 전체 경로 검증

```sql
CREATE TABLE api_keys (
  provider_name TEXT PRIMARY KEY,  -- provider 이름 자체가 PK (UNIQUE 보장)
  encrypted_key TEXT NOT NULL,     -- AES-GCM 암호화된 키
  created_at INTEGER NOT NULL,     -- 초 단위 Unix timestamp
  updated_at INTEGER NOT NULL      -- 초 단위 Unix timestamp
);
```

**참고**: 설계 문서에서 `provider_name UNIQUE`로 명시했으므로, PK를 provider_name으로 하면 별도 UUID PK가 불필요하여 더 간결하다. 다만 기존 테이블들이 UUID v7 PK를 사용하는 패턴과 일관성이 깨지므로, UUID v7 PK + provider_name UNIQUE INDEX 방식도 검토한다.

**Detection:**
- 마이그레이션 체인 테스트: v0 -> v11 전체 경로 테스트
- 스키마 스냅샷 픽스처 갱신 + 검증

---

## Minor Pitfalls

---

### L-01: CoinGecko Demo API 월간 10,000 호출 상한 소진 시 침묵 실패

**Severity:** LOW
**Confidence:** HIGH (CoinGecko 문서에서 직접 확인)
**Phase:** CoinGeckoOracle 구현 단계

**What goes wrong:**
CoinGecko Demo API는 분당 30회 외에 **월간 10,000회** 호출 상한이 있다. 이를 초과하면 API가 에러를 반환하지만, 이 특정 에러를 처리하지 않으면 일반 "서비스 장애"로 취급되어 관리자가 원인을 파악하기 어렵다.

**Prevention:**
- 월간 호출 횟수 추정 표시 (CacheStats에 coinGeckoCallsThisMonth 필드)
- 상한 초과 에러 감지 시 관리자 알림 + "Pro API 키로 업그레이드 권장" 메시지

---

### L-02: 가격 나이 AGING 경고 로그가 높은 빈도로 기록되어 로그 오염

**Severity:** LOW
**Confidence:** MEDIUM (운영 환경 추론)
**Phase:** classifyPriceAge() + 경고 로그 구현 단계

**What goes wrong:**
가격 나이가 5~30분(AGING) 범위일 때 매 트랜잭션마다 `PRICE_STALE` 경고 로그를 기록하면:
- 5분 간격으로 가격이 갱신되지 않는 비활성 시간대에 모든 트랜잭션이 경고를 생성
- audit_log 테이블이 불필요한 경고로 빠르게 성장
- 실제 중요한 STALE(>30분) 경고가 AGING 경고에 묻힘

**Prevention:**
- AGING 경고는 토큰별 최초 1회만 기록 (5분 간격 리셋)
- 또는 AGING 경고는 info 레벨, STALE 경고는 warning 레벨로 구분
- 감사 로그가 아닌 일반 로거에만 기록 (audit_log 테이블 오염 방지)

---

### L-03: zodToJsonSchema 버전 호환성 -- zod v3 vs v4

**Severity:** LOW
**Confidence:** MEDIUM (npm 패키지 의존성 분석)
**Phase:** MCP Tool 변환 레이어 구현 단계

**What goes wrong:**
프로젝트가 zod v3.25를 사용하고 있는데, `zod-to-json-schema` 패키지의 호환 버전이 맞지 않거나 향후 zod v4 마이그레이션 시 변환 로직이 깨진다.

**Prevention:**
- `zod-to-json-schema@3.x` 사용 (현재 zod v3 호환)
- Action Provider의 inputSchema가 zodToJsonSchema에서 지원하는 타입만 사용하도록 문서화

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Mitigation |
|-------------|---------------|------------|
| IPriceOracle 인터페이스 | TokenRef 타입과 기존 토큰 관련 타입(ALLOWED_TOKENS의 token, token_registry의 address) 간 불일치 | TokenRef가 기존 타입의 슈퍼셋이 되도록 설계, 변환 함수 제공 |
| PythOracle 구현 | feedId 매핑 전략 미결정 상태에서 구현 시작 | 하드코딩 맵부터 시작, CoinGecko fallback으로 미매핑 토큰 커버 |
| CoinGeckoOracle 구현 | Demo API 키를 config.toml에 평문 저장하는 실수 | SettingsService의 isCredential=true 패턴 사용 |
| OracleChain 교차 검증 | 편차 계산 공식 오류 (절대값 누락, 분모 0) | 편차 계산 함수를 별도 유닛으로 분리하여 경계값 테스트 |
| InMemoryPriceCache | LRU 직접 구현의 엣지 케이스 버그 | 128항목 상한, 동시 접근, TTL 경계값 테스트 철저히 작성 |
| resolveEffectiveAmountUsd() | 5개 TransactionType별 분기 누락 (특히 BATCH 합산) | 각 타입별 독립 테스트 + BATCH 합산 테스트 |
| SpendingLimitRuleSchema | 기존 네이티브 전용 정책과의 하위 호환성 | USD 필드는 optional, 미설정 시 USD 평가 스킵 |
| DatabasePolicyEngine USD 통합 | evaluateAndReserve() 내 비동기 호출 금지 | Oracle 호출은 stage3Policy() 초반에서 수행, 결과만 전달 |
| IActionProvider 인터페이스 | resolve() 반환값이 파이프라인 입력 형식과 불일치 | ContractCallRequest -> TransactionRequest 변환 어댑터 레이어 |
| ActionProviderRegistry | 플러그인 로드 실패가 데몬 전체를 크래시 | 개별 플러그인 에러 격리, try-catch 감싸기 |
| MCP Tool 변환 | zodToJsonSchema 변환 시 정보 손실 | 단순 스키마 권장, MCP 호출 시 Zod 재검증 |
| ActionProviderApiKeyStore | 기존 settings-crypto.ts와 다른 암호화 패턴 도입 | 기존 HKDF + AES-GCM 패턴 재사용 |
| DB 마이그레이션 v11 | api_keys 테이블 제약 조건 누락 | 기존 스키마 패턴 준수, 체인 마이그레이션 테스트 |
| POST /v1/actions/:provider/:action | Action 요청이 기존 정책(CONTRACT_WHITELIST 등)에 의해 차단 | Action이 생성한 ContractCallRequest도 정책 평가를 거치도록 보장 |
| Admin API Keys UI | 키 마스킹 표시 (앞 4자만) vs API 키 길이가 4자 미만 | 4자 미만 키 처리 (전체 마스킹 또는 최소 길이 검증) |
| Skill 파일 동기화 | 새 엔드포인트 추가 후 skill 파일 업데이트 누락 | CLAUDE.md 규칙에 따라 REST/MCP 변경 시 skill 파일 동기화 체크리스트 |

---

## Integration Pitfalls (시스템 간 상호작용)

---

### I-01: Action Provider resolve() -> 기존 정책 엔진 -> 예상치 못한 차단

**What goes wrong:**
Action Provider가 DeFi 프로토콜의 스왑/스테이킹 트랜잭션을 resolve()하면 ContractCallRequest가 생성되고, 이것이 파이프라인을 통과할 때:
1. CONTRACT_WHITELIST 정책에 해당 DeFi 컨트랙트가 없으면 차단
2. METHOD_WHITELIST 정책에 해당 function selector가 없으면 차단
3. SPENDING_LIMIT이 value 필드(네이티브 전송량)만 평가하여 토큰 스왑의 실제 가치를 반영하지 못함

**Prevention:**
- Action Provider 설치 가이드에 "해당 프로토콜 컨트랙트를 CONTRACT_WHITELIST에 추가해야 합니다" 안내 포함
- Action Provider의 metadata에 `requiredPolicies` 필드 추가 (미래 확장) -- 필요한 CONTRACT_WHITELIST 항목을 자동 제안
- Admin UI에서 Action Provider 활성화 시 관련 정책 설정 안내 표시

---

### I-02: Oracle 장애 + Action Provider 실행이 동시에 발생하면 DeFi 트랜잭션의 USD 평가 불가

**What goes wrong:**
AI 에이전트가 Jupiter Swap Action을 실행하려고 할 때:
1. resolve()는 성공 (ContractCallRequest 생성)
2. resolveEffectiveAmountUsd()에서 Oracle 장애로 USD 평가 실패
3. 네이티브 금액(value 필드)만으로 평가 -> 스왑의 실제 가치가 반영 안 됨
4. 결과: 고가치 스왑이 낮은 티어로 승인될 수 있음

**Prevention:**
- CONTRACT_CALL 타입에서 value가 0인 경우 (토큰 스왑처럼 네이티브 전송이 없는 경우), Oracle 장애 시 보수적으로 NOTIFY 이상 강제
- 또는 Action Provider의 metadata에 `riskLevel`이 명시되어 있으면 이를 최소 티어로 활용

---

### I-03: 알림 시스템과 Oracle 상태 알림의 무한 루프

**What goes wrong:**
Oracle이 장애 상태일 때 매 트랜잭션마다 `PRICE_UNAVAILABLE` 감사 로그가 기록되고, 이에 연동된 알림이 발송된다. 알림 자체가 rate limit(20rpm)에 의해 제한되지만, 장기 Oracle 장애 시 알림 채널이 동일 메시지로 도배된다.

**Prevention:**
- Oracle 장애 알림은 "상태 전이 시 1회"만 발송 (up->down 1회, down->up 1회)
- 연속 PRICE_UNAVAILABLE 감사 로그는 첫 발생과 마지막 발생만 기록 (중간은 카운터)

---

## Sources

### Price Oracle / Manipulation
- [CertiK: Oracle Wars - Price Manipulation Attacks](https://www.certik.com/resources/blog/oracle-wars-the-rise-of-price-manipulation-attacks)
- [Cyfrin: Price Oracle Manipulation Attacks Guide](https://www.cyfrin.io/blog/price-oracle-manipulation-attacks-with-examples)
- [Halborn: Price Oracle Manipulation in DeFi](https://www.halborn.com/blog/post/what-are-price-oracle-manipulation-attacks-in-defi)

### Pyth Network
- [Pyth Rate Limits](https://docs.pyth.network/price-feeds/core/rate-limits) -- 10초당 30회, 초과 시 60초 lockout
- [Pyth Hermes Architecture](https://docs.pyth.network/price-feeds/core/how-pyth-works/hermes)
- [Pyth Price Feed IDs](https://docs.pyth.network/price-feeds/pro/price-feed-ids)
- [Pyth API Reference](https://docs.pyth.network/price-feeds/core/api-reference)

### CoinGecko
- [CoinGecko Rate Limits](https://support.coingecko.com/hc/en-us/articles/4538771776153-What-is-the-rate-limit-for-CoinGecko-API-public-plan) -- Demo: 30 calls/min, 10,000 calls/month
- [CoinGecko Common Errors](https://docs.coingecko.com/docs/common-errors-rate-limit)

### ESM / Plugin Security
- [GitHub Advisory: ESM dynamic import arbitrary execution](https://github.com/endojs/endo/security/advisories/GHSA-9c4h-3f7h-322r)
- [vm2 Critical Sandbox Escape CVE-2026-22709](https://www.endorlabs.com/learn/cve-2026-22709-critical-sandbox-escape-in-vm2-enables-arbitrary-code-execution) -- CVSS 9.8
- [isolated-vm: Secure JS environments](https://github.com/laverdet/isolated-vm)

### Encryption
- [Libsodium SecretBox](https://libsodium.gitbook.io/doc/secret-key_cryptography/secretbox)
- [Libsodium Key Derivation](https://libsodium.gitbook.io/doc/key_derivation)
- [sodium-native SecretBox docs](https://sodium-friends.github.io/docs/docs/secretkeyboxencryption)
