# Domain Pitfalls: Sign-Only 트랜잭션 서명 + Unsigned TX 파싱 + 정책 매핑 + Default Deny 토글 + MCP 리소스 확장

**Domain:** Self-hosted AI agent wallet daemon -- sign-only pipeline, unsigned transaction parsing, policy mapping, default deny toggles, MCP skill resources
**Project:** WAIaaS v1.7 (추정 마일스톤)
**Researched:** 2026-02-14
**Overall Confidence:** MEDIUM-HIGH (기존 코드베이스 직접 분석, viem/Solana 공식 문서 검증, MCP SDK 문서 교차 확인)

---

## Overview

이 문서는 **기존 6-stage 송금 파이프라인(build->simulate->sign->submit->confirm)에 sign-only 파이프라인(parse->policy->sign->return)을 추가할 때** 발생하는 함정을 다룬다. 기존 PITFALLS.md(v0.8)가 Owner 상태 전이와 정책 다운그레이드에 집중했다면, 이 문서는 **외부 dApp이 만든 unsigned transaction을 파싱하여 정책 평가 후 서명만 반환하는 흐름** 특유의 위험에 집중한다.

핵심 차이점: 기존 파이프라인은 WAIaaS가 트랜잭션을 직접 빌드하므로 내용을 완전히 통제한다. Sign-only 파이프라인은 **외부에서 구성한 트랜잭션을 신뢰해야 하는** 근본적 신뢰 경계 변화가 발생한다.

각 함정은 **Critical(보안 구멍 또는 자금 손실)**, **High(정책 우회 또는 주요 재작업)**, **Moderate(기술 부채 또는 UX 혼란)** 3단계로 분류한다.

---

## Critical Pitfalls

보안 구멍, 정책 우회, 또는 자금 손실을 야기하는 실수.

---

### C-01: Unsigned TX 파싱 불완전 -- 정책 우회 경로 (Parser Bypass)

**Severity:** CRITICAL
**Confidence:** HIGH (EVM calldata 4-byte selector collision 연구, Solana instruction 구조 직접 분석)

**What goes wrong:**
외부 dApp이 보내온 unsigned transaction에서 type/amount/to/contract 등을 정확하게 추출하지 못하면, 정책 엔진이 잘못된 TransactionParam으로 평가하게 된다. 구체적 시나리오:

**EVM 공격 벡터:**
1. 외부 dApp이 ERC-20 `transfer(address,uint256)` 호출이 포함된 unsigned tx를 보냄
2. 파서가 calldata에서 4-byte selector `0xa9059cbb`를 추출
3. 그러나 `multicall` 안에 감싸진 경우, 외부 calldata는 `multicall(bytes[])` 셀렉터만 보임
4. 파서가 이를 단순 CONTRACT_CALL로 분류 → ALLOWED_TOKENS 정책 우회
5. 실제로는 허용되지 않은 토큰을 전송하는 트랜잭션에 서명 완료

**Solana 공격 벡터:**
1. Solana VersionedTransaction에 Address Lookup Table (ALT)이 포함됨
2. 파서가 ALT를 resolve하지 않으면 instruction의 실제 program ID를 알 수 없음
3. System Program transfer처럼 보이지만 실제로는 다른 프로그램의 CPI
4. 금액/수신자 정보를 잘못 추출하여 SPENDING_LIMIT 우회

**핵심 문제:** 파서가 지원하지 않는 instruction 패턴을 만나면 **안전한 기본값(deny)이 아닌 통과(INSTANT)로 처리**하는 실수. 현재 DatabasePolicyEngine은 정책이 0개일 때 `{ allowed: true, tier: 'INSTANT' }` 반환하므로, 파싱 실패 시 TransactionParam이 빈 값이면 정책을 우회할 수 있다.

**Why it happens:**
- EVM calldata는 ABI 없이 정확한 디코딩이 불가능 (4-byte selector만으로는 함수 시그니처 모호)
- Solana VersionedTransaction의 ALT는 온체인 조회 없이 resolve 불가
- 파서 개발 시 "알려진 패턴만 처리하고 나머지는 통과" 접근
- 현재 `buildTransactionParam()` 함수가 `default: TRANSFER`로 fallback하는 패턴과 동일 실수

**Warning signs:**
- 파서에 `default` 또는 `else` 분기가 `type: 'TRANSFER', amount: '0'`을 반환
- ALT가 포함된 Solana tx에 대한 테스트 케이스 부재
- multicall/batch 패턴이 감싸진 EVM tx에 대한 테스트 케이스 부재
- `CONTRACT_CALL`로 분류된 tx에 selector가 없는 경우의 처리 미정의

**Prevention:**
1. **파싱 실패 = DENY:** 파서가 분류할 수 없는 트랜잭션은 반드시 `{ allowed: false, reason: 'Unable to classify transaction for policy evaluation' }` 반환. 절대로 INSTANT 통과 금지.
2. **ALT resolve 필수:** Solana tx에 ALT가 포함되어 있으면 `getAddressLookupTable` RPC를 호출하여 실제 주소를 resolve한 뒤 instruction을 분석. RPC 실패 시 deny.
3. **EVM calldata 깊이 제한:** multicall, batch 등 중첩된 calldata는 1단계까지만 파싱하고, 2단계 이상 중첩은 deny. ABI 없이 디코딩할 때의 모호성을 명시적으로 인정.
4. **알려진 프로토콜 화이트리스트:** Jupiter, Raydium 등 알려진 프로그램의 instruction 레이아웃을 사전 등록하고, 등록되지 않은 프로그램의 instruction은 `UNKNOWN_PROGRAM`으로 분류하여 CONTRACT_WHITELIST 정책으로 제어.
5. **파싱 결과 감사 로그:** 모든 sign-only 요청에 대해 파싱 결과(분류된 type, 추출된 amount/to/contract)를 audit_log에 기록하여 사후 검증 가능.

**Phase:** Unsigned TX 파서 구현 시 (가장 첫 번째 phase에서 완료해야 함)

---

### C-02: SPENDING_LIMIT reserved_amount 영원히 해제되지 않는 문제 -- 서명 후 미제출 트랜잭션

**Severity:** CRITICAL
**Confidence:** HIGH (현재 코드 직접 분석 -- `evaluateAndReserve`와 `releaseReservation` 흐름 확인)

**What goes wrong:**
현재 `evaluateAndReserve()`는 트랜잭션 행에 `reserved_amount`를 기록하고, `releaseReservation()`은 FAILED/CANCELLED/EXPIRED 상태 전이 시 호출된다. 그런데 sign-only 파이프라인에서는:

1. 외부 dApp이 unsigned tx 제출 → 정책 평가 → `evaluateAndReserve()`로 금액 예약
2. WAIaaS가 서명을 반환 → 서명된 tx를 dApp에게 돌려줌
3. **dApp이 서명된 tx를 제출하지 않음** (사용자 취소, 네트워크 전환, 앱 종료 등)
4. WAIaaS 입장에서는 트랜잭션이 SIGNED 상태로 영원히 남음
5. `reserved_amount`가 해제되지 않아 SPENDING_LIMIT이 점점 소진됨
6. 결국 정상 트랜잭션도 "한도 초과"로 거부됨

**현재 코드의 문제:**
```typescript
// database-policy-engine.ts L526-528
// reserved_amount는 PENDING/QUEUED 상태의 tx만 합산
// 하지만 sign-only tx는 SIGNED 상태이고 PENDING/QUEUED가 아님
// → SIGNED 상태를 합산에 포함하면 기존 파이프라인과 충돌
// → 포함하지 않으면 reservation이 무의미
```

**Solana 특유의 문제:**
- Solana tx는 blockhash lifetime(~60초)이 있어 만료 후에는 제출 불가
- 만료 시점을 WAIaaS가 추적할 수 있지만, dApp이 새 blockhash로 재구성할 수 있음
- 같은 금액의 새 tx에 또 서명 요청이 올 수 있어 이중 예약 위험

**EVM 특유의 문제:**
- EVM tx에는 blockhash 만료 개념 없음 → nonce가 사용되기 전까지 무기한 유효
- 서명된 tx를 언제든 제출할 수 있어 reservation 해제 시점을 결정할 수 없음
- nonce가 다른 tx에 의해 사용되면 해당 서명은 무효화되지만, WAIaaS가 이를 감지하려면 주기적 폴링 필요

**Why it happens:**
- 기존 파이프라인은 build->sign->submit이 동기적이므로 submit 성공/실패 시 즉시 reservation 해제
- Sign-only는 submit이 WAIaaS 밖에서 일어나므로 lifecycle 추적 불가
- "서명 = 자금 이동 확정"이 아닌 환경을 기존 reservation 모델이 처리 못함

**Warning signs:**
- `reserved_amount` SUM이 시간이 지나면서 단조 증가
- wallet의 실제 잔액은 변하지 않았는데 SPENDING_LIMIT에 걸리는 현상
- sign-only tx에 대한 `releaseReservation` 호출 경로가 없음

**Prevention:**
1. **TTL 기반 자동 해제:** sign-only 트랜잭션의 `reserved_amount`에 TTL(Time-To-Live)을 설정. Solana: blockhash 만료 시간(~60초 + 여유 30초 = 90초). EVM: 설정 가능한 TTL(기본 10분).
2. **SIGNED 상태 전용 reservation 테이블:** 기존 transactions 테이블의 `reserved_amount`와 분리하여 `sign_only_reservations` 테이블에 `{txId, amount, walletId, expiresAt}` 저장. `evaluateAndReserve`에서 이 테이블도 합산.
3. **주기적 만료 처리:** `processExpired()` 패턴(DelayQueue에서 이미 사용)을 재활용하여 만료된 sign-only reservation을 주기적으로 해제.
4. **온체인 확인 옵션:** 서명 반환 시 `txHash`를 예측하여 기록하고, 주기적으로 온체인에서 확인 여부를 폴링. 확인되면 reservation을 정상 완료 처리, 미확인이면 TTL 후 해제.
5. **예약 없이 현재 잔액 기반 평가 옵션:** sign-only 모드에서는 `evaluateAndReserve` 대신 `evaluate`만 사용하고, TOCTOU 대신 on-chain balance 확인으로 대체하는 접근도 고려. 단, 동시 서명 요청 시 이중 지출 가능성.

**Phase:** Sign-only 파이프라인 정책 통합 시 (reserved_amount 전략 결정이 선행되어야 함)

---

### C-03: DELAY/APPROVAL 티어와 동기적 Sign-Only 흐름의 근본적 비호환

**Severity:** CRITICAL
**Confidence:** HIGH (현재 stage4Wait 코드 직접 분석 -- `throw WAIaaSError('PIPELINE_HALTED')` 패턴)

**What goes wrong:**
현재 파이프라인에서 DELAY/APPROVAL 티어는 `stage4Wait`에서 `PIPELINE_HALTED` 에러를 throw하여 파이프라인을 중단하고, 별도 워커(DelayQueue.processExpired / ApprovalWorkflow.approve)가 나중에 Stages 5-6을 실행한다. Sign-only 파이프라인에서 이 패턴은:

**DELAY 문제:**
1. 10 SOL 서명 요청 → 정책 평가 → DELAY(15분)
2. 15분 대기? → HTTP 요청이 15분간 열려 있어야 함 (비현실적)
3. PIPELINE_HALTED throw? → 클라이언트가 서명을 받지 못함
4. 15분 후 서명 반환? → 원래 unsigned tx의 blockhash가 이미 만료 (Solana)

**APPROVAL 문제:**
1. 20 SOL 서명 요청 → 정책 평가 → APPROVAL
2. Owner 승인 대기? → 무기한 대기 불가
3. Owner가 승인하면? → 이미 blockhash 만료, 원래 unsigned tx 무효
4. dApp이 새 unsigned tx를 만들어 재요청? → 정책 재평가 필요 → 무한 루프 가능

**핵심 딜레마:** sign-only는 본질적으로 **동기적 요청-응답 패턴**인데, DELAY/APPROVAL은 **비동기 워크플로우**다. 이 두 패턴을 호환시키려면 근본적 설계 결정이 필요하다.

**Why it happens:**
- 기존 파이프라인은 WAIaaS가 tx lifecycle 전체를 소유하므로 비동기 워크플로우가 자연스러움
- Sign-only에서는 tx lifecycle 소유권이 dApp에 있어 비동기 대기가 불가능
- "정책 엔진 재사용"이라는 목표와 "동기적 서명 반환"이라는 요구가 충돌

**Warning signs:**
- sign-only 엔드포인트에 DELAY/APPROVAL 처리가 "TODO"로 남아 있음
- sign-only에서 DELAY 시 "즉시 서명하되 NOTIFY로 다운그레이드"하는 편의적 결정
- stage4Wait를 sign-only에서 스킵하는 코드 (정책 우회와 동의어)

**Prevention:**
1. **방안 A: Sign-only는 INSTANT/NOTIFY만 허용.** DELAY/APPROVAL 티어 결과가 나오면 서명 거부 + 에러 응답에 tier 정보 포함. 클라이언트에게 "이 금액은 sign-only로 처리할 수 없습니다. WAIaaS 내장 파이프라인(POST /v1/wallets/:id/send)을 사용하세요." 안내. **가장 안전하고 권장되는 접근.**
2. **방안 B: 2-phase sign-only.** Phase 1: 서명 요청 → 정책 평가 → DELAY/APPROVAL이면 `signRequestId` 반환. Phase 2: DELAY 만료 또는 Owner 승인 후 → 클라이언트가 `signRequestId`로 서명 수령. 단, Phase 2에서 원래 unsigned tx가 만료되었을 수 있으므로 재제출 필요.
3. **방안 C: 별도 sign-only 정책.** sign-only 전용 SPENDING_LIMIT을 추가하여 sign-only에서는 INSTANT만 적용되는 한도를 별도 설정. 기존 정책과 분리되어 관리 복잡성 증가.
4. **어떤 방안이든, DELAY/APPROVAL 결과에 대한 처리를 명시적으로 정의해야 함.** "스킵" 또는 "미구현"은 절대 금지.

**Phase:** Sign-only 파이프라인 설계 시 (첫 phase에서 아키텍처 결정 필수)

---

## High Pitfalls

정책 의미 변경, 기존 기능 파괴, 또는 주요 재작업을 야기하는 실수.

---

### H-01: Default Deny 토글의 기존 정책 의미 역전 -- "아무 정책 없음 = 전부 허용" 깨짐

**Severity:** HIGH
**Confidence:** HIGH (DatabasePolicyEngine.evaluate() L171-174 직접 분석)

**What goes wrong:**
현재 DatabasePolicyEngine의 동작:
```typescript
// Step 2: No policies -> INSTANT passthrough
if (rows.length === 0) {
  return { allowed: true, tier: 'INSTANT' };
}
```

정책이 0개이면 모든 트랜잭션이 INSTANT으로 통과한다. 이것은 v1.1부터의 의도적 설계("정책 없음 = 사용 편의")다. Default Deny 토글을 도입하면:

**시나리오 1: 전역 Default Deny 활성화**
1. 운영자가 admin에서 "Default Deny" 토글 ON
2. 기존에 정책 없이 운영하던 모든 wallet의 트랜잭션이 즉시 거부
3. 에이전트가 갑자기 모든 작업 실패 → 운영 중단

**시나리오 2: 부분적 Default Deny**
1. ALLOWED_TOKENS, CONTRACT_WHITELIST, APPROVED_SPENDERS는 이미 개별적으로 default deny
2. TRANSFER(native token)만 "정책 없으면 허용"
3. TRANSFER에도 default deny를 적용하면 → WHITELIST 정책이 없는 wallet에서 모든 전송 거부
4. WHITELIST는 현재 "정책이 없으면 제한 없음" (L718-722: `if (!whitelist) return null;`)

**핵심 문제:** "default deny"가 적용되는 범위(어떤 정책 타입? 어떤 트랜잭션 타입?)를 명확히 정의하지 않으면, 기존 동작과 새 동작의 경계에서 예상 못한 거부가 발생한다.

**Why it happens:**
- "Default Deny"가 단일 boolean 토글이 아닌, 정책 타입별로 다른 의미를 가짐
- 기존 정책 엔진이 "정책 없음 = 허용"을 여러 곳에서 하드코딩
- ALLOWED_TOKENS/CONTRACT_WHITELIST는 이미 default deny인데 WHITELIST/SPENDING_LIMIT은 아닌 불균형

**Warning signs:**
- Default Deny 토글이 단일 설정 값 하나로 구현됨
- 토글 전환 시 기존 wallet의 정책을 점검하는 마이그레이션 로직 없음
- "정책 없음 = 허용" 패턴이 evaluate(), evaluateAndReserve(), evaluateBatch() 3곳에 산재

**Prevention:**
1. **정책 타입별 default deny 제어:** 단일 토글 대신, 정책 타입별로 default deny 여부를 설정. 예: `{ WHITELIST: false, SPENDING_LIMIT: false, ALLOWED_TOKENS: true(이미), CONTRACT_WHITELIST: true(이미) }`. 기존 default deny인 타입은 변경 불가(역호환).
2. **토글 전환 시 영향도 미리보기:** admin UI에서 "Default Deny를 활성화하면 N개 wallet에서 M개 트랜잭션 타입이 차단됩니다"를 시뮬레이션 결과로 보여줌.
3. **단계적 적용:** 전역 토글 대신 wallet별로 적용. 새 wallet에는 default deny 적용, 기존 wallet은 opt-in.
4. **"정책 없음 = 허용" 코드 모두 추출:** evaluate()의 L171-174를 `defaultBehavior(walletId)` 함수로 추출하여 단일 제어 지점에서 관리.

**Phase:** Default Deny 토글 구현 시

---

### H-02: Solana VersionedTransaction 파싱 시 Legacy vs V0 분기 누락

**Severity:** HIGH
**Confidence:** HIGH (Solana VersionedTransaction 공식 문서, SolanaAdapter의 `txDecoder` 사용 패턴 확인)

**What goes wrong:**
Solana에는 Legacy Transaction과 Versioned Transaction(V0)이 공존한다:

1. **Legacy Transaction:** `Transaction` 클래스, 모든 주소가 message.accountKeys에 직접 포함
2. **Versioned Transaction (V0):** `VersionedTransaction` 클래스, Address Lookup Table(ALT)로 주소 압축

파서가 Legacy만 지원하고 V0을 무시하면:
- ALT를 사용하는 Jupiter, Raydium 등 모든 DeFi 트랜잭션 파싱 실패
- ALT에 포함된 프로그램 ID를 식별 못해 policy 분류 불가

파서가 V0만 지원하고 Legacy를 무시하면:
- 간단한 SOL 전송(많은 dApp이 아직 Legacy 사용)이 파싱 실패

**현재 코드의 맥락:**
```typescript
// adapter.ts L79: txDecoder = getTransactionDecoder()
// txDecoder는 @solana/kit의 decoder로 Legacy와 V0 모두 디코딩 가능
// 하지만 디코딩 후 instruction 분석은 수동으로 해야 함
```

**ALT resolve의 추가 복잡성:**
- ALT 조회는 RPC 호출 필요 (`getAddressLookupTable`)
- RPC 호출은 비동기 + 네트워크 지연
- ALT가 존재하지 않거나 비활성화된 경우 처리 필요
- ALT 데이터가 파싱 시점과 서명 시점 사이에 변경될 수 있음 (rare but possible)

**Why it happens:**
- Solana ecosystem이 Legacy에서 V0으로 전환 중이라 양쪽 모두 지원 필요
- ALT resolve가 I/O를 동반하여 "순수 파싱" 범주를 벗어남
- @solana/kit의 decoder가 format 분기를 자동 처리하지만 의미론적 분석은 별도 구현 필요

**Warning signs:**
- 파서 테스트에 `VersionedMessage.V0`이 포함된 테스트 케이스 없음
- ALT가 포함된 serialized tx에 대한 RPC mock 테스트 없음
- "Solana tx = Legacy" 가정이 코드에 존재

**Prevention:**
1. **양쪽 format 모두 지원:** `txDecoder.decode(bytes)`의 결과에서 `compiledMessage.version`을 확인하여 Legacy(undefined/legacy)와 V0(0)을 분기.
2. **ALT resolve를 파서의 필수 단계로 포함:** V0 tx이면 ALT resolve 없이 instruction 분석 금지. resolve 실패 시 deny.
3. **resolve된 전체 주소 목록을 캐시:** 같은 ALT에 대한 중복 RPC 호출 방지 (ALT 주소는 자주 바뀌지 않음).
4. **파싱 결과에 format 메타데이터 포함:** `{ format: 'legacy' | 'v0', hasALT: boolean, resolvedAccounts: number }` 등을 감사 로그에 기록.

**Phase:** Solana TX 파서 구현 시

---

### H-03: EVM Calldata에서 금액/수신자 추출 실패 -- ABI 없는 디코딩의 한계

**Severity:** HIGH
**Confidence:** HIGH (viem `parseTransaction` 문서 확인, calldata 디코딩 연구 교차 검증)

**What goes wrong:**
EVM unsigned tx를 `viem.parseTransaction()`으로 디코딩하면 to, value, data(calldata)가 추출된다. 그러나:

**Case 1: ERC-20 transfer**
- `to` = ERC-20 컨트랙트 주소 (실제 수신자 아님)
- `value` = 0 (네이티브 ETH 전송 없음)
- `data` = `0xa9059cbb` + ABI-encoded(recipient, amount)
- 정책 평가에 필요한 실제 수신자와 금액은 calldata 안에 있음
- ABI-encoding 규격을 알면 디코딩 가능하지만, 정확한 함수 시그니처를 확인해야 함

**Case 2: multicall/aggregate**
- `to` = Multicall3 컨트랙트 (0xcA11...)
- `data` = `aggregate3(Call3[])` -- 내부에 여러 호출이 중첩
- 각 내부 호출의 target/calldata를 재귀적으로 파싱해야 실제 의도 파악
- SPENDING_LIMIT을 개별 호출별로? 합산?

**Case 3: 알 수 없는 함수**
- `selector`가 4bytes.directory에 없는 커스텀 함수
- calldata에서 금액/수신자를 추출 불가
- 정책 평가를 위한 `amount`를 `value` (네이티브 전송분)으로만 제한? → 토큰 전송 금액 누락

**현재 코드와의 차이:**
현재 EVM 파이프라인은 WAIaaS가 직접 `encodeFunctionData`로 calldata를 만들므로 내용을 완전히 알고 있다. Sign-only에서는 외부가 만든 calldata를 역해석해야 한다.

**Why it happens:**
- EVM은 calldata가 자기 기술적(self-describing)이 아님 -- ABI가 있어야 정확한 디코딩 가능
- 4-byte selector collision이 존재 (같은 selector, 다른 함수 시그니처)
- proxy 패턴, delegatecall, multicall 등이 실제 호출 대상을 숨김

**Prevention:**
1. **알려진 패턴만 정확히 파싱, 나머지는 CONTRACT_CALL로 분류:** ERC-20 transfer/approve, ERC-721 transferFrom, native ETH transfer는 정확히 파싱. 그 외는 `{ type: 'CONTRACT_CALL', contractAddress: tx.to, selector: data.slice(0,10), amount: tx.value }` 로 분류하여 CONTRACT_WHITELIST + METHOD_WHITELIST 정책으로 제어.
2. **ABI 제출 옵션:** sign-only API에 `abi` 파라미터를 선택적으로 받아, ABI가 있으면 정확한 디코딩 수행. ABI 없으면 selector 기반 분류.
3. **토큰 레지스트리 활용:** `to` 주소가 token_registry 테이블의 ERC-20 컨트랙트 주소와 일치하면 → TOKEN_TRANSFER로 분류하고 calldata에서 recipient/amount를 ABI-decode.
4. **value + 추정 토큰 금액 합산:** 네이티브 value는 확정, 토큰 금액은 ABI decode 성공 시에만 합산. 실패 시 토큰 금액 0으로 처리하되 경고 로그.

**Phase:** EVM TX 파서 구현 시

---

### H-04: 11개 PolicyType에 대한 불완전 매핑 -- Sign-Only 특유의 정책 갭

**Severity:** HIGH
**Confidence:** HIGH (현재 11개 PolicyType와 sign-only 파싱 가능 정보의 교차 분석)

**What goes wrong:**
현재 11개 PolicyType 중 sign-only 파서가 제공할 수 있는 정보:

| PolicyType | 기존 파이프라인 | Sign-Only 파서 | 갭 |
|------------|:-------------:|:-------------:|-----|
| SPENDING_LIMIT | amount 확정 | amount 추정(ABI decode 의존) | 금액 정확도 |
| WHITELIST | to 확정 | to = 컨트랙트일 수 있음 (실제 수신자는 calldata 안) | 수신자 정확도 |
| ALLOWED_TOKENS | token.address 확정 | ERC-20 컨트랙트 주소 = to (추론) | 토큰 식별 |
| CONTRACT_WHITELIST | contractAddress 확정 | to (정확) | OK |
| METHOD_WHITELIST | selector 확정 | selector 4bytes (정확) | OK |
| APPROVED_SPENDERS | spender 확정 | calldata decode 의존 | 스펜더 정확도 |
| APPROVE_AMOUNT_LIMIT | amount 확정 | calldata decode 의존 | 금액 정확도 |
| APPROVE_TIER_OVERRIDE | type 확정 | selector 기반 추론 | 타입 정확도 |
| ALLOWED_NETWORKS | network 확정 | chainId에서 파생 (EVM) / 요청 파라미터 (Solana) | OK |
| TIME_RESTRICTION | 요청 시점 | 요청 시점 | OK |
| RATE_LIMIT | 요청 시점 | 요청 시점 | OK |

**갭이 있는 6개 정책에서 오평가 발생 시:**
- WHITELIST가 ERC-20 컨트랙트 주소로 평가되어 실제 수신자 통과
- SPENDING_LIMIT이 `value=0`으로 평가되어 고액 토큰 전송이 INSTANT 통과
- APPROVE가 일반 CONTRACT_CALL로 분류되어 APPROVE_AMOUNT_LIMIT 우회

**Why it happens:**
- 기존 정책 엔진이 "WAIaaS가 빌드한 트랜잭션" 전제로 TransactionParam을 정의
- 외부 tx에서 같은 수준의 정보를 추출하는 것이 구조적으로 불가능한 경우 존재
- 정책 갭을 인지하지 못하고 "파싱 성공 = 정책 평가 완전" 으로 간주

**Prevention:**
1. **PolicyParam에 confidence 필드 추가:**
```typescript
interface SignOnlyTransactionParam extends TransactionParam {
  confidence: 'HIGH' | 'MEDIUM' | 'LOW';
  // HIGH: 확정적 추출 (native transfer, to 주소)
  // MEDIUM: ABI decode 성공 (ERC-20 transfer/approve)
  // LOW: 추론 (unknown selector, multicall 내부)
}
```
2. **confidence LOW이면 DELAY/APPROVAL로 강제 승격:** 파싱 정확도가 낮은 tx는 더 엄격한 tier로 평가.
3. **정책 매핑 불가능 시 명시적 fallback:** "이 정책 타입은 sign-only에서 평가 불가능합니다" 경고와 함께 deny 또는 운영자 설정 가능한 fallback.
4. **sign-only 전용 제한 정책 타입 도입 검토:** sign-only에서 확정적으로 평가 가능한 정책만 적용하는 모드.

**Phase:** 정책 매핑 레이어 설계/구현 시

---

### H-05: 기존 파이프라인 Transaction 상태 모델과의 충돌

**Severity:** HIGH
**Confidence:** HIGH (TRANSACTION_STATUSES enum 직접 분석)

**What goes wrong:**
현재 트랜잭션 상태:
```typescript
TRANSACTION_STATUSES = ['PENDING', 'QUEUED', 'EXECUTING', 'SUBMITTED', 'CONFIRMED', 'FAILED', 'CANCELLED', 'EXPIRED', 'PARTIAL_FAILURE']
```

Sign-only 트랜잭션의 lifecycle:
```
요청 → 파싱 → 정책 평가 → 서명 → 반환 → (외부에서 제출) → (온체인 확인?)
```

이 lifecycle에 맞는 상태가 현재 enum에 없다:
- `SIGNED`: 서명 완료, 아직 제출 안 됨 (없음)
- `EXTERNALLY_SUBMITTED`: 외부에서 제출됨 (없음)
- `SIGN_REJECTED`: 정책 거부로 서명 거절 (CANCELLED과 다른 의미)

**기존 상태를 재사용하면:**
- `PENDING`으로 시작? → 기존 DELAY 큐 처리기가 이 tx를 잡아갈 수 있음
- `SUBMITTED`으로 마킹? → WAIaaS가 제출한 게 아닌데 SUBMITTED
- `CONFIRMED`를 온체인 확인 후 설정? → sign-only tx의 txHash를 어떻게 알지?

**DB CHECK 제약:**
```sql
CHECK (status IN ('PENDING', 'QUEUED', 'EXECUTING', 'SUBMITTED', 'CONFIRMED', 'FAILED', 'CANCELLED', 'EXPIRED', 'PARTIAL_FAILURE'))
```
새 상태를 추가하면 DB 마이그레이션 필요 (ALTER TABLE로 CHECK 제약 변경 → SQLite에서는 테이블 재생성).

**Why it happens:**
- 기존 상태 모델이 "WAIaaS가 tx lifecycle 전체를 소유" 전제로 설계됨
- Sign-only는 lifecycle 소유권이 분할되는 새로운 패턴
- 기존 enum에 새 상태를 추가하면 모든 기존 코드(query, index, UI)에 영향

**Warning signs:**
- sign-only tx에 `status: 'PENDING'`을 사용하고 `type`으로만 구분하는 편의적 접근
- 기존 트랜잭션 목록 API에 sign-only tx가 섞여 혼란
- admin UI 대시보드 통계가 sign-only tx를 잘못 집계

**Prevention:**
1. **새 상태 추가: `SIGNED`:** transactions 테이블 CHECK 제약에 `SIGNED` 추가. DB 마이그레이션(MIG-01~06 패턴) 실행. `SIGNED` = "서명 완료, 외부 제출 대기". TTL 후 `EXPIRED`로 전이.
2. **`signOnly` 플래그 컬럼 추가:** `sign_only INTEGER DEFAULT 0`으로 기존 tx와 명확 분리. 기존 쿼리에 `WHERE sign_only = 0` 조건 추가 불필요 (기본값 0이므로 기존 데이터 영향 없음).
3. **기존 쿼리 보호:** `processExpired()`와 `evaluateAndReserve()`의 `WHERE status IN ('PENDING', 'QUEUED')` 쿼리에 sign-only tx가 간섭하지 않도록 필터 추가.
4. **Admin UI 분리 표시:** sign-only tx를 별도 탭 또는 아이콘으로 구분 표시.

**Phase:** DB 스키마 확장 + 상태 머신 설계 시 (파이프라인 구현 전)

---

## Moderate Pitfalls

기술 부채, UX 혼란, 또는 통합 문제를 야기하는 실수.

---

### M-01: MCP Skill Resource 핸들러의 Content Negotiation 누락

**Severity:** MEDIUM
**Confidence:** MEDIUM (MCP SDK 공식 문서 + 현재 리소스 구현 분석)

**What goes wrong:**
현재 3개 MCP 리소스(`wallet-balance`, `wallet-address`, `system-status`)는 `application/json` MIME으로 API 응답을 그대로 반환한다. Skill 파일(`.skill.md`)을 MCP 리소스로 제공할 때:

1. Skill 파일은 Markdown (`text/markdown`)
2. 하지만 MCP 리소스의 `mimeType`을 `text/markdown`으로 설정하면 JSON 응답을 기대하는 기존 클라이언트와 불일치
3. 반대로 `application/json`으로 설정하면 Markdown 컨텐츠가 JSON 파싱 실패

**MCP SDK spec 준수 문제:**
```
// MCP spec: resources should return structured content
// If an output schema is defined, servers must conform to it
// Tools that provide structured content should also return the same data
// as a text block for backward compatibility
```

4. Skill 파일 내용이 변경되면 리소스 응답도 변경되어야 하는데, 파일 변경 감지 메커니즘이 없음
5. 여러 skill 파일이 있으면 각각 별도 리소스 URI가 필요 (`waiaas://skills/wallet`, `waiaas://skills/transactions` 등)

**Why it happens:**
- 기존 리소스가 모두 API 프록시 패턴이므로 파일 기반 리소스 경험 없음
- MCP spec의 리소스 타입 다양성(JSON, text, markdown)을 단일 패턴으로 처리
- Skill 파일이 빌드 시점에 번들링되는지 런타임에 읽히는지 미결정

**Prevention:**
1. **MIME 타입 정확히 설정:** Skill 리소스는 `text/markdown`, API 프록시 리소스는 `application/json`. MCP SDK는 `mimeType` 필드를 존중.
2. **파일 기반 리소스 로더:** Skill 파일을 `skills/` 디렉토리에서 읽어 리소스로 등록. 파일 시스템 기반이므로 `fs.readFileSync` 사용 (MCP server는 동기적 초기화 가능).
3. **리소스 목록 자동 생성:** `skills/` 디렉토리의 `*.skill.md` 파일을 스캔하여 리소스 URI 자동 등록. 파일이 추가/삭제되면 MCP 서버 재시작 시 반영.
4. **리소스 URI 네이밍 컨벤션:** `waiaas://skills/{domain}` (예: `waiaas://skills/wallet`, `waiaas://skills/transactions`).

**Phase:** MCP 리소스 확장 구현 시

---

### M-02: Sign-Only API 응답에 서명된 트랜잭션 포맷 불일치

**Severity:** MEDIUM
**Confidence:** MEDIUM (Solana/EVM 서명 포맷 차이 분석)

**What goes wrong:**
Sign-only API가 서명된 트랜잭션을 반환할 때 포맷 결정:

**Solana:**
- 서명은 signature bytes (64 bytes)
- 서명된 전체 tx = signature + compiledMessage bytes
- dApp은 전체 서명된 tx bytes를 `sendRawTransaction`에 전달
- 반환 포맷: base64 또는 base58 인코딩된 전체 tx?

**EVM:**
- 서명은 (r, s, v) 3개 값
- 서명된 전체 tx = RLP(nonce, gasPrice, ..., r, s, v)
- dApp은 `eth_sendRawTransaction`에 hex string 전달
- 반환 포맷: `0x`-prefixed hex string?

**불일치 문제:**
- 같은 API에서 chain에 따라 다른 포맷 반환 → 클라이언트 코드 복잡
- base64 vs base58 vs hex 인코딩 혼란
- partial signature(Solana multi-sig 시나리오) vs full signature 구분 필요

**Why it happens:**
- 기존 파이프라인은 서명 결과를 내부적으로만 사용(submitTransaction으로 전달)하므로 포맷이 중요하지 않았음
- Sign-only는 서명 결과를 외부 클라이언트에 반환해야 하므로 인터페이스 설계 필요
- 두 체인의 서명 구조가 근본적으로 다름

**Prevention:**
1. **체인별 표준 포맷 준수:** Solana: base64-encoded full signed transaction (web3.js 표준). EVM: `0x`-prefixed hex-encoded full signed transaction (eth_sendRawTransaction 표준).
2. **API 응답 스키마 명확 정의:**
```typescript
{
  signedTransaction: string;  // 체인 표준 포맷
  encoding: 'base64' | 'hex'; // 인코딩 명시
  chain: ChainType;
  expiresAt?: number;         // Solana only: blockhash 만료 시점
}
```
3. **SDK에 디코딩 헬퍼 제공:** `WAIaaSClient.decodeSignedTransaction(response)` 메서드로 체인별 포맷을 투명하게 처리.

**Phase:** Sign-only API 인터페이스 설계 시

---

### M-03: EVM Calldata Encoding 도구와 Sign-Only 파이프라인의 역할 혼동

**Severity:** MEDIUM
**Confidence:** MEDIUM (마일스톤 컨텍스트 분석)

**What goes wrong:**
마일스톤에 "EVM calldata encoding" 기능이 포함되어 있다. 이것이 두 가지 다른 목적으로 해석될 수 있다:

1. **도구로서의 calldata encoding:** AI 에이전트가 함수 시그니처 + 파라미터로 calldata를 생성할 수 있는 유틸리티 (MCP 도구 / REST API)
2. **파이프라인의 일부:** sign-only 파이프라인에서 파싱된 calldata를 재검증하기 위한 내부 기능

**혼동 시나리오:**
- calldata encoding 도구가 sign-only 파이프라인과 결합되어, "에이전트가 calldata를 만들고 → WAIaaS가 tx 빌드하고 → sign-only로 서명" 하는 이중 경로 발생
- 이 경우 기존 CONTRACT_CALL 파이프라인(POST /v1/wallets/:id/send + type: CONTRACT_CALL)과 기능 중복
- 에이전트가 어떤 경로를 사용해야 하는지 혼란

**Why it happens:**
- calldata encoding과 sign-only가 같은 마일스톤에 있어 통합 유혹
- 실제로는 독립적 기능인데 의존 관계가 있는 것처럼 구현

**Prevention:**
1. **명확한 역할 분리:** calldata encoding = 순수 유틸리티 (입력: ABI + 함수명 + 파라미터, 출력: hex calldata). sign-only = 외부 tx 서명 서비스 (입력: unsigned tx bytes, 출력: signed tx). 두 기능은 독립.
2. **사용 시나리오 문서화:** "dApp이 만든 tx에 서명하려면 sign-only 사용", "WAIaaS 내에서 컨트랙트 호출하려면 기존 CONTRACT_CALL 사용", "calldata만 만들고 싶으면 encoding 도구 사용".
3. **API 엔드포인트 분리:** `POST /v1/wallets/:id/sign` (sign-only), `POST /v1/utils/encode-calldata` (encoding 도구), `POST /v1/wallets/:id/send` (기존 파이프라인).

**Phase:** 기능 스코프 정의 시 (첫 phase에서 명확히)

---

### M-04: sign-only + NOTIFY 티어에서 알림 누락 또는 이중 알림

**Severity:** MEDIUM
**Confidence:** MEDIUM (NotificationService 연동 패턴 분석)

**What goes wrong:**
현재 파이프라인에서 NOTIFY 티어는:
1. stage3Policy에서 NOTIFY tier 결정
2. stage4Wait에서 passthrough (INSTANT과 동일)
3. stage5Execute에서 TX_SUBMITTED 알림
4. stage6Confirm에서 TX_CONFIRMED 알림

Sign-only에서 NOTIFY 티어 시:
1. 정책 평가 → NOTIFY → 서명 반환 (WAIaaS 제어 종료)
2. WAIaaS가 "TX_SUBMITTED" 알림을 보내야 하나? → 아직 제출 안 됨
3. dApp이 제출 후 WAIaaS에 "제출했다"고 알려줘야 하나? → 콜백 메커니즘 없음
4. 결과: NOTIFY 알림이 누락되거나, "서명됨" 시점에 잘못된 알림 발송

**Why it happens:**
- NOTIFY의 원래 의미: "실행은 하되 운영자에게 알림" → sign-only에서는 "실행" 주체가 WAIaaS가 아님
- 알림 트리거(TX_REQUESTED, TX_SUBMITTED, TX_CONFIRMED)가 파이프라인 stage에 묶여 있음

**Prevention:**
1. **TX_SIGN_REQUESTED / TX_SIGNED 이벤트 타입 추가:** sign-only 전용 알림 이벤트. NOTIFY 티어일 때 TX_SIGNED 시점에 알림 발송.
2. **알림 메시지 차별화:** "서명 요청됨: 10 SOL → 9bKrTD... (서명 완료, 외부 제출 대기)" -- "완료됨"이 아닌 "서명됨" 상태를 명확히 표시.
3. **콜백 URL 옵션:** sign-only 요청 시 `callbackUrl`을 선택적으로 받아, dApp이 tx 제출 결과를 알려주면 WAIaaS가 TX_CONFIRMED 알림 발송.

**Phase:** Sign-only 알림 통합 시

---

### M-05: Skill 파일 변경 시 MCP 리소스 캐시 정합성

**Severity:** MEDIUM
**Confidence:** LOW (MCP SDK 리소스 캐싱 동작 미확인 -- 훈련 데이터 기반)

**What goes wrong:**
Skill 파일이 MCP 리소스로 제공될 때, 파일 내용이 업데이트되면:

1. MCP 서버가 시작 시점에 파일을 읽어 캐시 → 이후 파일 변경이 반영 안 됨
2. AI 에이전트가 오래된 skill 정보로 API 호출 → 스키마 불일치 에러
3. 데몬 재시작 없이 skill 파일 반영 불가 → 운영 불편

**CLAUDE.md 규칙과의 충돌:**
```
## Interface Sync
- REST API, SDK, MCP 인터페이스가 변경되면 `skills/` 파일도 반드시 함께 업데이트한다.
```
Skill 파일은 인터페이스 변경 시 업데이트되는데, MCP 리소스 캐시는 서버 재시작 전까지 반영 안 됨.

**Prevention:**
1. **매 요청마다 파일 읽기:** Skill 파일은 크기가 작으므로(수 KB) 매 리소스 요청마다 `fs.readFileSync` 호출. 캐싱 불필요.
2. **대안: 파일 감시 (fs.watch):** 파일 변경 시 캐시 무효화. 그러나 fs.watch의 플랫폼 차이(macOS FSEvents vs Linux inotify)로 복잡성 증가. 비권장.
3. **리소스 URI에 버전 포함 검토:** `waiaas://skills/wallet?v=1.4.6` -- MCP spec이 query parameter를 허용하는지 확인 필요.

**Phase:** MCP 리소스 확장 구현 시

---

### M-06: ALLOWED_NETWORKS 정책이 sign-only에서 chainId 기반으로만 작동

**Severity:** MEDIUM
**Confidence:** HIGH (현재 ALLOWED_NETWORKS 정책 코드 분석)

**What goes wrong:**
현재 ALLOWED_NETWORKS 정책은 `transaction.network` 필드(WAIaaS NetworkType enum 값)와 비교한다. Sign-only에서:

**EVM:**
- unsigned tx의 RLP에 `chainId` 포함 (EIP-155)
- `chainId` → NetworkType 매핑 필요 (1 → 'ethereum-mainnet', 11155111 → 'ethereum-sepolia' 등)
- 매핑 테이블에 없는 chainId → network 분류 불가 → ALLOWED_NETWORKS 평가 불가

**Solana:**
- unsigned tx에 network 정보가 없음 (Solana tx에는 chainId 개념 없음)
- network는 RPC 엔드포인트로만 결정됨
- sign-only 요청 시 `network` 파라미터를 별도로 받아야 함

**Why it happens:**
- 기존 파이프라인에서는 `resolveNetwork()`가 wallet.environment와 wallet.defaultNetwork에서 network를 결정
- Sign-only에서는 unsigned tx 자체에서 network를 추출해야 하지만, 체인마다 방법이 다름

**Prevention:**
1. **EVM chainId → NetworkType 매핑 함수:** `evm-chain-map.ts`에 이미 chain 정보가 있으므로 확장하여 chainId → NetworkType 매핑 제공. 매핑 실패 시 deny.
2. **Solana sign-only API에 `network` 필수 파라미터:** Solana tx에서 network를 추출할 수 없으므로 API 요청 시 명시적으로 받음.
3. **cross-chain 검증:** EVM tx의 chainId와 wallet의 environment/defaultNetwork가 일치하는지 추가 검증. 불일치 시 deny ("Wallet is configured for ethereum-sepolia but transaction targets chainId 1").

**Phase:** Sign-only API 인터페이스 설계 시

---

## Phase-Specific Warning Summary

| Phase Topic | Likely Pitfall | Severity | Mitigation Key |
|-------------|---------------|----------|---------------|
| **아키텍처 설계 (첫 phase)** | C-03: DELAY/APPROVAL과 동기적 sign-only 비호환 | CRITICAL | 방안 A(INSTANT/NOTIFY만 허용) 권장 |
| **Unsigned TX 파서** | C-01: 파싱 불완전 → 정책 우회 | CRITICAL | 파싱 실패 = DENY, ALT resolve 필수 |
| **Unsigned TX 파서** | H-02: Legacy vs V0 분기 누락 | HIGH | 양쪽 format 모두 지원 |
| **Unsigned TX 파서** | H-03: ABI 없는 calldata 디코딩 한계 | HIGH | 알려진 패턴만 파싱, 나머지 CONTRACT_CALL |
| **정책 매핑 레이어** | H-04: 11개 PolicyType 불완전 매핑 | HIGH | confidence 필드 + fallback 정책 |
| **정책 통합** | C-02: reserved_amount 영원히 해제 안 됨 | CRITICAL | TTL 기반 자동 해제 |
| **DB 스키마 확장** | H-05: Transaction 상태 모델 충돌 | HIGH | SIGNED 상태 추가 + signOnly 플래그 |
| **Default Deny 토글** | H-01: 기존 정책 의미 역전 | HIGH | 정책 타입별 제어 + 영향도 미리보기 |
| **Sign-only API 설계** | M-02: 서명 포맷 불일치 | MEDIUM | 체인별 표준 포맷 + encoding 명시 |
| **Sign-only API 설계** | M-06: ALLOWED_NETWORKS chainId 매핑 | MEDIUM | chainId→NetworkType 매핑 + cross-chain 검증 |
| **기능 스코프** | M-03: calldata encoding 역할 혼동 | MEDIUM | 명확한 역할 분리 + API 분리 |
| **알림 통합** | M-04: NOTIFY 알림 누락/이중 발송 | MEDIUM | TX_SIGN_REQUESTED/TX_SIGNED 이벤트 추가 |
| **MCP 리소스** | M-01: Skill 리소스 Content Negotiation | MEDIUM | MIME 타입 정확 설정 + 파일 기반 로더 |
| **MCP 리소스** | M-05: Skill 파일 캐시 정합성 | MEDIUM | 매 요청마다 파일 읽기 |

---

## Integration Risk Matrix

기존 코드 컴포넌트별 sign-only 추가 시 영향도:

| 컴포넌트 | 변경 필요 | 위험도 | 주의사항 |
|----------|:--------:|:------:|---------|
| `pipeline.ts` | 신규 `executeSign()` 메서드 추가 | HIGH | 기존 `executeSend()`에 영향 주지 않아야 함 |
| `stages.ts` | stage1~3 재사용, stage4~6 분기 | HIGH | PipelineContext에 `signOnly` 플래그 추가 |
| `database-policy-engine.ts` | `evaluateAndReserve` TTL 로직 추가 | HIGH | 기존 reservation 쿼리 변경 시 TOCTOU 재검증 |
| `schema.ts` | transactions CHECK 제약 변경 | MEDIUM | DB 마이그레이션 필수 (MIG 패턴) |
| `@waiaas/core` enums | TRANSACTION_STATUSES에 SIGNED 추가 | MEDIUM | 모든 패키지 재빌드 |
| `mcp/server.ts` | Skill 리소스 등록 추가 | LOW | 기존 리소스에 영향 없음 |
| `admin UI` | sign-only tx 표시 | LOW | 새 탭/필터 추가 |
| `notification-service.ts` | 새 이벤트 타입 추가 | LOW | 기존 이벤트에 영향 없음 |

---

## Sources

### HIGH Confidence
- WAIaaS 코드베이스 직접 분석: `pipeline.ts`, `stages.ts`, `database-policy-engine.ts`, `schema.ts` (v1.4.6)
- [viem parseTransaction 문서](https://v1.viem.sh/docs/utilities/parseTransaction.html) -- EVM unsigned tx 파싱 지원 확인
- [Solana Versioned Transactions 가이드](https://solana.com/developers/guides/advanced/versions) -- Legacy vs V0, ALT 구조
- [EVM Calldata 디코딩 연구 (Jonathan Becker)](https://www.jbecker.dev/research/decoding-raw-calldata) -- ABI 없는 calldata 파싱 한계와 모호성
- [QuickNode: Transaction Calldata Demystified](https://www.quicknode.com/guides/ethereum-development/transactions/ethereum-transaction-calldata) -- 4-byte selector, ABI encoding 구조
- [Solana Token Program 문서](https://spl.solana.com/token) -- SPL Token instruction 분류 (Transfer, TransferChecked, Approve)
- [Solana VersionedTransaction Deserialization Issue #34608](https://github.com/solana-labs/solana/issues/34608) -- JSON 직렬화/역직렬화 문제

### MEDIUM Confidence
- [MCP Best Practices: Architecture & Implementation Guide](https://modelcontextprotocol.info/docs/best-practices/) -- MCP 리소스 구현 패턴
- [Implementing MCP: Tips, Tricks and Pitfalls (Nearform)](https://nearform.com/digital-community/implementing-model-context-protocol-mcp-tips-tricks-and-pitfalls/) -- MCP 구현 시 common mistakes
- [MCP Specification (2025-11-25)](https://modelcontextprotocol.io/specification/2025-11-25) -- 리소스 핸들러, MIME 타입, 출력 스키마 규격
- [Circle Signing APIs](https://developers.circle.com/wallets/signing-apis) -- 지갑 서명 API 보안 고려사항
- [Turnkey EVM Transaction Parsing](https://docs.turnkey.com/networks/ethereum) -- EVM unsigned tx 파싱 + policy engine 연동 사례

### LOW Confidence (아키텍처적 추론 기반)
- SPENDING_LIMIT reservation TTL 전략 -- 기존 사례 미발견, 논리적 추론
- DELAY/APPROVAL과 sign-only 비호환 해결 패턴 -- 기존 wallet-as-a-service 사례에서 sign-only를 INSTANT 전용으로 제한하는 패턴은 확인했으나, 대안 패턴(2-phase sign)은 추론
- MCP Skill 리소스 캐싱 동작 -- MCP SDK의 리소스 캐싱 메커니즘에 대한 공식 문서 부족
