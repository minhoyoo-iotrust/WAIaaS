# Architecture Research: MCP 세션 관리 자동화

**연구일:** 2026-02-09
**전체 신뢰도:** HIGH (v0.5 세션 갱신 프로토콜(53), MCP 인터페이스(38), Telegram Bot(40), CLI 플로우(54), 알림 아키텍처(35), 모노레포 구조(24) 직접 분석 기반)

---

## 1. 핵심 아키텍처 변경 요약

v0.9는 **기존 MCP Server(`@waiaas/mcp`)에 SessionManager를 추가하고, 기존 TelegramBotService와 CLI에 토큰 파일 관리 기능을 확장하는 마일스톤**이다. 변경의 본질은 "MCP 프로세스가 환경변수의 고정 토큰에 의존한다"는 가정을 "MCP 프로세스가 파일 기반으로 토큰을 자율 관리한다"로 전환하는 것이다.

**아키텍처적 영향:**
- `@waiaas/mcp` 패키지에 SessionManager 싱글턴 추가: 토큰 로드, 자동 갱신, 파일 영속화, 401 시 재로드
- `~/.waiaas/mcp-token` 파일 신규: daemon, MCP server, Telegram bot, CLI 4개 컴포넌트 공유 자원
- `@waiaas/mcp` tool handler 전체의 토큰 참조 방식 변경: 상수 `SESSION_TOKEN` -> `sessionManager.getToken()`
- TelegramBotService에 `/newsession` 명령어 1개 추가 + 파일 쓰기 기능
- CLI에 `mcp setup`, `mcp refresh-token` 커맨드 2개 추가
- NotificationService에 `SESSION_EXPIRING_SOON` 이벤트 1개 추가 (16개 -> 17개)

**변경하지 않는 것:**
- 데몬의 세션 갱신 API (PUT /v1/sessions/:id/renew) -- 기존 그대로
- 세션 갱신 프로토콜의 5종 안전 장치 -- 기존 그대로
- MCP Server의 6개 Tool + 3개 Resource 구조 -- tool 추가 없음
- MCP stdio transport 방식 -- 기존 그대로
- Telegram Bot의 2-Tier 인증 모델 -- 기존 그대로
- SQLite 스키마 -- 변경 없음 (agents.default_constraints 추가 검토만)

---

## 2. 통합 지점 분석

### 2.1 SessionManager와 MCP Tool Handler 통합

**현재 구조 (v0.8 확정):**

```
packages/mcp/src/server.ts:
  const SESSION_TOKEN = process.env.WAIAAS_SESSION_TOKEN ?? ''
  // 모든 tool에서 SESSION_TOKEN 상수 직접 참조
  headers: { 'Authorization': `Bearer ${SESSION_TOKEN}` }
```

**v0.9 변경:**

```
packages/mcp/src/server.ts:
  const sessionManager = new SessionManager({ ... })

  // 모든 tool에서 sessionManager.getToken() 호출
  headers: { 'Authorization': `Bearer ${sessionManager.getToken()}` }
```

**통합 패턴:** SessionManager 인스턴스를 `createMcpServer()` 함수에서 생성하고, 각 tool/resource 등록 함수에 전달한다. MCP SDK의 `server.tool()` 콜백 내부에서 `sessionManager.getToken()`을 호출하는 클로저 패턴을 사용한다.

```typescript
// packages/mcp/src/server.ts (v0.9)
export function createMcpServer(): { server: McpServer; sessionManager: SessionManager } {
  const sessionManager = new SessionManager({
    tokenFilePath: path.join(os.homedir(), '.waiaas', 'mcp-token'),
    envToken: process.env.WAIAAS_SESSION_TOKEN,
    baseUrl: process.env.WAIAAS_BASE_URL ?? 'http://127.0.0.1:3100',
  })

  const server = new McpServer({
    name: 'waiaas-wallet',
    version: '0.9.0',
  })

  // sessionManager를 tool 등록 함수에 전달
  registerTools(server, sessionManager)
  registerResources(server, sessionManager)

  return { server, sessionManager }
}
```

**tool handler 변경 범위:**

| 파일 | 변경 | 영향 |
|------|------|------|
| `tools/send-token.ts` | `SESSION_TOKEN` -> `sessionManager.getToken()` | 소 |
| `tools/get-balance.ts` | 동일 | 소 |
| `tools/get-address.ts` | 동일 | 소 |
| `tools/list-transactions.ts` | 동일 | 소 |
| `tools/get-transaction.ts` | 동일 | 소 |
| `tools/get-nonce.ts` | 인증 불필요 (유지) | 없음 |
| `resources/wallet-balance.ts` | `SESSION_TOKEN` -> `sessionManager.getToken()` | 소 |
| `resources/wallet-address.ts` | 동일 | 소 |
| `resources/system-status.ts` | 동일 | 소 |
| `internal/api-client.ts` | SessionManager 참조로 전환 | 중 |

**핵심 설계 결정: api-client.ts 리팩토링**

현재 각 tool이 `fetch()` 를 직접 호출하고 `SESSION_TOKEN`을 하드코딩한다. v0.9에서 `api-client.ts`에 토큰 주입을 집중하면 변경 지점을 단일화할 수 있다.

```typescript
// packages/mcp/src/internal/api-client.ts (v0.9 리팩토링)
export class ApiClient {
  constructor(
    private baseUrl: string,
    private sessionManager: SessionManager,
  ) {}

  async get(path: string): Promise<Response> {
    return fetch(`${this.baseUrl}${path}`, {
      headers: { 'Authorization': `Bearer ${this.sessionManager.getToken()}` },
    })
  }

  async post(path: string, body: unknown): Promise<Response> {
    return fetch(`${this.baseUrl}${path}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.sessionManager.getToken()}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    })
  }

  /**
   * 401 수신 시 토큰 재로드 후 1회 재시도
   */
  async getWithRetry(path: string): Promise<Response> {
    const res = await this.get(path)
    if (res.status === 401) {
      const reloaded = await this.sessionManager.tryReloadFromFile()
      if (reloaded) {
        return this.get(path)
      }
    }
    return res
  }

  async postWithRetry(path: string, body: unknown): Promise<Response> {
    const res = await this.post(path, body)
    if (res.status === 401) {
      const reloaded = await this.sessionManager.tryReloadFromFile()
      if (reloaded) {
        return this.post(path, body)
      }
    }
    return res
  }
}
```

이 패턴의 장점:
1. tool handler는 `apiClient.getWithRetry('/v1/wallet/balance')`만 호출
2. 401 재시도 로직이 한 곳에 집중
3. SessionManager 의존성이 ApiClient에만 존재
4. 기존 6개 tool + 3개 resource의 변경이 `SESSION_TOKEN` -> `apiClient` 교체로 단순화

### 2.2 토큰 파일(`~/.waiaas/mcp-token`) 소유권 모델

**핵심 문제:** `~/.waiaas/mcp-token` 파일에 4개 컴포넌트가 접근한다.

| 컴포넌트 | 프로세스 | 읽기 | 쓰기 | 시점 |
|----------|---------|:----:|:----:|------|
| **MCP Server** | Claude Desktop 자식 프로세스 | O | O | 시작 시 로드, 갱신 성공 시 저장 |
| **Daemon (SessionService)** | 데몬 메인 프로세스 | X | X | 직접 접근 안 함 (API 응답으로 토큰 반환) |
| **Telegram Bot** | 데몬 내부 (동일 프로세스) | X | O | `/newsession` 시 새 토큰 저장 |
| **CLI** | 독립 프로세스 | X | O | `mcp setup`, `mcp refresh-token` 시 저장 |

**Self-Hosted 전제의 핵심 이점:** 모든 프로세스가 동일 머신, 동일 OS 사용자로 실행된다. 따라서:
- 파일시스템 권한으로 접근 제어 충분 (`0o600`)
- 네트워크 기반 토큰 전달 불필요
- 프로세스간 통신(IPC) 불필요 -- 파일이 곧 IPC 채널

**소유권 규칙:**

```
쓰기 우선순위 (충돌 시):
  1. CLI / Telegram Bot (새 세션 생성 = 새 토큰)
  2. MCP SessionManager (갱신 = 기존 세션의 새 토큰)

읽기:
  1. MCP SessionManager만 (시작 시, 401 수신 시)
```

**충돌 시나리오 분석:**

| 시나리오 | 발생 조건 | 결과 | 대응 |
|---------|----------|------|------|
| MCP 갱신 중 Telegram 새 세션 | 동시 파일 쓰기 | 원자적 쓰기로 안전 | 마지막 쓰기 승리 (둘 다 유효한 토큰) |
| Telegram 직후 MCP 갱신 | 기존 토큰으로 갱신 시도 | 성공 (기존 세션 아직 유효) | MCP가 새 세션 모름 -> 401 시 재로드 |
| CLI refresh 중 MCP 갱신 | CLI가 기존 세션 폐기 + 새 세션 생성 | MCP 갱신 실패 (기존 세션 폐기됨) | MCP에서 401 -> 파일 재로드 -> 새 토큰 |

**모든 시나리오에서 MCP의 401 재로드가 최종 안전장치로 동작한다.** 이는 v0.9 objectives에서 설계한 "lazy reload" 패턴의 정당성을 뒷받침한다.

### 2.3 원자적 파일 쓰기 패턴

토큰 파일 쓰기 시 `write-file-atomic` 패턴을 적용하여 부분 쓰기를 방지한다.

```typescript
import { writeFileSync, renameSync, unlinkSync } from 'node:fs'
import { randomBytes } from 'node:crypto'

function atomicWriteToken(filePath: string, token: string): void {
  const tmpPath = `${filePath}.${randomBytes(4).toString('hex')}.tmp`
  try {
    writeFileSync(tmpPath, token, { mode: 0o600, encoding: 'utf-8' })
    renameSync(tmpPath, filePath)  // POSIX atomic rename
  } catch (err) {
    try { unlinkSync(tmpPath) } catch {}  // cleanup on failure
    throw err
  }
}
```

**이 패턴을 사용하는 컴포넌트:**
- `SessionManager.persistToken()` (MCP 프로세스)
- `TelegramBotService./newsession` 핸들러 (데몬 프로세스)
- CLI `mcp setup` / `mcp refresh-token` (CLI 프로세스)

세 컴포넌트 모두 동일한 유틸리티 함수를 공유해야 한다. 이 함수는 `@waiaas/core`에 배치하거나, `@waiaas/cli`와 `@waiaas/mcp`가 각각 구현할 수 있다. **추천: `@waiaas/core`의 `utils/token-file.ts`에 배치.** CLI, MCP, daemon 모두 `@waiaas/core`를 의존하므로 코드 중복 방지.

```typescript
// packages/core/src/utils/token-file.ts
export const MCP_TOKEN_FILENAME = 'mcp-token'

export function getMcpTokenPath(dataDir?: string): string {
  const dir = dataDir ?? path.join(os.homedir(), '.waiaas')
  return path.join(dir, MCP_TOKEN_FILENAME)
}

export function writeMcpToken(filePath: string, token: string): void {
  // atomic write (위 패턴)
}

export function readMcpToken(filePath: string): string | null {
  // 파일 존재 확인, 권한 검증 (0o600), symlink 거부, 읽기
}
```

### 2.4 MCP stdio 프로세스 생명주기와 SessionManager

**MCP 프로세스 모델 (MCP 스펙 기반):**

```
Claude Desktop 시작
  -> claude_desktop_config.json 읽기
  -> MCP Server 자식 프로세스 생성 (npx @waiaas/mcp)
  -> 환경변수 WAIAAS_SESSION_TOKEN 전달
  -> stdio 연결 (stdin/stdout JSON-RPC)
  -> MCP Lifecycle: initialize -> initialized -> 운영
  -> 대화 종료 또는 타임아웃
  -> Claude Desktop이 MCP 프로세스 종료 (SIGTERM 또는 stdin 닫기)
```

**SessionManager 생명주기와의 정합:**

```
MCP 프로세스 시작
  ├─ index.ts: createMcpServer() 호출
  │   └─ SessionManager 생성
  │       ├─ loadToken(): 파일 > env var 우선순위
  │       ├─ JWT 디코딩 (서명 미검증, exp/sid 추출)
  │       └─ start(): 갱신 타이머 스케줄링
  │
  ├─ server.connect(transport): stdio 연결
  │
  ├─ [운영 중]
  │   ├─ tool 호출 -> sessionManager.getToken() -> API 호출
  │   ├─ 60% TTL 경과 -> renew() -> 새 토큰 -> 파일 저장
  │   └─ 401 수신 -> tryReloadFromFile() -> 새 토큰 시도
  │
  └─ MCP 프로세스 종료
      └─ sessionManager.dispose(): 타이머 해제
```

**프로세스 재시작 시 동작:**

```
프로세스 재시작 (Claude Desktop이 MCP 서버 재생성)
  ├─ SessionManager 새 인스턴스 생성
  ├─ loadToken():
  │   ├─ ~/.waiaas/mcp-token 파일 존재?
  │   │   ├─ Yes: 파일 토큰 사용 (이전 인스턴스가 갱신한 최신 토큰)
  │   │   └─ No: env var WAIAAS_SESSION_TOKEN 사용 (최초 부트스트랩)
  │   └─ JWT exp 확인
  │       ├─ 유효: 정상 운영 시작 + 갱신 스케줄
  │       └─ 만료: 에러 상태 -> LLM에 안내 메시지
  └─ 정상 운영 시작
```

**핵심:** 파일 기반 영속화 덕분에 프로세스 재시작이 투명하다. 이전 인스턴스가 갱신한 토큰이 파일에 남아 있으므로, 새 인스턴스는 최신 토큰을 즉시 사용할 수 있다. env var의 초기 토큰은 파일이 없는 경우의 fallback으로만 동작한다.

### 2.5 Telegram `/newsession`과 기존 TelegramBotService 통합

**현재 TelegramBotService 구조 (40-telegram-bot-docker.md):**

```
TelegramBotService
├── commandHandlers: Map<string, CommandHandler>
│   ├── /status -> statusHandler
│   ├── /balance -> balanceHandler
│   ├── /agents -> agentsHandler
│   ├── /sessions -> sessionsHandler
│   ├── /approve -> approveHandler
│   ├── /reject -> rejectHandler
│   ├── /kill -> killHandler
│   └── /auth -> authHandler
├── Long Polling Loop
└── 서비스 의존성 (DI)
    ├── sessionService
    ├── transactionService
    ├── killSwitchService
    └── notificationChannel (TelegramChannel)
```

**v0.9 추가:**

```
TelegramBotService
├── commandHandlers: Map<string, CommandHandler>
│   ├── (기존 8개)
│   └── /newsession -> newsessionHandler  // [v0.9 추가]
├── Long Polling Loop
└── 서비스 의존성 (DI)
    ├── (기존 4개)
    ├── agentService                      // [v0.9 추가] 에이전트 목록 조회용
    └── tokenFileWriter                   // [v0.9 추가] mcp-token 파일 쓰기용
```

**`/newsession` 처리 흐름 상세:**

```
1. Owner: /newsession
2. isAuthorizedOwner(chatId) 검증 -> Tier 1 (chatId)
3. agentService.listActive() -> 에이전트 목록
4. 인라인 키보드 표시: [Agent 1] [Agent 2] ...
5. Owner: [에이전트 선택]
6. 기본 constraints 결정:
   ├─ agents.default_constraints (DB)
   ├─ config.toml [session].default_constraints
   └─ 하드코딩 기본값
7. sessionService.create({ agentId, constraints })
   └─ 내부적으로 masterAuth implicit (봇이 데몬 내부에서 직접 호출)
8. writeMcpToken(tokenFilePath, newToken)
   └─ 원자적 쓰기 (0o600)
9. Telegram 완료 메시지 전송
10. MCP Server:
    └─ 다음 API 호출 시 401 수신 -> tryReloadFromFile() -> 새 토큰 사용
```

**Race condition 분석:**

| 경합 | 발생 확률 | 영향 | 대응 |
|------|:--------:|------|------|
| Bot 쓰기 + MCP 갱신 동시 | 극히 낮음 (ms 단위 겹침) | 둘 중 하나 덮어쓰기 | 원자적 rename으로 파일 무결성 보장. MCP 401 시 재로드. |
| Bot 쓰기 완료 전 MCP 읽기 | 낮음 | MCP가 불완전 토큰 읽기 | 원자적 rename으로 방지. rename 전에는 기존 파일 유지. |
| Bot 새 세션 + MCP 기존 세션 갱신 | 보통 | MCP 갱신 성공 (기존 세션 아직 유효) | Bot이 기존 세션 명시적 폐기하면 MCP 401 -> 재로드 |

**결론:** 원자적 파일 쓰기 + MCP의 401 lazy reload 조합으로 모든 race condition이 안전하게 해결된다. `fs.watch` 같은 실시간 감시는 불필요하다.

### 2.6 CLI `mcp setup` / `mcp refresh-token`과 기존 CLI 통합

**현재 CLI 구조 (54-cli-flow-redesign.md):**

```
packages/cli/src/commands/
├── init.ts
├── start.ts
├── stop.ts
├── status.ts
├── agent/
│   ├── create.ts
│   ├── list.ts
│   ├── info.ts
│   ├── set-owner.ts      [v0.8]
│   └── remove-owner.ts   [v0.8]
├── session/
│   └── create.ts
├── owner/
│   └── withdraw.ts       [v0.8]
└── backup.ts
```

**v0.9 추가:**

```
packages/cli/src/commands/
├── (기존)
└── mcp/
    ├── setup.ts           [v0.9]
    └── refresh-token.ts   [v0.9]
```

**`mcp setup` 데이터 흐름:**

```
waiaas mcp setup --agent-id <id> [--expires-in 604800] [--constraints '...']
  ↓
1. 데몬 상태 확인 (GET /health)
   ├─ 데몬 미기동: 에러 메시지 + "waiaas start 먼저 실행하세요"
   └─ 데몬 응답: 계속
  ↓
2. masterAuth implicit 세션 생성
   POST /v1/sessions { agentId, expiresIn, constraints }
   └─ X-Master-Password: <stdin 또는 env var>
  ↓
3. 응답에서 token 추출
  ↓
4. writeMcpToken(getMcpTokenPath(), token)  // 원자적, 0o600
  ↓
5. stdout에 안내 메시지 출력:
   - 토큰 파일 경로
   - 만료 시각
   - Claude Desktop config.json 경로 안내 (최초 1회)
```

**에러 처리 (데몬 미기동 시):**

```typescript
// packages/cli/src/commands/mcp/setup.ts
async function mcpSetup(options: McpSetupOptions): Promise<void> {
  // 1. 데몬 접근 가능 여부 확인
  try {
    const health = await fetch(`${options.baseUrl}/health`)
    if (!health.ok) throw new Error('Daemon unhealthy')
  } catch (err) {
    console.error('Error: WAIaaS daemon is not running.')
    console.error('Start the daemon first: waiaas start')
    process.exit(1)
  }

  // 2. 세션 생성 (기존 session create 로직 재사용)
  const result = await createSession({
    agentId: options.agentId,
    expiresIn: options.expiresIn ?? 604800,
    constraints: options.constraints,
    masterPassword: await resolveMasterPassword(),
    baseUrl: options.baseUrl,
  })

  // 3. 토큰 파일 저장
  const tokenPath = getMcpTokenPath()
  writeMcpToken(tokenPath, result.token)

  // 4. 안내 출력
  console.log(`MCP session created for agent "${options.agentId}"`)
  console.log(`Token saved to ${tokenPath}`)
  console.log(`Expires: ${result.expiresAt} (${formatDuration(options.expiresIn ?? 604800)})`)
  // ...
}
```

### 2.7 SESSION_EXPIRING_SOON 알림 통합

**현재 NotificationEventType (35-notification-architecture.md, v0.8 기준 16개):**

```typescript
const NotificationEventType = {
  TX_NOTIFY: 'TX_NOTIFY',
  TX_DELAY_QUEUED: 'TX_DELAY_QUEUED',
  TX_DOWNGRADED_DELAY: 'TX_DOWNGRADED_DELAY',     // v0.8
  TX_DELAY_EXECUTED: 'TX_DELAY_EXECUTED',
  TX_APPROVAL_REQUEST: 'TX_APPROVAL_REQUEST',
  TX_APPROVAL_EXPIRED: 'TX_APPROVAL_EXPIRED',
  TX_CONFIRMED: 'TX_CONFIRMED',
  TX_FAILED: 'TX_FAILED',
  KILL_SWITCH_ACTIVATED: 'KILL_SWITCH_ACTIVATED',
  KILL_SWITCH_RECOVERED: 'KILL_SWITCH_RECOVERED',
  AUTO_STOP_TRIGGERED: 'AUTO_STOP_TRIGGERED',
  SESSION_CREATED: 'SESSION_CREATED',
  SESSION_REVOKED: 'SESSION_REVOKED',
  SESSION_RENEWED: 'SESSION_RENEWED',
  SESSION_RENEWAL_REJECTED: 'SESSION_RENEWAL_REJECTED',
  DAILY_SUMMARY: 'DAILY_SUMMARY',
} as const
```

**v0.9 추가 (+1 = 17개):**

```typescript
SESSION_EXPIRING_SOON: 'SESSION_EXPIRING_SOON'     // v0.9
```

**발생 트리거 지점:**

이 이벤트의 트리거는 **MCP SessionManager 프로세스 내부**에서 발생하지만, **데몬의 NotificationService**를 통해 전송된다. 문제: MCP 프로세스는 데몬 외부에 있으므로 NotificationService에 직접 접근할 수 없다.

**해결 방안: 데몬 API 경유**

```
MCP SessionManager:
  갱신 실패 (RENEWAL_LIMIT_REACHED 또는 SESSION_LIFETIME_EXCEEDED)
  ↓
  POST /v1/notifications/session-expiring (API 호출)
  또는 기존 갱신 응답에서 데몬이 자동 판단
```

**추천: 데몬 측 자동 판단.** 이유:
- 갱신 API (PUT /v1/sessions/:id/renew) 호출 시 데몬이 `renewal_count`, `max_renewals`, `absolute_expires_at`를 알고 있음
- 갱신 응답에서 `remainingRenewals <= 3` 또는 `absoluteExpiresAt - now <= 24h` 조건 충족 시 자동 알림
- MCP에 별도 알림 API 호출 로직 추가 불필요
- MCP는 갱신만 시도하고, 데몬이 상태 기반으로 알림 결정

```typescript
// packages/daemon/src/services/session-service.ts (v0.9 보완)
async renewSession(sessionId: string): Promise<RenewalResult> {
  // ... 기존 갱신 로직 ...

  // [v0.9] 만료 임박 알림 판단
  const remainingRenewals = session.maxRenewals - newRenewalCount
  const timeToAbsoluteExpiry = session.absoluteExpiresAt - now
  const EXPIRING_THRESHOLD_SECONDS = 24 * 60 * 60  // 24시간
  const RENEWAL_THRESHOLD = 3

  if (remainingRenewals <= RENEWAL_THRESHOLD || timeToAbsoluteExpiry <= EXPIRING_THRESHOLD_SECONDS) {
    await this.notificationService.notify({
      eventType: 'SESSION_EXPIRING_SOON',
      severity: 'warning',
      data: {
        sessionId,
        agentName: agent.name,
        expiresAt: session.absoluteExpiresAt,
        remainingRenewals,
      },
    })
  }

  return result
}
```

---

## 3. 신규 컴포넌트

### 3.1 SessionManager 클래스

| 항목 | 값 |
|------|-----|
| **패키지** | `@waiaas/mcp` |
| **파일** | `packages/mcp/src/session-manager.ts` |
| **타입** | 클래스 (싱글턴 인스턴스, 서버당 1개) |
| **의존성** | `@waiaas/core` (token-file 유틸리티), Node.js `fs`, `timers` |

```typescript
class SessionManager {
  // 상태
  private token: string
  private sessionId: string
  private expiresAt: number       // epoch ms
  private expiresIn: number       // original TTL (ms)
  private renewalCount: number
  private maxRenewals: number
  private timer: NodeJS.Timeout | null = null
  private renewing: boolean = false  // 동시 갱신 방지

  // 설정
  private readonly tokenFilePath: string
  private readonly baseUrl: string

  // 퍼블릭 API
  getToken(): string                           // tool handler용
  async start(): Promise<void>                 // 갱신 스케줄러 시작
  dispose(): void                              // 정리
  async tryReloadFromFile(): Promise<boolean>  // 401 시 호출
}
```

### 3.2 토큰 파일 유틸리티

| 항목 | 값 |
|------|-----|
| **패키지** | `@waiaas/core` |
| **파일** | `packages/core/src/utils/token-file.ts` |
| **Export** | `getMcpTokenPath()`, `writeMcpToken()`, `readMcpToken()` |

### 3.3 ApiClient 리팩토링

| 항목 | 값 |
|------|-----|
| **패키지** | `@waiaas/mcp` |
| **파일** | `packages/mcp/src/internal/api-client.ts` |
| **변경** | 기존 fetch 래퍼에 SessionManager 참조 추가, 401 자동 재시도 |

---

## 4. 수정 대상 컴포넌트

| 컴포넌트 | 패키지 | 변경 규모 | 변경 내용 | 설계 문서 |
|----------|--------|:---------:|----------|-----------|
| **MCP Server 초기화** | `@waiaas/mcp` | **대** | SessionManager 생성/시작, tool handler에 전달, dispose 연결 | SDK-MCP (38) |
| **MCP tool/resource handlers** | `@waiaas/mcp` | 중 | `SESSION_TOKEN` -> `apiClient.getWithRetry()` 전환 (8개 파일) | SDK-MCP (38) |
| **MCP api-client** | `@waiaas/mcp` | 중 | SessionManager 참조, 401 자동 재시도 | SDK-MCP (38) |
| **TelegramBotService** | `@waiaas/daemon` | 중 | `/newsession` 명령어 + 인라인 키보드 + 토큰 파일 쓰기 | TGBOT-DOCK (40) |
| **NotificationService** | `@waiaas/daemon` | 소 | SESSION_EXPIRING_SOON 이벤트 타입 1개 추가 | NOTI-ARCH (35) |
| **SessionService (데몬)** | `@waiaas/daemon` | 소 | 갱신 시 만료 임박 알림 트리거 조건 추가 | SESS-RENEW (53) |
| **CLI 커맨드 구조** | `@waiaas/cli` | 중 | `mcp` 서브커맨드 그룹 + setup/refresh-token 2개 | CLI-REDESIGN (54) |
| **데이터 디렉토리 스펙** | `@waiaas/core` | 소 | `~/.waiaas/mcp-token` 파일 사양 추가 | CORE-01 (24) |
| **BotFather 명령어 목록** | 문서만 | 소 | `newsession - Create new MCP session` 추가 | TGBOT-DOCK (40) |

---

## 5. 완전 데이터 흐름

### 5.1 정상 운영 흐름 (자동 갱신)

```
[1] Claude Desktop 시작
    └─ MCP 프로세스 생성: npx @waiaas/mcp
       env: WAIAAS_SESSION_TOKEN=wai_sess_eyJ...

[2] SessionManager 초기화
    ├─ loadToken():
    │   ├─ ~/.waiaas/mcp-token 존재? Yes -> 파일 토큰 사용
    │   └─ No -> env var 토큰 사용
    ├─ JWT 디코딩: sid=019502a8..., exp=2026-02-16T14:00Z
    └─ start(): setTimeout(renew, expiresIn * 0.6)

[3] Tool 호출 (정상)
    Claude: "잔액 확인해줘"
    └─ get_balance tool
       └─ apiClient.getWithRetry('/v1/wallet/balance')
          └─ Authorization: Bearer {sessionManager.getToken()}
          └─ 200 OK -> 결과 반환

[4] 자동 갱신 (4.2일 후)
    SessionManager.renew():
    ├─ PUT http://127.0.0.1:3100/v1/sessions/019502a8.../renew
    │   Authorization: Bearer {currentToken}
    ├─ 200 OK: { token: "wai_sess_NEW...", expiresAt, renewalCount }
    ├─ 메모리: token = newToken, expiresAt = newExpiry
    ├─ 파일: writeMcpToken(~/.waiaas/mcp-token, newToken)
    └─ 타이머: 다음 갱신 재스케줄

[5] 데몬 측 (갱신 응답 후)
    SessionService:
    ├─ 기존 token_hash 교체, renewal_count++
    ├─ remainingRenewals = 27 (> 3) -> 알림 없음
    └─ SESSION_RENEWED 알림 -> Owner Telegram

[6] 다음 Tool 호출
    └─ sessionManager.getToken() -> 새 토큰 반환
    └─ 정상 동작 계속
```

### 5.2 절대 수명 만료 -> Telegram 재생성 흐름

```
[1] SessionManager 갱신 시도
    PUT /v1/sessions/:id/renew -> 403 SESSION_LIFETIME_EXCEEDED
    └─ 갱신 포기

[2] 데몬: SESSION_EXPIRING_SOON 알림 (이전 갱신 시 이미 발송)
    -> Telegram: "세션 만료 임박, /newsession으로 재생성하세요"

[3] Owner: /newsession (Telegram)
    ├─ TelegramBotService:
    │   ├─ isAuthorizedOwner(chatId) 검증
    │   ├─ agentService.listActive() -> 에이전트 목록
    │   └─ 인라인 키보드: [trading-bot] [monitoring-bot]
    ├─ Owner: [trading-bot 선택]
    ├─ TelegramBotService:
    │   ├─ constraints = agents.default_constraints ?? config 기본값
    │   ├─ sessionService.create({ agentId, constraints })
    │   │   └─ masterAuth implicit (봇 = 데몬 내부)
    │   ├─ writeMcpToken(~/.waiaas/mcp-token, newToken)  // 원자적
    │   └─ Telegram 완료 메시지: "New session created. Token file updated."
    └─ 완료

[4] MCP Server (다음 tool 호출 시)
    ├─ apiClient.getWithRetry('/v1/wallet/balance')
    │   └─ Authorization: Bearer {oldExpiredToken}
    │   └─ 401 AUTH_TOKEN_EXPIRED
    ├─ tryReloadFromFile():
    │   ├─ readMcpToken(~/.waiaas/mcp-token)
    │   ├─ 파일 토큰 != 현재 토큰 -> 새 토큰으로 교체
    │   └─ return true
    ├─ 재시도: GET /v1/wallet/balance
    │   └─ Authorization: Bearer {newToken}
    │   └─ 200 OK
    └─ 갱신 스케줄 재시작

[5] 서비스 연속성 달성
    └─ MCP 프로세스 재시작 없이 새 세션으로 전환
    └─ Claude Desktop 대화 맥락 유지
```

### 5.3 CLI mcp setup 최초 설정 흐름

```
[1] Owner: waiaas mcp setup --agent-id trading-bot

[2] CLI:
    ├─ GET http://127.0.0.1:3100/health -> 200 (데몬 실행 중)
    ├─ masterAuth 해석 (stdin 프롬프트 또는 env var)
    ├─ POST /v1/sessions {
    │     agentId: "trading-bot",
    │     expiresIn: 604800,
    │     constraints: { /* 기본값 */ }
    │   }
    │   X-Master-Password: ****
    ├─ 200 OK: { token, sessionId, expiresAt }
    ├─ writeMcpToken(~/.waiaas/mcp-token, token)
    └─ stdout:
        "MCP session created for agent 'trading-bot'"
        "Token saved to ~/.waiaas/mcp-token"
        "Expires: 2026-02-16T14:00:00Z (7 days)"
        ""
        "Claude Desktop 설정에 다음을 추가하세요 (최초 1회):"
        "~/Library/Application Support/Claude/claude_desktop_config.json"
        "{ mcpServers: { waiaas-wallet: { command: 'npx', args: ['@waiaas/mcp'], env: { ... } } } }"

[3] Owner: Claude Desktop config.json에 MCP 서버 설정 추가 (최초 1회)

[4] Claude Desktop 시작 -> MCP 프로세스 시작
    └─ SessionManager: ~/.waiaas/mcp-token 파일에서 토큰 로드
    └─ 정상 운영 시작
```

### 5.4 CLI mcp setup 데몬 미기동 시

```
[1] Owner: waiaas mcp setup --agent-id trading-bot

[2] CLI:
    ├─ GET http://127.0.0.1:3100/health -> ECONNREFUSED
    ├─ stderr:
    │   "Error: WAIaaS daemon is not running."
    │   "Start the daemon first: waiaas start"
    └─ exit(1)
```

---

## 6. 컴포넌트 의존 관계 및 빌드 순서

### 6.1 의존 그래프

```
┌─────────────────────────────────────────────────────────────┐
│  Layer 0: 공유 유틸리티                                         │
│                                                              │
│  token-file.ts (getMcpTokenPath, writeMcpToken, readMcpToken)│
│  SESSION_EXPIRING_SOON 이벤트 타입 정의                       │
│                                                              │
│  패키지: @waiaas/core                                         │
└──────────────────────────┬──────────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           v               v               v
┌──────────────────┐ ┌──────────┐ ┌────────────────┐
│ Layer 1A:        │ │ Layer 1B:│ │ Layer 1C:      │
│ SessionManager   │ │ 데몬 측   │ │ CLI mcp        │
│ + ApiClient      │ │ 알림 통합 │ │ 서브커맨드      │
│                  │ │          │ │                │
│ SessionManager   │ │ Session  │ │ mcp setup      │
│ ApiClient        │ │ Service  │ │ mcp refresh    │
│ (401 재시도)     │ │ 만료 임박 │ │                │
│                  │ │ 알림     │ │                │
│ @waiaas/mcp      │ │ @waiaas/ │ │ @waiaas/cli    │
│                  │ │ daemon   │ │                │
└────────┬─────────┘ └────┬─────┘ └────────┬───────┘
         │                │               │
         │         ┌──────┘               │
         v         v                      v
┌────────────────────────┐  ┌───────────────────────┐
│ Layer 2A:              │  │ Layer 2B:             │
│ MCP tool/resource      │  │ Telegram /newsession  │
│ 핸들러 마이그레이션     │  │ 인라인 키보드 + 파일  │
│                        │  │                       │
│ @waiaas/mcp            │  │ @waiaas/daemon        │
└───────────┬────────────┘  └───────────┬───────────┘
            │                           │
            v                           v
┌─────────────────────────────────────────────────────┐
│ Layer 3: 통합 테스트 + 설계 문서 업데이트                │
│                                                      │
│  E2E: SessionManager -> 갱신 -> 파일 저장 -> 재로드   │
│  E2E: Telegram /newsession -> 파일 -> MCP 401 재로드  │
│  E2E: CLI mcp setup -> 파일 -> MCP 시작               │
│  설계 문서 7개 v0.9 통합                                │
│                                                      │
│  @waiaas/mcp, @waiaas/daemon, @waiaas/cli            │
└─────────────────────────────────────────────────────┘
```

### 6.2 추천 빌드 순서 (페이즈 구조 제안)

**Phase A: 공유 인프라 (Layer 0)**

| # | 작업 | 패키지 | 산출물 |
|---|------|--------|--------|
| 1 | token-file.ts 유틸리티 구현 | `@waiaas/core` | getMcpTokenPath, writeMcpToken, readMcpToken |
| 2 | SESSION_EXPIRING_SOON 이벤트 타입 추가 | `@waiaas/core` | NotificationEventType 확장 |
| 3 | `~/.waiaas/mcp-token` 파일 사양 CORE-01 반영 | 문서 | CORE-01 (24) 업데이트 |

**Phase B: SessionManager 핵심 (Layer 1A) -- 이 마일스톤의 핵심**

| # | 작업 | 패키지 | 산출물 |
|---|------|--------|--------|
| 4 | SessionManager 클래스 설계 | `@waiaas/mcp` | session-manager.ts 스펙 |
| 5 | ApiClient 리팩토링 설계 | `@waiaas/mcp` | api-client.ts 스펙 (401 자동 재시도) |
| 6 | MCP Server 초기화 변경 설계 | `@waiaas/mcp` | server.ts (createMcpServer 시그니처 변경) |
| 7 | Tool/Resource 핸들러 마이그레이션 설계 | `@waiaas/mcp` | SESSION_TOKEN -> apiClient 전환 스펙 |

**Phase C: 데몬 측 통합 (Layer 1B + 2B)**

| # | 작업 | 패키지 | 산출물 |
|---|------|--------|--------|
| 8 | SessionService 만료 임박 알림 트리거 설계 | `@waiaas/daemon` | 갱신 응답 후 알림 조건 |
| 9 | Telegram /newsession 설계 | `@waiaas/daemon` | 명령어 핸들러 + 인라인 키보드 + 파일 쓰기 |
| 10 | 기본 constraints 결정 규칙 설계 | `@waiaas/daemon` | agents.default_constraints 검토 |

**Phase D: CLI 확장 (Layer 1C)**

| # | 작업 | 패키지 | 산출물 |
|---|------|--------|--------|
| 11 | `waiaas mcp setup` 설계 | `@waiaas/cli` | 커맨드 인터페이스 + 데몬 API 호출 + 파일 쓰기 |
| 12 | `waiaas mcp refresh-token` 설계 | `@waiaas/cli` | 기존 세션 폐기 + 새 세션 + 파일 교체 |

**Phase E: 설계 문서 통합 (Layer 3)**

| # | 작업 | 대상 문서 | 변경 규모 |
|---|------|----------|:---------:|
| 13 | SDK-MCP (38) v0.9 통합 | 38-sdk-mcp-interface.md | 대 |
| 14 | NOTI-ARCH (35) v0.9 통합 | 35-notification-architecture.md | 소 |
| 15 | TGBOT-DOCK (40) v0.9 통합 | 40-telegram-bot-docker.md | 중 |
| 16 | CLI-REDESIGN (54) v0.9 통합 | 54-cli-flow-redesign.md | 중 |
| 17 | SESS-RENEW (53) v0.9 통합 | 53-session-renewal-protocol.md | 소 |
| 18 | CORE-01 (24) v0.9 통합 | 24-monorepo-data-directory.md | 소 |
| 19 | CORE-02 (25) v0.9 통합 | 25-sqlite-schema.md | 소 |

### 6.3 병렬 작업 가능 영역

| 작업 그룹 | 내용 | 선행 조건 |
|----------|------|----------|
| Phase A | 공유 유틸리티 | 없음 |
| Phase B | SessionManager + ApiClient | Phase A |
| Phase C | 데몬 알림 + Telegram | Phase A |
| Phase D | CLI mcp 커맨드 | Phase A |
| Phase E | 설계 문서 통합 | Phase B + C + D |

**Phase B, C, D는 Phase A 완료 후 병렬 가능.** 다만, 설계 마일스톤이므로 논리적 순서(B -> C -> D)로 진행하는 것이 일관성 유지에 유리하다.

---

## 7. 아키텍처 결정 근거

### 7.1 SessionManager 배치: `@waiaas/mcp` 내부 (확정)

**대안 검토:**

| 위치 | 장점 | 단점 |
|------|------|------|
| `@waiaas/core` | 재사용 가능 | MCP 전용 로직을 core에 넣는 것은 오염 |
| `@waiaas/sdk` | SDK와 공유 | SDK는 이미 `renewSession()` 자체 구현 보유 |
| **`@waiaas/mcp`** | **관심사 분리, MCP 전용** | **재사용 불가 (불필요)** |

**결정: `@waiaas/mcp`.** SessionManager는 MCP stdio 프로세스의 특수한 요구(파일 기반 영속화, 401 lazy reload)에 맞춤화된 컴포넌트이다. SDK는 메모리 내 토큰 관리로 충분하고, 데몬은 토큰을 발행하는 측이므로 자체 갱신이 불필요하다.

### 7.2 토큰 감지 전략: Lazy Reload (확정, fs.watch 거부)

**대안 검토:**

| 전략 | 장점 | 단점 |
|------|------|------|
| `fs.watch` | 실시간 감지 | macOS FSEvents race condition, 크로스 플랫폼 불안정 |
| 폴링 (setInterval) | 단순 | 불필요한 I/O, 배터리 소모 |
| **401 lazy reload** | **I/O 최소, 안정적** | **새 토큰 적용까지 1회 실패** |

**결정: 401 lazy reload.** MCP tool 호출 빈도가 높지 않고 (사용자 대화 기반), 1회 401 실패 후 즉시 재시도하므로 사용자 체감 지연이 없다. fs.watch의 플랫폼별 불안정성은 Self-Hosted 다양한 환경(macOS, Linux, Windows/WSL)에서 지원 부담을 크게 증가시킨다.

### 7.3 SessionManager 갱신 vs 외부 토큰 교체의 우선순위

**시나리오:** SessionManager가 60% TTL에 갱신을 시도하는 동시에, Telegram Bot이 `/newsession`으로 완전히 새로운 세션을 생성한 경우.

**동작:**
1. SessionManager가 기존 세션으로 갱신 시도 -> 성공 (기존 세션 아직 유효)
2. 파일에는 Telegram이 쓴 새 세션 토큰이 있음
3. SessionManager는 갱신 성공 후 자신의 토큰을 파일에 덮어씀
4. **결과: 파일에 기존 세션의 갱신된 토큰이 저장됨, Telegram의 새 세션 토큰 소실**

**문제인가?** 아니다. 이유:
- 기존 세션의 갱신된 토큰은 유효하다
- Telegram의 새 세션도 데몬 DB에 존재한다 (파일에 없을 뿐)
- 기존 세션이 절대 수명에 도달하면, 401 -> tryReloadFromFile에서 파일 토큰이 여전히 만료됨 -> 에러 상태 -> Owner가 `/newsession` 재실행

**그러나:** Telegram `/newsession`이 기존 세션을 **명시적으로 폐기**하면 다른 결과:
1. Telegram: sessionService.revoke(oldSessionId) + sessionService.create(newSession)
2. SessionManager: 기존 세션으로 갱신 시도 -> 401 SESSION_REVOKED
3. tryReloadFromFile() -> 파일에 새 토큰 -> 교체 -> 정상 운영

**추천: `/newsession`은 기존 MCP 세션을 명시적으로 폐기한 후 새 세션을 생성한다.** 이렇게 하면 SessionManager가 자연스럽게 401 경로를 통해 새 토큰으로 전환된다.

### 7.4 알림 트리거: MCP 측 vs 데몬 측

**결정: 데몬 측에서 자동 판단.** (섹션 2.7 참조)

MCP는 갱신 API만 호출하고, 데몬이 갱신 응답 처리 중 만료 임박 조건을 확인하여 알림을 발송한다. 이 방식의 장점:
- MCP에 알림 API 호출 코드 불필요
- 데몬이 모든 알림의 단일 소스 (NOTI-ARCH 일관성 유지)
- 데몬이 DB 상태(renewal_count, absolute_expires_at)를 직접 보유

---

## 8. 변경하지 않는 컴포넌트

| 컴포넌트 | 이유 |
|----------|------|
| 세션 갱신 API (PUT /v1/sessions/:id/renew) | SessionManager가 이 API의 클라이언트. API 자체는 변경 불필요 |
| 5종 안전 장치 | maxRenewals, 절대 수명, 50% 시점, 거부 윈도우, 갱신 단위 고정 -- 모두 유지 |
| MCP 6개 Tool 목록 | 도구 추가/삭제 없음. 인증 방식만 변경 |
| MCP stdio transport | 프로세스 모델 변경 없음 |
| Telegram 2-Tier 인증 | /newsession은 Tier 1 (chatId). 기존 구조 유지 |
| SQLite 스키마 | 테이블/컬럼 변경 없음. agents.default_constraints 추가는 검토만 |
| config.toml | 추가 설정 키 없음. MCP 토큰 경로는 하드코딩 (~/.waiaas/mcp-token) |
| Keystore / PolicyEngine | 세션 관리와 무관 |
| IChainAdapter / SolanaAdapter | 세션 관리와 무관 |

---

## 9. 리스크 및 주의사항

### 9.1 단일 토큰 파일의 한계

`~/.waiaas/mcp-token`은 단일 파일이므로, **단일 MCP 세션만 관리**한다. 다중 MCP 클라이언트(예: Claude Desktop + Cursor 동시 사용) 시나리오에서는 두 클라이언트가 동일 토큰을 공유하거나, 갱신 경합이 발생한다. v0.9 objectives에서 "다중 MCP 클라이언트 동시 접속 시나리오"를 범위 외로 명시하고 있으므로, 이 한계는 수용한다.

**향후 확장:** 다중 클라이언트 지원 시 `~/.waiaas/mcp-tokens/<client-id>.token` 디렉토리 구조로 전환 가능.

### 9.2 MCP 프로세스 재시작 시 타이머 재설정

SessionManager의 갱신 타이머는 `setTimeout`으로 구현된다. MCP 프로세스가 재시작되면 타이머가 초기화된다. 재시작 후 SessionManager가 파일에서 토큰을 로드할 때, JWT의 `iat`(issued at)과 `exp`를 사용하여 **남은 TTL의 60% 경과 시점**을 재계산하고 타이머를 재설정해야 한다.

```typescript
// 재시작 후 타이머 재계산
const now = Date.now()
const elapsed = now - this.issuedAt
const renewalPoint = this.expiresIn * 0.6
const delay = Math.max(0, renewalPoint - elapsed)
this.timer = setTimeout(() => this.renew(), delay)
```

### 9.3 agents.default_constraints 추가 여부

`/newsession`에서 기본 constraints를 적용하려면 에이전트별 기본 constraints 소스가 필요하다. 현재 agents 테이블에 `default_constraints` 컬럼이 없다.

**선택지:**
1. agents 테이블에 `default_constraints TEXT` 컬럼 추가 (DB 변경)
2. config.toml에 `[session].default_constraints` 전역 기본값만 사용
3. 하드코딩 기본값만 사용 (expiresIn=604800, maxRenewals=30)

**추천: 선택지 2 + 3 조합.** v0.9는 설계 마일스톤이므로 DB 스키마 변경을 최소화한다. config.toml 전역 기본값이 있으면 사용하고, 없으면 하드코딩 기본값을 적용한다. 에이전트별 커스텀이 필요하면 Desktop/CLI에서 명시적으로 constraints를 지정한다.

### 9.4 보안: 토큰 파일 심볼릭 링크 공격

`readMcpToken()`에서 심볼릭 링크를 감지하고 거부해야 한다. 공격자가 `~/.waiaas/mcp-token`을 심볼릭 링크로 교체하여 다른 파일을 읽도록 유도할 수 있다.

```typescript
import { lstatSync } from 'node:fs'

function readMcpToken(filePath: string): string | null {
  const stat = lstatSync(filePath)
  if (stat.isSymbolicLink()) {
    console.error('[waiaas] mcp-token is a symbolic link. Refusing to load.')
    return null
  }
  // ... 읽기 진행
}
```

---

## 10. 신뢰도 평가

| 영역 | 신뢰도 | 근거 |
|------|:------:|------|
| SessionManager 설계 | HIGH | v0.9 objectives에서 인터페이스/동작 완전 정의, SDK의 renewSession() 패턴 참조 |
| 토큰 파일 소유권 모델 | HIGH | Self-Hosted 단일 머신 전제에서 race condition 시나리오 전수 분석 |
| MCP tool handler 통합 | HIGH | 기존 38-sdk-mcp-interface.md의 6개 tool 코드 직접 분석, 변경 지점 명확 |
| Telegram /newsession | HIGH | 기존 40-telegram-bot-docker.md의 TelegramBotService 구조에 명령어 1개 추가만 |
| CLI mcp 커맨드 | HIGH | 기존 54-cli-flow-redesign.md의 커맨드 구조에 서브커맨드 그룹 추가만 |
| SESSION_EXPIRING_SOON 알림 | HIGH | 기존 알림 체계에 이벤트 1개 추가, 트리거 지점(데몬 갱신 응답)이 명확 |
| 원자적 파일 쓰기 | MEDIUM | write-file-atomic npm 패키지 패턴 검증, POSIX rename 원자성 확인. Windows 환경에서의 원자성은 추가 검증 필요 |
| 다중 MCP 클라이언트 | N/A | 범위 외 (v0.9 objectives 명시) |

---

## Sources

### 프로젝트 내부 문서 (HIGH confidence)
- v0.9 objectives (objectives/v0.9-session-management-automation.md) -- SessionManager 설계 원본
- SDK-MCP (38-sdk-mcp-interface.md) -- MCP Server 패키지 구조, 6개 tool, 3개 resource, 토큰 전달 메커니즘
- SESS-RENEW (53-session-renewal-protocol.md) -- 세션 갱신 프로토콜, 5종 안전 장치, 토큰 회전
- TGBOT-DOCK (40-telegram-bot-docker.md) -- TelegramBotService 구조, 8개 명령어, 2-Tier 인증
- CLI-REDESIGN (54-cli-flow-redesign.md) -- CLI 커맨드 구조, 서브커맨드 패턴
- NOTI-ARCH (35-notification-architecture.md) -- 16개 알림 이벤트, NotificationService
- CORE-01 (24-monorepo-data-directory.md) -- 데이터 디렉토리 구조, 파일 권한
- v0.8 ARCHITECTURE (v0.8-ARCHITECTURE.md) -- Owner 선택적 등록 아키텍처 패턴

### 외부 참조 (MEDIUM confidence)
- [MCP Lifecycle Spec](https://modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle) -- stdio 프로세스 생명주기
- [write-file-atomic npm](https://www.npmjs.com/package/write-file-atomic) -- 원자적 파일 쓰기 패턴
- [@modelcontextprotocol/sdk](https://github.com/modelcontextprotocol/typescript-sdk) -- MCP TypeScript SDK

---

*작성: 2026-02-09*
*기반: v0.9 objectives + 7개 설계 문서 (SDK-MCP, SESS-RENEW, TGBOT-DOCK, CLI-REDESIGN, NOTI-ARCH, CORE-01, CORE-02)*
*전제: Self-Hosted 단일 머신 아키텍처, 단일 MCP 클라이언트*
