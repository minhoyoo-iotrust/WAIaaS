# Architecture Patterns: v1.5 Price Oracle + Action Provider

**Domain:** DeFi Price Oracle + ESM Plugin Architecture
**Researched:** 2026-02-15

---

## Recommended Architecture

### Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| `IPriceOracle` (core) | 인터페이스 + 타입 정의 (TokenRef, PriceInfo, CacheStats) | 구현체들이 implement |
| `PythOracle` (daemon) | Pyth Hermes REST API 호출, feed ID 매핑 | InMemoryPriceCache, Hermes API |
| `CoinGeckoOracle` (daemon) | CoinGecko REST API 호출, platformId 매핑 | InMemoryPriceCache, CoinGecko API |
| `OracleChain` (daemon) | Pyth->CoinGecko fallback, 교차 검증 인라인 | PythOracle, CoinGeckoOracle |
| `InMemoryPriceCache` (daemon) | LRU 128항목, 5분 TTL, FRESH/AGING/STALE | OracleChain, 구현체들 |
| `resolveEffectiveAmountUsd` (daemon) | PipelineInput -> PriceResult 변환 | OracleChain, Pipeline Stage 3 |
| `IActionProvider` (core) | 플러그인 인터페이스 (metadata/actions/resolve) | 구현체들이 implement |
| `ActionProviderRegistry` (daemon) | 플러그인 발견/로드/검증/CRUD | IActionProvider, MCP Server |
| `McpToolConverter` (daemon) | ActionDefinition -> MCP Tool 변환 | ActionProviderRegistry, MCP Server |
| `ApiKeyStore` (daemon) | API 키 암호화 CRUD | SettingsService/settings-crypto, DB |

### Data Flow

#### 1. USD 정책 평가 플로우

```
Transaction Request
    |
    v
Pipeline Stage 3 (정책 평가)
    |
    v
resolveEffectiveAmountUsd(input, oracle)
    |
    v
OracleChain.getPrice(tokenRef)
    |
    +--> PythOracle.getPrice()
    |       |
    |       +--> InMemoryPriceCache.get(key)
    |       |       |
    |       |       +-- HIT (FRESH) --> return cached
    |       |       +-- HIT (AGING) --> return cached + warning log
    |       |       +-- HIT (STALE) --> treat as MISS
    |       |       +-- MISS --> fetch from Hermes API
    |       |
    |       +--> fetch("https://hermes.pyth.network/v2/updates/price/latest?ids[]=...")
    |       |       |
    |       |       +--> 200 OK --> parse, cache, return PriceInfo
    |       |       +--> 429/5xx --> throw ChainError('TRANSIENT')
    |       |
    |       +--> return PriceInfo { usdPrice, confidence, source: 'pyth' }
    |
    +--> [Pyth 실패 시] CoinGeckoOracle.getPrice()  (키 미설정 시 스킵)
    |       |
    |       +--> fetch("https://api.coingecko.com/api/v3/simple/token_price/...")
    |       +--> return PriceInfo { usdPrice, source: 'coingecko' }
    |
    +--> [교차 검증] Pyth 성공 + CoinGecko 성공 + 키 설정 시
    |       |
    |       +--> 편차 <= 5% --> Primary(Pyth) 가격 채택
    |       +--> 편차 > 5% --> STALE 격하 + PRICE_DEVIATION_WARNING 로그
    |
    +--> [모두 실패] ORACLE_UNAVAILABLE
    |
    v
PriceResult (discriminated union)
    |
    +-- success(usdAmount) --> USD 기준 SPENDING_LIMIT 평가
    +-- oracleDown()       --> 네이티브 금액만으로 티어 결정
    +-- notListed()        --> 최소 NOTIFY 격상 + UNLISTED_TOKEN_TRANSFER 감사 로그
```

#### 2. Action Provider 실행 플로우

```
POST /v1/actions/:provider/:action  (또는 MCP Tool 호출)
    |
    v
ActionProviderRegistry.getProvider(providerName)
    |
    +--> 미등록 --> 404 PROVIDER_NOT_FOUND
    +--> requiresApiKey && 키 미설정 --> 403 API_KEY_REQUIRED
    |
    v
provider.resolve(actionName, params, context)
    |
    +--> Zod로 params 검증 (ActionDefinition.inputSchema)
    +--> resolve() 실행 --> ContractCallRequest 반환
    +--> 반환값 Zod 검증 (ContractCallRequestSchema)
    |
    v
ContractCallRequest
    |
    v
기존 파이프라인 (Stage 1~6)
    Stage 1: 입력 검증
    Stage 2: 파라미터 해석
    Stage 3: 정책 평가 (+ resolveEffectiveAmountUsd)
    Stage 4: 실행 준비
    Stage 5: 빌드 -> 시뮬레이트 -> 서명 -> 제출
    Stage 6: 결과 기록
    |
    v
TransactionResult
```

---

## Patterns to Follow

### Pattern 1: OracleChain (Chain of Responsibility + Cross-Validation)

**What:** 다수 가격 소스를 우선순위로 시도하고, 성공한 소스의 결과를 반환. 다수 소스 성공 시 교차 검증.

**When:** 외부 API fallback이 필요하고, 데이터 신뢰성 검증이 필요할 때.

```typescript
class OracleChain implements IPriceOracle {
  private readonly primary: PythOracle;
  private readonly fallback: CoinGeckoOracle | null; // 키 미설정 시 null

  async getPrice(token: TokenRef): Promise<PriceInfo> {
    let primaryResult: PriceInfo | null = null;
    let fallbackResult: PriceInfo | null = null;

    // 1. Primary 시도
    try {
      primaryResult = await this.primary.getPrice(token);
    } catch (e) {
      // Primary 실패 -> fallback 시도
    }

    // 2. Fallback 시도 (교차 검증 또는 Primary 실패 시)
    if (this.fallback) {
      try {
        fallbackResult = await this.fallback.getPrice(token);
      } catch (e) {
        // Fallback도 실패
      }
    }

    // 3. 결과 결정
    if (primaryResult && fallbackResult) {
      return this.crossValidate(primaryResult, fallbackResult);
    }
    if (primaryResult) return primaryResult;
    if (fallbackResult) return fallbackResult;

    throw new ChainError('TRANSIENT', 'ORACLE_UNAVAILABLE');
  }

  private crossValidate(primary: PriceInfo, fallback: PriceInfo): PriceInfo {
    const deviation = Math.abs(primary.usdPrice - fallback.usdPrice) / primary.usdPrice;
    if (deviation > 0.05) {
      // 5% 초과 -> STALE 격하
      auditLog('PRICE_DEVIATION_WARNING', { primary, fallback, deviation });
      return { ...primary, isStale: true };
    }
    return primary;
  }
}
```

### Pattern 2: PriceResult Discriminated Union

**What:** 가격 조회 결과를 3가지 상태로 명확히 구분.

**When:** 가격 조회 결과에 따라 정책 평가 분기가 필요할 때.

```typescript
type PriceResult =
  | { type: 'success'; usdAmount: number }
  | { type: 'oracleDown' }   // 일시적 장애 -> 네이티브 금액만
  | { type: 'notListed' };   // 영구적 미등록 -> NOTIFY 격상

function resolveEffectiveAmountUsd(
  input: PipelineInput,
  oracle: IPriceOracle,
): Promise<PriceResult> {
  try {
    const price = await oracle.getPrice(tokenRef);
    if (price.isStale) return { type: 'oracleDown' };
    return { type: 'success', usdAmount: calculateUsd(input, price) };
  } catch (e) {
    if (isNotListedError(e)) return { type: 'notListed' };
    return { type: 'oracleDown' };
  }
}
```

### Pattern 3: validate-then-trust (Plugin Loading)

**What:** 플러그인 로드 시 인터페이스 준수를 Zod로 검증하고, 통과 후 신뢰.

**When:** 외부 코드를 로드하되 샌드박스 없이 안전성을 보장해야 할 때.

```typescript
async function loadAndValidatePlugin(filePath: string): Promise<IActionProvider> {
  const module = await import(pathToFileURL(filePath).href);
  const provider = module.default ?? module.provider;

  // 1. metadata 검증
  const metadata = ActionProviderMetadataSchema.safeParse(provider?.metadata);
  if (!metadata.success) {
    logger.error(`Plugin ${filePath}: invalid metadata`, metadata.error);
    throw new Error(`Invalid plugin metadata: ${filePath}`);
  }

  // 2. actions 배열 검증
  const actions = z.array(ActionDefinitionSchema).safeParse(provider?.actions);
  if (!actions.success) {
    throw new Error(`Invalid plugin actions: ${filePath}`);
  }

  // 3. resolve 함수 존재 확인
  if (typeof provider?.resolve !== 'function') {
    throw new Error(`Plugin missing resolve(): ${filePath}`);
  }

  // 4. 검증 통과 -> 신뢰
  return provider as IActionProvider;
}
```

### Pattern 4: Cache-Aside with Stampede Prevention

**What:** 캐시 미스 시 외부 소스에서 조회하되, 동시 요청의 중복 조회를 방지.

```typescript
class InMemoryPriceCache {
  private readonly cache = new Map<string, { node: LRUNode<PriceInfo> }>();
  private readonly pending = new Map<string, Promise<PriceInfo>>();

  async getOrFetch(
    key: string,
    fetcher: () => Promise<PriceInfo>,
  ): Promise<PriceInfo> {
    // 1. 캐시 확인
    const cached = this.get(key);
    if (cached && classifyPriceAge(cached.fetchedAt) === 'FRESH') {
      this.stats.hits++;
      return cached;
    }

    // 2. in-flight 확인
    const existing = this.pending.get(key);
    if (existing) return existing;

    // 3. 새로 fetch
    const promise = fetcher()
      .then(result => { this.set(key, result); return result; })
      .finally(() => this.pending.delete(key));

    this.pending.set(key, promise);
    return promise;
  }
}
```

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: 가격 $0 Fallback

**What:** 가격을 조회할 수 없을 때 `usdPrice: 0`을 반환.
**Why bad:** USD spending limit을 완전히 우회. $0 전송은 항상 INSTANT 티어 통과.
**Instead:** PriceResult discriminated union으로 `notListed` 상태 명시. 최소 NOTIFY 격상.

### Anti-Pattern 2: Oracle 응답 무기한 캐시

**What:** 가격 데이터를 TTL 없이 영구 캐시.
**Why bad:** 오래된 가격으로 정책 평가 -> 보안 위험. BTC $60K 캐시가 $100K 시점에 사용되면 실제 가치의 60%로만 평가.
**Instead:** 5분 TTL + FRESH/AGING/STALE 3단계. STALE>30분은 USD 평가 스킵.

### Anti-Pattern 3: 플러그인 resolve()에서 서명/제출

**What:** IActionProvider.resolve()에서 트랜잭션 서명이나 온체인 제출을 직접 수행.
**Why bad:** 정책 평가, 승인 플로우, 감사 로그를 모두 우회. 보안 모델 붕괴.
**Instead:** resolve()는 반드시 `ContractCallRequest`만 반환. 서명/제출은 기존 파이프라인 Stage 5에서 수행.

### Anti-Pattern 4: 동기적 플러그인 로드

**What:** 데몬 시작 시 플러그인 로드를 동기적으로 수행.
**Why bad:** 플러그인 파일이 크거나 네트워크 import를 사용하면 데몬 시작이 블로킹.
**Instead:** `import()`는 비동기. `Promise.allSettled()`로 병렬 로드 + 개별 실패 격리.

### Anti-Pattern 5: CoinGecko API 키 config.toml 평문 저장

**What:** API 키를 config.toml에 평문으로 저장.
**Why bad:** 파일 시스템 접근 시 키 노출. CLAUDE.md 보안 원칙 위반.
**Instead:** DB 암호화 저장 (HKDF+AES-256-GCM). Admin Settings에서 마스킹 조회.

---

## 모듈 배치 (기존 컨벤션 기반)

기존 daemon 구조: `api/`, `infrastructure/`, `pipeline/`, `notifications/`

```
packages/core/src/
  interfaces/
    price-oracle.types.ts        # IPriceOracle, TokenRef, PriceInfo, PriceAge, CacheStats
    action-provider.types.ts     # IActionProvider, ActionProviderMetadata, ActionDefinition, ActionContext
  schemas/
    spending-limit-rule.schema.ts  # SpendingLimitRuleSchema (USD 필드 포함)

packages/daemon/src/
  infrastructure/
    oracle/
      price-cache.ts             # InMemoryPriceCache (LRU 128, 5분 TTL)
      price-age.ts               # classifyPriceAge(), PriceAge enum
      pyth-oracle.ts             # PythOracle implements IPriceOracle
      pyth-feed-ids.ts           # PYTH_FEED_IDS 하드코딩 맵 + 동적 검색
      coingecko-oracle.ts        # CoinGeckoOracle implements IPriceOracle
      oracle-chain.ts            # OracleChain (fallback + 교차 검증)
      index.ts                   # re-exports
    action/
      action-provider-registry.ts  # ActionProviderRegistry
      mcp-tool-converter.ts      # ActionDefinition -> MCP Tool
      api-key-store.ts           # ActionProviderApiKeyStore
      index.ts
  pipeline/
    resolve-effective-amount-usd.ts  # resolveEffectiveAmountUsd()
  api/routes/
    actions.ts                   # POST /v1/actions/:provider/:action
    admin.ts                     # (확장) GET /v1/admin/oracle-status, api-keys CRUD
```

---

## Scalability Considerations

| Concern | 현재 (v1.5) | 100개 토큰 | 1000개 토큰 |
|---------|------------|-----------|------------|
| 캐시 크기 | 128항목 LRU | 충분 | 자주 사용하는 128개만 캐시, 나머지 퇴출 |
| Pyth API | 30 req/10s 제한 | 배치 조회로 1-2 req | 배치 + 캐시로 5-10 req |
| CoinGecko API | 30 req/min Demo | 배치 조회로 3-5 req/min | Pro 키 필요 (500 req/min) |
| Feed ID 매핑 | 하드코딩 10~15개 | 동적 검색 필요 | feedId 매핑 전용 캐시 필요 |
| Action Provider | ~5개 플러그인 | 충분 | MCP 도구 수 증가, priority 관리 필요 |

---

## Sources

- [Pyth Hermes API Reference](https://docs.pyth.network/price-feeds/core/api-reference) - Endpoint design [HIGH]
- [CoinGecko API Token Price](https://docs.coingecko.com/reference/simple-token-price) - Token lookup [HIGH]
- [Node.js ESM Documentation](https://nodejs.org/api/esm.html) - Plugin loading pattern [HIGH]
- [v1.5 목표 문서](/Users/minho.yoo/dev/wallet/WAIaaS/objectives/v1.5-defi-price-oracle.md) - Architecture decisions [HIGH]
