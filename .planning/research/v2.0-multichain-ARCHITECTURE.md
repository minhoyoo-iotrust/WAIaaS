# Architecture: Multichain Environment Model Integration

**Domain:** Self-Hosted AI Agent Wallet Daemon -- Multichain Environment Model
**Researched:** 2026-02-14
**Confidence:** HIGH (based on direct codebase analysis of existing v1.4.4 implementation)

## Executive Summary

WAIaaS 현재 아키텍처는 지갑(wallet)을 단일 네트워크에 바인딩한다. `wallets.network` 컬럼이 wallet 생성 시 고정되고, 이 값이 AdapterPool 리졸브, 파이프라인 전체, 정책 평가, 자산 조회까지 전파된다. 멀티체인 환경 모델은 이 바인딩을 `environment` (testnet/mainnet)로 완화하여, 하나의 EVM 지갑이 같은 환경의 여러 네트워크에서 트랜잭션을 실행할 수 있게 한다.

이 변경은 시스템의 "네트워크 리졸루션 시점"을 지갑 생성 시에서 트랜잭션 요청 시로 이동시키는 것이 핵심이다. 아래 5개 영역의 구체적 통합 방안을 상세히 기술한다.

---

## 1. 핵심 개념: Environment Model

### 1.1 현재 모델 (As-Is)

```
Wallet Creation -> network 고정 (e.g., 'ethereum-sepolia')
                -> 모든 후속 작업이 이 network 사용
                -> AdapterPool.resolve(chain, wallet.network)
                -> Pipeline: ctx.wallet.network 불변
```

**데이터 흐름:**
```
POST /wallets { chain: 'ethereum', network: 'ethereum-sepolia' }
  -> wallets.network = 'ethereum-sepolia' (고정)
  -> 이후 모든 트랜잭션이 ethereum-sepolia에서 실행
  -> getBalance -> adapter(ethereum-sepolia).getBalance()
  -> getAssets -> adapter(ethereum-sepolia).getAssets()
```

### 1.2 목표 모델 (To-Be)

```
Wallet Creation -> environment 고정 (e.g., 'testnet' 또는 'mainnet')
                -> 트랜잭션 요청 시 network 지정 (e.g., 'polygon-amoy')
                -> AdapterPool.resolve(chain, request.network)
                -> Pipeline: network는 요청 컨텍스트에서 리졸브
```

**Environment 정의:**
```typescript
const ENVIRONMENT_TYPES = ['testnet', 'mainnet'] as const;
type EnvironmentType = (typeof ENVIRONMENT_TYPES)[number];

// Environment -> Network 매핑
const ENVIRONMENT_NETWORKS: Record<ChainType, Record<EnvironmentType, NetworkType[]>> = {
  solana: {
    testnet: ['devnet', 'testnet'],
    mainnet: ['mainnet'],
  },
  ethereum: {
    testnet: ['ethereum-sepolia', 'polygon-amoy', 'arbitrum-sepolia', 'optimism-sepolia', 'base-sepolia'],
    mainnet: ['ethereum-mainnet', 'polygon-mainnet', 'arbitrum-mainnet', 'optimism-mainnet', 'base-mainnet'],
  },
};
```

**핵심 불변식:** 지갑의 environment가 'testnet'이면, 해당 지갑은 testnet 네트워크에서만 트랜잭션 실행 가능. mainnet 네트워크 요청은 정책 레벨에서 거부.

---

## 2. Component-Level Integration Analysis

### 2.1 수정 대상 모듈 (Modified Components)

| Component | 파일 | 변경 범위 | 복잡도 |
|-----------|------|----------|--------|
| **Zod Schema: chain.ts** | `@waiaas/core/src/enums/chain.ts` | ENVIRONMENT_TYPES 추가, validateChainNetwork -> validateEnvironmentNetwork 확장 | Low |
| **Zod Schema: wallet.schema.ts** | `@waiaas/core/src/schemas/wallet.schema.ts` | network -> environment 변경, 호환 필드 유지 | Low |
| **Zod Schema: transaction.schema.ts** | `@waiaas/core/src/schemas/transaction.schema.ts` | network 필드 추가 (TransactionRequestSchema에 optional network) | Low |
| **DB Schema: schema.ts** | `daemon/src/infrastructure/database/schema.ts` | wallets.environment 추가, transactions.network 추가 | Med |
| **DB Migration: migrate.ts** | `daemon/src/infrastructure/database/migrate.ts` | v6 마이그레이션 (wallets.network -> wallets.environment, transactions.network 추가) | High |
| **Pipeline: pipeline.ts** | `daemon/src/pipeline/pipeline.ts` | PipelineDeps에 adapterPool 추가, adapter 리졸브 시점 변경 | Med |
| **Pipeline: stages.ts** | `daemon/src/pipeline/stages.ts` | PipelineContext.wallet.network -> resolvedNetwork, stage1에서 network 리졸브 | Med |
| **Policy Engine: database-policy-engine.ts** | `daemon/src/pipeline/database-policy-engine.ts` | ALLOWED_NETWORKS 정책 타입 추가, TransactionParam에 network 추가 | Med |
| **AdapterPool: adapter-pool.ts** | `daemon/src/infrastructure/adapter-pool.ts` | 변경 불필요 (이미 chain:network 기반, 호출부만 변경) | None |
| **Transaction Routes: transactions.ts** | `daemon/src/api/routes/transactions.ts` | network 파라미터 리졸브 로직 추가 | Med |
| **Wallet Routes: wallets.ts** | `daemon/src/api/routes/wallets.ts` | environment 파라미터 처리, 하위호환 network 지원 | Med |
| **Wallet Query: wallet.ts** | `daemon/src/api/routes/wallet.ts` | getAssets 멀티네트워크 집계 | High |
| **Config: loader.ts** | `daemon/src/infrastructure/config/loader.ts` | 변경 불필요 (RPC 키 이미 네트워크별로 존재) | None |
| **Keystore: keystore.ts** | `daemon/src/infrastructure/keystore/keystore.ts` | KeystoreFileV1.network -> 환경 정보 추가 (호환) | Low |
| **Daemon: daemon.ts** | `daemon/src/lifecycle/daemon.ts` | executeFromStage5에서 network 리졸브 변경 | Low |
| **MCP Tools** | `mcp/src/tools/*.ts` | SDK API 변경 반영 | Low |
| **Policy Enum: policy.ts** | `@waiaas/core/src/enums/policy.ts` | ALLOWED_NETWORKS 추가 | Low |

### 2.2 신규 추가 모듈 (New Components)

| Component | 위치 | 역할 |
|-----------|------|------|
| **NetworkResolver** | `daemon/src/infrastructure/network-resolver.ts` | environment + request.network -> 유효한 NetworkType 리졸브 |
| **ALLOWED_NETWORKS 정책 평가기** | DatabasePolicyEngine 내부 메서드 추가 | 지갑별 허용 네트워크 제한 |
| **Multi-network Asset Aggregator** | `daemon/src/api/routes/wallet.ts` 내부 | 여러 네트워크 자산 병합 조회 |

---

## 3. Question 1: AdapterPool -- 트랜잭션 요청 시 네트워크 리졸브

### 3.1 현재 흐름 (As-Is)

```
POST /v1/transactions/send
  -> wallet = db.select(wallets).where(id=walletId)
  -> rpcUrl = resolveRpcUrl(config.rpc, wallet.chain, wallet.network)  // <-- wallet.network 사용
  -> adapter = adapterPool.resolve(wallet.chain, wallet.network, rpcUrl)
  -> ctx.wallet.network = wallet.network
  -> pipeline stages all use ctx.wallet.network
```

`transactions.ts` 라인 256-265에서 `wallet.chain`과 `wallet.network`로 어댑터를 리졸브한다.

### 3.2 변경 방안

**AdapterPool 자체는 변경 불필요.** AdapterPool은 이미 `chain:network` 키로 캐싱하는 범용 풀이다. 변경이 필요한 것은 "어떤 network를 전달할 것인가"를 결정하는 **호출부(caller)**이다.

```typescript
// NEW: NetworkResolver -- 트랜잭션 요청에서 network 추출 + environment 교차 검증
export class NetworkResolver {
  /**
   * 트랜잭션 요청에서 target network를 리졸브한다.
   *
   * 우선순위:
   * 1. request.network (명시적 네트워크 지정)
   * 2. wallet.defaultNetwork (environment 내 기본 네트워크)
   * 3. chain 기본값 (solana -> devnet/mainnet, ethereum -> ethereum-sepolia/ethereum-mainnet)
   *
   * 검증:
   * - 리졸브된 network가 wallet.environment에 허용되는지 확인
   * - ALLOWED_NETWORKS 정책 존재 시 추가 제한 적용
   */
  resolve(
    wallet: { chain: ChainType; environment: EnvironmentType },
    requestNetwork?: NetworkType,
  ): NetworkType {
    // 1. 명시적 지정이 있으면 사용
    const targetNetwork = requestNetwork ?? this.getDefaultNetwork(wallet.chain, wallet.environment);

    // 2. environment 교차 검증
    const allowedNetworks = ENVIRONMENT_NETWORKS[wallet.chain][wallet.environment];
    if (!allowedNetworks.includes(targetNetwork)) {
      throw new WAIaaSError('VALIDATION_ERROR', {
        message: `Network '${targetNetwork}' is not allowed in environment '${wallet.environment}' for chain '${wallet.chain}'`,
      });
    }

    return targetNetwork;
  }

  private getDefaultNetwork(chain: ChainType, env: EnvironmentType): NetworkType {
    if (chain === 'solana') {
      return env === 'mainnet' ? 'mainnet' : 'devnet';
    }
    // EVM: environment 내 첫 번째 네트워크가 기본값
    return ENVIRONMENT_NETWORKS[chain][env][0];
  }
}
```

### 3.3 변경된 Transaction Route 흐름

```typescript
// transactions.ts 변경 후
router.openapi(sendTransactionRoute, async (c) => {
  const walletId = c.get('walletId') as string;
  const wallet = await deps.db.select().from(wallets).where(eq(wallets.id, walletId)).get();

  const request = await c.req.json();

  // NEW: 트랜잭션 요청에서 network 리졸브
  const networkResolver = new NetworkResolver();
  const resolvedNetwork = networkResolver.resolve(
    { chain: wallet.chain as ChainType, environment: wallet.environment as EnvironmentType },
    request.network as NetworkType | undefined,  // 5-type 요청에 optional network 필드
  );

  // AdapterPool은 resolvedNetwork로 리졸브 (기존과 동일한 인터페이스)
  const rpcUrl = resolveRpcUrl(config.rpc, wallet.chain, resolvedNetwork);
  const adapter = await deps.adapterPool.resolve(wallet.chain as ChainType, resolvedNetwork, rpcUrl);

  const ctx: PipelineContext = {
    ...deps,
    walletId,
    wallet: {
      publicKey: wallet.publicKey,
      chain: wallet.chain,
      network: resolvedNetwork,  // <-- 리졸브된 네트워크
    },
    request,
    txId: '',
  };

  // 이하 기존 파이프라인 동일
});
```

### 3.4 핵심 설계 결정

| # | 결정 | 근거 |
|---|------|------|
| 1 | AdapterPool 인터페이스 변경 없음 | 이미 chain:network 기반 범용 캐싱. 호출부에서 올바른 network를 전달하면 됨 |
| 2 | NetworkResolver를 별도 클래스로 분리 | 단일 책임 원칙. 트랜잭션 라우트, daemon executeFromStage5, MCP 도구에서 공통 사용 |
| 3 | request.network를 optional로 유지 | 하위호환. 기존 단일 네트워크 지갑은 network 미지정 시 환경 기본값 사용 |
| 4 | environment 교차 검증은 NetworkResolver에서 수행 | 정책 엔진 전에 빠른 실패. testnet 지갑이 mainnet에 접근하는 것을 구조적으로 차단 |

---

## 4. Question 2: 6-Stage Pipeline 데이터 흐름

### 4.1 현재 PipelineContext의 network 전파

```
PipelineContext 생성 (transactions.ts 268-281)
  -> ctx.wallet.network = wallet.network (DB에서 읽은 고정값)

Stage 1 (Validate): ctx.wallet.chain을 transactions.chain에 INSERT
Stage 2 (Auth): network 미사용
Stage 3 (Policy): ctx.wallet.chain을 buildTransactionParam에 전달
Stage 4 (Wait): network 미사용
Stage 5 (Execute): ctx.adapter가 이미 특정 network에 바인딩됨
Stage 6 (Confirm): ctx.adapter.waitForConfirmation 사용
```

**문제:** `ctx.wallet.network`가 현재 불변인데, 환경 모델에서는 트랜잭션별로 다를 수 있다.

### 4.2 변경 방안: PipelineContext 확장

```typescript
export interface PipelineContext {
  // Dependencies
  db: BetterSQLite3Database<typeof schema>;
  adapter: IChainAdapter;       // 이미 리졸브된 adapter (변경 없음)
  keyStore: LocalKeyStore;
  policyEngine: IPolicyEngine;
  masterPassword: string;

  // Request data
  walletId: string;
  wallet: {
    publicKey: string;
    chain: string;
    environment: string;       // NEW: 'testnet' | 'mainnet'
    network: string;           // CHANGED: 리졸브된 target network (요청별)
  };
  request: SendTransactionRequest | TransactionRequest;

  // State accumulated through stages
  txId: string;
  tier?: PolicyTier;
  // ... (기존 필드 동일)
}
```

### 4.3 Stage별 변경 상세

#### Stage 1: Validate + DB INSERT

```
변경 전: transactions.chain = ctx.wallet.chain (chain만 저장)
변경 후: transactions.chain = ctx.wallet.chain
         transactions.network = ctx.wallet.network  // NEW: 리졸브된 network 저장
```

```typescript
// stages.ts stage1Validate 변경
await ctx.db.insert(transactions).values({
  id: ctx.txId,
  walletId: ctx.walletId,
  chain: ctx.wallet.chain,
  network: ctx.wallet.network,  // NEW: 트랜잭션별 네트워크 기록
  type: txType,
  status: 'PENDING',
  amount: amount ?? null,
  toAddress: toAddress ?? null,
  sessionId: ctx.sessionId ?? null,
  createdAt: now,
});
```

#### Stage 2: Auth
변경 없음. sessionAuth는 network와 무관.

#### Stage 3: Policy

```
변경 전: buildTransactionParam(req, txType, ctx.wallet.chain)
변경 후: buildTransactionParam(req, txType, ctx.wallet.chain, ctx.wallet.network)
```

TransactionParam에 `network` 필드 추가:

```typescript
interface TransactionParam {
  type: string;
  amount: string;
  toAddress: string;
  chain: string;
  network: string;      // NEW: ALLOWED_NETWORKS 정책 평가용
  tokenAddress?: string;
  contractAddress?: string;
  selector?: string;
  spenderAddress?: string;
  approveAmount?: string;
}
```

ALLOWED_NETWORKS 정책은 Stage 3에서 WHITELIST 다음, ALLOWED_TOKENS 전에 평가:

```
Step 4:   WHITELIST (기존)
Step 4.a: ALLOWED_NETWORKS (NEW)  -- network가 허용 목록에 있는지
Step 4b:  ALLOWED_TOKENS (기존)
Step 4c:  CONTRACT_WHITELIST (기존)
...
```

#### Stage 4: Wait
변경 없음. 대기 로직은 network와 무관.

#### Stage 5: Execute
변경 없음. `ctx.adapter`가 이미 올바른 network에 연결되어 있으므로, `buildByType(ctx.adapter, ...)` 호출이 자동으로 올바른 네트워크에서 실행됨.

#### Stage 6: Confirm
변경 없음. `ctx.adapter.waitForConfirmation()`이 같은 adapter(같은 network)에서 실행.

### 4.4 데이터 흐름 다이어그램

```
POST /v1/transactions/send { type: 'TRANSFER', to: '...', amount: '...', network: 'polygon-amoy' }
  |
  v
[Transaction Route]
  1. wallet = db.select(wallets, id=walletId)  -> { chain: 'ethereum', environment: 'testnet' }
  2. resolvedNetwork = NetworkResolver.resolve(wallet, request.network)  -> 'polygon-amoy'
  3. rpcUrl = resolveRpcUrl(config.rpc, 'ethereum', 'polygon-amoy')
  4. adapter = adapterPool.resolve('ethereum', 'polygon-amoy', rpcUrl)
  5. ctx = { wallet: { chain: 'ethereum', environment: 'testnet', network: 'polygon-amoy' }, adapter, ... }
  |
  v
[Stage 1: Validate]
  - Zod 검증 (request body)
  - transactions INSERT: { chain: 'ethereum', network: 'polygon-amoy', ... }
  |
  v
[Stage 2: Auth] -- 통과
  |
  v
[Stage 3: Policy]
  - WHITELIST 평가
  - ALLOWED_NETWORKS 평가: 'polygon-amoy' in wallet의 허용 네트워크 목록?
  - ALLOWED_TOKENS 평가 (있는 경우)
  - SPENDING_LIMIT 평가
  |
  v
[Stage 4: Wait] -- tier에 따라 대기 또는 통과
  |
  v
[Stage 5: Execute]
  - adapter(polygon-amoy).buildTransaction()
  - adapter(polygon-amoy).simulateTransaction()
  - keyStore.decryptPrivateKey(walletId)  -- 같은 keypair, 다른 네트워크
  - adapter(polygon-amoy).signTransaction()
  - adapter(polygon-amoy).submitTransaction()
  |
  v
[Stage 6: Confirm]
  - adapter(polygon-amoy).waitForConfirmation()
```

---

## 5. Question 3: Policy Table -- Network-Scoped Rules

### 5.1 현재 정책 테이블 구조

```sql
policies (
  id TEXT PRIMARY KEY,
  wallet_id TEXT REFERENCES wallets(id),  -- NULL = global
  type TEXT NOT NULL,  -- 10 PolicyType
  rules TEXT NOT NULL,  -- JSON
  priority INTEGER NOT NULL DEFAULT 0,
  enabled INTEGER NOT NULL DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
)
```

정책은 wallet_id(또는 global) + type으로 식별된다. **현재 network 스코핑이 없다.**

### 5.2 방안 A: policies 테이블에 network 컬럼 추가 (권장)

```sql
ALTER TABLE policies ADD COLUMN network TEXT;
-- NULL = 모든 네트워크 적용 (현재 동작과 동일)
-- 'polygon-amoy' = 해당 네트워크에서만 적용
```

```
CREATE INDEX idx_policies_wallet_network ON policies(wallet_id, network, enabled);
```

**Override Resolution 변경:**

```
현재: wallet-specific > global (같은 type)
변경: wallet+network-specific > wallet-specific > global+network > global (같은 type)
```

구체적 리졸브 우선순위:

```typescript
private resolveOverrides(rows: PolicyRow[], walletId: string, network: string): PolicyRow[] {
  const typeMap = new Map<string, PolicyRow>();

  // 우선순위 (낮 -> 높):
  // 1. global, network=null (모든 네트워크)
  // 2. global, network=specific (특정 네트워크 글로벌)
  // 3. wallet-specific, network=null (지갑별 모든 네트워크)
  // 4. wallet-specific, network=specific (지갑별 특정 네트워크)

  for (const row of rows) {
    const existing = typeMap.get(row.type);
    if (!existing) {
      // network가 null이거나 일치하는 것만
      if (row.network === null || row.network === network) {
        typeMap.set(row.type, row);
      }
      continue;
    }

    const scoreNew = this.policyScore(row, walletId, network);
    const scoreExisting = this.policyScore(existing, walletId, network);

    if (scoreNew > scoreExisting) {
      typeMap.set(row.type, row);
    }
  }

  return Array.from(typeMap.values());
}

private policyScore(row: PolicyRow, walletId: string, network: string): number {
  let score = 0;
  if (row.walletId === walletId) score += 2;  // wallet-specific
  if (row.network === network) score += 1;     // network-specific
  return score;
}
```

### 5.3 새로운 ALLOWED_NETWORKS 정책 타입

```typescript
// POLICY_TYPES에 'ALLOWED_NETWORKS' 추가
export const POLICY_TYPES = [
  'SPENDING_LIMIT',
  'WHITELIST',
  'TIME_RESTRICTION',
  'RATE_LIMIT',
  'ALLOWED_TOKENS',
  'CONTRACT_WHITELIST',
  'METHOD_WHITELIST',
  'APPROVED_SPENDERS',
  'APPROVE_AMOUNT_LIMIT',
  'APPROVE_TIER_OVERRIDE',
  'ALLOWED_NETWORKS',       // NEW
] as const;
```

**ALLOWED_NETWORKS rules 스키마:**

```typescript
interface AllowedNetworksRules {
  networks: Array<{ network: NetworkType; enabled: boolean }>;
}
```

**평가 로직:**

```typescript
private evaluateAllowedNetworks(
  resolved: PolicyRow[],
  transaction: TransactionParam,
): PolicyEvaluation | null {
  const policy = resolved.find((p) => p.type === 'ALLOWED_NETWORKS');

  // 정책 미설정 시 environment 내 모든 네트워크 허용 (기본 허용)
  // -- environment 교차 검증은 NetworkResolver가 이미 수행
  if (!policy) return null;

  const rules: AllowedNetworksRules = JSON.parse(policy.rules);
  const isAllowed = rules.networks.some(
    (n) => n.network === transaction.network && n.enabled,
  );

  if (!isAllowed) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: `Network '${transaction.network}' is not in ALLOWED_NETWORKS policy`,
    };
  }

  return null;
}
```

### 5.4 기본 거부 vs 기본 허용 결정

| 정책 | 기존 기본값 | 근거 |
|------|-----------|------|
| ALLOWED_TOKENS | 기본 거부 | 토큰 전송은 명시적 허가 필요 |
| CONTRACT_WHITELIST | 기본 거부 | 컨트랙트 호출은 명시적 허가 필요 |
| APPROVED_SPENDERS | 기본 거부 | approve는 명시적 허가 필요 |
| **ALLOWED_NETWORKS** | **기본 허용** | environment가 이미 testnet/mainnet으로 제한. 추가 네트워크 제한은 선택적 |

ALLOWED_NETWORKS는 **기본 허용**으로 설계한다. 이유:
1. `environment` 레벨에서 이미 testnet/mainnet 격리가 보장됨
2. ALLOWED_TOKENS 등의 기본 거부 패턴은 "미설정 = 위험"이지만, ALLOWED_NETWORKS는 "미설정 = 환경 내 모든 네트워크"로 안전
3. 사용자가 Arbitrum만 사용하고 싶으면 ALLOWED_NETWORKS 정책으로 명시적 제한

### 5.5 Network-Scoped SPENDING_LIMIT 예시

```json
// 정책 1: wallet-specific, network=null (모든 네트워크 공통 한도)
{
  "wallet_id": "uuid-1",
  "type": "SPENDING_LIMIT",
  "network": null,
  "rules": "{\"instant_max\":\"1000000000\",\"notify_max\":\"5000000000\",\"delay_max\":\"10000000000\",\"delay_seconds\":300}"
}

// 정책 2: wallet-specific, network='ethereum-mainnet' (메인넷 한도 강화)
{
  "wallet_id": "uuid-1",
  "type": "SPENDING_LIMIT",
  "network": "ethereum-mainnet",
  "rules": "{\"instant_max\":\"100000000\",\"notify_max\":\"500000000\",\"delay_max\":\"1000000000\",\"delay_seconds\":600}"
}
```

정책 2가 ethereum-mainnet 트랜잭션에 우선 적용된다 (network-specific > network-null).

---

## 6. Question 4: getAssets 멀티네트워크 집계

### 6.1 현재 흐름

```
GET /v1/wallet/assets
  -> wallet.network로 단일 adapter 리졸브
  -> adapter.getAssets(wallet.publicKey) 호출
  -> 단일 네트워크의 자산만 반환
```

### 6.2 변경 방안: 병렬 멀티네트워크 조회

```typescript
// wallet.ts GET /wallet/assets 변경
router.openapi(walletAssetsRoute, async (c) => {
  const walletId = c.get('walletId') as string;
  const wallet = await resolveWalletById(deps.db, walletId);

  // 쿼리 파라미터로 특정 네트워크만 조회 가능
  const queryNetwork = c.req.query('network') as NetworkType | undefined;

  // environment에서 허용되는 네트워크 목록
  const allowedNetworks = ENVIRONMENT_NETWORKS[wallet.chain as ChainType][wallet.environment as EnvironmentType];

  // 특정 네트워크 요청 시 단일 조회 (기존과 동일한 성능)
  if (queryNetwork) {
    if (!allowedNetworks.includes(queryNetwork)) {
      throw new WAIaaSError('VALIDATION_ERROR', {
        message: `Network '${queryNetwork}' not in environment '${wallet.environment}'`,
      });
    }
    const assets = await fetchAssetsForNetwork(deps, wallet, queryNetwork);
    return c.json({ walletId, chain: wallet.chain, environment: wallet.environment, network: queryNetwork, assets }, 200);
  }

  // 전체 environment 조회: 모든 네트워크 병렬 조회
  const allAssets: Array<{ network: string; assets: AssetInfo[] }> = [];

  const results = await Promise.allSettled(
    allowedNetworks.map(async (network) => {
      const assets = await fetchAssetsForNetwork(deps, wallet, network);
      return { network, assets };
    }),
  );

  for (const result of results) {
    if (result.status === 'fulfilled') {
      allAssets.push(result.value);
    } else {
      // RPC 실패 시 해당 네트워크 스킵 (fail-soft)
      // 에러 로그는 남기되 전체 응답을 실패시키지 않음
      console.warn(`getAssets failed for network:`, result.reason);
    }
  }

  return c.json({
    walletId: wallet.id,
    chain: wallet.chain,
    environment: wallet.environment,
    networks: allAssets.map(({ network, assets }) => ({
      network,
      assets: assets.map((a) => ({
        mint: a.mint,
        symbol: a.symbol,
        name: a.name,
        balance: a.balance.toString(),
        decimals: a.decimals,
        isNative: a.isNative,
        usdValue: a.usdValue,
      })),
    })),
  }, 200);
});
```

### 6.3 응답 스키마 변경

```typescript
// 기존 응답 (하위호환)
{
  walletId: string;
  chain: string;
  network: string;
  assets: AssetInfoDto[];
}

// 새 응답 (멀티네트워크)
{
  walletId: string;
  chain: string;
  environment: string;
  networks: Array<{
    network: string;
    assets: AssetInfoDto[];
  }>;
}
```

### 6.4 성능 고려사항

| 시나리오 | 네트워크 수 | 예상 지연 | 대응 |
|---------|-----------|----------|------|
| Solana testnet | 2 (devnet, testnet) | ~200ms | Promise.allSettled로 병렬 |
| EVM testnet | 5개 | ~500ms | Promise.allSettled로 병렬, timeout 5s |
| EVM mainnet | 5개 | ~500ms | 동일 |
| `?network=polygon-amoy` | 1개 | ~100ms | 단일 조회 (기존과 동일) |

**Timeout 전략:**
```typescript
const ASSET_QUERY_TIMEOUT = 5_000; // 5초

async function fetchAssetsForNetwork(deps, wallet, network): Promise<AssetInfo[]> {
  const rpcUrl = resolveRpcUrl(config.rpc, wallet.chain, network);
  const adapter = await deps.adapterPool.resolve(wallet.chain, network, rpcUrl);

  // 개별 네트워크 조회에 5초 타임아웃
  const result = await Promise.race([
    adapter.getAssets(wallet.publicKey),
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error(`getAssets timeout for ${network}`)), ASSET_QUERY_TIMEOUT),
    ),
  ]);

  return result;
}
```

### 6.5 getBalance 변경

`GET /wallet/balance`도 동일한 패턴으로 변경. `?network=` 쿼리 파라미터 지원:

```
GET /wallet/balance                     -> environment 기본 네트워크의 네이티브 잔액
GET /wallet/balance?network=polygon-amoy -> polygon-amoy의 네이티브 잔액
```

---

## 7. Question 5: Migration Path -- wallets.network -> wallets.environment

### 7.1 마이그레이션 전략

기존 프로젝트 규칙에 따라 ALTER TABLE 증분 마이그레이션을 사용한다 (DB 삭제 후 재생성 금지).

**v6 마이그레이션:** `wallets.environment` 컬럼 추가 + 데이터 변환

### 7.2 v6 마이그레이션 상세

```typescript
MIGRATIONS.push({
  version: 6,
  description: 'Add environment column to wallets, add network column to transactions',
  managesOwnTransaction: true,
  up: (sqlite) => {
    sqlite.exec('BEGIN');

    try {
      // ---- Part 1: wallets.environment 추가 ----

      // SQLite는 ALTER TABLE ADD COLUMN으로 컬럼 추가 가능 (CHECK 없이)
      sqlite.exec("ALTER TABLE wallets ADD COLUMN environment TEXT NOT NULL DEFAULT 'testnet'");

      // 기존 데이터의 environment 값 결정: network에서 파생
      // Solana: mainnet -> 'mainnet', devnet/testnet -> 'testnet'
      sqlite.exec(`
        UPDATE wallets SET environment = CASE
          WHEN network = 'mainnet' THEN 'mainnet'
          WHEN network IN ('ethereum-mainnet', 'polygon-mainnet', 'arbitrum-mainnet', 'optimism-mainnet', 'base-mainnet') THEN 'mainnet'
          ELSE 'testnet'
        END
      `);

      // ---- Part 2: transactions.network 추가 ----

      sqlite.exec("ALTER TABLE transactions ADD COLUMN network TEXT");

      // 기존 트랜잭션의 network 값: 해당 wallet의 network에서 복사
      sqlite.exec(`
        UPDATE transactions SET network = (
          SELECT wallets.network FROM wallets WHERE wallets.id = transactions.wallet_id
        )
      `);

      // ---- Part 3: 인덱스 추가 ----

      sqlite.exec('CREATE INDEX IF NOT EXISTS idx_wallets_environment ON wallets(environment)');
      sqlite.exec('CREATE INDEX IF NOT EXISTS idx_transactions_network ON transactions(network)');

      // ---- Part 4: policies.network 추가 ----

      sqlite.exec("ALTER TABLE policies ADD COLUMN network TEXT");

      // 기존 정책은 network=NULL (모든 네트워크에 적용)
      // ALTER TABLE ADD COLUMN의 기본값은 NULL이므로 UPDATE 불필요

      sqlite.exec('CREATE INDEX IF NOT EXISTS idx_policies_wallet_network ON policies(wallet_id, network, enabled)');

      sqlite.exec('COMMIT');
    } catch (err) {
      sqlite.exec('ROLLBACK');
      throw err;
    }

    // FK integrity check
    sqlite.pragma('foreign_keys = ON');
    const fkErrors = sqlite.pragma('foreign_key_check') as unknown[];
    if (fkErrors.length > 0) {
      throw new Error(`FK integrity check failed after v6 migration: ${JSON.stringify(fkErrors)}`);
    }
  },
});
```

### 7.3 v7 마이그레이션: CHECK 제약 업데이트

SQLite는 ALTER TABLE로 CHECK 제약을 추가할 수 없다. `wallets.environment`에 CHECK 제약을 추가하려면 12-step 테이블 재생성이 필요하다.

```typescript
MIGRATIONS.push({
  version: 7,
  description: 'Rebuild wallets table with environment CHECK constraint, remove legacy network column option',
  managesOwnTransaction: true,
  up: (sqlite) => {
    sqlite.exec('BEGIN');

    try {
      // wallets_new: environment 컬럼 + CHECK + network 유지 (하위호환)
      sqlite.exec(`CREATE TABLE wallets_new (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  chain TEXT NOT NULL CHECK (chain IN (${inList(CHAIN_TYPES)})),
  network TEXT NOT NULL CHECK (network IN (${inList(NETWORK_TYPES)})),
  environment TEXT NOT NULL CHECK (environment IN ('testnet', 'mainnet')),
  public_key TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'CREATING' CHECK (status IN (${inList(WALLET_STATUSES)})),
  owner_address TEXT,
  owner_verified INTEGER NOT NULL DEFAULT 0 CHECK (owner_verified IN (0, 1)),
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  suspended_at INTEGER,
  suspension_reason TEXT
)`);

      sqlite.exec('INSERT INTO wallets_new SELECT * FROM wallets');
      sqlite.exec('DROP TABLE wallets');
      sqlite.exec('ALTER TABLE wallets_new RENAME TO wallets');

      // 인덱스 재생성
      sqlite.exec('CREATE UNIQUE INDEX idx_wallets_public_key ON wallets(public_key)');
      sqlite.exec('CREATE INDEX idx_wallets_status ON wallets(status)');
      sqlite.exec('CREATE INDEX idx_wallets_chain_network ON wallets(chain, network)');
      sqlite.exec('CREATE INDEX idx_wallets_owner_address ON wallets(owner_address)');
      sqlite.exec('CREATE INDEX idx_wallets_environment ON wallets(environment)');

      // 종속 테이블의 FK 재생성이 필요하지만,
      // wallets PK (id TEXT)는 변경되지 않으므로 CASCADE FK는 유지됨
      // SQLite는 ALTER TABLE RENAME 시 FK를 자동 갱신하지 않음!
      // -> 종속 테이블(sessions, transactions, policies)도 재생성 필요

      // ... (v3 마이그레이션과 동일한 12-step 패턴으로 종속 테이블 재생성)
      // 여기서는 간략화. 실제 구현 시 v3과 같은 전체 종속 테이블 재생성 패턴 적용

      sqlite.exec('COMMIT');
    } catch (err) {
      sqlite.exec('ROLLBACK');
      throw err;
    }

    sqlite.pragma('foreign_keys = ON');
    const fkErrors = sqlite.pragma('foreign_key_check') as unknown[];
    if (fkErrors.length > 0) {
      throw new Error(`FK integrity check failed after v7 migration: ${JSON.stringify(fkErrors)}`);
    }
  },
});
```

### 7.4 마이그레이션 분할 전략 (권장)

복잡도를 관리하기 위해 v6과 v7을 분리한다:

| Migration | 내용 | 복잡도 | 데이터 손실 위험 |
|-----------|------|--------|---------------|
| **v6** | ADD COLUMN (environment, network) + 데이터 변환 + 인덱스 | Low | 없음 |
| **v7** | CHECK 제약 추가를 위한 12-step 테이블 재생성 | High | 낮음 (동일 데이터 복사) |

v6은 안전한 ALTER TABLE ADD COLUMN만 사용하므로 즉시 적용 가능. v7은 테이블 재생성이 필요하므로 별도 단계에서 진행.

### 7.5 wallets.network 컬럼 유지 결정

**wallets.network를 삭제하지 않고 유지한다.** 이유:

1. **하위호환:** 기존 REST API 응답에서 `wallet.network`를 반환 중. 즉시 삭제하면 SDK/MCP 클라이언트가 깨짐
2. **기본 네트워크:** `wallets.network`를 "환경 내 기본 네트워크"로 재정의. 트랜잭션 요청에 network가 미지정일 때 사용
3. **Keystore 호환:** KeystoreFileV1에 network 필드가 있으므로, 기존 키스토어 파일과의 호환성 유지

**의미 변경:**
```
Before: wallets.network = "이 지갑이 사용하는 유일한 네트워크"
After:  wallets.network = "이 지갑의 기본 네트워크 (환경 내)"
        wallets.environment = "이 지갑의 환경 (testnet/mainnet)"
```

---

## 8. Keystore 통합

### 8.1 핵심: 하나의 키쌍이 여러 네트워크에서 사용 가능

EVM 체인의 핵심 특성: **같은 개인키가 모든 EVM 네트워크에서 동일한 주소를 생성한다.** secp256k1 키쌍은 네트워크에 무관.

```
Private Key -> Public Key -> Address (0x1234...abcd)
이 주소가 Ethereum, Polygon, Arbitrum, Optimism, Base 모든 네트워크에서 동일
```

Solana도 마찬가지: ed25519 키쌍은 mainnet, devnet, testnet에서 동일한 주소.

### 8.2 Keystore 변경 사항

KeystoreFileV1에서 `network` 필드는 **참조용(reference)**이었고, 암호화/복호화에 영향을 주지 않았다.

**변경 없음:** Keystore는 walletId로 키를 식별하며, network 변경과 무관. 기존 코드:

```typescript
// keystore.ts - decryptPrivateKey(walletId, masterPassword)
// walletId로 파일 경로 결정, network 미사용
private keystorePath(walletId: string): string {
  return join(this.keystoreDir, `${walletId}.json`);
}
```

KeystoreFileV1 포맷은 선택적으로 `environment` 필드를 추가할 수 있지만, 기능적으로 필요하지 않다 (메타데이터 용도).

---

## 9. Component Boundaries

### 9.1 변경 경계 요약

```
@waiaas/core (공유 타입)
├── enums/chain.ts          -- ENVIRONMENT_TYPES, ENVIRONMENT_NETWORKS 추가
├── enums/policy.ts         -- 'ALLOWED_NETWORKS' 추가
├── schemas/wallet.schema.ts -- environment 필드 추가
└── schemas/transaction.schema.ts -- 5-type에 optional network 필드 추가

@waiaas/daemon (서버)
├── infrastructure/
│   ├── database/
│   │   ├── schema.ts       -- wallets.environment, transactions.network, policies.network 추가
│   │   └── migrate.ts      -- v6, v7 마이그레이션 추가
│   ├── adapter-pool.ts     -- 변경 없음
│   └── network-resolver.ts -- NEW: NetworkResolver 클래스
├── pipeline/
│   ├── pipeline.ts         -- PipelineDeps 변경 없음 (adapter는 외부에서 리졸브)
│   ├── stages.ts           -- PipelineContext.wallet 확장, stage1에 network INSERT
│   └── database-policy-engine.ts -- ALLOWED_NETWORKS 평가, network-scoped 리졸브
├── api/routes/
│   ├── wallets.ts          -- POST /wallets: environment 파라미터 처리
│   ├── wallet.ts           -- GET /wallet/assets: 멀티네트워크 집계
│   └── transactions.ts     -- POST /transactions/send: NetworkResolver 통합
└── lifecycle/daemon.ts     -- executeFromStage5: NetworkResolver 통합

@waiaas/mcp (MCP 서버)
└── tools/*.ts              -- SDK API 변경 반영 (network 파라미터 전달)

@waiaas/sdk (TypeScript SDK)
└── client.ts               -- sendTransaction에 optional network 파라미터

waiaas (Python SDK)
└── client.py               -- send_transaction에 optional network 파라미터
```

### 9.2 의존 그래프

```
@waiaas/core (enums, schemas)     <- 모든 패키지가 의존
  |
  v
@waiaas/daemon
  ├── infrastructure/database/migrate.ts  <- schema.ts 변경에 의존
  ├── infrastructure/network-resolver.ts  <- core enums에 의존
  ├── pipeline/stages.ts                  <- schema 변경에 의존
  ├── pipeline/database-policy-engine.ts  <- policy enum에 의존
  ├── api/routes/transactions.ts          <- network-resolver에 의존
  ├── api/routes/wallets.ts               <- network-resolver에 의존
  ├── api/routes/wallet.ts                <- adapter-pool에 의존
  └── lifecycle/daemon.ts                 <- network-resolver에 의존
```

---

## 10. Anti-Patterns to Avoid

### Anti-Pattern 1: Environment를 런타임에서 변경 가능하게 만들기
**What:** PUT /wallets/:id/environment로 testnet -> mainnet 전환 허용
**Why bad:** testnet 토큰과 mainnet 토큰이 혼재, 정책 스코핑 혼란, 기존 트랜잭션 히스토리와 불일치
**Instead:** environment는 지갑 생성 시 고정. 다른 environment가 필요하면 새 지갑 생성.

### Anti-Pattern 2: 모든 네트워크 자산을 항상 집계하기
**What:** GET /wallet/assets가 항상 5개 네트워크 병렬 조회
**Why bad:** 불필요한 RPC 호출 5배 증가, 응답 지연 500ms+
**Instead:** `?network=` 쿼리 파라미터로 단일 네트워크 조회 기본, 전체 집계는 명시적 요청 시에만.

### Anti-Pattern 3: AdapterPool 내부에 environment 로직 넣기
**What:** AdapterPool.resolveForEnvironment(chain, environment)
**Why bad:** AdapterPool은 범용 어댑터 캐시 풀. environment 비즈니스 로직을 주입하면 SRP 위반
**Instead:** NetworkResolver가 environment -> network 변환, AdapterPool은 기존 chain:network 인터페이스 유지.

### Anti-Pattern 4: transactions.network를 NOT NULL로 만들기 (마이그레이션 시)
**What:** ALTER TABLE ADD COLUMN network TEXT NOT NULL DEFAULT 'unknown'
**Why bad:** 기존 트랜잭션에 잘못된 기본값이 들어감
**Instead:** NULL 허용 후 UPDATE로 wallet.network에서 파생, 이후 NOT NULL 전환은 v7에서 처리.

---

## 11. Scalability Considerations

| Concern | 100 wallets | 10K wallets | 1M wallets |
|---------|------------|------------|------------|
| AdapterPool 캐시 크기 | 최대 13 (13 NetworkType) | 동일 (네트워크 수 고정) | 동일 |
| getAssets 병렬 조회 | 5 RPC/요청 | 동일 (지갑당) | 캐시 레이어 필요 |
| policies 테이블 스캔 | < 100 rows | ~50K rows | network 인덱스 + 파티셔닝 고려 |
| transactions.network 인덱스 | 무시 가능 | 인덱스 효과적 | 복합 인덱스 (wallet_id, network, status) |

---

## 12. Suggested Build Order

의존성 그래프 기반 빌드 순서:

### Phase A: Core Types + DB Schema (선행 조건)
1. `@waiaas/core/enums/chain.ts` -- ENVIRONMENT_TYPES, ENVIRONMENT_NETWORKS 추가
2. `@waiaas/core/enums/policy.ts` -- ALLOWED_NETWORKS 추가
3. `@waiaas/core/schemas/wallet.schema.ts` -- environment 필드 추가
4. `@waiaas/core/schemas/transaction.schema.ts` -- 5-type에 optional network 필드
5. DB schema.ts (Drizzle 스키마 업데이트)
6. DB migrate.ts v6 마이그레이션 (ADD COLUMN)
7. DDL pushSchema 업데이트 (LATEST_SCHEMA_VERSION = 7)

### Phase B: NetworkResolver + Pipeline Integration
8. `daemon/infrastructure/network-resolver.ts` -- NetworkResolver 클래스
9. `daemon/pipeline/stages.ts` -- PipelineContext 확장, stage1에 network INSERT
10. `daemon/pipeline/database-policy-engine.ts` -- ALLOWED_NETWORKS 평가 + network-scoped 리졸브

### Phase C: Route Integration
11. `daemon/api/routes/wallets.ts` -- POST /wallets: environment 파라미터 처리
12. `daemon/api/routes/transactions.ts` -- POST /transactions/send: NetworkResolver 통합
13. `daemon/api/routes/wallet.ts` -- GET /wallet/assets: 멀티네트워크 집계
14. `daemon/lifecycle/daemon.ts` -- executeFromStage5 변경

### Phase D: CHECK 제약 마이그레이션
15. DB migrate.ts v7 마이그레이션 (12-step 테이블 재생성)

### Phase E: SDK + MCP Integration
16. `@waiaas/sdk` -- sendTransaction에 optional network
17. `@waiaas/mcp` -- MCP 도구에 network 파라미터
18. Python SDK -- send_transaction에 optional network
19. skill 파일 업데이트

### Phase F: Admin UI + Tests
20. Admin UI -- 지갑 상세에서 environment 표시, 네트워크 선택 UI
21. 단위 테스트 -- NetworkResolver, ALLOWED_NETWORKS 정책
22. 통합 테스트 -- 멀티네트워크 파이프라인 E2E
23. 마이그레이션 테스트 -- v6, v7 마이그레이션 검증

**Phase ordering rationale:**
- A -> B: 코어 타입이 먼저 있어야 파이프라인 통합 가능
- B -> C: 파이프라인 로직이 먼저 있어야 라우트에서 호출 가능
- C -> D: CHECK 제약은 기능이 동작한 후 안전하게 추가
- C -> E: REST API가 확정된 후 SDK/MCP 반영
- All -> F: 모든 기능 구현 후 테스트

---

## 13. Sources

| Source | Type | Confidence |
|--------|------|-----------|
| `packages/core/src/enums/chain.ts` | Codebase | HIGH |
| `packages/core/src/schemas/wallet.schema.ts` | Codebase | HIGH |
| `packages/core/src/schemas/transaction.schema.ts` | Codebase | HIGH |
| `packages/daemon/src/infrastructure/database/schema.ts` | Codebase | HIGH |
| `packages/daemon/src/infrastructure/database/migrate.ts` | Codebase | HIGH |
| `packages/daemon/src/infrastructure/adapter-pool.ts` | Codebase | HIGH |
| `packages/daemon/src/pipeline/pipeline.ts` | Codebase | HIGH |
| `packages/daemon/src/pipeline/stages.ts` | Codebase | HIGH |
| `packages/daemon/src/pipeline/database-policy-engine.ts` | Codebase | HIGH |
| `packages/daemon/src/api/routes/transactions.ts` | Codebase | HIGH |
| `packages/daemon/src/api/routes/wallets.ts` | Codebase | HIGH |
| `packages/daemon/src/api/routes/wallet.ts` | Codebase | HIGH |
| `packages/daemon/src/infrastructure/keystore/keystore.ts` | Codebase | HIGH |
| `packages/daemon/src/infrastructure/config/loader.ts` | Codebase | HIGH |
| `packages/daemon/src/lifecycle/daemon.ts` | Codebase | HIGH |
| `packages/core/src/interfaces/IChainAdapter.ts` | Codebase | HIGH |
| EVM secp256k1 address derivation (chain-agnostic) | Domain knowledge | HIGH |
| Solana ed25519 address derivation (network-agnostic) | Domain knowledge | HIGH |
