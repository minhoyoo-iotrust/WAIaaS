# Technology Stack: v1.5.1 x402 Client Support

**Project:** WAIaaS v1.5.1 -- x402 프로토콜 클라이언트 지원
**Researched:** 2026-02-15
**Mode:** Subsequent Milestone (stack additions only)

---

## Executive Summary

x402 클라이언트 구현을 위한 6가지 기술 영역을 조사한 결과, **신규 npm 의존성 1개(@x402/core)만 추가하고 나머지는 기존 스택으로 해결**하는 전략을 권장한다. @x402/core v2.3.1은 Zod 기반 스키마를 공식 제공하므로 WAIaaS의 Zod SSoT 원칙과 완벽하게 호환된다. EVM EIP-3009 서명은 viem 2.x의 `signTypedData` (이미 import 가능)로, Solana 부분 서명은 @solana/kit의 기존 `signBytes` 패턴으로 구현 가능하다. SSRF 보호는 외부 라이브러리 대신 Node.js 내장 `dns.lookup` + `ipaddr.js`(Node.js 내장 의존)로 직접 구현하고, HTTP 클라이언트는 native fetch를 사용한다.

---

## Recommended Stack Additions

### 신규 의존성: 1개

| Technology | Version | Purpose | Why |
|------------|---------|---------|-----|
| `@x402/core` | ^2.3.1 | x402 v2 프로토콜 타입, Zod 스키마, PaymentRequired/PaymentPayload 파싱 | Coinbase 공식 Zod 스키마 제공. 자체 정의 대비 스펙 변경 추종 비용 제거. 유일한 런타임 의존성이 `zod ^3.24.2`로 WAIaaS와 동일 |

### 신규 devDependency: 없음

### 명시적으로 추가하지 않는 것 (Anti-Dependencies)

| 라이브러리 | 왜 추가하지 않는가 |
|-----------|-----------------|
| `@x402/fetch` | x402 fetch 래퍼. 자체 wrapFetch 패턴이지만 WAIaaS는 SSRF 보호 + 정책 평가가 필요하므로 자체 핸들러 구현 필수. fetch 래퍼 사용 불가 |
| `@x402/evm` | EVM 결제 서명 구현. viem 2.x를 의존하지만, WAIaaS는 이미 viem을 직접 사용하므로 중복. 또한 @x402/evm의 `ClientEvmSigner` 인터페이스는 외부 wallet용이지 로컬 키 관리 데몬용이 아님 |
| `@x402/svm` | Solana 결제 서명 구현. @solana/kit 5.x를 사용하나 WAIaaS는 6.x. 버전 충돌 위험. 또한 facilitator 인터페이스 포함 등 서버 측 로직이 클라이언트에 불필요 |
| `@coinbase/x402` | Coinbase 호스팅 facilitator SDK. 클라이언트는 facilitator와 직접 통신하지 않으므로 불필요 |
| `caip` (npm) | CAIP-2 파싱 라이브러리. x402가 사용하는 CAIP-2 형식은 `namespace:reference`로 단순. `string.split(':')` 수준이므로 라이브러리 불필요 |
| `request-filtering-agent` | SSRF 보호용 http.Agent. Node.js native fetch는 http.Agent를 지원하지 않으므로 사용 불가 |
| `ssrf-req-filter` | 동일 이유. http.Agent 기반이라 native fetch와 호환 불가 |
| `private-ip` | 사설 IP 판별. multicast 주소를 비-사설로 잘못 분류하는 CVE 존재. 자체 구현이 더 안전 |
| `ipaddr.js` (직접 의존) | Node.js가 이미 `ipaddr.js`를 내부적으로 사용. 하지만 직접 의존 추가 대신 `node:net` + `node:dns` 내장 모듈로 구현 |

---

## 상세 분석: 6가지 기술 영역

### 1. x402 타입/스키마: @x402/core 사용

**결론: @x402/core v2.3.1의 Zod 스키마를 직접 import하여 사용한다.**

**신뢰도: HIGH** -- npm 패키지 확인, GitHub 소스 코드 검증 완료.

**@x402/core 패키지 분석:**

```
패키지: @x402/core v2.3.1
라이선스: Apache-2.0 (WAIaaS와 동일)
런타임 의존성: zod ^3.24.2 (WAIaaS의 zod ^3.24.0과 호환)
빌드: TypeScript 5.7.3, tsup, dual CJS/ESM
exports: '.', './client', './facilitator', './http', './server', './types', './types/v1', './utils', './schemas'
```

**핵심 export 구조:**

```typescript
// @x402/core/types -- TypeScript 타입
export type Network = `${string}:${string}`;  // CAIP-2 형식
export type PaymentRequirements = {
  scheme: string;
  network: Network;
  asset: string;
  amount: string;
  payTo: string;
  maxTimeoutSeconds: number;
  extra: Record<string, unknown>;
};
export type PaymentRequired = {
  x402Version: number;
  error?: string;
  resource: ResourceInfo;
  accepts: PaymentRequirements[];
  extensions?: Record<string, unknown>;
};
export type PaymentPayload = {
  x402Version: number;
  resource: ResourceInfo;
  accepted: PaymentRequirements;
  payload: Record<string, unknown>;
  extensions?: Record<string, unknown>;
};

// @x402/core/schemas -- Zod 스키마
export const NetworkSchemaV2;       // CAIP-2 형식 검증
export const PaymentRequirementsV2Schema;
export const PaymentRequiredV2Schema;
export const PaymentPayloadV2Schema;
// + discriminatedUnion (v1/v2 겸용)
export const PaymentRequiredSchema;
export const PaymentPayloadSchema;
```

**WAIaaS 통합 전략:**

```typescript
// packages/core/src/interfaces/x402.types.ts
// @x402/core의 스키마를 import하되, WAIaaS 전용 타입은 자체 Zod 스키마로 정의

import { PaymentRequiredV2Schema, PaymentPayloadV2Schema } from '@x402/core/schemas';
import type { PaymentRequired, PaymentPayload, PaymentRequirements } from '@x402/core/types';
import { z } from 'zod';

// WAIaaS 전용 요청/응답 타입만 자체 정의
export const X402FetchRequestSchema = z.object({
  url: z.string().url(),
  method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).default('GET'),
  headers: z.record(z.string()).optional(),
  body: z.string().optional(),
});
export type X402FetchRequest = z.infer<typeof X402FetchRequestSchema>;

// x402 프로토콜 타입은 @x402/core에서 re-export
export { PaymentRequiredV2Schema, PaymentPayloadV2Schema };
export type { PaymentRequired, PaymentPayload, PaymentRequirements };
```

**왜 자체 Zod 스키마 대신 @x402/core를 사용하는가:**

1. **스펙 추종 비용 제거**: x402 스펙이 v2.x -> v3.x로 업데이트되면 @x402/core만 업데이트하면 됨
2. **Zod SSoT 호환**: @x402/core가 이미 Zod로 스키마를 정의하므로 WAIaaS의 Zod → TS 파생 패턴과 동일
3. **검증 함수 재사용**: `parsePaymentRequired()`, `validatePaymentPayload()` 등 @x402/core의 유틸리티 함수 활용 가능
4. **단일 런타임 의존성**: zod만 의존하므로 번들 크기 영향 최소

**주의사항:**

@x402/core는 `./client`, `./server`, `./facilitator` subpath도 export하나, WAIaaS는 `./types`와 `./schemas`만 사용한다. Client/Server/Facilitator 로직은 WAIaaS 자체 구현이 필요하기 때문이다 (정책 평가, SSRF 보호, 감사 로그 등).

---

### 2. EVM EIP-3009 서명: viem `signTypedData` (기존 스택)

**결론: 이미 설치된 viem 2.x의 `signTypedData` API를 사용한다. 추가 의존성 없음.**

**신뢰도: HIGH** -- viem 공식 문서 확인, EvmAdapter에서 privateKeyToAccount 이미 사용 중.

**EIP-3009 TransferWithAuthorization 서명 구조:**

x402 EVM exact 스킴은 EIP-3009 `transferWithAuthorization`을 사용한다. 이는 EIP-712 typed data 서명이며, viem의 `account.signTypedData()`로 직접 생성 가능하다.

```typescript
import { privateKeyToAccount } from 'viem/accounts';
import type { Hex } from 'viem';

// 기존 EvmAdapter와 동일 패턴으로 계정 생성
const privateKeyHex = `0x${Buffer.from(privateKey).toString('hex')}` as Hex;
const account = privateKeyToAccount(privateKeyHex);

// EIP-3009 TransferWithAuthorization 서명 (EIP-712)
const signature = await account.signTypedData({
  domain: {
    name: tokenName,           // e.g., 'USD Coin'
    version: tokenVersion,     // e.g., '2'
    chainId: chainId,          // e.g., 8453 (Base)
    verifyingContract: tokenAddress,  // USDC contract address
  },
  types: {
    TransferWithAuthorization: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'validAfter', type: 'uint256' },
      { name: 'validBefore', type: 'uint256' },
      { name: 'nonce', type: 'bytes32' },
    ],
  },
  primaryType: 'TransferWithAuthorization',
  message: {
    from: walletAddress,       // 결제자(WAIaaS 월렛)
    to: payTo,                 // 수신자(PaymentRequirements.payTo)
    value: amount,             // 결제 금액
    validAfter: 0n,            // 즉시 유효
    validBefore: deadline,     // maxTimeoutSeconds 기반 만료
    nonce: randomNonce,        // 32바이트 랜덤 논스 (replay 방지)
  },
});
```

**x402 EVM PaymentPayload 생성:**

```typescript
// EIP-3009 authorization 객체 구성
const authorization = {
  from: walletAddress,
  to: payTo,
  value: amount.toString(),
  validAfter: '0',
  validBefore: deadline.toString(),
  nonce: randomNonce,
};

// x402 PaymentPayload
const payload = {
  x402Version: 2,
  resource: { url: targetUrl },
  accepted: selectedRequirement,
  payload: {
    signature: signature,     // EIP-712 서명 (0x-prefixed hex)
    authorization: authorization,
  },
};
```

**Permit2 방식 (대안):**

x402 EVM exact 스킴은 EIP-3009 외에 Permit2 방식도 지원한다. Permit2는 `PermitWitnessTransferFrom` 구조체를 사용하며 Uniswap의 Permit2 컨트랙트를 경유한다. 그러나 **WAIaaS v1.5.1에서는 EIP-3009만 지원**하는 것을 권장한다:

- EIP-3009은 USDC(x402의 주요 결제 토큰)에 네이티브 구현됨
- Permit2는 사전 approve 트랜잭션이 필요하여 복잡도 증가
- x402 v2에서 EIP-3009이 기본 방식

**viem API 호환성:**

| viem 함수 | 현재 사용 여부 | x402에서의 활용 |
|-----------|-------------|--------------|
| `privateKeyToAccount` | O (EvmAdapter) | 동일 패턴으로 EIP-712 서명자 생성 |
| `account.signTransaction` | O (EvmAdapter) | x402에서는 사용하지 않음 (EIP-3009은 tx가 아닌 typed data 서명) |
| `account.signTypedData` | X (신규 활용) | EIP-3009 TransferWithAuthorization 서명 |
| `hexToBytes` / `toHex` | O (EvmAdapter) | 서명값 변환 |

`account.signTypedData`는 viem의 `LocalAccount` 인터페이스에 포함된 메서드로, `privateKeyToAccount`로 생성한 계정 객체에서 바로 호출 가능하다. 별도 import 불필요.

---

### 3. Solana SPL TransferChecked 부분 서명: @solana/kit (기존 스택)

**결론: 기존 SolanaAdapter의 signTransaction 패턴을 그대로 활용한다. 추가 의존성 없음.**

**신뢰도: HIGH** -- SolanaAdapter에서 동일 패턴 실사용 중. x402 SVM 스펙 확인 완료.

**x402 Solana 부분 서명 프로세스:**

x402 Solana exact 스킴에서 클라이언트는:
1. SPL TransferChecked instruction이 포함된 트랜잭션을 빌드
2. 클라이언트 월렛으로 **부분 서명** (feePayer 서명 없이)
3. 부분 서명된 트랜잭션을 base64로 인코딩하여 PaymentPayload에 포함
4. facilitator가 feePayer 서명을 추가하여 최종 제출

**구현 전략:**

```typescript
import {
  createTransactionMessage,
  setTransactionMessageFeePayer,
  appendTransactionMessageInstruction,
  setTransactionMessageLifetimeUsingBlockhash,
  compileTransaction,
  getTransactionEncoder,
  signBytes,
  createKeyPairFromBytes,
  createKeyPairFromPrivateKeyBytes,
  getAddressFromPublicKey,
  address,
  createNoopSigner,
  pipe,
} from '@solana/kit';
import { getTransferCheckedInstruction, findAssociatedTokenPda } from '@solana-program/token';

// 1. 트랜잭션 빌드 (feePayer = facilitator의 주소, PaymentRequirements.extra.feePayer에서 가져옴)
const feePayerAddress = address(paymentRequirements.extra.feePayer as string);
const feePayerSigner = createNoopSigner(feePayerAddress);  // feePayer는 noop (facilitator가 나중에 서명)

const walletKeyPair = privateKey.length === 64
  ? await createKeyPairFromBytes(privateKey)
  : await createKeyPairFromPrivateKeyBytes(privateKey.slice(0, 32));
const walletAddress = await getAddressFromPublicKey(walletKeyPair.publicKey);

// 2. SPL TransferChecked instruction 생성
const transferIx = getTransferCheckedInstruction({
  source: sourceAta,
  mint: address(paymentRequirements.asset),
  destination: destinationAta,
  authority: walletAddress,  // 이체 권한자 = 월렛
  amount: BigInt(paymentRequirements.amount),
  decimals: tokenDecimals,
});

// 3. 트랜잭션 메시지 구성
const txMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (msg) => setTransactionMessageFeePayer(feePayerSigner, msg),
  (msg) => setTransactionMessageLifetimeUsingBlockhash(blockhash, msg),
  (msg) => appendTransactionMessageInstruction(transferIx, msg),
);

// 4. 컴파일
const compiled = compileTransaction(txMessage);

// 5. 부분 서명 (월렛 서명만, feePayer 서명 없이)
const signature = await signBytes(walletKeyPair.privateKey, compiled.messageBytes);
const partiallySignedTx = {
  ...compiled,
  signatures: {
    ...compiled.signatures,
    [walletAddress]: signature,
    // feePayer 서명 슬롯은 비워둠 (facilitator가 채움)
  },
};

// 6. base64 인코딩
const txEncoder = getTransactionEncoder();
const serialized = new Uint8Array(txEncoder.encode(partiallySignedTx));
const base64Tx = Buffer.from(serialized).toString('base64');

// 7. PaymentPayload 구성
const payload = {
  x402Version: 2,
  resource: { url: targetUrl },
  accepted: selectedRequirement,
  payload: {
    transaction: base64Tx,  // base64 부분 서명 트랜잭션
  },
};
```

**기존 SolanaAdapter와의 차이점:**

| 측면 | 기존 signTransaction | x402 부분 서명 |
|------|---------------------|--------------|
| feePayer | 월렛 자체 | facilitator (PaymentRequirements.extra.feePayer) |
| 서명 완전성 | 완전 서명 (feePayer = signer 동일) | 부분 서명 (feePayer 서명 빈 슬롯) |
| 제출 | WAIaaS가 submitTransaction | 리소스 서버/facilitator가 제출 |
| blockhash | RPC에서 직접 조회 | RPC에서 조회 (동일) |

**@solana/kit 6.x의 부분 서명 지원:**

@solana/kit의 `compileTransaction`은 모든 signer 슬롯을 포함하되 서명이 없는 슬롯은 빈 상태로 둔다. `signBytes`로 특정 signer만 서명하면 자연스럽게 부분 서명 트랜잭션이 된다. 별도의 `partiallySignTransaction` 함수가 필요하지 않다 -- 현재 SolanaAdapter.signTransaction()의 패턴과 동일하게 특정 키로만 서명하면 된다.

**주의: noopSigner와 feePayer 관계:**

`createNoopSigner(feePayerAddress)`는 feePayer 주소를 트랜잭션 메시지에 등록하되 실제 서명은 하지 않는다. @solana/kit에서 이미 SolanaAdapter의 `buildTransaction`에서 사용하는 패턴이다. x402에서는 facilitator의 주소를 noopSigner로 지정하여, 서명 슬롯은 만들되 클라이언트 측에서는 서명하지 않는 방식이다.

---

### 4. SSRF 보호: 자체 구현 (`node:dns` + `node:net`)

**결론: 외부 라이브러리 없이 Node.js 내장 모듈로 SSRF 가드를 직접 구현한다.**

**신뢰도: HIGH** -- OWASP 가이드라인 + Node.js 내장 API 기반.

**외부 라이브러리를 사용하지 않는 이유:**

1. `request-filtering-agent` (v3.2.0): `http.Agent` 기반이라 native `fetch`와 호환 불가
2. `ssrf-req-filter`: 동일 문제 (`http.Agent` 기반)
3. `private-ip`: multicast SSRF 바이패스 CVE 존재
4. `nossrf`: DNS 리바인딩 방어 실패 보고됨

**구현 전략: DNS 해석 후 IP 검증 → fetch 호출:**

```typescript
// packages/daemon/src/services/x402/ssrf-guard.ts
import { lookup } from 'node:dns/promises';
import { isIP } from 'node:net';

// RFC 5735/6890 기반 사설/예약 IP 범위
const BLOCKED_IPV4_RANGES = [
  { prefix: '0.',        name: 'this-network' },
  { prefix: '10.',       name: 'private-class-a' },
  { prefix: '127.',      name: 'loopback' },
  { prefix: '169.254.',  name: 'link-local' },
  { prefix: '192.168.',  name: 'private-class-c' },
  // 172.16.0.0/12 = 172.16.x - 172.31.x
] as const;

const BLOCKED_IPV6 = ['::1', '::'];
const BLOCKED_IPV6_PREFIXES = ['fe80:', 'fc00:', 'fd00:', 'ff00:'];

function isPrivateIPv4(ip: string): boolean {
  if (BLOCKED_IPV4_RANGES.some(r => ip.startsWith(r.prefix))) return true;
  // 172.16.0.0/12 체크
  const parts = ip.split('.');
  if (parts[0] === '172') {
    const second = parseInt(parts[1], 10);
    if (second >= 16 && second <= 31) return true;
  }
  return false;
}

function isPrivateIPv6(ip: string): boolean {
  const normalized = ip.toLowerCase();
  if (BLOCKED_IPV6.includes(normalized)) return true;
  return BLOCKED_IPV6_PREFIXES.some(p => normalized.startsWith(p));
}

function isPrivateIP(ip: string): boolean {
  return isIP(ip) === 4 ? isPrivateIPv4(ip) : isPrivateIPv6(ip);
}

/**
 * SSRF 가드: URL의 호스트를 DNS 해석하여 사설 IP 접근을 차단한다.
 *
 * 방어 대상:
 * 1. 직접 사설 IP 입력 (http://127.0.0.1)
 * 2. DNS 리바인딩 (내부 IP로 해석되는 도메인)
 * 3. IPv4-mapped IPv6 (::ffff:127.0.0.1)
 * 4. 옥탈/헥스 IP 인코딩 (0x7f.1 = 127.0.0.1)
 */
export async function validateUrlSafety(urlString: string): Promise<URL> {
  const url = new URL(urlString);

  // 1. 프로토콜 검증 (HTTPS만 또는 HTTP도 허용)
  if (!['http:', 'https:'].includes(url.protocol)) {
    throw new Error(`Blocked protocol: ${url.protocol}`);
  }

  // 2. 호스트가 직접 IP인 경우
  const hostname = url.hostname;
  if (isIP(hostname)) {
    if (isPrivateIP(hostname)) {
      throw new Error(`Blocked private IP: ${hostname}`);
    }
    return url;
  }

  // 3. DNS 해석하여 실제 IP 확인
  const { address: resolvedIP } = await lookup(hostname);
  if (isPrivateIP(resolvedIP)) {
    throw new Error(`Blocked: ${hostname} resolves to private IP ${resolvedIP}`);
  }

  return url;
}
```

**추가 보호 레이어:**

- `X402_ALLOWED_DOMAINS` 정책이 1차 방어 (도메인 화이트리스트)
- SSRF 가드는 2차 방어 (화이트리스트 통과 후에도 DNS 리바인딩 방어)
- config.toml의 `request_timeout = 30`으로 시간 제한

**Node.js 22 호환성:**

`node:dns/promises`의 `lookup()`은 Node.js 22에서 안정 API. `node:net`의 `isIP()`도 안정 API. 추가 polyfill 불필요.

---

### 5. HTTP 클라이언트: native `fetch` (기존 스택)

**결론: Node.js 22 내장 `fetch`를 사용한다. 추가 라이브러리 없음.**

**신뢰도: HIGH** -- Node.js 22에서 fetch는 안정 API (undici 기반).

**WAIaaS의 zero external dependency 철학과 일치하며, 이미 프로젝트에서 native fetch를 사용하는 패턴이 존재한다.**

```typescript
// packages/daemon/src/services/x402/x402-handler.ts

async function proxyRequest(
  url: URL,
  method: string,
  headers?: Record<string, string>,
  body?: string,
  paymentHeader?: string,
  timeout: number = 30_000,
): Promise<Response> {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeout);

  try {
    const fetchHeaders: Record<string, string> = {
      ...headers,
      ...(paymentHeader ? { 'X-PAYMENT': paymentHeader } : {}),
    };

    return await fetch(url.toString(), {
      method,
      headers: fetchHeaders,
      body: method !== 'GET' ? body : undefined,
      signal: controller.signal,
      redirect: 'manual',  // 리다이렉트 수동 처리 (SSRF 방지)
    });
  } finally {
    clearTimeout(timer);
  }
}
```

**native fetch를 선택하는 이유:**

| 고려 사항 | native fetch | axios/got/node-fetch |
|----------|-------------|---------------------|
| 의존성 추가 | 없음 | npm 패키지 추가 필요 |
| Node.js 22 호환 | 내장 (undici 기반) | 별도 설치 필요 |
| AbortController | 네이티브 지원 | 라이브러리별 상이 |
| 리다이렉트 제어 | `redirect: 'manual'` | 가능하나 API 상이 |
| http.Agent (SSRF) | 미지원 | 지원 (불필요) |
| WAIaaS 철학 | 일치 (zero-dep) | 불필요한 의존성 |

**SSRF 보호와의 통합:**

native fetch는 `http.Agent`를 지원하지 않으므로, SSRF 보호는 fetch 호출 **전에** DNS 해석 + IP 검증으로 수행한다 (섹션 4 참조). 이는 실제로 더 안전하다 -- Agent 기반 SSRF 보호는 DNS 리바인딩 공격에 취약할 수 있지만, 사전 DNS 해석 방식은 해석된 IP를 직접 검증한다.

**리다이렉트 처리:**

```typescript
// 리다이렉트를 수동 처리하여 SSRF 바이패스 방지
// 외부 서버가 리다이렉트로 내부 IP로 유도하는 공격 방어
const response = await fetch(url, { redirect: 'manual' });
if (response.status >= 300 && response.status < 400) {
  const location = response.headers.get('Location');
  if (location) {
    // 리다이렉트 대상도 SSRF 검증
    const redirectUrl = await validateUrlSafety(location);
    return fetch(redirectUrl.toString(), { redirect: 'manual' });
  }
}
```

---

### 6. CAIP-2 네트워크 식별자: 자체 매핑 테이블 (라이브러리 없음)

**결론: x402 CAIP-2 식별자와 WAIaaS NetworkType 사이의 양방향 매핑을 상수 테이블로 정의한다.**

**신뢰도: HIGH** -- x402 Network Support 페이지 + CAIP-2 스펙 + WAIaaS chain.ts 직접 확인.

**x402 CAIP-2 → WAIaaS NetworkType 매핑:**

```typescript
// packages/core/src/interfaces/x402.types.ts (또는 별도 caip-mapping.ts)

/**
 * x402 CAIP-2 네트워크 식별자 ↔ WAIaaS NetworkType 매핑.
 *
 * CAIP-2 형식: namespace:reference
 *   - EVM: eip155:{chainId}
 *   - Solana: solana:{truncatedGenesisHash}
 *
 * 출처:
 *   - https://docs.cdp.coinbase.com/x402/network-support
 *   - https://namespaces.chainagnostic.org/solana/caip2
 *   - packages/core/src/enums/chain.ts (WAIaaS NetworkType)
 */
export const CAIP2_TO_NETWORK: Record<string, { chain: ChainType; network: NetworkType }> = {
  // EVM
  'eip155:1':       { chain: 'ethereum', network: 'ethereum-mainnet' },
  'eip155:11155111': { chain: 'ethereum', network: 'ethereum-sepolia' },
  'eip155:137':     { chain: 'ethereum', network: 'polygon-mainnet' },
  'eip155:80002':   { chain: 'ethereum', network: 'polygon-amoy' },
  'eip155:42161':   { chain: 'ethereum', network: 'arbitrum-mainnet' },
  'eip155:421614':  { chain: 'ethereum', network: 'arbitrum-sepolia' },
  'eip155:10':      { chain: 'ethereum', network: 'optimism-mainnet' },
  'eip155:11155420': { chain: 'ethereum', network: 'optimism-sepolia' },
  'eip155:8453':    { chain: 'ethereum', network: 'base-mainnet' },
  'eip155:84532':   { chain: 'ethereum', network: 'base-sepolia' },

  // Solana (genesis hash truncated to 32 chars)
  'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': { chain: 'solana', network: 'mainnet' },
  'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1':  { chain: 'solana', network: 'devnet' },
  'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z':  { chain: 'solana', network: 'testnet' },
};

// 역방향 매핑 (WAIaaS → x402)
export const NETWORK_TO_CAIP2: Record<NetworkType, string> = Object.fromEntries(
  Object.entries(CAIP2_TO_NETWORK).map(([caip2, { network }]) => [network, caip2]),
) as Record<NetworkType, string>;

// CAIP-2 파싱 유틸리티
export function parseCaip2(network: string): { namespace: string; reference: string } {
  const colonIndex = network.indexOf(':');
  if (colonIndex === -1) throw new Error(`Invalid CAIP-2 identifier: ${network}`);
  return {
    namespace: network.slice(0, colonIndex),
    reference: network.slice(colonIndex + 1),
  };
}

// x402 네트워크 → WAIaaS 네트워크 변환
export function resolveX402Network(caip2: string): { chain: ChainType; network: NetworkType } {
  const resolved = CAIP2_TO_NETWORK[caip2];
  if (!resolved) throw new Error(`Unsupported x402 network: ${caip2}`);
  return resolved;
}
```

**왜 `caip` npm 패키지를 사용하지 않는가:**

1. CAIP-2 파싱은 `string.split(':')` 수준으로 단순 -- 라이브러리 불필요
2. WAIaaS가 지원하는 네트워크는 13개로 유한 집합 -- 상수 매핑이 가장 명확
3. x402에서 사용하는 CAIP-2는 `namespace:reference` 형식만 -- CAIP-10 (계정 ID) 등은 불필요
4. `caip` 패키지(v0.10.x)는 CAIP-2 외에 CAIP-10, CAIP-19 등 불필요한 기능 포함

**x402 v2에서 지원되는 네트워크 목록 (CDP Facilitator 기준):**

| x402 CAIP-2 | WAIaaS NetworkType | 지원 상태 |
|-------------|-------------------|----------|
| `eip155:8453` (Base Mainnet) | `base-mainnet` | WAIaaS 지원 O |
| `eip155:84532` (Base Sepolia) | `base-sepolia` | WAIaaS 지원 O |
| `eip155:1` (Ethereum Mainnet) | `ethereum-mainnet` | WAIaaS 지원 O |
| `eip155:10` (Optimism) | `optimism-mainnet` | WAIaaS 지원 O |
| `eip155:137` (Polygon) | `polygon-mainnet` | WAIaaS 지원 O |
| `eip155:42161` (Arbitrum One) | `arbitrum-mainnet` | WAIaaS 지원 O |
| `eip155:43114` (Avalanche C-Chain) | N/A | WAIaaS 지원 X (미래 확장) |
| `eip155:43113` (Avalanche Fuji) | N/A | WAIaaS 지원 X |
| `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp` (Mainnet) | `mainnet` | WAIaaS 지원 O |
| `solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1` (Devnet) | `devnet` | WAIaaS 지원 O |

**Avalanche 미지원 처리:** PaymentRequirements의 network가 `eip155:43114`이면 `X402_UNSUPPORTED_NETWORK` 에러를 반환한다. 향후 Avalanche 지원 시 매핑 테이블에 추가만 하면 된다.

---

## 패키지별 변경 사항 요약

### @waiaas/core

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| interfaces/x402.types.ts (신규) | X402FetchRequest/Response Zod 스키마, CAIP-2 매핑 테이블, PaymentRequirements re-export | `@x402/core ^2.3.1` 추가 |
| enums/transaction.ts | TransactionType에 `X402_PAYMENT` 추가 | 없음 |
| enums/policy.ts | PolicyType에 `X402_ALLOWED_DOMAINS` 추가 | 없음 |

### @waiaas/daemon

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| services/x402/x402-handler.ts (신규) | 402 응답 파싱, (scheme, network) 선택, 결제 서명, 재요청 | 없음 (`@x402/core`는 core에서 재사용) |
| services/x402/payment-signer.ts (신규) | EVM EIP-3009 서명 + Solana 부분 서명 생성 | 없음 (viem, @solana/kit 기존 사용) |
| services/x402/ssrf-guard.ts (신규) | DNS 해석 + 사설 IP 차단 | 없음 (node:dns, node:net 내장) |
| routes/x402.ts (신규) | POST /v1/x402/fetch 엔드포인트 | 없음 |

### @waiaas/adapters (evm, solana)

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| 없음 | x402 결제 서명은 IChainAdapter를 경유하지 않음. payment-signer.ts에서 viem / @solana/kit 직접 사용 | 없음 |

**x402 결제 서명이 IChainAdapter를 경유하지 않는 이유:**

EIP-3009은 트랜잭션이 아닌 EIP-712 typed data 서명이다. IChainAdapter의 `signTransaction`은 트랜잭션 서명 전용이므로, EIP-3009 서명을 위한 별도 payment-signer 모듈이 필요하다. Solana도 마찬가지로 feePayer가 다른 부분 서명 트랜잭션을 생성해야 하므로 기존 `buildTransaction` + `signTransaction` 흐름과 다르다.

그러나 payment-signer는 기존 어댑터와 동일한 하위 라이브러리(viem, @solana/kit)를 사용하며, 키 관리는 기존 KeyStore를 통해 접근한다.

### @waiaas/sdk

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| client.ts | `x402Fetch()` 메서드 추가 | 없음 (0-dep SDK) |

### @waiaas/mcp

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| tools/x402-fetch.ts (신규) | x402_fetch 도구 | 없음 |

### python-sdk (waiaas)

| 변경 | 내용 | 의존성 변경 |
|------|------|-----------|
| client.py | `x402_fetch()` 메서드 추가 | 없음 |

---

## 설치 변경

```bash
# @waiaas/core에 @x402/core 추가
cd packages/core && pnpm add @x402/core@^2.3.1

# 나머지 패키지는 변경 없음
```

---

## 버전 핀 현황

| 패키지 | package.json 범위 | 실제 설치 버전 | x402에서의 활용 |
|--------|------------------|-------------|--------------|
| **@x402/core** (신규) | ^2.3.1 | 2.3.1 | PaymentRequired/PaymentPayload Zod 스키마, Network 타입 |
| viem | ^2.21.0 | 2.45.3 | `signTypedData` (EIP-712/EIP-3009), `privateKeyToAccount` |
| @solana/kit | ^6.0.1 | 6.0.1 | `signBytes`, `compileTransaction`, `createNoopSigner` (부분 서명) |
| zod | ^3.24.0 | 3.25.76 | X402FetchRequest/Response 스키마 (Zod SSoT) |
| hono | ^4.11.9 | 4.x | POST /v1/x402/fetch 라우트 |

---

## Confidence Assessment

| 영역 | 신뢰도 | 근거 |
|------|--------|------|
| @x402/core 타입/스키마 | HIGH | npm 패키지 확인, GitHub 소스 검증, package.json 확인 (zod ^3.24.2, Apache-2.0) |
| viem signTypedData | HIGH | viem 공식 문서 확인, EvmAdapter에서 privateKeyToAccount 이미 사용, signTypedData는 LocalAccount 인터페이스 내장 메서드 |
| Solana 부분 서명 | HIGH | SolanaAdapter.signTransaction() 기존 패턴과 동일. x402 SVM 스펙에서 부분 서명 방식 확인. createNoopSigner 이미 사용 중 |
| SSRF 자체 구현 | HIGH | OWASP 가이드라인 기반, Node.js 22 내장 API (dns/promises, net), 외부 라이브러리 CVE 분석 완료 |
| native fetch | HIGH | Node.js 22 안정 API, WAIaaS zero-dep 철학 일치 |
| CAIP-2 매핑 | HIGH | x402 Network Support 문서 + CAIP-2 스펙 + WAIaaS chain.ts 직접 대조. 매핑 테이블 완전성 확인 |
| @x402/svm 버전 차이 | MEDIUM | @x402/svm v2.3.0이 @solana/kit ^5.1.0 사용 (WAIaaS는 6.x). 직접 사용하지 않으므로 문제 없으나, x402 참조 구현 확인 시 API 차이 주의 필요 |
| EIP-3009 도메인 파라미터 | MEDIUM | USDC v2 컨트랙트의 domain name/version은 체인별로 다를 수 있음. 구현 시 on-chain 조회 또는 상수 테이블 필요 |

---

## Alternatives Considered

| 카테고리 | 권장 | 대안 | 왜 대안이 아닌가 |
|---------|------|------|-----------------|
| x402 타입 | `@x402/core` import | 자체 Zod 스키마 정의 | 스펙 변경 추종 비용. @x402/core가 이미 Zod 제공. 런타임 의존성 zod만 |
| EVM 결제 서명 | viem `signTypedData` | `@x402/evm` 패키지 사용 | @x402/evm은 외부 wallet용 인터페이스. WAIaaS는 로컬 키로 직접 서명. 또한 viem 이미 설치 |
| Solana 결제 서명 | @solana/kit 직접 사용 | `@x402/svm` 패키지 사용 | @x402/svm은 @solana/kit ^5.1.0 (WAIaaS는 6.x), 버전 충돌 위험 |
| SSRF 보호 | node:dns + node:net 자체 구현 | `request-filtering-agent` v3.2.0 | native fetch와 호환 불가 (http.Agent 기반) |
| HTTP 클라이언트 | native fetch | axios/got | WAIaaS zero-dep 철학. fetch 충분 |
| CAIP-2 파싱 | 상수 매핑 테이블 | `caip` npm 패키지 | 단순 split(':') 수준. 불필요한 의존성 |

---

## Sources

### 공식 패키지 (HIGH)
- [@x402/core npm](https://www.npmjs.com/package/@x402/core) -- v2.3.1, Apache-2.0, zod ^3.24.2
- [@x402/evm npm](https://www.npmjs.com/package/@x402/evm) -- v2.3.1, viem ^2.39.3
- [@x402/svm npm](https://www.npmjs.com/package/@x402/svm) -- v2.3.0, @solana/kit ^5.1.0

### GitHub 소스 (HIGH)
- [coinbase/x402 repo](https://github.com/coinbase/x402) -- 모노레포 구조, specs/schemes/
- [x402 core package.json](https://github.com/coinbase/x402/blob/main/typescript/packages/core/package.json) -- v2.3.1 확인
- [x402 core schemas/index.ts](https://github.com/coinbase/x402/blob/main/typescript/packages/core/src/schemas/index.ts) -- Zod 스키마 구조
- [x402 core types/index.ts](https://github.com/coinbase/x402/blob/main/typescript/packages/core/src/types/index.ts) -- 타입 export 구조
- [x402 EVM exact scheme spec](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md) -- EIP-3009 구조
- [x402 SVM exact scheme spec](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md) -- SPL TransferChecked 부분 서명
- [x402 EVM signer.ts](https://github.com/coinbase/x402/blob/main/typescript/packages/mechanisms/evm/src/signer.ts) -- ClientEvmSigner 인터페이스 (signTypedData)

### 공식 문서 (HIGH)
- [x402 Network Support](https://docs.cdp.coinbase.com/x402/network-support) -- CAIP-2 매핑 목록
- [x402 v2 Launch](https://www.x402.org/writing/x402-v2-launch) -- v2 변경 사항
- [viem signTypedData (Local Account)](https://viem.sh/docs/accounts/local/signTypedData) -- EIP-712 서명 API
- [viem signTypedData (Wallet)](https://viem.sh/docs/actions/wallet/signTypedData.html) -- domain/types/primaryType/message 구조
- [CAIP-2 Specification](https://standards.chainagnostic.org/CAIPs/caip-2) -- 블록체인 식별자 표준
- [Solana CAIP-2 Namespace](https://namespaces.chainagnostic.org/solana/caip2) -- genesis hash 기반 식별자
- [EIP-3009 Specification](https://eips.ethereum.org/EIPS/eip-3009) -- TransferWithAuthorization 표준

### 보안 참조 (HIGH)
- [OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html) -- SSRF 방어 가이드
- [OWASP SSRF Prevention in Node.js](https://owasp.org/www-community/pages/controls/SSRF_Prevention_in_Nodejs) -- Node.js 특화 가이드
- [private-ip multicast bypass](https://www.nodejs-security.com/blog/dont-be-fooled-multicast-ssrf-bypass-private-ip) -- private-ip CVE
- [nossrf bypass](https://www.nodejs-security.com/blog/bypassing-ssrf-protection-nossrf) -- nossrf DNS 리바인딩 취약점

### 코드베이스 직접 검증 (HIGH)
- `packages/core/src/enums/chain.ts` -- NetworkType 13개, ChainType 2개 정의
- `packages/adapters/evm/src/adapter.ts` -- viem privateKeyToAccount, signTransaction 패턴
- `packages/adapters/solana/src/adapter.ts` -- @solana/kit signBytes, createNoopSigner, compileTransaction 패턴
- `objectives/v1.5.1-x402-client.md` -- 마일스톤 목표, 컴포넌트 정의, E2E 시나리오 23개
