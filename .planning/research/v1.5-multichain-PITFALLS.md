# Domain Pitfalls: 멀티체인 환경 모델 전환

**Domain:** 기존 단일 네트워크 지갑 시스템에 멀티체인/멀티네트워크 환경 모델 추가
**Project:** WAIaaS v1.5 (multichain wallet environment model)
**Researched:** 2026-02-14
**Overall Confidence:** HIGH (코드베이스 직접 분석 62,296 LOC + 1,467 테스트 + SQLite 공식 문서 + RPC 최적화 가이드 + 하드웨어 지갑 격리 취약점 연구)

---

## Overview

이 문서는 **62K LOC, 1,467 테스트, 42 REST 엔드포인트, 10 PolicyType, 6-stage 파이프라인**을 가진 기존 시스템에 **wallet-level network에서 transaction-level network 해석으로 전환**할 때 발생하는 구체적 함정을 다룬다.

기존 모델: 지갑 생성 시 `chain + network`가 고정되며, 모든 트랜잭션은 해당 지갑의 네트워크를 사용.
새 모델: 지갑이 `chain + environment(mainnet/testnet)`로 생성되고, 트랜잭션이 구체적 `network`를 지정.

각 함정은 **Critical(재작성/자금 손실)**, **High(데이터 정합성/보안 열화)**, **Moderate(성능 저하/DX 혼란)**, **Minor(기술 부채)** 4단계로 분류한다.

**핵심 위험 영역 6가지:**
1. DB 마이그레이션 안전성 (v6 migration, network -> environment 의미 변환)
2. API 하위 호환성 (선택적 network 파라미터 추가의 암묵적 계약 파괴)
3. AdapterPool 메모리/연결 관리 (어댑터 수 증가에 따른 리소스 문제)
4. 정책 엔진 정확성 (네트워크 범위 규칙의 edge case)
5. getAssets 성능 (N개 병렬 RPC 호출의 성능 저하)
6. Testnet/Mainnet 격리 실패 (실 자금 위험)

---

## Critical Pitfalls

재작성 수준의 보안 결함, 자금 손실, 또는 데이터 손실을 야기하는 실수.

---

### C-01: Testnet 키로 Mainnet 트랜잭션 서명 -- 환경 격리 실패

**Severity:** CRITICAL
**Confidence:** HIGH (TheCharlatan의 Coin Isolation Bypass 연구, Ledger/Trezor/KeepKey 취약점 확인)
**Design Decision:** environment 모델 도입, 트랜잭션 network 파라미터 검증

**What goes wrong:**
environment 모델에서 `testnet` 환경의 지갑이 트랜잭션 요청 시 `network: 'ethereum-mainnet'`을 지정할 수 있다. 서명은 같은 개인키(secp256k1/ed25519)로 수행되므로, testnet 지갑의 키가 mainnet 트랜잭션에 서명하면 **실 자금이 이동**한다.

현재 코드의 위험 지점:
```typescript
// pipeline.ts:67-74 -- wallet에서 chain/network를 읽어 context에 설정
const ctx: PipelineContext = {
  wallet: {
    publicKey: wallet.publicKey,
    chain: wallet.chain,
    network: wallet.network, // 현재: wallet-level network, 변경 후: request-level network
  },
  request,
};
```

새 모델에서 `wallet.network`가 `wallet.environment`로 바뀌고 `request.network`가 추가되면, 파이프라인이 request의 network로 어댑터를 resolve할 때 **환경 경계를 넘는 검증이 없다면** testnet 지갑이 mainnet에서 실행된다.

**Why it happens:**
- EVM 체인에서 같은 개인키는 모든 네트워크에서 동일한 주소를 생성한다 (secp256k1 동일 커브)
- Solana도 ed25519 키는 mainnet/devnet/testnet 모두에서 유효하다
- "environment"는 논리적 구분이지만 암호학적으로는 동일한 키 공간을 공유한다

**Consequences:**
- Testnet 환경의 지갑이 mainnet 자금을 실제로 이동시킬 수 있다
- 반대로 mainnet 지갑이 testnet에서 실행되면 가스비를 실 자금으로 소모한다
- AI 에이전트가 잘못된 network 파라미터를 보내면 자금 손실이 자동화된다

**Prevention:**
1. `validateEnvironmentNetwork(environment, network)` 함수를 파이프라인 Stage 1에서 **가장 먼저** 실행. mainnet 환경은 `*-mainnet` 네트워크만, testnet 환경은 `*-sepolia/*-amoy/devnet/testnet` 네트워크만 허용
2. AdapterPool.resolve()에서도 이중 검증 -- environment-network 불일치 시 즉시 에러
3. 키스토어에서 키 로드 시 environment 태그 확인 (키 파일에 environment 메타데이터 포함)
4. 이 검증은 bypass 가능한 위치(미들웨어)가 아닌, 반드시 통과하는 위치(Stage 1 + 키 서명 직전)에 배치

**Detection:**
- audit_log에 environment-network 불일치 시도를 CRITICAL severity로 기록
- 모니터링에서 testnet 지갑의 mainnet RPC 호출 감지

**Phase:** environment 모델 설계 단계에서 반드시 해결. 구현 첫 번째 단계에서 이 검증부터 작성.

---

### C-02: DB 마이그레이션 v6 -- SQLite CHECK 제약 조건 변경의 12-step 테이블 재생성 위험

**Severity:** CRITICAL
**Confidence:** HIGH (v2, v3 마이그레이션 코드 직접 분석 + SQLite 공식 문서 ALTER TABLE 제한사항)
**Design Decision:** wallets.network -> wallets.environment 컬럼 의미 변경, CHECK 제약 업데이트

**What goes wrong:**
`wallets` 테이블의 `network` 컬럼을 `environment`로 변환하려면 SQLite의 12-step 테이블 재생성이 필요하다. 현재 CHECK 제약:
```sql
CHECK (network IN ('mainnet', 'devnet', 'testnet', 'ethereum-mainnet', 'ethereum-sepolia', ...))
```
이를 다음으로 변경해야 한다:
```sql
CHECK (environment IN ('mainnet', 'testnet'))
```

v3 마이그레이션(agents->wallets)에서 이미 경험한 것처럼, **5개 FK 테이블(sessions, transactions, policies, audit_log, notification_logs)** 모두를 동시에 재생성해야 한다. 하지만 이번에는 추가 위험이 있다:

1. **데이터 변환이 필요하다**: 기존 `network` 값을 `environment`로 매핑해야 한다
   - `mainnet`, `ethereum-mainnet`, `polygon-mainnet`, `arbitrum-mainnet`, `optimism-mainnet`, `base-mainnet` -> `mainnet`
   - `devnet`, `testnet`, `ethereum-sepolia`, `polygon-amoy`, `arbitrum-sepolia`, `optimism-sepolia`, `base-sepolia` -> `testnet`
2. **transactions 테이블에 network 컬럼을 추가해야 한다**: 기존 트랜잭션의 network는 wallet에서 유추해야 한다
3. **token_registry 테이블도 영향받는다**: `network` 컬럼이 그대로 유지되지만, 새 환경 모델과의 관계가 변경된다

**현재 코드의 구체적 위험:**
```typescript
// migrate.ts:284-353 -- v2 마이그레이션이 이미 12-step을 사용
// managesOwnTransaction: true로 PRAGMA foreign_keys=OFF 필요
// v3 마이그레이션(362-541)은 6개 테이블을 동시에 재생성
// v6은 v3보다 더 복잡: 데이터 변환 + 새 컬럼 추가 + 인덱스 재생성
```

**Consequences:**
- 마이그레이션 실패 시 데이터베이스 손상 (wallets 테이블 DROP 후 ROLLBACK 실패)
- 기존 지갑의 network 정보 유실 (environment만 남고 원래 어떤 specific network였는지 복원 불가)
- FK 무결성 위반 (foreign_keys=OFF 상태에서 COMMIT 후 불일치 발견)
- `idx_wallets_chain_network` 인덱스가 `idx_wallets_chain_environment`로 바뀌면서 기존 쿼리 성능 저하

**Prevention:**
1. **마이그레이션을 2단계로 분리**:
   - v6a: `wallets`에 `environment` 컬럼 ADD (ALTER TABLE ADD COLUMN은 SQLite에서 안전), 기존 `network`에서 값 계산하여 채움
   - v6b: `network` 컬럼 제거 + CHECK 제약 변경 (이때만 12-step 재생성)
   - `transactions`에 `network` 컬럼 ADD (ALTER TABLE ADD COLUMN), 기존 wallet.network에서 채움
2. **원본 network 값을 보존**: `transactions.network`에 기존 wallet의 network 값을 기록한 **후에만** wallets에서 network 컬럼을 제거. 순서가 바뀌면 데이터 유실
3. **PRAGMA foreign_key_check 후 COMMIT**: v2/v3 패턴 그대로 따름
4. **v6 마이그레이션 테스트에서 실제 데이터 시나리오 재현**: Solana mainnet + EVM ethereum-sepolia 혼합 데이터로 테스트

**Detection:**
- 마이그레이션 전후 `SELECT COUNT(*)` 비교 (row count preservation)
- `PRAGMA foreign_key_check` 빈 배열 확인
- `PRAGMA integrity_check` 통과 확인

**Phase:** DB 마이그레이션 설계 단계. 마이그레이션 스크립트 TDD 작성이 최우선.

---

### C-03: 기존 지갑 network 정보의 비가역적 유실 -- 마이그레이션 데이터 변환 순서 오류

**Severity:** CRITICAL
**Confidence:** HIGH (현재 스키마 직접 분석)
**Design Decision:** wallets.network -> wallets.environment 변환 시 데이터 보존 전략

**What goes wrong:**
현재 스키마:
```
wallets: chain, network (e.g., 'solana' + 'devnet')
transactions: chain (no network column)
```

`wallets.network`을 `wallets.environment`로 변환하면, 기존 지갑이 **어떤 specific network를 사용했는지** 정보가 사라진다.

예: Solana 지갑 `network: 'devnet'`은 `environment: 'testnet'`으로 변환. 하지만 나중에 이 지갑이 실제로 어느 네트워크에서 운영됐는지 알 수 없다.

더 심각한 문제: **기존 transactions 테이블에는 network 컬럼이 없다.** `transactions.chain`만 있다. 새 모델에서 `transactions.network`를 추가할 때, 기존 트랜잭션의 network를 `wallet.network`에서 유추해야 하는데, **이미 wallet.network가 environment로 변환되었다면 유추할 수 없다**.

**Consequences:**
- 기존 트랜잭션의 네트워크 정보 영구 유실
- audit_log의 역추적 불가능 (어떤 네트워크에서 실행됐는지 모름)
- 데이터 정합성 검증 불가

**Prevention:**
1. **마이그레이션 순서 엄격 준수**:
   - Step 1: `transactions`에 `network` TEXT 컬럼 추가 (ALTER TABLE ADD COLUMN)
   - Step 2: `UPDATE transactions SET network = (SELECT network FROM wallets WHERE id = transactions.wallet_id)` -- 기존 wallet.network에서 복사
   - Step 3: 그 다음에야 `wallets.network` -> `wallets.environment` 변환
2. **wallets에 `default_network` 컬럼 추가 고려**: 기존 network 값을 default_network으로 보존하여 역호환 유지
3. **마이그레이션 테스트에서 순서 뒤집기 시나리오 검증**: Step 1-3 순서가 바뀌면 실패하는 테스트 작성

**Phase:** DB 마이그레이션 구현 단계의 첫 번째 작업. 데이터 보존이 확인된 후에만 스키마 변경 진행.

---

## High Pitfalls

보안 열화, 데이터 정합성 위협, 또는 광범위한 테스트 실패를 야기하는 실수.

---

### H-01: API 하위 호환성 파괴 -- 선택적 network 파라미터의 암묵적 계약 변경

**Severity:** HIGH
**Confidence:** HIGH (42 REST 엔드포인트, SDK/MCP/Admin 클라이언트 코드 직접 분석)
**Design Decision:** POST /v1/transactions/send에 optional `network` 필드 추가

**What goes wrong:**
현재 `POST /v1/transactions/send`는 wallet의 network를 자동으로 사용한다:
```typescript
// transactions.ts:258-263 -- wallet.chain + wallet.network로 어댑터 resolve
const rpcUrl = resolveRpcUrl(deps.config.rpc, wallet.chain, wallet.network);
const adapter = await deps.adapterPool.resolve(
  wallet.chain as ChainType,
  wallet.network as NetworkType,
  rpcUrl,
);
```

새 모델에서 `network`를 optional로 추가하면:
1. **기존 SDK 클라이언트(`WAIaaSClient.sendToken()`)가 network를 보내지 않는다** -- 이때 어떤 network가 기본값인가?
2. **MCP 도구(`send-transaction`)도 network 파라미터가 없다** -- 기존 MCP 토큰은 특정 wallet에 바인딩되어 있으므로, wallet의 default_network를 써야 한다
3. **응답 스키마가 달라진다** -- 기존 `{ chain, network }` 응답에서 `network`의 의미가 바뀐다. 기존에는 wallet-level이었지만 이제는 transaction-level

Zalando REST API 가이드라인에 따르면: "새 optional 파라미터 추가는 하위 호환적이지만, **기존 파라미터의 의미(semantics)가 바뀌는 것은 breaking change**다."

**Consequences:**
- 기존 SDK v1.4.x 사용자가 업그레이드 없이도 API를 호출할 수 있지만, 응답의 `network` 필드 의미가 달라져 혼란
- MCP 에이전트가 잘못된 네트워크에서 트랜잭션을 실행할 수 있음
- Python SDK (`waiaas` 패키지)도 동시에 업데이트 필요

**Prevention:**
1. **default_network 전략**: wallet에 `default_network`를 저장. network 미지정 시 default_network 사용. 이것은 기존 동작(wallet.network 사용)과 완전히 동일
2. **응답에 `resolvedNetwork` 필드 추가**: 기존 `network`는 wallet의 environment, 새 `resolvedNetwork`는 실제 실행된 network. 기존 클라이언트는 `network`만 보고, 새 클라이언트는 `resolvedNetwork`도 확인
3. **SDK/MCP/Admin 동시 업데이트 필수**: v1.4.x -> v1.5.x 업그레이드 시 SDK/MCP도 함께 업데이트하도록 버전 호환성 매트릭스 명시
4. **OpenAPI 스펙에서 breaking change 여부 자동 검증**: `oasdiff` 도구로 breaking change 탐지

**Phase:** API 설계 단계. 응답 스키마 변경 전에 하위 호환성 전략 확정.

---

### H-02: AdapterPool 캐시 키 변경으로 기존 연결 고아화

**Severity:** HIGH
**Confidence:** HIGH (adapter-pool.ts 직접 분석)
**Design Decision:** AdapterPool.cacheKey() 변경

**What goes wrong:**
현재 AdapterPool:
```typescript
// adapter-pool.ts:41-43
private cacheKey(chain: ChainType, network: NetworkType): string {
  return `${chain}:${network}`;
}
```

새 모델에서 wallet이 `environment`를 가지고 트랜잭션이 `network`를 지정하면, 같은 wallet에서 다른 network로의 트랜잭션이 가능해진다. 예를 들어:
- 첫 번째 트랜잭션: `ethereum:ethereum-sepolia` -> 어댑터 생성 및 캐시
- 두 번째 트랜잭션: `ethereum:arbitrum-sepolia` -> **다른** 어댑터 필요

이 자체는 정상 동작이지만, 문제는 **기존 코드에서 wallet 단위로 어댑터를 resolve하는 패턴이 있다**는 것:

```typescript
// wallet.ts:147-150 -- wallet의 chain/network로 단일 어댑터 resolve
const adapter = await deps.adapterPool.resolve(
  wallet.chain as ChainType,
  wallet.network as NetworkType,  // 이제 이것은 'environment'이므로 유효한 network가 아님
  rpcUrl,
);
```

`wallet.environment`(예: `'testnet'`)로 어댑터를 resolve하면 **어댑터가 어떤 구체적 네트워크에 연결해야 하는지 알 수 없다**.

**Consequences:**
- 기존 코드의 모든 `wallet.network` 참조 42건이 동작 변경 (9개 소스 파일)
- getBalance, getAssets 등 wallet-level 쿼리에서 "어떤 네트워크의 잔액?"이라는 질문이 발생
- 잘못된 캐시 키로 어댑터 공유 시 다른 네트워크의 RPC에 요청 전송

**Prevention:**
1. **getBalance/getAssets에 network 파라미터 추가**: 또는 wallet의 `default_network` 사용
2. **AdapterPool.cacheKey()는 변경하지 않는다**: 기존 `chain:network` 키가 정확하다. environment는 캐시 키와 무관
3. **wallet.network 참조 42건을 전수 검사**: 각각이 어떤 의미로 사용하는지 분류하고, `wallet.environment`로 바꿀 것과 `request.network` 또는 `wallet.default_network`로 바꿀 것을 구분

**Detection:**
- 타입 시스템 활용: `wallet.network`의 타입을 `EnvironmentType`으로 변경하면, `NetworkType`을 기대하는 곳에서 컴파일 에러 발생

**Phase:** AdapterPool은 변경 불필요. wallet 참조 리팩토링이 핵심 작업.

---

### H-03: 정책 엔진의 네트워크 범위 불일치 -- ALLOWED_TOKENS이 다른 네트워크의 토큰을 허용

**Severity:** HIGH
**Confidence:** HIGH (DatabasePolicyEngine 코드 직접 분석, 1007라인)
**Design Decision:** ALLOWED_NETWORKS PolicyType 추가, 기존 정책의 네트워크 범위 지정

**What goes wrong:**
현재 정책 평가에서 **네트워크 구분이 없다**:
```typescript
// database-policy-engine.ts:665-666 -- case-insensitive 비교만, 네트워크 무시
const isAllowed = rules.tokens.some(
  (t) => t.address.toLowerCase() === tokenAddress.toLowerCase(),
);
```

멀티네트워크 환경에서 이 코드는 위험하다:
- USDC on Ethereum Mainnet: `0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`
- USDC on Polygon: `0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359` (다른 주소!)
- 하지만 같은 주소가 다른 네트워크에서 전혀 다른 컨트랙트일 수 있다

더 심각한 경우: **EVM 네트워크에서 같은 contract address가 다른 토큰일 수 있다**. Ethereum mainnet의 `0x1234...`가 Polygon에서는 malicious contract일 수 있다. ALLOWED_TOKENS 정책이 네트워크를 구분하지 않으면, 한 네트워크에서 허용된 주소가 다른 네트워크에서도 자동 허용된다.

기존 코드에서 `chain` optional 필드가 있지만 사용되지 않는다:
```typescript
// policy.schema.ts:23-27
const AllowedTokensRulesSchema = z.object({
  tokens: z.array(z.object({
    address: z.string().min(1),
    symbol: z.string().min(1).max(10).optional(),
    chain: ChainTypeEnum.optional(), // 있지만 평가에서 무시됨!
  })).min(1),
});
```

**Consequences:**
- 네트워크 A에서 허용된 토큰 주소가 네트워크 B에서도 허용되어, 의도하지 않은 컨트랙트와 상호작용
- CONTRACT_WHITELIST도 동일한 문제: 한 네트워크의 화이트리스트가 모든 네트워크에 적용
- SPENDING_LIMIT의 금액 기준이 네트워크별 통화 단위와 맞지 않을 수 있음 (ETH on Ethereum vs ETH on Arbitrum은 같은 자산이지만, POL on Polygon은 다른 자산)

**Prevention:**
1. **정책 rules에 `network` 필드 추가**: `{ tokens: [{ address, network?, ... }] }`. network가 명시되면 해당 네트워크에서만 적용, 미명시면 모든 네트워크에 적용
2. **ALLOWED_NETWORKS 정책 타입 추가**: 허용된 네트워크 목록. 이 정책이 없으면 environment의 모든 네트워크 허용 (기본 거부가 아닌, 환경 내 자유 허용)
3. **평가 시 네트워크 컨텍스트 전달**: `TransactionParam`에 `network` 필드 추가하여 현재 어떤 네트워크인지 정책 엔진에 전달
4. **기존 ALLOWED_TOKENS/CONTRACT_WHITELIST 정책은 자동으로 wallet의 기존 network에 범위 지정**: 마이그레이션 시 기존 정책 rules에 `network: '기존wallet.network'` 추가

**Phase:** 정책 엔진 확장 설계 단계. 새 PolicyType 추가와 기존 정책의 네트워크 범위 지정을 동시에 설계.

---

### H-04: 기존 1,467 테스트의 광범위한 실패 -- `wallet.network` 참조의 의미 변경

**Severity:** HIGH
**Confidence:** HIGH (grep 분석: chain 참조 176건/44파일, network 참조 108건/41파일, wallet.network 42건/9파일)
**Design Decision:** `wallets.network` -> `wallets.environment` 리팩토링 범위

**What goes wrong:**
코드베이스에서 network 관련 참조 수:
- `network: 'devnet'` 또는 `network: 'ethereum-sepolia'` 등 구체적 네트워크 값 참조: **108건, 41개 파일**
- `chain: 'solana'` 또는 `chain: 'ethereum'` 참조: **176건, 44개 파일**
- `wallet.network` 또는 `wallet.chain` 직접 접근: **42건, 9개 파일**

이 중 상당수가 테스트 파일의 fixture/mock 데이터:
- `api-agents.test.ts`: 9건 (지갑 생성 테스트)
- `evm-lifecycle-e2e.test.ts`: 10건 (EVM 전체 생명주기)
- `sdk/client.test.ts`: 12건 (SDK 응답 mock)
- `database-policy-engine.test.ts`: 29건 (정책 엔진 테스트)

**핵심 문제:** 단순히 `network`를 `environment`로 치환(find-replace)하면, 어댑터 resolve나 RPC URL 해석에서 구체적 네트워크가 필요한 곳이 깨진다.

**Consequences:**
- 일괄 리네이밍 시 수백 건의 테스트 실패
- 실패한 테스트를 수정하는 과정에서 의미를 잘못 이해하여 테스트가 잘못된 것을 검증하게 됨
- CI 파이프라인이 장기간 red 상태

**Prevention:**
1. **타입 시스템을 방파제로 활용**: `EnvironmentType = 'mainnet' | 'testnet'`과 `NetworkType`을 분리하여, 컴파일러가 혼용을 잡아내게 함
2. **변경을 3단계로 진행**:
   - Phase A: 새 타입/인터페이스 추가 (기존 코드 변경 없음)
   - Phase B: 내부 구현에서 environment 사용 시작 (wallet 생성, DB 스키마)
   - Phase C: 외부 인터페이스 변경 (API 응답, SDK 타입)
3. **테스트 분류**: network 값이 environment로 바뀌어야 하는 테스트 vs. 구체적 network 값이 유지되어야 하는 테스트를 사전 분류
4. **v3 마이그레이션(agents->wallets)에서의 경험 활용**: 당시 `agent_id` -> `wallet_id` 리네이밍으로 유사한 대규모 변경을 수행했으므로, 같은 패턴 적용

**Phase:** 구현 시작 전에 영향 범위 분석 완료. 타입 변경을 먼저 하고 컴파일 에러로 가이드.

---

### H-05: MCP 토큰 + 세션의 하위 호환성 -- 기존 JWT에 network claim이 바인딩됨

**Severity:** HIGH
**Confidence:** MEDIUM (세션/JWT 코드 간접 분석, 정확한 JWT payload 구조는 추가 확인 필요)
**Design Decision:** 기존 세션 토큰의 유효성 유지 전략

**What goes wrong:**
기존 세션은 wallet에 바인딩되어 있고, wallet은 `chain + network`로 고정되어 있다. JWT payload에 `walletId`가 포함되어 있으므로, wallet의 network가 environment로 바뀌면:

1. 기존 JWT 토큰은 여전히 유효 (walletId로 조회하면 wallet을 찾을 수 있음)
2. 하지만 해당 wallet의 `network` 컬럼이 `environment`로 바뀌면, 기존 코드가 `wallet.network`를 사용하여 어댑터를 resolve하는 곳에서 문제 발생
3. MCP SessionManager가 자동으로 세션을 관리하는데, network 변경 후 기존 세션으로 트랜잭션 실행 시 어떤 network를 사용하는가?

**Consequences:**
- 데몬 업그레이드 후 기존 MCP 세션이 "어댑터를 찾을 수 없음" 에러 발생 가능
- AI 에이전트가 세션 재생성을 요구받아 중단 시간 발생
- 진행 중인 PENDING/QUEUED 트랜잭션의 네트워크 해석이 불확실

**Prevention:**
1. **wallet.default_network 보존**: environment 전환 시 기존 network 값을 `default_network`에 저장. 세션/트랜잭션에서 network를 명시하지 않으면 `default_network` 사용
2. **기존 세션 무효화 불필요**: walletId 기반 조회는 동일하게 동작. network 해석 로직만 변경
3. **진행 중 트랜잭션 처리**: 마이그레이션 시 PENDING/QUEUED 트랜잭션에 network 컬럼을 채운 후 스키마 변경 (C-03 참조)

**Phase:** 세션 관리 호환성은 API 설계 단계에서 확인. 마이그레이션 순서가 핵심.

---

## Moderate Pitfalls

성능 저하, DX 혼란, 또는 운영 복잡성 증가를 야기하는 실수.

---

### M-01: getAssets N-way 병렬 RPC 호출의 성능 폭발

**Severity:** MODERATE
**Confidence:** HIGH (QuickNode RPC 효율성 가이드 + Chainstack Multicall 비교 분석)
**Design Decision:** 멀티네트워크 getAssets 구현 전략

**What goes wrong:**
현재 getAssets는 **단일 네트워크에 단일 RPC 호출**:
```typescript
// wallet.ts:235 -- 단일 어댑터로 getAssets 호출
const assets = await adapter.getAssets(wallet.publicKey);
```

멀티네트워크에서는 한 wallet이 N개 네트워크에 자산을 가질 수 있다. environment가 `testnet`이면 최대 6개 네트워크(devnet, ethereum-sepolia, polygon-amoy, arbitrum-sepolia, optimism-sepolia, base-sepolia), `mainnet`이면 최대 6개(mainnet, ethereum-mainnet, polygon-mainnet, arbitrum-mainnet, optimism-mainnet, base-mainnet).

각 네트워크마다 getAssets()를 호출하면:
- EVM getAssets()는 내부적으로 N개 ERC-20 balanceOf 호출을 수행 (토큰당 1 RPC call)
- 6 네트워크 x 10 토큰 = **60 RPC 호출**
- RPC 응답 시간 P99: 200-500ms (QuickNode 벤치마크)
- 최악의 경우 총 응답 시간: **수 초 ~ 수십 초**

QuickNode 가이드에 따르면: "A slow request delays the entire batch, whereas multiple requests in parallel return faster." 하지만 6개 네트워크를 모두 병렬로 호출하면 RPC rate limit에 걸릴 수 있다.

**Consequences:**
- `GET /v1/wallet/assets` 응답 시간이 수 초로 증가
- RPC 제공자 rate limiting으로 429 에러 빈발
- AI 에이전트의 의사 결정 루프 지연 (잔액 확인 -> 전송 판단 -> 실행)
- 무료 RPC 플랜 사용 시 일일 할당량 빠르게 소진

**Prevention:**
1. **기본 동작은 default_network 단일 조회**: `GET /v1/wallet/assets`는 기존처럼 단일 네트워크. 멀티네트워크 조회는 `GET /v1/wallet/assets?networks=all` 또는 `?networks=ethereum-mainnet,polygon-mainnet`로 opt-in
2. **결과 캐싱**: 네트워크별 잔액을 TTL 기반 캐시 (30초~5분). stale 데이터 허용 여부를 `Cache-Control` 헤더로 제어
3. **Multicall3 활용 (EVM)**: 같은 체인의 여러 토큰 잔액을 단일 RPC 호출로 조회. Chainstack 분석에 따르면 HTTP batch보다 비용 효율적 (단일 요청으로 카운트)
4. **Promise.allSettled + 타임아웃**: 병렬 호출 시 가장 느린 네트워크가 전체를 블로킹하지 않도록 per-network 타임아웃 (3초). 실패한 네트워크는 `{ network, error: 'timeout' }`로 응답
5. **점진적 반환**: SSE 또는 chunked response로 네트워크별로 결과를 스트리밍 (v2.0+ 고려)

**Phase:** getAssets 확장 설계 단계. 기본 동작은 단일 네트워크 유지가 핵심.

---

### M-02: AdapterPool 메모리 증가 -- 6+ 네트워크 동시 연결

**Severity:** MODERATE
**Confidence:** MEDIUM (현재 AdapterPool은 단순 Map, viem/solana-kit의 메모리 사용량은 실측 필요)
**Design Decision:** AdapterPool 크기 제한 및 LRU 전략

**What goes wrong:**
현재 AdapterPool은 생성된 어댑터를 영구 캐싱한다:
```typescript
// adapter-pool.ts:35-36
private readonly _pool = new Map<string, IChainAdapter>();
```

기존 모델: 지갑 수만큼 어댑터 (중복 네트워크는 공유). 일반적으로 2-5개.
새 모델: 환경의 모든 네트워크에 어댑터가 필요. 최대 13개 (`NETWORK_TYPES` 배열 크기).

각 EvmAdapter는 viem publicClient를 생성하고, 이는 HTTP transport + 내부 상태를 보유한다. SolanaAdapter는 Solana RPC connection을 유지한다.

13개 동시 연결:
- viem publicClient: ~5-10MB per instance (추정, 실측 필요)
- Solana RPC connection: ~2-5MB per instance (추정)
- 총: **최대 50-130MB 추가 메모리** (단일 데몬 기준)

**Consequences:**
- 작은 서버(512MB RAM)에서 메모리 부족
- 사용하지 않는 네트워크의 연결이 RPC 제공자 연결 수 제한을 소모
- disconnect() 호출이 누락되면 리소스 누수

**Prevention:**
1. **LRU 전략**: AdapterPool에 `maxSize` 설정. 제한 초과 시 가장 오래 사용하지 않은 어댑터를 evict. 기본 `maxSize: 8`
2. **idle 타임아웃**: 5분간 사용하지 않은 어댑터 자동 disconnect. 다음 요청 시 lazy reconnect
3. **on-demand 연결**: 환경의 모든 네트워크에 미리 연결하지 않음. 실제 요청이 올 때만 연결
4. **evict() 메서드는 이미 존재**: `adapter-pool.ts:99-110`에 evict가 구현되어 있으므로, LRU 로직만 추가하면 됨
5. **메모리 프로파일링**: 실제 viem/solana-kit 인스턴스의 메모리 사용량을 측정하여 maxSize 튜닝

**Phase:** AdapterPool 확장 구현 단계. LRU는 간단한 추가이므로 과도한 설계 불필요.

---

### M-03: config.toml RPC URL 폭발 -- 13개 네트워크 x RPC URL 관리 부담

**Severity:** MODERATE
**Confidence:** HIGH (현재 config.toml 평탄화 17키 정책)
**Design Decision:** 멀티네트워크 RPC URL 설정 전략

**What goes wrong:**
현재 RPC URL 해석:
```typescript
// adapter-pool.ts:20-33
export function resolveRpcUrl(rpcConfig, chain, network) {
  if (chain === 'solana') {
    return rpcConfig[`solana_${network}`]; // rpc.solana_devnet
  } else if (chain === 'ethereum') {
    return rpcConfig[`evm_${network.replace(/-/g, '_')}`]; // rpc.evm_ethereum_sepolia
  }
}
```

현재 `NETWORK_TYPES`에 13개 네트워크가 정의되어 있으므로, 모든 네트워크에 RPC URL을 설정하려면 config.toml에 13개 키가 필요:
```toml
[rpc]
solana_mainnet = "https://..."
solana_devnet = "https://..."
solana_testnet = "https://..."
evm_ethereum_mainnet = "https://..."
evm_ethereum_sepolia = "https://..."
evm_polygon_mainnet = "https://..."
# ... 7개 더
```

사용자가 모든 네트워크를 사용하지 않더라도, **사용하지 않는 네트워크의 RPC URL이 비어있으면 어댑터 resolve 실패**. 현재 `resolveRpcUrl()`은 빈 문자열을 반환하고, `adapter.connect('')`은 실패한다.

**Consequences:**
- config.toml이 복잡해져 DX 저하
- 첫 설정에서 13개 RPC URL을 모두 채워야 한다는 압박감
- 무료 RPC URL이 없는 네트워크에서 설정 불가

**Prevention:**
1. **사용하는 네트워크만 설정**: environment + 실제 사용 네트워크만 RPC URL 필요. 설정되지 않은 네트워크로 트랜잭션 요청 시 명확한 에러 메시지 ("`RPC URL not configured for network 'arbitrum-mainnet'. Add rpc.evm_arbitrum_mainnet to config.toml`")
2. **기본 RPC URL 제공**: 공개 RPC 엔드포인트를 폴백으로 사용 (rate limited이지만 설정 없이 동작). `config.toml`에 명시적으로 설정하면 오버라이드
3. **WAIAAS_RPC_* 환경변수**: `WAIAAS_RPC_EVM_ETHEREUM_MAINNET` 형식으로 환경변수에서도 설정 가능 (기존 패턴)
4. **settings 테이블 활용**: Admin UI에서 RPC URL을 동적으로 변경할 수 있도록 settings 테이블에도 저장 (v1.4.4에서 이미 settings 패턴 구현)

**Phase:** config 확장 설계 단계. 기존 `resolveRpcUrl()` 함수에 에러 메시지 개선만으로 대부분 해결 가능.

---

### M-04: 트랜잭션 테이블의 network 컬럼 누락 -- 히스토리 쿼리 불가

**Severity:** MODERATE
**Confidence:** HIGH (현재 transactions 스키마 직접 확인)
**Design Decision:** transactions 테이블에 network 컬럼 추가

**What goes wrong:**
현재 `transactions` 테이블에는 `chain` 컬럼만 있고 `network` 컬럼이 없다:
```typescript
// schema.ts:117-118
chain: text('chain').notNull(),
txHash: text('tx_hash'),
```

기존에는 wallet의 network로 유추할 수 있었지만, 멀티네트워크에서는 같은 wallet이 다른 network에서 트랜잭션을 실행할 수 있으므로 **트랜잭션별 network 기록이 필수**다.

network를 추가하지 않으면:
- "이 트랜잭션이 어느 네트워크에서 실행됐는가?" 질문에 답할 수 없음
- block explorer 링크 생성 불가 (네트워크에 따라 explorer URL이 다름)
- 감사 추적 불완전

**Prevention:**
1. `ALTER TABLE transactions ADD COLUMN network TEXT` (안전한 SQLite 작업)
2. 기존 트랜잭션은 `UPDATE transactions SET network = (SELECT network FROM wallets WHERE id = transactions.wallet_id)` (C-03의 순서 참조)
3. 새 트랜잭션은 Stage 1에서 `network`를 `resolved_network`으로 기록
4. CHECK 제약은 처음에는 추가하지 않는다 (network 값이 wallet 생성 시점의 값과 다를 수 있으므로). 나중에 NETWORK_TYPES CHECK 추가 가능

**Phase:** DB 마이그레이션 단계. C-02/C-03과 함께 진행.

---

### M-05: Admin UI 대시보드의 네트워크 표시 혼란

**Severity:** MODERATE
**Confidence:** MEDIUM (Admin UI 코드는 Preact + signals, 직접적 영향 범위는 추가 확인 필요)
**Design Decision:** Admin UI에서 environment vs network 표시 전략

**What goes wrong:**
현재 Admin UI는 wallet의 `chain + network`를 표시한다:
```
Wallets: [SOL devnet] [ETH ethereum-sepolia]
```

새 모델에서 `environment`만 표시하면:
```
Wallets: [SOL testnet] [ETH testnet]
```
이것은 두 지갑이 같은 네트워크인지 다른 네트워크인지 구분할 수 없게 만든다.

**Prevention:**
1. Wallet 목록에서 `chain + environment` 표시 (기존과 유사한 UX)
2. Wallet 상세 페이지에서 `default_network` + `사용 가능한 네트워크 목록` 표시
3. Transaction 목록에서 `network` 컬럼 추가 (구체적 네트워크 표시)
4. Balance 위젯에서 네트워크별 잔액 분리 표시

**Phase:** Admin UI 확장은 API 변경 이후. 낮은 우선순위.

---

## Minor Pitfalls

기술 부채 또는 향후 확장성 저해를 야기하는 실수.

---

### L-01: Zod SSoT 파생 순서 복잡화 -- EnvironmentType 추가의 파급 효과

**Severity:** MINOR
**Confidence:** HIGH (Zod SSoT 체인 직접 확인)
**Design Decision:** EnvironmentType 열거형 추가

**What goes wrong:**
현재 SSoT 체인: `Zod -> TypeScript -> OpenAPI -> Drizzle -> DB CHECK`.
`EnvironmentType = z.enum(['mainnet', 'testnet'])`을 추가하면:
- `NETWORK_TYPES` 배열은 그대로 유지 (transaction-level에서 사용)
- `ENVIRONMENT_TYPES` 배열 신규 추가
- `wallets` 테이블에서 `check_network` -> `check_environment` 변경
- `validateChainNetwork()` 함수에 `validateChainEnvironment()` 추가

Zod 스키마에서 파생되는 OpenAPI 스펙이 달라지므로, 기존 OpenAPI 클라이언트(Python SDK 등)가 재생성 필요.

**Prevention:**
1. `EnvironmentType`을 `@waiaas/core`에 추가하고, `CHAIN_TYPES`, `NETWORK_TYPES`와 함께 export
2. `validateEnvironmentNetwork(environment, network)` 함수: environment -> 허용 가능한 network 목록 매핑
3. OpenAPI 스펙 변경은 불가피 -- major version bump는 아니지만 SDK 재빌드 필요

**Phase:** core 패키지 타입 추가가 첫 번째 작업.

---

### L-02: EVM_CHAIN_MAP과 environment 매핑의 이중 관리

**Severity:** MINOR
**Confidence:** HIGH (evm-chain-map.ts 직접 분석)
**Design Decision:** 네트워크-환경 매핑 전략

**What goes wrong:**
현재 `EVM_CHAIN_MAP`은 `EvmNetworkType -> EvmChainEntry` 매핑:
```typescript
// evm-chain-map.ts:18-29
export const EVM_CHAIN_MAP: Record<EvmNetworkType, EvmChainEntry> = {
  'ethereum-mainnet': { viemChain: mainnet, ... },
  'ethereum-sepolia': { viemChain: sepolia, ... },
  // ... 8개 더
};
```

environment 모델 추가 시 "이 네트워크는 어느 environment에 속하는가?" 매핑이 필요:
```typescript
const NETWORK_TO_ENVIRONMENT: Record<NetworkType, EnvironmentType> = {
  'mainnet': 'mainnet',
  'devnet': 'testnet',
  'testnet': 'testnet',
  'ethereum-mainnet': 'mainnet',
  'ethereum-sepolia': 'testnet',
  // ...
};
```

이 매핑이 `EVM_CHAIN_MAP`과 별도로 관리되면 동기화 누락 위험.

**Prevention:**
1. `EVM_CHAIN_MAP`에 `environment` 필드 추가: `{ viemChain, chainId, nativeSymbol, nativeName, environment }`
2. 또는 `NETWORK_TO_ENVIRONMENT`를 `@waiaas/core`에 단일 정의하고, `EVM_CHAIN_MAP`에서 참조
3. 빌드타임 검증 테스트: 모든 `NETWORK_TYPES` 항목이 `NETWORK_TO_ENVIRONMENT`에 존재하는지 확인

**Phase:** core 패키지 타입 확장 단계.

---

### L-03: token_registry 테이블의 네트워크 범위 -- 환경별 vs 네트워크별

**Severity:** MINOR
**Confidence:** HIGH (token_registry 스키마 직접 확인)
**Design Decision:** token_registry의 network 컬럼 유지/변경

**What goes wrong:**
현재 `token_registry`는 `network` 컬럼으로 토큰을 저장:
```sql
UNIQUE INDEX idx_token_registry_network_address ON token_registry(network, address)
```

이것은 새 모델과 잘 맞는다 -- 토큰은 특정 네트워크에 배포되므로 network-level이 정확하다. 하지만:
- 같은 토큰(예: USDC)이 여러 네트워크에 존재하면 각각 별도 행
- `getAdapterTokenList(wallet.network)`가 호출되는데, wallet.network가 environment로 바뀌면 어떤 네트워크의 토큰을 반환하는가?

**Prevention:**
1. `token_registry.network`는 그대로 유지 (구체적 네트워크가 맞음)
2. `getAdapterTokenList()` 호출 시 `wallet.network` 대신 `resolvedNetwork` 사용
3. "환경의 모든 네트워크 토큰 조회"는 별도 API로 제공: `getTokensByEnvironment(environment)` -> 모든 해당 네트워크의 토큰 반환

**Phase:** token_registry 변경 최소화. 호출부만 수정.

---

## Phase-Specific Warnings

| Phase Topic | Likely Pitfall | Severity | Mitigation |
|------------|---------------|----------|------------|
| **EnvironmentType 추가 (core)** | L-01: Zod SSoT 파생 순서 복잡화 | Minor | EnvironmentType을 NetworkType과 동일한 패턴으로 추가. validateEnvironmentNetwork() 함수 작성 |
| **DB 마이그레이션 v6** | C-02, C-03: 테이블 재생성 + 데이터 변환 순서 | Critical | 2단계 분리 (v6a: ADD COLUMN + 데이터 복사, v6b: 12-step 재생성). transactions.network를 먼저 채운 후 wallets.network 변환 |
| **wallet.network -> wallet.environment 리팩토링** | H-04: 1,467 테스트 광범위 실패 | High | 타입 시스템으로 컴파일 에러 가이드. 3단계 진행 (타입 추가 -> 내부 구현 -> 외부 인터페이스) |
| **Pipeline network 해석 변경** | C-01: testnet/mainnet 격리 실패 | Critical | Stage 1에서 environment-network 교차 검증을 가장 먼저 실행. 키 서명 직전에도 이중 검증 |
| **API 응답 스키마 변경** | H-01: 하위 호환성 파괴 | High | default_network 전략. 기존 `network` 필드 의미 유지. `resolvedNetwork` 새 필드 추가 |
| **AdapterPool 확장** | H-02: 캐시 키 변경 + M-02: 메모리 증가 | High/Moderate | AdapterPool 캐시 키는 변경 불필요. LRU + idle 타임아웃 추가 |
| **정책 엔진 확장** | H-03: 네트워크 범위 불일치 | High | TransactionParam에 network 추가. 기존 정책에 network scope 마이그레이션. ALLOWED_NETWORKS 신규 타입 |
| **getAssets 멀티네트워크** | M-01: N-way RPC 성능 폭발 | Moderate | 기본 동작은 단일 네트워크 유지. 멀티네트워크는 opt-in. 캐싱 + Multicall3 + 타임아웃 |
| **config.toml 확장** | M-03: RPC URL 폭발 | Moderate | 사용하는 네트워크만 설정 필수. 미설정 네트워크는 명확한 에러 메시지 |
| **Admin UI 업데이트** | M-05: 표시 혼란 | Moderate | environment + default_network 조합 표시. 낮은 우선순위 |

---

## 마이그레이션 안전성 체크리스트

v3 마이그레이션(agents->wallets) 경험에서 도출한 v6 마이그레이션 체크리스트:

| # | 항목 | 근거 |
|---|------|------|
| 1 | `PRAGMA foreign_keys = OFF` 설정 확인 | SQLite 12-step 테이블 재생성 필수 조건 |
| 2 | `managesOwnTransaction: true` 사용 | migrate.ts 패턴 준수 |
| 3 | `transactions.network` 채움 -> `wallets.network` 변환 (순서 필수) | C-03 데이터 유실 방지 |
| 4 | `SELECT COUNT(*)` 전후 비교 | 행 수 보존 확인 |
| 5 | `PRAGMA foreign_key_check` 빈 배열 | FK 무결성 |
| 6 | v3 패턴의 인덱스 전수 재생성 | DROP + CREATE 패턴 |
| 7 | audit_log.event_type 변환 불필요 확인 | v3에서 AGENT_* -> WALLET_* 했으므로 추가 변환 없음 |
| 8 | 기존 데이터로 round-trip 테스트 | Solana mainnet + EVM sepolia 혼합 데이터 |
| 9 | `LATEST_SCHEMA_VERSION` 업데이트 (5 -> 6 또는 7) | pushSchema()가 새 DB에서 올바른 버전 기록 |
| 10 | `getCreateTableStatements()` DDL 업데이트 | 새 DB 생성 시 최신 스키마 반영 |

---

## Sources

### 직접 분석 (HIGH confidence)
- WAIaaS 코드베이스: `packages/daemon/src/infrastructure/database/schema.ts` (10 테이블 스키마)
- WAIaaS 코드베이스: `packages/daemon/src/infrastructure/database/migrate.ts` (v2-v5 마이그레이션)
- WAIaaS 코드베이스: `packages/daemon/src/infrastructure/adapter-pool.ts` (어댑터 풀 구현)
- WAIaaS 코드베이스: `packages/daemon/src/pipeline/database-policy-engine.ts` (정책 엔진 1007라인)
- WAIaaS 코드베이스: `packages/daemon/src/api/routes/wallet.ts` (getAssets 구현)
- WAIaaS 코드베이스: `packages/core/src/enums/chain.ts` (NETWORK_TYPES 13개)
- WAIaaS 코드베이스: `packages/adapters/evm/src/evm-chain-map.ts` (EVM 10 네트워크 매핑)

### 외부 참조 (MEDIUM-HIGH confidence)
- [SQLite ALTER TABLE 공식 문서](https://www.sqlite.org/lang_altertable.html) -- 12-step 테이블 재생성 절차, CHECK 제약 제한사항
- [Hardware Wallet Coin Isolation Bypass](https://thecharlatan.ch/Coin-Isolation/) -- testnet/mainnet 격리 취약점, Ledger/Trezor/KeepKey/Coldcard 영향
- [QuickNode RPC 효율성 가이드](https://www.quicknode.com/guides/quicknode-products/apis/guide-to-efficient-rpc-requests) -- 병렬 vs 배치 요청 성능, rate limiting, 타임아웃 전략
- [Chainstack Multicall vs HTTP Batch 비교](https://docs.chainstack.com/docs/http-batch-request-vs-multicall-contract) -- EVM Multicall3 최적화, 비용 비교
- [Zalando REST API Guidelines - Compatibility](https://github.com/zalando/restful-api-guidelines/blob/main/chapters/compatibility.adoc) -- API 하위 호환성 원칙, breaking change 정의
- [SQLite CHECK 제약 조건 마이그레이션](https://synkee.com.sg/blog/safely-modify-sqlite-table-columns-with-production-data/) -- SQLite 컬럼 변경 안전 가이드
