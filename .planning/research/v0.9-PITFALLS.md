# Domain Pitfalls: MCP Session Management Automation

**Domain:** MCP Server 내장 SessionManager, Telegram 세션 재생성, CLI 토큰 관리
**Project:** WAIaaS v0.9
**Researched:** 2026-02-09
**Overall Confidence:** MEDIUM-HIGH (Node.js 공식 문서, Telegram Bot API, MCP 스펙, Claude Desktop 이슈 트래커, npm write-file-atomic 이슈, v0.5-v0.8 설계 문서 교차 검증)

---

## Overview

이 문서는 **기존 MCP Server(stdio 기반, 환경변수 토큰 전달)에 SessionManager(자동 갱신 + 파일 영속화)를 추가할 때** 발생하는 함정을 다룬다. v0.8 PITFALLS.md의 Owner 상태 전이/정책 다운그레이드 위험과는 달리, v0.9 특유의 타이머 정확성, 토큰 파일 경합, MCP stdio 프로세스 모델 제약, 외부 토큰 감지 타이밍, Telegram 콜백 만료에 집중한다.

각 함정은 **Critical(서비스 중단 또는 보안 결함)**, **High(토큰 갱신 실패 또는 데이터 손실)**, **Medium(UX 열화 또는 엣지 케이스)** 3단계로 분류한다.

---

## Critical Pitfalls

서비스 중단, 보안 결함, 또는 토큰 영속성 파괴를 야기하는 실수.

---

### C-01: setTimeout 32비트 정수 오버플로우 -- 갱신 타이머 즉시 실행

**Severity:** CRITICAL
**Confidence:** HIGH (Node.js 공식 문서, MDN setTimeout 스펙, npm/max-timeout 이슈)

**What goes wrong:**
Node.js의 `setTimeout`은 내부적으로 부호 있는 32비트 정수로 지연 시간을 저장한다. 최대값은 `2,147,483,647ms` (약 24.85일)이다. 이 값을 초과하면 **지연이 1ms로 설정되어 콜백이 즉시 실행**된다.

v0.9 SessionManager의 갱신 스케줄: `expiresIn * 0.6`. 기본 expiresIn은 604,800초(7일)이므로 60% 시점은 362,880초 = 362,880,000ms. 이 값은 32비트 한계 이내이므로 기본 설정에서는 안전하다.

**그러나** config.toml에서 expiresIn을 변경할 수 있다:
- expiresIn = 30일(2,592,000초) -> 60% = 1,555,200,000ms (안전, ~18일)
- expiresIn = 90일(7,776,000초) -> 60% = 4,665,600,000ms (**오버플로우! 즉시 실행**)

갱신 타이머가 즉시 실행되면:
1. 프로세스 시작 직후 PUT /renew 호출
2. Guard 3 (50% 시점 미경과) 위반으로 `RENEWAL_TOO_EARLY` 403
3. 30초 후 재시도 -> 다시 403
4. 1회 재시도 후 갱신 포기 -> 세션이 갱신 없이 만료

**Warning signs:**
- expiresIn이 41일(~3,542,400초) 이상인 세션에서 갱신 타이머가 무한 반복 실패
- 프로세스 시작 직후 로그에 `RENEWAL_TOO_EARLY` 에러 반복 출현
- `setTimeout` 호출 시 ms 값이 `Number.MAX_SAFE_INTEGER`와 비교되지 않고 그대로 전달됨

**Prevention:**
```typescript
// SessionManager.scheduleRenewal()
const MAX_TIMEOUT_MS = 2_147_483_647  // 2^31 - 1

function safeSetTimeout(callback: () => void, delayMs: number): NodeJS.Timeout {
  if (delayMs > MAX_TIMEOUT_MS) {
    // 체이닝: MAX_TIMEOUT_MS만큼 대기 후 남은 시간으로 재스케줄
    return setTimeout(() => {
      safeSetTimeout(callback, delayMs - MAX_TIMEOUT_MS)
    }, MAX_TIMEOUT_MS)
  }
  return setTimeout(callback, delayMs)
}
```

**Detection:**
- SessionManager.start() 시점에 계산된 renewalDelayMs를 로그에 기록
- renewalDelayMs > MAX_TIMEOUT_MS 시 WARN 로그 출력
- config.toml의 expiresIn Zod 검증에서 `max(7776000)` (90일) 제한을 유지하되, 60% 시점 계산 후 32비트 한계 초과 여부를 런타임 경고로 출력

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) 작성 시

**Sources:**
- [Node.js Timers documentation](https://nodejs.org/api/timers.html) -- delay 인자 설명
- [MDN setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout) -- 32비트 정수 제한
- [nodejs/node#22860](https://github.com/nodejs/node/issues/22860) -- 공식 이슈
- [sindresorhus/max-timeout](https://github.com/sindresorhus/max-timeout) -- 라이브러리 참고

---

### C-02: 토큰 파일 쓰기 경합 -- 데몬/Telegram/CLI 동시 쓰기로 파일 손상

**Severity:** CRITICAL
**Confidence:** HIGH (Node.js fs.writeFileSync 동작, npm/write-file-atomic 이슈, WAIaaS v0.9 아키텍처 분석)

**What goes wrong:**
`~/.waiaas/mcp-token` 파일에 3개의 쓰기 주체가 존재한다:
1. **MCP SessionManager** -- 자동 갱신 성공 시 새 토큰 저장
2. **Telegram Bot** -- `/newsession` 명령 처리 시 새 토큰 저장
3. **CLI** -- `waiaas mcp setup` / `waiaas mcp refresh-token` 실행 시

Self-Hosted 단일 머신이지만, 이들은 **별도 프로세스**이다:
- 데몬 프로세스 (Hono HTTP server + Telegram Bot)
- MCP Server 프로세스 (Claude Desktop 자식 프로세스)
- CLI 프로세스 (사용자가 터미널에서 실행)

**경합 시나리오 1: MCP 갱신 + Telegram /newsession 동시 실행**
```
시간 t0: SessionManager 갱신 성공 -> 새 토큰 A를 파일에 쓰기 시작
시간 t0+1ms: Telegram /newsession 처리 -> 새 세션의 토큰 B를 파일에 쓰기 시작
시간 t0+2ms: 토큰 A 쓰기 완료 (파일 = 토큰 A)
시간 t0+3ms: 토큰 B 쓰기 완료 (파일 = 토큰 B, 토큰 A 덮어씀)
결과: SessionManager는 메모리에 토큰 A를 보유하지만, 파일은 토큰 B
다음 MCP 프로세스 재시작 시 토큰 B 로드 -> 정상 (B가 더 새로우므로)
```

이 시나리오는 **실제로는 대부분 무해**하다. 새 세션 토큰(B)이 파일에 남으므로 MCP 재시작 시 최신 토큰을 사용한다.

**경합 시나리오 2: 파일 쓰기 중 프로세스 크래시 (파일 부분 쓰기)**
```
시간 t0: writeFileSync 시작 (토큰 = "wai_sess_eyJhbGci...")
시간 t0+xms: 프로세스 SIGKILL로 종료 (쓰기 도중)
결과: 파일에 "wai_sess_eyJhb" (잘린 JWT) -> 파싱 실패
```

**경합 시나리오 3: Windows NTFS rename 비원자성**
`write-file-atomic` 라이브러리를 사용해도 Windows에서는 rename이 원자적이지 않다. 두 프로세스가 동시에 같은 파일에 쓰면 `EPERM: operation not permitted` 에러가 발생할 수 있다.

**Warning signs:**
- MCP Server가 파일에서 로드한 토큰으로 API 호출 시 `AUTH_TOKEN_INVALID` 반환
- mcp-token 파일 내용이 유효한 JWT 형식이 아님 (잘린 문자열)
- Windows에서 EPERM 에러 로그

**Prevention:**

1. **원자적 쓰기 (write-then-rename) 패턴 필수:**
```typescript
import { writeFileSync, renameSync, mkdirSync } from 'node:fs'
import { join, dirname } from 'node:path'
import { randomBytes } from 'node:crypto'

function atomicWriteToken(filePath: string, token: string): void {
  const dir = dirname(filePath)
  mkdirSync(dir, { recursive: true })
  const tmpPath = join(dir, `.mcp-token.${process.pid}.${randomBytes(4).toString('hex')}.tmp`)
  try {
    writeFileSync(tmpPath, token, { mode: 0o600 })
    renameSync(tmpPath, filePath)  // POSIX에서 원자적
  } catch (err) {
    // 임시 파일 정리
    try { unlinkSync(tmpPath) } catch {}
    throw err
  }
}
```

2. **파일 읽기 시 유효성 검증:**
```typescript
function loadTokenFromFile(filePath: string): string | null {
  try {
    const content = readFileSync(filePath, 'utf-8').trim()
    if (!content.startsWith('wai_sess_')) return null
    // JWT 3-part 구조 확인
    const jwt = content.slice(9)  // 'wai_sess_' 제거
    if (jwt.split('.').length !== 3) return null
    return content
  } catch {
    return null
  }
}
```

3. **Windows에서는 retry-on-EPERM:**
```typescript
function atomicWriteTokenWithRetry(filePath: string, token: string, maxRetries = 3): void {
  for (let i = 0; i < maxRetries; i++) {
    try {
      atomicWriteToken(filePath, token)
      return
    } catch (err: any) {
      if (err.code === 'EPERM' && i < maxRetries - 1) {
        // 10~50ms 랜덤 대기 후 재시도
        const delay = 10 + Math.random() * 40
        Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, delay)
        continue
      }
      throw err
    }
  }
}
```

4. **"마지막 쓰기 우선" (Last-Writer-Wins) 정책 명시:** 3개 쓰기 주체 중 가장 마지막에 쓴 토큰이 유효하다고 명시적으로 정의한다. 이는 Single-Machine 전제에서 합리적이다 -- 가장 최근에 생성된 세션이 사용되어야 한다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) + CLI MCP 커맨드 설계 (SESS-AUTO-03)

**Sources:**
- [npm/write-file-atomic#28](https://github.com/npm/write-file-atomic/issues/28) -- Windows EPERM 문제
- [Node.js fs.writeFileSync](https://nodejs.org/api/fs.html) -- 원자성 미보장
- [cross-platform-node-guide: permissions](https://github.com/ehmicky/cross-platform-node-guide/blob/main/docs/5_security/permissions.md)

---

### C-03: JWT payload 무검증 디코딩 시 조작된 토큰 수용 위험

**Severity:** CRITICAL
**Confidence:** HIGH (Auth0 JWT 취약점 연구, OWASP JWT 테스트 가이드, WAIaaS v0.9 objective 분석)

**What goes wrong:**
v0.9 설계에서 SessionManager는 토큰 파일/환경변수에서 로드한 JWT의 payload를 **서명 검증 없이** base64url 디코딩만으로 `sessionId`, `exp`, `iat`을 추출한다:

```
// v0.9 objective 1.3 "토큰 로드 전략":
// "JWT payload 디코딩 (서명 검증 없이, base64url만) -> sessionId, exp, iat 추출"
```

이 설계의 의도: MCP Server는 JWT 서명 비밀키를 보유하지 않으므로 (비밀키는 데몬에만 존재), 서명 검증이 **불가능**하다. 따라서 payload의 `exp`만 추출하여 갱신 스케줄링에 사용하고, 실제 인증은 API 호출 시 데몬이 수행한다.

**보안 위험: 직접적이지 않지만 간접적**

MCP Server가 직접 인가 결정을 하는 것이 아니므로 "조작된 exp로 갱신을 건너뛰게 하는" 공격은 불가능하다 -- 갱신 자체가 데몬 API 호출이고, 데몬이 JWT를 검증한다. 그러나:

1. **조작된 exp → 잘못된 갱신 타이밍:** 공격자가 mcp-token 파일에 exp가 매우 먼 미래인 조작 JWT를 심으면, SessionManager가 갱신을 스케줄하지 않는다. 결과: 실제 세션은 이미 만료되었지만 SessionManager는 갱신을 시도하지 않고, 모든 API 호출이 401로 실패한다.

2. **조작된 sid → 다른 세션 갱신 시도:** 공격자가 sid를 다른 세션의 ID로 바꾸면, SessionManager가 PUT /v1/sessions/{조작된ID}/renew를 호출한다. 그러나 Bearer 토큰 자체는 원래 세션의 것이므로 데몬의 sessionAuth에서 `SESSION_RENEWAL_MISMATCH`로 거부된다.

3. **DoS 벡터:** 조작된 exp = 1 (이미 만료)이면, SessionManager가 시작 시 "이미 만료" 상태에 진입하고, 파일 재로드를 시도하지만 파일이 여전히 조작 토큰이므로 무한 에러 루프.

**핵심 문제:** 토큰 파일이 **로컬 파일시스템**에 있으므로, 파일 접근 = 시스템 접근이다. 토큰 파일을 조작할 수 있는 공격자는 이미 시스템을 장악한 것이므로 JWT 조작은 부차적이다. **그러나** 방어 심층(defense-in-depth) 원칙상 파일 무결성 검증은 여전히 가치가 있다.

**Warning signs:**
- mcp-token 파일의 JWT exp와 데몬 DB의 sessions.expires_at이 불일치
- SessionManager가 갱신을 스케줄하지 않는데 API 호출이 401로 실패
- 로그에 `AUTH_TOKEN_INVALID` 반복 (토큰 서명 불일치)

**Prevention:**

1. **로드 시 데몬에 토큰 유효성 확인 요청 (권장):**
```typescript
// SessionManager.loadToken() 시
// 1. 파일/env에서 토큰 로드
// 2. base64url로 exp/sid 추출 (스케줄링 용)
// 3. 데몬에 GET /v1/sessions/:sid 호출 (Bearer: 로드한 토큰)
//    -> 200: 세션 유효, 서버 측 expiresAt 확인
//    -> 401: 토큰 무효 -> 에러 상태 진입
//    -> 404: 세션 없음 -> 에러 상태 진입
```
이 방법은 추가 HTTP 왕복 1회를 필요로 하지만, 프로세스 시작 시 1회만 수행하므로 성능 영향이 없다.

2. **base64url 디코딩 방어적 파싱:**
```typescript
function decodeJwtPayload(token: string): JwtPayload | null {
  try {
    const jwt = token.startsWith('wai_sess_') ? token.slice(9) : token
    const parts = jwt.split('.')
    if (parts.length !== 3) return null
    const payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf-8'))
    // 필수 claim 존재 확인
    if (typeof payload.exp !== 'number') return null
    if (typeof payload.sid !== 'string') return null
    if (typeof payload.aid !== 'string') return null
    // exp 범위 검증 (과거 10년 ~ 미래 1년)
    const now = Math.floor(Date.now() / 1000)
    if (payload.exp < now - 315_360_000 || payload.exp > now + 31_536_000) return null
    return payload
  } catch {
    return null
  }
}
```

3. **symlink 검증 (S-04 시나리오):** v0.9 objective에 이미 명시됨 (`S-04: 토큰 파일 심볼릭 링크 -> symlink 감지 -> 로드 거부`). `lstatSync`로 symlink 여부를 확인한다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) 작성 시

**Sources:**
- [Auth0: Critical JWT Vulnerabilities](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
- [OWASP JWT Testing Guide](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/10-Testing_JSON_Web_Tokens)
- WAIaaS v0.9 objective 섹션 1.3 (토큰 로드 전략)

---

## High-Risk Pitfalls

토큰 갱신 실패, 서비스 불연속성, 또는 플랫폼 호환성 문제를 야기하는 실수.

---

### H-01: setTimeout 타이머 드리프트 -- 장기 실행 시 갱신 시점 누적 오차

**Severity:** HIGH
**Confidence:** HIGH (Node.js 공식 문서, nodejs/node#21822, Node.js Event Loop 문서)

**What goes wrong:**
Node.js `setTimeout`의 지연 시간은 **보장값이 아닌 최소값**이다. 공식 문서: "Timer callbacks will run as early as they can be scheduled after the specified amount of time has passed; however, Operating System scheduling or the running of other callbacks may delay them."

갱신 타이머가 362,880,000ms(약 4.2일) 후에 실행되도록 스케줄한다. 이 기간 동안:
- Event loop이 바쁘면 콜백이 지연된다
- GC(Garbage Collection) pause가 발생하면 추가 지연
- OS 레벨 스케줄링으로 수초~수십초 지연 가능

4.2일 타이머 자체의 드리프트는 보통 수초~수분 수준이므로, 세션 갱신의 맥락에서는 **실질적 문제가 되지 않는다** -- Guard 3 (50% 시점)이 expiresIn의 50%를 요구하고, 갱신 시도는 60% 시점이므로 10% 여유가 있다.

**그러나 누적 드리프트가 문제:** 30회 갱신 x 각 수분 드리프트 = 절대 수명 접근 시점에서 예상보다 수시간 늦게 갱신 시도 -> Guard 2 (절대 수명) 위반으로 예상치 못한 갱신 실패.

**Warning signs:**
- 갱신 로그의 실제 시각이 예정 시각보다 계속 뒤로 밀림
- 절대 수명 만료 1~2일 전에 갱신이 `SESSION_ABSOLUTE_LIFETIME_EXCEEDED`로 실패
- `expiresIn`이 짧을수록 (예: 1시간) 드리프트가 누적됨

**Prevention:**
```typescript
// 자기 보정 타이머 패턴
function scheduleRenewal(): void {
  const now = Date.now()
  const renewAtMs = this.referenceTimeMs + (this.expiresInMs * 0.6)
  const delayMs = Math.max(renewAtMs - now, 0)

  this.timer = safeSetTimeout(() => {
    this.renew()
  }, delayMs)
}

// 갱신 성공 후 다음 스케줄은 서버 응답의 expiresAt을 기준으로 재계산
async renew(): Promise<void> {
  const result = await this.callRenewApi()
  if (result.success) {
    // 서버 측 expiresAt을 신뢰 (드리프트 보정)
    this.referenceTimeMs = Date.now()
    this.expiresAtMs = new Date(result.data.expiresAt).getTime()
    this.expiresInMs = this.expiresAtMs - this.referenceTimeMs
    this.scheduleRenewal()  // 서버 시간 기준 재스케줄
  }
}
```

핵심: 서버 응답의 `expiresAt`을 기준으로 다음 갱신 시점을 재계산하면, 누적 드리프트가 매 갱신마다 0으로 리셋된다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) 작성 시

**Sources:**
- [Node.js Timers](https://nodejs.org/api/timers.html) -- "a minimum of ms milliseconds"
- [nodejs/node#21822](https://github.com/nodejs/node/issues/21822) -- setInterval drift in production

---

### H-02: MCP Server 프로세스 kill 중 갱신 inflight -- 토큰 파일과 메모리 불일치

**Severity:** HIGH
**Confidence:** MEDIUM (Claude Desktop MCP 프로세스 관리 이슈, MCP 프로토콜 스펙, Node.js signal handling)

**What goes wrong:**
Claude Desktop은 MCP Server를 자식 프로세스로 spawn한다. 사용자가 Claude Desktop을 종료하거나 MCP 서버를 재시작하면, Claude Desktop이 MCP Server 프로세스에 SIGTERM (또는 Windows에서는 강제 종료)을 보낸다.

갱신이 inflight인 상태에서 프로세스가 종료되면:

**시나리오 A: API 호출 전 종료**
```
1. 타이머 콜백 시작
2. renew() 호출 준비
3. SIGTERM 수신 -> 프로세스 종료
결과: 갱신 미수행. 무해 -- 기존 토큰이 파일에 남아있음.
```

**시나리오 B: API 호출 후, 파일 쓰기 전 종료**
```
1. PUT /v1/sessions/:id/renew -> 200 OK (새 토큰 발급)
2. 데몬 DB에서 token_hash 교체 완료 (구 토큰 무효화)
3. SIGTERM 수신 -> 프로세스 종료
4. 파일에는 여전히 구 토큰
결과: 다음 시작 시 파일에서 구 토큰 로드 -> 데몬에 구 토큰으로 API 호출 -> 401 AUTH_TOKEN_INVALID
```

시나리오 B가 **핵심 문제**: 데몬 측에서 token_hash가 이미 교체되었으므로 구 토큰은 영구적으로 무효하다. 갱신 응답의 새 토큰은 메모리에만 존재하고 파일에 저장되지 못한 채 프로세스가 종료된다.

**추가 문제: Windows에서 MCP 자식 프로세스 미정리**
Claude Code의 Windows 이슈에서 MCP Server 프로세스가 Claude 종료 시 제대로 종료되지 않는 문제가 보고되어 있다 (orphan process). 이 경우 갱신 타이머가 계속 돌면서 데몬에 반복 갱신을 시도할 수 있다.

**Warning signs:**
- MCP Server 재시작 후 첫 API 호출이 항상 `AUTH_TOKEN_INVALID`
- v0.9 설계의 lazy reload(401 시 파일 재로드) 경로에서 "파일 토큰 == 현재 토큰" -> 에러 상태 진입
- 갱신 로그에 성공이 기록되었으나, 다음 시작 시 파일의 토큰이 갱신 전 버전

**Prevention:**

1. **갱신 응답을 파일에 먼저 쓰고, 메모리를 교체:**
```typescript
async renew(): Promise<void> {
  const result = await this.callRenewApi()
  if (result.success) {
    // 1. 파일 먼저 (프로세스 kill 시 파일이 최신 상태 보장)
    atomicWriteToken(this.tokenFilePath, result.data.token)
    // 2. 메모리 교체 (이후 tool 호출에서 새 토큰 사용)
    this.token = result.data.token
    this.expiresAt = new Date(result.data.expiresAt).getTime()
    // 3. 다음 갱신 스케줄
    this.scheduleRenewal()
  }
}
```
이 순서에서 SIGTERM이 단계 1 이후 단계 2 이전에 오면: 파일에 새 토큰이 있으므로 다음 시작 시 정상. 단, 메모리에는 구 토큰이 남아 현재 세션의 나머지 tool 호출이 401을 받을 수 있지만, 이는 프로세스 종료 직전이므로 무의미하다.

2. **graceful shutdown에서 inflight 갱신 완료 대기:**
```typescript
process.on('SIGTERM', async () => {
  if (this.isRenewing) {
    // 최대 5초간 갱신 완료 대기
    await Promise.race([
      this.renewPromise,
      new Promise(resolve => setTimeout(resolve, 5000))
    ])
  }
  this.dispose()
  process.exit(0)
})
```

3. **시작 시 토큰 유효성 확인 (C-03 Prevention 1번과 통합):** 프로세스 시작 시 데몬에 토큰 유효성을 확인하여, 시나리오 B 상황을 즉시 감지한다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) + MCP Server lifecycle 설계

**Sources:**
- [Windows MCP process cleanup issue](https://github.com/anthropics/claude-code/issues/15211)
- [MCP Protocol Specification](https://www.claudemcp.com/specification) -- stdio transport lifecycle
- [Claude Desktop config](https://apxml.com/courses/getting-started-model-context-protocol/chapter-4-debugging-and-client-integration/configuration-claude-desktop)

---

### H-03: 0o600 파일 권한이 Windows에서 무의미 -- 토큰 파일 보안 공백

**Severity:** HIGH
**Confidence:** HIGH (Node.js 공식 문서, nodejs/node-v0.x-archive#4812, cross-platform-node-guide)

**What goes wrong:**
v0.9 설계에서 토큰 파일 사양은 `0o600` (Owner read/write only)이다. 이 POSIX 권한 모드는 macOS와 Linux에서 정상 동작하지만, **Windows NTFS에서는 Node.js의 `fs.chmod()`가 제한적으로 동작**한다.

Node.js 공식 문서: "On Windows, only the write permission can be changed, and the distinction among the permissions of group, owner, or others is not implemented." 즉, `0o600`으로 설정해도 Windows에서는:
- 읽기 전용(`0o444`) 또는 읽기/쓰기(`0o666`)만 설정 가능
- 그룹/기타 사용자 구분 불가
- NTFS ACL은 별도로 관리해야 함

결과: Windows에서 `~/.waiaas/mcp-token` 파일이 **다른 사용자에게도 읽기 가능**할 수 있다. 단일 사용자 머신에서는 실질적 위험이 낮지만, 다중 사용자 환경에서는 토큰 노출 위험이 존재한다.

**추가 문제: `fs.access()` 기반 권한 확인도 불완전**
Windows에서 `fs.access()`는 ACL을 검사하지 않고 읽기전용 속성만 확인한다. 따라서 S-01 보안 시나리오("0o600 외 권한 시 로드 거부")는 Windows에서 의미 없는 검증이 된다.

**Warning signs:**
- Windows에서 S-01 테스트가 항상 통과 (실제로는 권한이 666으로 설정됨)
- `fs.statSync(tokenPath).mode & 0o777`이 Windows에서 항상 `0o666` 반환
- 다중 사용자 Windows 서버에서 다른 사용자가 토큰 파일 읽기 가능

**Prevention:**

1. **플랫폼별 권한 전략:**
```typescript
import { platform } from 'node:os'

function setTokenFilePermissions(filePath: string): void {
  if (platform() === 'win32') {
    // Windows: icacls로 ACL 설정 (Node.js chmod 대신)
    // 또는 NTFS 스트림 기반 보호는 과도하므로,
    // %APPDATA%/waiaas 디렉토리에 저장하여 사용자 프로필 격리에 의존
    console.warn('[WARN] Windows: POSIX file permissions not supported. '
      + 'Token file is protected by user profile isolation only.')
  } else {
    chmodSync(filePath, 0o600)
  }
}
```

2. **Windows에서의 권한 검증 스킵:**
```typescript
function validateTokenFilePermissions(filePath: string): boolean {
  if (platform() === 'win32') {
    // Windows에서는 POSIX 권한 검증이 의미 없으므로 경고만 출력
    return true
  }
  const stats = statSync(filePath)
  const mode = stats.mode & 0o777
  if (mode !== 0o600) {
    console.error(`[ERROR] Token file has insecure permissions: ${mode.toString(8)}`)
    return false
  }
  return true
}
```

3. **Windows용 대안 저장소 경로:**
```
macOS/Linux: ~/.waiaas/mcp-token
Windows: %LOCALAPPDATA%\waiaas\mcp-token (AppData\Local)
```
`%LOCALAPPDATA%`는 Windows에서 사용자별로 격리된 디렉토리이다.

4. **설계 문서에 Windows 제한 명시:** 51-platform-test-scope.md에 이미 플랫폼별 테스트 범위가 정의되어 있으므로, 토큰 파일 보안에 대한 Windows 제한을 명시적으로 추가한다.

**Phase:** CLI MCP 커맨드 설계 (SESS-AUTO-03) + CORE-01(24) 토큰 파일 사양 업데이트

**Sources:**
- [Node.js fs.chmod Windows limitation](https://github.com/nodejs/node-v0.x-archive/issues/4812)
- [cross-platform-node-guide: permissions](https://github.com/ehmicky/cross-platform-node-guide/blob/main/docs/5_security/permissions.md)
- [Node.js fs documentation](https://nodejs.org/api/fs.html) -- Windows ACL limitation

---

### H-04: Claude Desktop 반복 에러 시 MCP Server 연결 해제 -- 세션 만료 복구 불가

**Severity:** HIGH
**Confidence:** MEDIUM (Claude Desktop 이슈 트래커, MCP 커뮤니티 리포트, 공식 문서 미확인)

**What goes wrong:**
MCP Server가 tool 호출에 대해 반복적으로 에러를 반환하면, Claude Desktop이 MCP Server를 "disconnected" 상태로 표시하거나 프로세스를 종료할 수 있다. 정확한 동작은 Claude Desktop 버전에 따라 다르며, 공식적으로 문서화되어 있지 않다.

v0.9에서 세션이 만료되면:
1. 모든 tool 호출이 `isError: true` + `AUTH_TOKEN_EXPIRED` 반환
2. Claude Desktop이 연속 에러를 감지
3. Claude Desktop이 MCP Server를 비정상으로 판단하고 연결 해제
4. Owner가 Telegram `/newsession` 또는 CLI로 새 토큰을 발급하더라도, MCP Server가 이미 disconnected
5. Claude Desktop을 수동으로 재시작해야 함 -> 대화 맥락 소실

이는 **v0.9의 핵심 목표 위반**이다: "에이전트 사이드에 세션 관리 부담을 주지 않는다" / "Claude Desktop 재시작 필요" 제거.

**Warning signs:**
- 세션 만료 후 Claude Desktop UI에서 MCP 서버가 "disconnected" 표시
- Telegram `/newsession`으로 새 토큰 발급 후에도 MCP tool 사용 불가
- Claude Desktop 로그에 "Failed to call tool" 반복 후 연결 해제 로그

**Prevention:**

1. **에러 응답에서 isError 대신 정보성 메시지 반환:**
세션 만료 시 tool 호출을 에러로 반환하는 대신, 정상 응답으로 "세션이 만료되어 갱신을 시도하고 있습니다" 메시지를 반환한다.

```typescript
async function withSessionRecovery(fn: () => Promise<McpToolResult>): Promise<McpToolResult> {
  try {
    return await fn()
  } catch (err: any) {
    if (err.code === 'AUTH_TOKEN_EXPIRED') {
      // 파일에서 새 토큰 재로드 시도
      const reloaded = await this.sessionManager.tryReloadFromFile()
      if (reloaded) {
        // 재로드 성공 -> 원래 요청 재시도
        return await fn()
      }
      // 재로드 실패 -> 에러가 아닌 안내 메시지 반환
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'session_expired',
            message: 'Session has expired. The owner has been notified to create a new session. '
              + 'Please try again in a few minutes.',
            retryable: true,
          })
        }]
        // 주의: isError를 설정하지 않음!
      }
    }
    // 다른 에러는 isError로 반환
    return toMcpError(err)
  }
}
```

2. **주기적 heartbeat으로 서버 연결 유지:**
MCP Resources의 주기적 구독 업데이트를 통해 Claude Desktop에 서버가 정상임을 알린다. 세션 만료 시에도 Resources는 캐시된 데이터를 반환할 수 있다.

3. **도구 결과에 재시도 가이드 포함:**
```
"Session expired. A new session will be available shortly.
You can continue asking me questions that don't require wallet operations,
or wait 2-3 minutes for the session to be restored."
```

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) -- 에러 처리 섹션

**Sources:**
- [Claude Code MCP 16h hang issue](https://github.com/anthropics/claude-code/issues/15945)
- [Claude Code SSE disconnect crash](https://github.com/anthropics/claude-code/issues/18557)
- [Claude Code auto-reconnect feature request](https://github.com/anthropics/claude-code/issues/15904)

---

### H-05: 갱신 중 tool 호출의 토큰 불일치 -- 구 토큰 in-flight 시 401

**Severity:** HIGH
**Confidence:** HIGH (v0.5 토큰 회전 메커니즘, 53-session-renewal-protocol.md 섹션 5.3)

**What goes wrong:**
v0.5 토큰 회전(Token Rotation)은 갱신 시 새 JWT를 발급하고 **구 토큰의 token_hash를 즉시 교체**한다 (53-session-renewal-protocol.md 섹션 5.3). 이는 보안상 올바르지만, MCP 환경에서 타이밍 문제를 만든다:

```
시간 t0: SessionManager.renew() 호출
시간 t0+10ms: PUT /v1/sessions/:id/renew -> 네트워크 전송 중
시간 t0+50ms: 데몬이 갱신 처리 -> DB에서 token_hash 교체 -> 구 토큰 무효화
시간 t0+55ms: Claude LLM이 get_balance tool 호출 -> SessionManager.getToken() -> 구 토큰 반환
시간 t0+60ms: HTTP GET /v1/agents/:id/balance (Bearer: 구 토큰) -> 데몬 수신
시간 t0+65ms: sessionAuth Stage 2: token_hash 불일치 -> 401 AUTH_TOKEN_INVALID
시간 t0+100ms: 갱신 응답 200 OK 수신 -> 메모리에 새 토큰 저장
```

v0.9 objective 섹션 1.6에서 이미 인식하고 있다: "갱신 중 tool 호출이 발생하면 현재(이전) 토큰이 사용된다." 그러나 데몬 측에서 token_hash가 이미 교체된 상태에서 구 토큰이 사용되면 **401이 발생**한다.

**Warning signs:**
- 갱신 직후(수십ms 이내) tool 호출이 401로 실패
- 이후 tool 호출은 정상 (새 토큰 적용)
- 간헐적 401 에러가 갱신 타이밍과 상관관계

**Prevention:**

1. **갱신 중 뮤텍스로 tool 호출 대기 (비권장 -- 지연 유발):**
갱신 중에는 모든 tool 호출을 대기시키는 방법. 그러나 갱신이 네트워크 왕복(수십~수백ms)을 포함하므로 체감 지연이 발생한다.

2. **401 자동 재시도 (권장):**
```typescript
async function callDaemonApi(method: string, path: string, body?: any): Promise<any> {
  const token = this.sessionManager.getToken()
  const response = await fetch(`${this.baseUrl}${path}`, {
    method,
    headers: { Authorization: `Bearer ${token}` },
    body: body ? JSON.stringify(body) : undefined,
  })

  if (response.status === 401) {
    // 갱신 중일 수 있으므로 50ms 대기 후 최신 토큰으로 재시도
    await new Promise(resolve => setTimeout(resolve, 50))
    const freshToken = this.sessionManager.getToken()
    if (freshToken !== token) {
      // 토큰이 교체됨 -> 새 토큰으로 재시도
      const retryResponse = await fetch(`${this.baseUrl}${path}`, {
        method,
        headers: { Authorization: `Bearer ${freshToken}` },
        body: body ? JSON.stringify(body) : undefined,
      })
      return retryResponse
    }
    // 토큰이 동일 -> 진짜 만료, 에러 반환
  }
  return response
}
```

3. **데몬 측 구 토큰 유예 기간 (가장 견고):**
53-session-renewal-protocol.md 섹션 5.3에서 "구 토큰이 자동으로 무효화된다"는 즉시 무효화를 전제한다. 그러나 갱신 시 구 token_hash를 `previous_token_hash` 컬럼에 5초간 보관하고, sessionAuth에서 primary hash 불일치 시 previous_token_hash도 확인하는 유예 기간을 두면 경합을 해소할 수 있다. 이 변경은 v0.7에서 설계된 JWT dual-key rotation 5분 체계와 유사하다.

**Phase:** SESS-RENEW(53) 보완 + SessionManager 설계 스펙 (SESS-AUTO-01)

**Sources:**
- WAIaaS 53-session-renewal-protocol.md 섹션 5.3 (구 토큰 자동 무효화)
- WAIaaS v0.7 JWT dual-key rotation 설계 (5분 유예)

---

## Medium-Risk Pitfalls

UX 열화, 엣지 케이스 동작 이상, 또는 운영상 불편을 야기하는 실수.

---

### M-01: Telegram callback_query 15초 타임아웃 -- /newsession 에이전트 선택 UX 실패

**Severity:** MEDIUM
**Confidence:** HIGH (Telegram Bot API 공식 문서, python-telegram-bot#2254)

**What goes wrong:**
Telegram Bot API의 `callback_query`는 **약 15초 이내**에 `answerCallbackQuery`를 호출해야 한다. 이 시간이 초과되면 클라이언트에 "Query is too old and response timeout expired" 에러가 표시된다.

v0.9 `/newsession` 플로우:
```
1. /newsession 명령 -> 에이전트 목록 인라인 키보드 표시
2. Owner가 에이전트 선택 버튼 클릭 -> callback_query 수신
3. sessionService.create() 호출 -> DB 세션 생성
4. 토큰 파일 저장
5. answerCallbackQuery + 완료 메시지 전송
```

**문제 시나리오 1: 느린 세션 생성**
세션 생성에 Argon2id 키 파생이 포함되면 ~300ms, JWT 서명 + DB 쓰기 + 파일 쓰기까지 합치면 보통 1초 이내. 15초 타임아웃과는 충분한 여유가 있다. 이 시나리오는 **실질적으로 무해**하다.

**문제 시나리오 2: 사용자가 오래된 인라인 키보드를 클릭**
Owner가 `/newsession`을 실행하고, 에이전트 목록이 표시된 후 **몇 시간 후**에 버튼을 클릭한다. Telegram은 callback_query를 보트에 전달하지만:
- 봇이 재시작되었을 수 있음 (callback_data 핸들러 미등록)
- 에이전트 목록이 변경되었을 수 있음 (삭제된 에이전트 선택)
- Telegram 서버가 "query is too old" 판단

**문제 시나리오 3: 로딩 스피너 지속**
사용자가 인라인 버튼을 클릭한 후, 봇이 `answerCallbackQuery`를 호출하지 않으면 Telegram 클라이언트에 **~5초간 로딩 스피너**가 표시된다. 스피너가 사라진 후 아무 반응이 없으면 사용자가 버튼을 반복 클릭하여 중복 세션 생성이 발생할 수 있다.

**Warning signs:**
- Telegram 로그에 "QUERY_ID_INVALID" 또는 "Bad Request: query is too old" 에러
- Owner가 인라인 키보드 클릭 후 로딩 스피너가 사라지지만 완료 메시지 없음
- 동일 에이전트에 대해 짧은 시간 내 여러 세션이 생성됨

**Prevention:**

1. **callback_query 즉시 응답 + 후속 메시지:**
```typescript
bot.on('callback_query', async (query) => {
  // 즉시 응답 (로딩 스피너 제거)
  await bot.answerCallbackQuery(query.id, { text: 'Creating session...' })

  try {
    // 세션 생성 (후속 처리)
    const result = await sessionService.create(/* ... */)
    // 완료 메시지는 별도 sendMessage로 전송
    await bot.sendMessage(query.message.chat.id, formatSessionCreatedMessage(result))
    // 인라인 키보드 제거 (중복 클릭 방지)
    await bot.editMessageReplyMarkup(query.message.chat.id, query.message.message_id, { inline_keyboard: [] })
  } catch (err) {
    await bot.sendMessage(query.message.chat.id, `Session creation failed: ${err.message}`)
  }
})
```

2. **callback_data에 타임스탬프 포함:**
```typescript
// callback_data 포맷: "newsession:{agentId}:{timestamp}"
const callbackData = `newsession:${agentId}:${Date.now()}`

// 핸들러에서 만료 확인
const [action, agentId, timestampStr] = query.data.split(':')
const age = Date.now() - parseInt(timestampStr)
if (age > 300_000) {  // 5분 초과
  await bot.answerCallbackQuery(query.id, {
    text: 'This selection has expired. Please use /newsession again.',
    show_alert: true,
  })
  return
}
```

3. **중복 생성 방지 (idempotency):**
callback_query.id를 키로 한 짧은 TTL(60초) 캐시를 두어, 동일 콜백의 중복 처리를 방지한다.

**Phase:** Telegram 세션 재생성 설계 스펙 (SESS-AUTO-02)

**Sources:**
- [Telegram Bot API: answerCallbackQuery](https://core.telegram.org/bots/api#answercallbackquery)
- [python-telegram-bot#2254: "query is too old"](https://github.com/python-telegram-bot/python-telegram-bot/issues/2254)

---

### M-02: 401 lazy reload의 사용자 체감 지연 -- 첫 실패가 LLM 응답에 노출

**Severity:** MEDIUM
**Confidence:** HIGH (v0.9 objective 섹션 4.1, MCP tool handler 에러 처리 패턴)

**What goes wrong:**
v0.9 설계의 토큰 전환 메커니즘은 **lazy reload**: 현재 토큰이 만료되면 API 호출이 401을 반환하고, 그때 파일에서 새 토큰을 재로드한다.

문제: 이 과정이 MCP tool 호출의 응답 시간에 포함된다. Telegram `/newsession`으로 새 토큰이 파일에 저장된 후, 다음 tool 호출의 흐름:

```
1. LLM: "get_balance" tool 호출
2. SessionManager: 메모리의 구 토큰으로 GET /v1/agents/:id/balance
3. 데몬: 401 AUTH_TOKEN_EXPIRED
4. SessionManager: 파일에서 새 토큰 로드 (파일 I/O ~1ms)
5. SessionManager: 새 토큰으로 GET /v1/agents/:id/balance 재시도
6. 데몬: 200 OK
7. MCP: 정상 결과 반환
```

이 경우 **사용자에게는 투명**하다 (약간의 지연만 발생). 그러나:

**문제 시나리오: 파일에 아직 새 토큰이 없는 경우**
- Telegram `/newsession` 처리가 아직 완료되지 않음
- 또는 CLI `mcp refresh-token`이 실행 중
- 파일의 토큰 == 메모리의 토큰 -> "진짜 만료" 판단 -> 에러 메시지

이 에러 메시지가 **LLM의 응답에 포함**된다. LLM이 "세션이 만료되었습니다"를 사용자에게 전달하고, 수 분 후 새 토큰이 도착하면 다시 정상 동작한다. 이 사이의 기간에 사용자가 혼란을 느끼거나, LLM이 "wallet 기능을 사용할 수 없다"고 판단하여 이후 tool 호출을 자체적으로 억제할 수 있다.

**Warning signs:**
- LLM 대화에 "세션이 만료되었습니다" 메시지가 간헐적으로 출현
- LLM이 wallet tool 호출을 "사용할 수 없다"고 판단하여 이후 요청을 거부
- 세션 전환 후 첫 1~2회 tool 호출만 실패하고 이후 정상

**Prevention:**

1. **에러 메시지에 "일시적" 표현 포함:**
```typescript
{
  status: 'session_transitioning',
  message: 'Session is being refreshed. This is temporary - please retry this request.',
  retryable: true
}
```

2. **주기적 파일 확인 (proactive check):**
만료 감지 시 즉시 파일을 확인하는 것 외에, 만료 예정 시점(exp - 60초)에 선제적으로 파일을 확인하여 외부 갱신을 조기에 감지한다.

3. **재시도 횟수 제한 및 백오프:**
```typescript
// 401 -> 파일 재로드 -> 재시도 실패 시
// 30초, 60초, 120초 간격으로 3회 추가 재로드 시도
// 이 기간에 Telegram/CLI가 파일을 갱신할 시간을 확보
```

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) -- 토큰 전환 섹션

---

### M-03: MCP Server 프로세스 재시작 시 환경변수 토큰과 파일 토큰 불일치 -- 부트스트랩 루프

**Severity:** MEDIUM
**Confidence:** HIGH (v0.9 objective 섹션 1.3, Claude Desktop config 분석)

**What goes wrong:**
토큰 로드 우선순위: **파일 > 환경변수**. 이 설계는 정상 운영에서는 올바르다. 그러나 엣지 케이스:

**시나리오: config.json의 토큰이 영구적으로 구버전**
```
1. waiaas mcp setup 실행 -> 세션 A 생성 -> 파일에 토큰 A 저장
2. claude_desktop_config.json의 WAIAAS_SESSION_TOKEN = 토큰 A
3. MCP Server 시작 -> 파일에서 토큰 A 로드 (정상)
4. 수회 갱신 -> 파일에 토큰 A' (갱신된 버전)
5. 30일 후 절대 수명 만료 -> 토큰 A' 무효
6. Telegram /newsession -> 세션 B 생성 -> 파일에 토큰 B 저장
7. MCP Server 재시작 -> 파일에서 토큰 B 로드 (정상)
```

여기까지는 정상. 그러나:

```
8. config.json에는 여전히 WAIAAS_SESSION_TOKEN = 토큰 A (최초 설정 그대로)
9. 파일이 삭제됨 (실수 또는 디스크 정리)
10. MCP Server 재시작 -> 파일 없음 -> 환경변수에서 토큰 A 로드
11. 토큰 A는 30일 전에 만료됨 -> 즉시 에러 상태 진입
12. Owner가 Telegram /newsession으로 새 토큰 C 발급 -> 파일에 저장
13. MCP Server는 이미 에러 상태 -> 파일 재로드 기회 없음 (lazy reload는 401 시에만 동작)
```

**핵심 문제:** config.json의 토큰은 **1회성 부트스트랩**용이지만, 영구적으로 남아 있다. 파일이 없는 상태에서 구 환경변수 토큰이 로드되면, 로드 시점에 이미 만료 판정되어 갱신 스케줄링 자체가 불가능하다.

**Warning signs:**
- MCP Server 시작 로그에 "토큰 만료됨" 에러가 반복
- config.json의 토큰과 현재 유효한 세션의 토큰이 다름
- `~/.waiaas/mcp-token` 파일이 존재하지 않는 상태에서 MCP Server 시작

**Prevention:**

1. **만료된 토큰으로 시작 시에도 주기적 파일 확인:**
```typescript
// 에러 상태에서도 60초마다 파일을 확인
startErrorRecoveryLoop(): void {
  this.recoveryTimer = setInterval(() => {
    const newToken = loadTokenFromFile(this.tokenFilePath)
    if (newToken && newToken !== this.token) {
      const payload = decodeJwtPayload(newToken)
      if (payload && payload.exp > Math.floor(Date.now() / 1000)) {
        // 유효한 새 토큰 발견 -> 정상 모드 복귀
        this.token = newToken
        this.scheduleRenewal()
        clearInterval(this.recoveryTimer)
      }
    }
  }, 60_000)
}
```

2. **config.json 토큰 갱신 안내:**
`waiaas mcp refresh-token` CLI 출력에 "config.json의 토큰은 초기 부트스트랩용이며, SessionManager가 파일 기반으로 관리합니다. config.json 업데이트는 불필요합니다." 메시지 포함.

3. **파일 생성 보장:** `waiaas mcp setup` 실행 시 파일이 생성되지 않는 경우는 없다. 그러나 사용자가 파일을 삭제하지 못하도록 방지할 수는 없으므로, 에러 복구 루프가 필수적이다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) -- 에러 복구 섹션

---

### M-04: 다중 MCP 클라이언트 동시 접속 시 단일 토큰 파일 충돌

**Severity:** MEDIUM
**Confidence:** MEDIUM (v0.9 objective "마일스톤 범위 외"에 명시, 향후 확장 대비)

**What goes wrong:**
v0.9 objective에서 명시적으로 범위 외로 선언했다: "다중 MCP 클라이언트 동시 접속 시나리오 (단일 토큰 파일 전제)". 그러나 사용자가 의도치 않게 이 상황에 놓일 수 있다:

- Claude Desktop + Cursor 동시 사용 (둘 다 같은 MCP Server 실행)
- Claude Desktop + 커스텀 MCP 클라이언트 동시 사용
- Docker 컨테이너 내 MCP Server + 호스트의 MCP Server

각 MCP Server 프로세스가 독립적으로:
1. 같은 `~/.waiaas/mcp-token` 파일을 읽음
2. 같은 세션으로 갱신 시도
3. 첫 번째 프로세스가 갱신 성공 -> token_hash 교체
4. 두 번째 프로세스의 갱신 시도 -> 401 AUTH_TOKEN_INVALID (구 토큰)
5. 두 번째 프로세스가 파일 재로드 -> 첫 번째 프로세스가 쓴 새 토큰 로드
6. 그러나 세 번째 갱신에서도 같은 경합 발생

**Warning signs:**
- 두 개 이상의 MCP 클라이언트에서 간헐적 401 에러
- 갱신 로그에 같은 세션에 대한 동시 갱신 시도 기록
- 토큰 파일이 짧은 시간 내에 여러 번 교체됨

**Prevention:**

1. **PID 기반 파일 잠금 (advisory lock):**
```typescript
// 토큰 파일 옆에 .lock 파일 생성
// mcp-token.lock 내용: { pid: 12345, startedAt: "2026-02-09T..." }
// 시작 시 lock 파일 확인 -> 해당 PID가 살아있으면 경고
```

2. **에이전트별 토큰 파일 분리 (향후 확장):**
```
~/.waiaas/mcp-tokens/{agent-id}.token
```
이렇게 하면 다른 에이전트의 MCP Server는 서로 다른 파일을 사용한다.

3. **v0.9에서는 경고 로그만 출력:** 범위 외이므로, 시작 시 다른 프로세스의 존재를 감지하면 경고를 출력하되 동작을 차단하지는 않는다.

**Phase:** SESS-AUTO-01에 "제한 사항" 섹션으로 명시

---

### M-05: SessionManager dispose() 미호출 -- 타이머 누수

**Severity:** MEDIUM
**Confidence:** HIGH (Node.js 프로세스 lifecycle, MCP Server shutdown 패턴)

**What goes wrong:**
SessionManager가 `setTimeout`으로 갱신 타이머를 등록한다. MCP Server 프로세스가 종료될 때 `dispose()`가 호출되지 않으면:

1. **타이머가 프로세스 종료를 차단:** `setTimeout` 콜백이 pending 상태이면 Node.js 이벤트 루프가 종료되지 않는다 (기본 동작). `timer.unref()`를 호출하면 이벤트 루프를 차단하지 않지만, 이 경우 프로세스가 예상보다 빨리 종료될 수 있다.

2. **orphan timer:** Windows에서 MCP Server 프로세스가 제대로 종료되지 않는 이슈(Claude Code#15211)와 결합하면, 좀비 프로세스의 타이머가 주기적으로 갱신 API를 호출한다.

**Warning signs:**
- MCP Server 프로세스 종료 시 행이 걸림 (타이머 대기)
- 데몬 로그에 종료된 것으로 예상되는 세션의 갱신 요청이 계속 수신됨
- `ps aux | grep mcp` 에서 오래된 프로세스 발견

**Prevention:**
```typescript
class SessionManager {
  private timer: NodeJS.Timeout | null = null

  start(): void {
    this.scheduleRenewal()
  }

  private scheduleRenewal(): void {
    this.clearTimer()
    const delay = this.calculateRenewalDelay()
    this.timer = safeSetTimeout(() => this.renew(), delay)
    this.timer.unref()  // 프로세스 종료를 차단하지 않음
  }

  dispose(): void {
    this.clearTimer()
  }

  private clearTimer(): void {
    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }
  }
}

// MCP Server 종료 시 반드시 호출
process.on('SIGTERM', () => {
  sessionManager.dispose()
  process.exit(0)
})

process.on('SIGINT', () => {
  sessionManager.dispose()
  process.exit(0)
})
```

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) -- lifecycle 섹션

---

### M-06: /newsession 후 MCP에 알림 수단 없음 -- MCP stdio는 push 불가

**Severity:** MEDIUM
**Confidence:** HIGH (MCP 프로토콜 스펙, stdio transport 제약)

**What goes wrong:**
MCP stdio transport는 **request-response 모델**이다. 서버가 클라이언트에 unsolicited 메시지를 보낼 수 없다 (MCP Notifications는 서버->클라이언트로 전송 가능하지만, Claude Desktop이 이를 처리하는 방식은 불확실하다).

v0.9 설계에서 Telegram `/newsession`으로 새 토큰이 파일에 저장된 후, MCP Server가 이를 감지하려면:
1. 다음 tool 호출이 401을 반환해야 함 (lazy reload)
2. 또는 fs.watch로 파일 변경을 감지해야 함 (v0.9 설계에서 명시적 배제)

**문제:** tool 호출이 없는 기간에는 MCP Server가 새 토큰의 존재를 모른다. 만약 세션 만료 후 Owner가 즉시 `/newsession`을 실행했지만, 사용자가 5분 뒤에 tool을 호출하면:
1. 5분간 MCP Server는 만료된 토큰을 보유
2. tool 호출 -> 401 -> 파일 재로드 -> 새 토큰 사용 -> 재시도 성공

이 5분간의 "blind period"는 **기능적으로 문제가 없다** (재로드가 투명하게 처리되므로). 그러나 만료 즉시 에러 메시지가 LLM에 노출되면 (H-04의 문제), 이후 LLM이 wallet tool 사용을 꺼려할 수 있다.

**Prevention:**
v0.9 설계의 lazy reload + 401 재시도 조합이 충분하다. 추가로:

1. **만료 예정 시 선제적 파일 확인:** 만료 60초 전에 한 번 파일을 확인하여, 외부 갱신이 이미 있었는지 확인한다.

2. **MCP notification을 통한 상태 알림 (향후):** MCP 프로토콜이 서버->클라이언트 notification을 지원하므로, SessionManager 상태 변경 시 notification을 전송할 수 있다. 그러나 Claude Desktop이 이를 어떻게 처리하는지 확인이 필요하다.

**Phase:** SessionManager 설계 스펙 (SESS-AUTO-01) -- 향후 고려 사항

---

## Phase-Specific Warnings

| Phase/산출물 | Likely Pitfall | Severity | Mitigation |
|------------|--------------|----------|-----------|
| SESS-AUTO-01 (SessionManager) | C-01: setTimeout 오버플로우 | CRITICAL | safeSetTimeout 래퍼 구현 |
| SESS-AUTO-01 (SessionManager) | C-02: 토큰 파일 쓰기 경합 | CRITICAL | atomic write-then-rename |
| SESS-AUTO-01 (SessionManager) | C-03: JWT 무검증 디코딩 | CRITICAL | 시작 시 데몬 API로 유효성 확인 |
| SESS-AUTO-01 (SessionManager) | H-01: 타이머 드리프트 | HIGH | 서버 응답 기준 재스케줄 |
| SESS-AUTO-01 (SessionManager) | H-02: kill 중 inflight 갱신 | HIGH | 파일 먼저 쓰기 + graceful shutdown |
| SESS-AUTO-01 (SessionManager) | H-04: 반복 에러 시 MCP 연결 해제 | HIGH | isError 회피, 안내 메시지 반환 |
| SESS-AUTO-01 (SessionManager) | H-05: 갱신 중 tool 호출 401 | HIGH | 401 자동 재시도 또는 데몬 유예 기간 |
| SESS-AUTO-01 (SessionManager) | M-02: lazy reload 지연 | MEDIUM | 만료 전 선제적 파일 확인 |
| SESS-AUTO-01 (SessionManager) | M-03: 환경변수 토큰 stale | MEDIUM | 에러 복구 루프 |
| SESS-AUTO-01 (SessionManager) | M-05: 타이머 누수 | MEDIUM | timer.unref() + dispose() |
| SESS-AUTO-01 (SessionManager) | M-06: stdio push 불가 | MEDIUM | lazy reload 충분, 선제적 확인 보완 |
| SESS-AUTO-02 (Telegram) | M-01: callback 15초 타임아웃 | MEDIUM | 즉시 answerCallbackQuery + 후속 메시지 |
| SESS-AUTO-03 (CLI) | C-02: 토큰 파일 쓰기 경합 | CRITICAL | atomic write (CLI에서도 동일 패턴) |
| SESS-AUTO-03 (CLI) | H-03: Windows 파일 권한 | HIGH | 플랫폼별 권한 전략 |
| SESS-RENEW(53) 보완 | H-05: 토큰 회전 in-flight 경합 | HIGH | previous_token_hash 유예 기간 |
| CORE-01(24) 보완 | H-03: Windows 토큰 보안 | HIGH | %LOCALAPPDATA% 경로 + 제한 문서화 |

---

## Verification Checklist

| # | 항목 | 상태 | 비고 |
|---|------|------|------|
| 1 | setTimeout 32비트 한계 반영 | 설계 필요 | safeSetTimeout 래퍼 |
| 2 | 토큰 파일 원자적 쓰기 | 설계 필요 | write-then-rename |
| 3 | JWT 무검증 디코딩 방어 | 설계 필요 | 시작 시 데몬 확인 |
| 4 | 타이머 드리프트 보정 | 설계 필요 | 서버 응답 기준 재스케줄 |
| 5 | 프로세스 kill 시 토큰 일관성 | 설계 필요 | 파일 먼저 쓰기 |
| 6 | Windows 파일 권한 제한 | 문서화 필요 | 플랫폼별 전략 |
| 7 | Claude Desktop 반복 에러 대응 | 설계 필요 | isError 회피 전략 |
| 8 | 토큰 회전 in-flight 경합 | 설계 필요 | 401 재시도 또는 유예 기간 |
| 9 | Telegram callback 즉시 응답 | 설계 필요 | answerCallbackQuery 선행 |
| 10 | 에러 복구 루프 | 설계 필요 | 만료 상태에서 주기적 파일 확인 |
| 11 | dispose() / unref() | 설계 필요 | 프로세스 종료 차단 방지 |
| 12 | 다중 MCP 클라이언트 경고 | 문서화 필요 | 제한 사항 명시 |

---

## Sources

### Official Documentation (HIGH confidence)
- [Node.js Timers API](https://nodejs.org/api/timers.html) -- setTimeout delay 스펙, timer 정확성
- [Node.js File System API](https://nodejs.org/api/fs.html) -- writeFileSync, chmod, Windows ACL 제한
- [MDN setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout) -- 32비트 정수 제한
- [Telegram Bot API: answerCallbackQuery](https://core.telegram.org/bots/api#answercallbackquery) -- callback 타임아웃
- [MCP Protocol Specification](https://www.claudemcp.com/specification) -- stdio transport, server lifecycle

### GitHub Issues & Discussions (MEDIUM confidence)
- [nodejs/node#22860](https://github.com/nodejs/node/issues/22860) -- setTimeout max delay
- [nodejs/node#21822](https://github.com/nodejs/node/issues/21822) -- setInterval drift
- [nodejs/node-v0.x-archive#4812](https://github.com/nodejs/node-v0.x-archive/issues/4812) -- Windows chmod limitation
- [npm/write-file-atomic#28](https://github.com/npm/write-file-atomic/issues/28) -- Windows EPERM
- [anthropics/claude-code#15211](https://github.com/anthropics/claude-code/issues/15211) -- Windows MCP process cleanup
- [anthropics/claude-code#15945](https://github.com/anthropics/claude-code/issues/15945) -- MCP server 16h hang
- [anthropics/claude-code#18557](https://github.com/anthropics/claude-code/issues/18557) -- SSE disconnect crash
- [anthropics/claude-code#15904](https://github.com/anthropics/claude-code/issues/15904) -- Auto-reconnect feature request
- [python-telegram-bot#2254](https://github.com/python-telegram-bot/python-telegram-bot/issues/2254) -- callback query timeout

### Security Research (HIGH confidence)
- [Auth0: Critical JWT Vulnerabilities](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
- [OWASP: JWT Testing Guide](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/10-Testing_JSON_Web_Tokens)
- [cross-platform-node-guide: permissions](https://github.com/ehmicky/cross-platform-node-guide/blob/main/docs/5_security/permissions.md)

### Project Internal (HIGH confidence)
- WAIaaS v0.9 objective (objectives/v0.9-session-management-automation.md)
- WAIaaS 53-session-renewal-protocol.md (토큰 회전, 5종 안전 장치)
- WAIaaS 30-session-token-protocol.md (JWT 구조, sessionAuth 2-stage)
- WAIaaS 38-sdk-mcp-interface.md (MCP Server 구성, tool handler)
- WAIaaS v0.7 objectives (JWT dual-key rotation, flock 잠금)
- WAIaaS v0.8 PITFALLS.md (이전 마일스톤 함정 문서)

---

*작성: 2026-02-09*
*기반 분석: v0.9 objective, 53-session-renewal-protocol, 30-session-token-protocol, 38-sdk-mcp-interface, v0.7 implementation blockers*
*전제: Self-Hosted 단일 머신 아키텍처, MCP stdio transport, Claude Desktop 자식 프로세스*
