---
phase: 152-enum-config-test
plan: 01
type: execute
wave: 1
depends_on: ["151-01", "151-02"]
files_modified:
  - scripts/verify-enum-ssot.ts
  - packages/daemon/src/infrastructure/database/checks.ts
  - packages/core/src/__tests__/enums.test.ts
  - packages/daemon/src/__tests__/enum-db-consistency.test.ts
  - packages/daemon/src/__tests__/config-loader.test.ts
  - packages/core/src/utils/format-amount.ts
  - packages/core/src/utils/index.ts
  - packages/core/src/index.ts
  - packages/core/src/__tests__/format-amount.test.ts
  - packages/daemon/src/__tests__/pagination-e2e.test.ts
  - package.json
  - turbo.json
autonomous: true

must_haves:
  truths:
    - "16개 Enum SSoT의 as const -> TS -> Zod -> Drizzle -> DB CHECK 4단계 일관성이 빌드타임 스크립트로 자동 검증된다"
    - "빌드타임 검증 스크립트 실패 시 CI가 중단된다 (exit code 1)"
    - "config.toml 12건 시나리오(CF-01~12)가 모두 테스트로 통과한다"
    - "NOTE-01 formatAmount/parseAmount 8건 테스트가 통과한다"
    - "NOTE-08 shutdown_timeout 4건 테스트가 통과한다"
    - "NOTE-11 커서 페이지네이션 5건 테스트가 통과한다"
    - "NOTE-02 알림 채널-정책 연동 5건 테스트가 통과한다"
  artifacts:
    - path: "scripts/verify-enum-ssot.ts"
      provides: "16개 Enum 4단계 빌드타임 검증 스크립트"
      exports: ["main"]
    - path: "packages/daemon/src/infrastructure/database/checks.ts"
      provides: "generateCheckConstraint 유틸리티"
      exports: ["generateCheckConstraint"]
    - path: "packages/core/src/__tests__/enums.test.ts"
      provides: "16개 Enum 런타임 Unit 테스트 (기존 확장)"
    - path: "packages/daemon/src/__tests__/enum-db-consistency.test.ts"
      provides: "Enum DB CHECK 일관성 Integration 테스트"
    - path: "packages/daemon/src/__tests__/config-loader.test.ts"
      provides: "CF-01~12 config.toml 로딩 테스트 (기존 확장)"
    - path: "packages/core/src/utils/format-amount.ts"
      provides: "NOTE-01 BalanceInfo 단위 변환 유틸리티"
      exports: ["formatAmount", "parseAmount"]
    - path: "packages/core/src/__tests__/format-amount.test.ts"
      provides: "NOTE-01 BalanceInfo 변환 8건 테스트"
    - path: "packages/daemon/src/__tests__/pagination-e2e.test.ts"
      provides: "NOTE-11 커서 페이지네이션 5건 E2E 테스트"
  key_links:
    - from: "scripts/verify-enum-ssot.ts"
      to: "packages/core/src/enums/*.ts"
      via: "dynamic import of SSoT arrays"
      pattern: "import.*TRANSACTION_STATUSES.*from.*@waiaas/core"
    - from: "scripts/verify-enum-ssot.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "sqlite_master CHECK SQL parsing"
      pattern: "sqlite_master.*CHECK"
    - from: "packages/daemon/src/__tests__/enum-db-consistency.test.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle schema import + in-memory SQLite"
      pattern: "buildCheckSql|CHECK"
    - from: "packages/daemon/src/__tests__/config-loader.test.ts"
      to: "packages/daemon/src/infrastructure/config/loader.ts"
      via: "loadConfig + DaemonConfigSchema import"
      pattern: "loadConfig|DaemonConfigSchema"
---

<objective>
16개 Enum SSoT 빌드타임 검증 체계 + config.toml 12건 테스트 + NOTE 매핑 4건(22 테스트 케이스) 구현

Purpose: SSoT 파생 체인(as const -> TS -> Zod -> Drizzle -> DB CHECK) 불일치를 빌드타임에 자동 차단하고, config 로딩과 NOTE 매핑의 테스트 커버리지를 완성한다.
Output: 빌드타임 검증 스크립트 1개, 테스트 파일 5개(신규 3 + 기존 확장 2), 유틸리티 2개
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/151-coverage-mock-infra/151-01-SUMMARY.md

@packages/core/src/enums/index.ts
@packages/core/src/enums/transaction.ts
@packages/core/src/enums/policy.ts
@packages/core/src/enums/wallet.ts
@packages/core/src/enums/notification.ts
@packages/core/src/enums/audit.ts
@packages/core/src/enums/system.ts
@packages/core/src/enums/chain.ts
@packages/core/src/enums/session.ts
@packages/core/src/enums/owner.ts
@packages/core/src/__tests__/enums.test.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/infrastructure/database/connection.ts
@packages/daemon/src/infrastructure/config/loader.ts
@packages/daemon/src/__tests__/config-loader.test.ts
@packages/core/src/utils/format-currency.ts
@docs/v0.4/49-enum-config-consistency-verification.md
@objectives/v1.7-quality-cicd.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enum SSoT 빌드타임 검증 스크립트 + DB 일관성 테스트</name>
  <files>
    scripts/verify-enum-ssot.ts
    packages/daemon/src/infrastructure/database/checks.ts
    packages/core/src/__tests__/enums.test.ts
    packages/daemon/src/__tests__/enum-db-consistency.test.ts
    package.json
    turbo.json
  </files>
  <action>
**1. `packages/daemon/src/infrastructure/database/checks.ts` 생성 (exported generateCheckConstraint)**

`schema.ts`의 `buildCheckSql`은 Drizzle `sql.raw()` 반환이라 테스트용 비교에 부적합. 순수 SQL 문자열을 반환하는 `generateCheckConstraint` 유틸리티를 별도 파일에 작성한다.

```typescript
/**
 * Generate SQLite CHECK constraint SQL from SSoT enum array.
 * Returns plain SQL string for test comparison against sqlite_master.
 */
export function generateCheckConstraint(column: string, values: readonly string[]): string {
  // SQL injection 방지: 값에 작은따옴표가 포함된 경우 에러
  for (const v of values) {
    if (v.includes("'")) {
      throw new Error(`Enum value contains single quote: '${v}'`);
    }
  }
  const quoted = values.map(v => `'${v}'`).join(', ');
  return `CHECK (${column} IN (${quoted}))`;
}
```

**2. `scripts/verify-enum-ssot.ts` 생성 (빌드타임 검증 스크립트)**

tsx(또는 node --import tsx)로 실행되는 스크립트. 4단계 방어 검증:

- **검증 대상 16개 Enum** (현재 코드베이스 실제 값):
  - TransactionStatus(10), TransactionType(7), PolicyType(12), PolicyTier(4)
  - WalletStatus(5), SessionStatus(3), NotificationEventType(25), NotificationLogStatus(2)
  - AuditAction(25), KillSwitchState(3), OwnerState(3)
  - ChainType(2), NetworkType(13), SolanaNetworkType(3), EvmNetworkType(10), EnvironmentType(2)

- **Step 1 (SSoT -> Zod 일치):** 각 Enum의 `as const` 배열과 대응 Zod enum의 `.options`를 비교. 불일치 시 에러.
- **Step 2 (배열 고유값):** `new Set(array).size === array.length` 검증.
- **Step 3 (DB CHECK 일치):** in-memory SQLite에서 schema.ts의 테이블을 생성 후, `sqlite_master`에서 CREATE TABLE SQL을 파싱하여 CHECK 제약 내의 값 목록을 추출. SSoT 배열과 비교.
  - **CHECK 대상 컬럼:** wallets.chain(CHAIN_TYPES), wallets.environment(ENVIRONMENT_TYPES), wallets.status(WALLET_STATUSES), transactions.type(TRANSACTION_TYPES), transactions.status(TRANSACTION_STATUSES), policies.type(POLICY_TYPES), notification_logs.status(NOTIFICATION_LOG_STATUSES)
  - **CHECK 비대상 (skip):** audit_log.event_type (TEXT, CHECK 없음 -- 확장 가능 설계), audit_log.severity (하드코딩 'info','warning','critical'), telegram_users.role (하드코딩), token_registry.source (하드코딩)
  - **Nullable CHECK 대상:** wallets.default_network, transactions.tier, transactions.network, policies.network -- NULL OR IN (...) 형태. NULL 허용 prefix를 파싱 후 값 목록만 비교.
- **Step 4 (값 개수 스냅샷):** 각 Enum의 예상 값 개수를 하드코딩하여 비교. 의도치 않은 값 추가/삭제를 감지.

스크립트 구조:
```typescript
import { ... } from '@waiaas/core';
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { sql } from 'drizzle-orm';
import * as schema from '../packages/daemon/src/infrastructure/database/schema.js';

// Step 1: SSoT <-> Zod 일치
// Step 2: 고유값 검증
// Step 3: DB CHECK 일치 (sqlite_master 파싱)
// Step 4: 값 개수 스냅샷

// 실패 시 process.exit(1), 성공 시 "16 enums verified" 출력
```

**중요:** 스크립트는 `better-sqlite3`로 in-memory DB를 생성하고 `drizzle-kit push`가 아닌 Drizzle의 `migrate` 또는 직접 `schema` 기반으로 테이블을 생성한다. 실제로는 `sql` API로 CREATE TABLE을 실행하는 것이 가장 간단하다. `drizzle-orm`의 `sql`을 사용해 `db.run(sql\`...\`)` 패턴으로 schema에서 테이블 DDL을 생성하면 된다. 대안: `sqlite.exec()`로 마이그레이션 SQL을 직접 실행. 가장 실용적인 접근: `better-sqlite3`로 `:memory:` DB 생성 후 현재 마이그레이션을 적용하거나, `schema.ts`의 테이블 정의를 직접 활용.

실제 구현시 가장 간단한 방법: `packages/daemon/src/infrastructure/database/migrate.ts`의 `runMigrations` 함수를 import하여 in-memory DB에 마이그레이션을 적용하거나, 이미 존재하는 DB 생성 로직을 활용. 마이그레이션 파일이 없다면 `drizzle-orm`의 internal API 대신, `schema.ts`에서 CHECK가 정의된 테이블들의 CREATE TABLE SQL을 하드코딩 없이 `drizzle-kit`으로 생성하는 방법을 사용.

**가장 실용적 접근 (권장):** `better-sqlite3`로 `:memory:` DB를 열고, `packages/daemon/src/infrastructure/database/migrate.ts`의 `runMigrations(db)` 함수를 호출하여 v1~v16 마이그레이션을 모두 적용. 그 후 `sqlite_master`를 조회.

**3. `package.json` 루트에 스크립트 추가:**

```json
"verify:enums": "tsx scripts/verify-enum-ssot.ts"
```

**4. `turbo.json`에 enum-verify 태스크 추가:**

turbo.json에는 이미 `typecheck` 태스크가 있다. `verify:enums` 스크립트는 Turborepo 태스크가 아닌 루트 스크립트로 실행하면 충분하다. CI의 Stage 2(PR)에서 `pnpm verify:enums`를 별도 step으로 호출한다. turbo.json 변경은 불필요할 수 있으나, `"enum-verify": { "dependsOn": ["build"] }` 태스크를 추가하면 CI에서 `turbo run enum-verify`로 실행 가능. 판단: turbo.json에 `enum-verify` 태스크를 추가하되 root 전용(패키지별 실행 아님).

**5. `packages/core/src/__tests__/enums.test.ts` 확장 (기존 파일)**

기존 테스트는 12개 Enum의 값 개수 + Zod options 일치 + 중복 없음을 검증한다. 이를 16개 Enum 전체로 확장하고 다음을 추가:

- SolanaNetworkType(3), EvmNetworkType(10) 값 개수 이미 테스트 존재 확인
- NotificationLogStatus(2) 값 개수 + Zod options 검증 추가 (현재 누락)
- `generateCheckConstraint` 출력 검증 (UT-06): `generateCheckConstraint('status', TRANSACTION_STATUSES)` 결과가 예상 SQL과 일치
- `generateCheckConstraint` SQL injection 방지 (UT-07): 작은따옴표 포함 값에서 에러 발생
- AuditAction const 키-값 일치 검증 (UT-08): `AUDIT_ACTIONS`는 배열이므로 이 검증은 skip (doc 49는 `AUDIT_LOG_EVENT_TYPES` 객체 참조했으나, 현재 코드에서 AuditAction은 배열)
- 전체 Enum import 경로에 `NOTIFICATION_LOG_STATUSES`, `NotificationLogStatusEnum` 추가

**6. `packages/daemon/src/__tests__/enum-db-consistency.test.ts` 신규 생성**

in-memory SQLite + 마이그레이션으로 실제 DB를 생성하고 CHECK 제약을 검증:

- **IT-01:** 각 SSoT 값으로 INSERT 성공 (wallets.status에 WALLET_STATUSES 각 값, transactions.type에 TRANSACTION_TYPES 각 값 등)
- **IT-02:** SSoT 밖의 값으로 INSERT 시 CHECK 제약 위반 에러 (wallets.status='PAUSED' -> SQLITE_CONSTRAINT)
- **IT-03:** `sqlite_master`에서 CHECK SQL 파싱 후 SSoT 배열과 비교 (wallets, transactions, policies, notification_logs 테이블)
- **IT-04:** 마이그레이션 후 7개 SSoT-derived CHECK 제약이 존재하는지 확인
- **IT-05:** audit_log.event_type에 CHECK 없이 임의 값 INSERT 가능 확인
- **IT-06:** 각 테이블별 CHECK 제약 존재 여부 매트릭스 검증

in-memory DB 생성 패턴:
```typescript
import Database from 'better-sqlite3';
import { runMigrations } from '../infrastructure/database/migrate.js';
// 또는 createDatabase + manual migration

const sqlite = new Database(':memory:');
// 마이그레이션 적용 후 테스트
```

**NOTE:** `runMigrations` 함수가 `sqlite` 인스턴스를 받는지 `drizzle` 인스턴스를 받는지 확인 필요. `createDatabase(':memory:')` + `runMigrations()` 패턴 사용 가능. 기존 테스트(database.test.ts, migration-chain.test.ts)의 패턴을 따를 것.
  </action>
  <verify>
1. `pnpm verify:enums` 실행 시 "16 enums verified" 출력 + exit code 0
2. `cd packages/core && pnpm vitest run src/__tests__/enums.test.ts` -- 기존 + 신규 테스트 모두 통과
3. `cd packages/daemon && pnpm vitest run src/__tests__/enum-db-consistency.test.ts` -- IT-01~06 통과
4. `generateCheckConstraint` 유틸 import 가능: `import { generateCheckConstraint } from '../infrastructure/database/checks.js'`
  </verify>
  <done>
- 빌드타임 검증 스크립트(`scripts/verify-enum-ssot.ts`)가 16개 Enum의 4단계 일관성을 자동 검증하고 불일치 시 exit 1로 실패한다
- `generateCheckConstraint` 유틸리티가 export되어 테스트와 스크립트에서 사용 가능하다
- 기존 enums.test.ts가 16개 Enum 전체를 커버하고 generateCheckConstraint 출력 + SQL injection 방지를 검증한다
- enum-db-consistency.test.ts가 실제 SQLite DB에서 CHECK 제약과 SSoT 배열의 일치를 검증한다 (IT-01~06)
  </done>
</task>

<task type="auto">
  <name>Task 2: config.toml CF-01~12 테스트 완성 + NOTE 매핑 4건(22 테스트 케이스)</name>
  <files>
    packages/daemon/src/__tests__/config-loader.test.ts
    packages/core/src/utils/format-amount.ts
    packages/core/src/utils/index.ts
    packages/core/src/index.ts
    packages/core/src/__tests__/format-amount.test.ts
    packages/daemon/src/__tests__/pagination-e2e.test.ts
  </files>
  <action>
**1. `packages/daemon/src/__tests__/config-loader.test.ts` 확장 (CF-01~12 완성)**

기존 테스트는 CF-01(기본값), CF-02(부분 오버라이드), CF-03(환경변수 우선순위)에 해당하는 테스트가 이미 존재한다. 누락된 시나리오를 추가한다.

**기존 테스트와 CF-01~12 매핑 분석:**
- CF-01 (기본값만): 이미 `returns all defaults when config.toml is missing` + `has correct default values` 존재. session_ttl 기본값 확인 보강 필요.
- CF-02 (부분 오버라이드): 이미 `fills other sections with defaults` + `loads valid config.toml` 존재. OK.
- CF-03 (환경변수 우선순위): 이미 `env override takes priority over toml value` 존재. OK.
- CF-04 (Docker hostname): 이미 테스트 없음. `WAIAAS_DAEMON_HOSTNAME=0.0.0.0` 테스트 추가.
- CF-05 (중첩 섹션 환경변수): 이미 `WAIAAS_SECURITY_SESSION_TTL` 테스트 존재. `WAIAAS_SECURITY_POLICY_DEFAULTS_DELAY_SECONDS` 추가 필요. **NOTE:** 현재 config loader에서 `policy_defaults_delay_seconds`는 `security` 섹션의 flat key이므로 `WAIAAS_SECURITY_POLICY_DEFAULTS_DELAY_SECONDS` -> `security.policy_defaults_delay_seconds`로 매핑된다. 확인 후 테스트.
- CF-06 (잘못된 값: port 음수): 이미 `rejects port below 1024` 존재. `port = -1` 추가.
- CF-07 (범위 밖 shutdown_timeout): 이미 `rejects shutdown_timeout below 5` 존재. `shutdown_timeout = 999 (max 300)` 추가.
- CF-08 (빈 문자열 환경변수): 테스트 없음. `WAIAAS_DAEMON_PORT=""` 추가.
- CF-09 (전체 섹션 기본값): 이미 `fills other sections with defaults` 존재. `[database]` 섹션 누락 시 기본값 추가 검증.
- CF-10 (다중 환경변수 동시): 테스트 없음. `WAIAAS_DAEMON_PORT=5000 + WAIAAS_DAEMON_LOG_LEVEL=debug + config.toml port=4000` 추가.
- CF-11 (특수 환경변수 제외): 이미 `special keys are NOT applied` 존재. OK.
- CF-12 (Zod 기본값): 테스트 없음. `[security]` 섹션만 있고 키 없는 config.toml 추가.

**추가할 테스트 (새 describe 블록 `config.toml CF-01~12 verification`):**

```typescript
describe('config.toml CF-01~12 verification (doc 49)', () => {
  // CF-04: Docker hostname 0.0.0.0
  it('CF-04: WAIAAS_DAEMON_HOSTNAME=0.0.0.0 allows Docker binding', () => {
    setEnv('WAIAAS_DAEMON_HOSTNAME', '0.0.0.0');
    const config = loadConfig(dir);
    expect(config.daemon.hostname).toBe('0.0.0.0');
  });

  // CF-05: 중첩 섹션 환경변수 (policy_defaults_delay_seconds)
  it('CF-05: nested env var WAIAAS_SECURITY_POLICY_DEFAULTS_DELAY_SECONDS=600', () => {
    setEnv('WAIAAS_SECURITY_POLICY_DEFAULTS_DELAY_SECONDS', '600');
    const config = loadConfig(dir);
    expect(config.security.policy_defaults_delay_seconds).toBe(600);
  });

  // CF-06: port -1
  it('CF-06: port = -1 rejected (min 1024)', () => {
    writeFileSync(join(dir, 'config.toml'), '[daemon]\nport = -1\n');
    expect(() => loadConfig(dir)).toThrow();
  });

  // CF-07: shutdown_timeout 999
  it('CF-07: shutdown_timeout = 999 rejected (max 300)', () => {
    writeFileSync(join(dir, 'config.toml'), '[daemon]\nshutdown_timeout = 999\n');
    expect(() => loadConfig(dir)).toThrow();
  });

  // CF-08: empty string env var
  it('CF-08: WAIAAS_DAEMON_PORT="" treated as empty string (defaults or parse error)', () => {
    setEnv('WAIAAS_DAEMON_PORT', '');
    // empty string -> parseEnvValue returns '' -> Zod rejects non-number for port
    // OR: empty string is ignored. Check actual behavior.
    // If it throws, expect throw. If defaults, expect 3100.
    const config = loadConfig(dir);
    // parseEnvValue('') returns '' (string), Zod port expects number -> should throw
    // BUT: applyEnvOverrides sets config.daemon.port = '' then DaemonConfigSchema rejects
    expect(() => loadConfig(saveTempDir(createTempDir()))).not.toThrow(); // actually need to test
  });

  // CF-09: [database] 섹션 없으면 기본값
  it('CF-09: missing [database] section uses all defaults', () => {
    writeFileSync(join(dir, 'config.toml'), '[daemon]\nport = 5000\n');
    const config = loadConfig(dir);
    expect(config.database.path).toBe('data/waiaas.db');
    expect(config.database.wal_checkpoint_interval).toBe(300);
    expect(config.database.busy_timeout).toBe(5000);
    expect(config.database.cache_size).toBe(64000);
  });

  // CF-10: 다중 환경변수 동시 적용
  it('CF-10: multiple env vars override simultaneously', () => {
    writeFileSync(join(dir, 'config.toml'), '[daemon]\nport = 4000\n');
    setEnv('WAIAAS_DAEMON_PORT', '5000');
    setEnv('WAIAAS_DAEMON_LOG_LEVEL', 'debug');
    const config = loadConfig(dir);
    expect(config.daemon.port).toBe(5000); // env wins
    expect(config.daemon.log_level).toBe('debug'); // env
  });

  // CF-12: Zod default 적용
  it('CF-12: [security] section present but empty, Zod defaults applied', () => {
    writeFileSync(join(dir, 'config.toml'), '[security]\n');
    const config = loadConfig(dir);
    expect(config.security.session_ttl).toBe(86400);
    expect(config.security.nonce_cache_max).toBe(1000);
    expect(config.security.policy_defaults_delay_seconds).toBe(300);
  });
});
```

**NOTE-08 테스트 (shutdown_timeout) -- config-loader.test.ts에 추가:**

doc 49 NOTE-08 shutdown_timeout 4건을 별도 describe로 추가:

```typescript
describe('NOTE-08: Docker shutdown timeline (shutdown_timeout)', () => {
  // N08-01: 기본값 30
  it('N08-01: shutdown_timeout defaults to 30', () => { ... });
  // N08-02: 최소값 5
  it('N08-02: shutdown_timeout=5 accepted (minimum)', () => { ... });
  // N08-03: 최대값 300
  it('N08-03: shutdown_timeout=300 accepted (maximum)', () => { ... });
  // N08-04: 범위 밖 4 -> ZodError
  it('N08-04: shutdown_timeout=4 rejected (below min 5)', () => { ... });
});
```

N08-01은 CF-01에서 이미 커버되므로 명시적 cross-reference 주석 추가. N08-04는 CF-07과 유사하나 다른 값(4 vs 999).

**2. `packages/core/src/utils/format-amount.ts` 신규 생성 (NOTE-01)**

BalanceInfo 단위 변환 유틸리티. bigint 기반 lamport/wei <-> 사람 읽기용 문자열 변환.

```typescript
/**
 * Format a raw blockchain amount (bigint, smallest unit) to human-readable string.
 *
 * @param amount - Raw amount in smallest unit (lamports for SOL, wei for ETH).
 * @param decimals - Number of decimal places (9 for SOL, 18 for ETH, 6 for USDC).
 * @returns Human-readable amount string with trailing zeros trimmed.
 * @throws Error if amount is negative.
 *
 * @example
 * formatAmount(1_000_000_000n, 9) // "1"
 * formatAmount(1_500_000n, 9)     // "0.0015"
 * formatAmount(0n, 9)             // "0"
 * formatAmount(1n, 9)             // "0.000000001"
 */
export function formatAmount(amount: bigint, decimals: number): string {
  if (amount < 0n) {
    throw new Error('Amount must be non-negative');
  }
  if (amount === 0n) return '0';

  const divisor = 10n ** BigInt(decimals);
  const intPart = amount / divisor;
  const fracPart = amount % divisor;

  if (fracPart === 0n) return intPart.toString();

  const fracStr = fracPart.toString().padStart(decimals, '0').replace(/0+$/, '');
  return `${intPart}.${fracStr}`;
}

/**
 * Parse a human-readable amount string to raw bigint (smallest unit).
 *
 * @param amount - Human-readable amount string (e.g. "1.5").
 * @param decimals - Number of decimal places.
 * @returns Raw amount in smallest unit as bigint.
 *
 * @example
 * parseAmount("1.5", 9) // 1_500_000_000n
 * parseAmount("1", 9)   // 1_000_000_000n
 */
export function parseAmount(amount: string, decimals: number): bigint {
  const parts = amount.split('.');
  const intPart = BigInt(parts[0] || '0');
  const fracStr = (parts[1] || '').padEnd(decimals, '0').slice(0, decimals);
  const fracPart = BigInt(fracStr);
  return intPart * (10n ** BigInt(decimals)) + fracPart;
}
```

**3. `packages/core/src/utils/index.ts` 및 `packages/core/src/index.ts` 업데이트:**

`utils/index.ts`에 `export { formatAmount, parseAmount } from './format-amount.js';` 추가.
`src/index.ts`에서 utils 경로에 이미 barrel이 있으면 그것을 통해 export. 없으면 직접 추가.

**4. `packages/core/src/__tests__/format-amount.test.ts` 신규 (NOTE-01: 8건)**

```
N01-01: SOL 기본 변환 (1_000_000_000n, 9) -> "1"
N01-02: SOL 소수점 (1_500_000n, 9) -> "0.0015"
N01-03: 0 lamport (0n, 9) -> "0"
N01-04: 1 lamport (1n, 9) -> "0.000000001"
N01-05: 역방향 parseAmount("1.5", 9) -> 1_500_000_000n
N01-06: MAX_SAFE_INTEGER 이하 BigInt 정확도
N01-07: MAX_SAFE_INTEGER 이상 BigInt 정밀도 손실 없음
N01-08: 음수 금액 거부 (-1n) -> Error
```

**5. `packages/daemon/src/__tests__/pagination-e2e.test.ts` 신규 (NOTE-11: 5건)**

Hono test client + 실제 SQLite (:memory:)로 커서 페이지네이션 E2E 테스트.

기존 코드의 페이지네이션 패턴 확인: `packages/daemon/src/api/routes/transactions.ts`와 `admin.ts`에서 `nextCursor` 사용. 해당 라우트를 대상으로 테스트.

```
N11-01: 빈 목록 -> items: [], nextCursor: null
N11-02: 1건 (단일 페이지) -> items: [1건], nextCursor: null
N11-03: limit+1건 (다음 페이지) -> items: [limit건], nextCursor: UUID v7
N11-04: cursor로 다음 페이지 -> 남은 items, nextCursor: null
N11-05: 잘못된 cursor 형식 -> 400 Bad Request
```

**NOTE:** 이 테스트는 daemon의 E2E 테스트이므로 Hono app 인스턴스를 생성하고 `app.request()` 또는 Hono test client 패턴을 사용한다. 기존 E2E 테스트(session-lifecycle-e2e.test.ts, evm-lifecycle-e2e.test.ts)의 패턴을 따를 것. masterAuth 인증 + in-memory DB + 마이그레이션 설정이 필요하다.

테스트 대상 엔드포인트: `GET /v1/wallets/{walletId}/transactions?limit=N&cursor=X` 또는 가장 간단한 `GET /v1/wallets?limit=N&cursor=X`.

**6. NOTE-02 알림 채널-정책 연동 (5건) -- config-loader.test.ts가 아닌 별도 파일이 적절하나, Phase 152 scope를 고려하면 단순화 가능.**

NOTE-02의 5건은 PolicyEngine + NotificationChannel 연동 Integration 테스트이다. 이는 Phase 155(보안 테스트 Part 1) SEC-02에서 커버될 예정이다. 그러나 Phase 152 요구사항 ENUM-03은 "테스트 필요 4건(22 테스트 케이스) 구현"을 명시하므로 NOTE-02도 여기서 구현해야 한다.

**NOTE-02 테스트 위치:** `packages/daemon/src/__tests__/notification-policy-integration.test.ts` 대신, pagination-e2e.test.ts 파일에 NOTE-02를 함께 넣으면 파일이 비대해지므로, 간단히 `packages/daemon/src/__tests__/note-02-notification-policy.test.ts`로 생성하거나, 기존 `notification-service.test.ts` 또는 `database-policy-engine.test.ts`에 describe 블록을 추가한다.

**가장 실용적:** `packages/daemon/src/__tests__/database-policy-engine.test.ts`에 `describe('NOTE-02: notification channel-policy integration')` 블록을 추가. 기존 PolicyEngine 테스트 설정(in-memory DB, mock channels)을 재활용할 수 있다. 만약 기존 파일이 너무 크거나 구조가 복잡하면 별도 파일 생성.

NOTE-02 5건:
```
N02-01: 활성 채널 0개 시 INSTANT만 허용
N02-02: 활성 채널 1개 시 DELAY 정상 동작
N02-03: 활성 채널 2개 이상 시 정상
N02-04: 채널 0개에서 APPROVAL 시도 -> INSTANT 강등 또는 거부
N02-05: 런타임 채널 비활성화 시 정책 재평가
```

**NOTE:** NOTE-02는 PolicyEngine의 채널 개수 기반 정책 조정 로직이 실제로 구현되어 있는지 먼저 확인 필요. 만약 구현되어 있지 않다면 테스트는 "현재 동작을 검증"하는 형태로 작성하되, TODO 주석으로 향후 구현 필요성을 기록. 기존 `default-policy-engine.ts`의 채널 연동 로직 확인 후 테스트 작성.
  </action>
  <verify>
1. `cd packages/daemon && pnpm vitest run src/__tests__/config-loader.test.ts` -- CF-01~12 + NOTE-08 모두 통과
2. `cd packages/core && pnpm vitest run src/__tests__/format-amount.test.ts` -- NOTE-01 8건 통과
3. `cd packages/daemon && pnpm vitest run src/__tests__/pagination-e2e.test.ts` -- NOTE-11 5건 통과
4. NOTE-02 관련 테스트 5건 통과 (위치: database-policy-engine.test.ts 또는 별도 파일)
5. `pnpm test:unit` -- 전체 테스트 suite 기존 + 신규 모두 통과 (pre-existing failures 제외)
  </verify>
  <done>
- config.toml 12건 시나리오(CF-01~12) 테스트가 모두 통과한다 (기존 + 신규 합산)
- NOTE-01 formatAmount/parseAmount 8건 테스트가 통과하고 유틸리티가 @waiaas/core에서 export된다
- NOTE-08 shutdown_timeout 4건이 config-loader 테스트에 포함되어 통과한다
- NOTE-11 커서 페이지네이션 5건 E2E 테스트가 통과한다
- NOTE-02 알림 채널-정책 연동 5건 테스트가 통과한다
- 총 22건 NOTE 테스트 + 12건 CF 테스트가 모두 green이다
  </done>
</task>

</tasks>

<verification>
1. `pnpm verify:enums` -- 16개 Enum SSoT 빌드타임 검증 성공 (exit 0)
2. `cd packages/core && pnpm vitest run src/__tests__/enums.test.ts` -- 전체 통과
3. `cd packages/core && pnpm vitest run src/__tests__/format-amount.test.ts` -- 8건 통과
4. `cd packages/daemon && pnpm vitest run src/__tests__/enum-db-consistency.test.ts` -- 6건 통과
5. `cd packages/daemon && pnpm vitest run src/__tests__/config-loader.test.ts` -- CF-01~12 + NOTE-08 통과
6. `cd packages/daemon && pnpm vitest run src/__tests__/pagination-e2e.test.ts` -- 5건 통과
7. NOTE-02 테스트 5건 통과
8. `pnpm test:unit` -- 전체 테스트 regression 없음
</verification>

<success_criteria>
1. 빌드타임 검증 스크립트가 16개 Enum의 as const -> TS -> Zod -> Drizzle -> DB CHECK 4단계 일관성을 자동 검증하고, 불일치 시 빌드가 실패한다
2. config.toml 로딩 테스트 12건(CF-01~12: 기본값, TOML 오버라이드, 환경변수, 잘못된 값 등)이 통과한다
3. NOTE-01~11 매핑 중 테스트 필요 4건(22 테스트 케이스)이 모두 통과한다
</success_criteria>

<output>
After completion, create `.planning/phases/152-enum-config-test/152-01-SUMMARY.md`
</output>
