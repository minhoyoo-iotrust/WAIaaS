---
phase: 133-sdk-mcp-skill-files
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/sdk/src/types.ts
  - packages/sdk/src/client.ts
  - packages/sdk/src/index.ts
  - packages/sdk/src/__tests__/client.test.ts
  - python-sdk/waiaas/models.py
  - python-sdk/waiaas/client.py
  - python-sdk/waiaas/__init__.py
  - python-sdk/tests/test_client.py
autonomous: true

must_haves:
  truths:
    - "TS SDK client.x402Fetch({url}) 호출 시 POST /v1/x402/fetch 요청이 전송된다"
    - "TS SDK 응답에서 payment 필드가 Optional로 처리되어 비-402 passthrough에서도 에러 없이 동작한다"
    - "Python SDK client.x402_fetch(url) 호출 시 POST /v1/x402/fetch 요청이 전송된다"
    - "Python SDK의 camelCase JSON 필드(payTo, txId)가 snake_case Python 필드로 올바르게 매핑된다"
    - "두 SDK 모두 옵셔널 파라미터(method, headers, body) 미전달 시 요청 본문에서 해당 필드가 제외된다"
  artifacts:
    - path: "packages/sdk/src/types.ts"
      provides: "X402FetchParams, X402PaymentInfo, X402FetchResponse 타입"
      contains: "X402FetchParams"
    - path: "packages/sdk/src/client.ts"
      provides: "x402Fetch() 메서드"
      contains: "x402Fetch"
    - path: "packages/sdk/src/index.ts"
      provides: "x402 타입 export"
      contains: "X402FetchParams"
    - path: "python-sdk/waiaas/models.py"
      provides: "X402FetchRequest, X402PaymentInfo, X402FetchResponse Pydantic 모델"
      contains: "X402FetchRequest"
    - path: "python-sdk/waiaas/client.py"
      provides: "x402_fetch() 메서드"
      contains: "x402_fetch"
    - path: "python-sdk/waiaas/__init__.py"
      provides: "x402 모델 export"
      contains: "X402FetchResponse"
  key_links:
    - from: "packages/sdk/src/client.ts"
      to: "/v1/x402/fetch"
      via: "this.http.post"
      pattern: "post.*x402/fetch"
    - from: "python-sdk/waiaas/client.py"
      to: "/v1/x402/fetch"
      via: "self._request"
      pattern: "_request.*POST.*x402/fetch"
---

<objective>
TS SDK와 Python SDK에 x402Fetch/x402_fetch 메서드를 추가하여 AI 에이전트가 POST /v1/x402/fetch REST API를 SDK를 통해 호출할 수 있는 상태를 만든다.

Purpose: AI 에이전트가 유료 API를 자율적으로 호출하기 위해 SDK 래퍼가 필요하다.
Output: TS SDK x402Fetch() + Python SDK x402_fetch() + 양쪽 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/133-sdk-mcp-skill-files/133-RESEARCH.md
@packages/sdk/src/types.ts
@packages/sdk/src/client.ts
@packages/sdk/src/index.ts
@packages/sdk/src/__tests__/client.test.ts
@python-sdk/waiaas/models.py
@python-sdk/waiaas/client.py
@python-sdk/waiaas/__init__.py
@python-sdk/tests/test_client.py
@python-sdk/tests/conftest.py
@packages/daemon/src/api/routes/x402.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TS SDK x402Fetch 타입 + 메서드 + 테스트</name>
  <files>
    packages/sdk/src/types.ts
    packages/sdk/src/client.ts
    packages/sdk/src/index.ts
    packages/sdk/src/__tests__/client.test.ts
  </files>
  <action>
**1. types.ts 끝에 x402 타입 추가:**

```typescript
// ---------------------------------------------------------------------------
// x402 Types
// ---------------------------------------------------------------------------

export interface X402FetchParams {
  /** Target URL to fetch (HTTPS required) */
  url: string;
  /** HTTP method (default: GET) */
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  /** Additional HTTP headers */
  headers?: Record<string, string>;
  /** Request body string */
  body?: string;
}

export interface X402PaymentInfo {
  /** Payment amount in smallest unit */
  amount: string;
  /** Asset identifier (e.g., 'USDC') */
  asset: string;
  /** CAIP-2 network identifier (e.g., 'eip155:8453') */
  network: string;
  /** Payment recipient address */
  payTo: string;
  /** WAIaaS transaction record ID */
  txId: string;
}

export interface X402FetchResponse {
  /** HTTP status code from the external server */
  status: number;
  /** Response headers from the external server */
  headers: Record<string, string>;
  /** Response body string from the external server */
  body: string;
  /** Payment details (present only when x402 payment was made) */
  payment?: X402PaymentInfo;
}
```

**2. client.ts에 x402Fetch 메서드 추가:**

import 목록에 `X402FetchParams`, `X402FetchResponse` 추가.
클래스 본문 끝 (`setDefaultNetwork` 이후, `extractSessionId` 이전)에 메서드 추가:

```typescript
// --- x402 ---
async x402Fetch(params: X402FetchParams): Promise<X402FetchResponse> {
  return withRetry(
    () => this.http.post<X402FetchResponse>(
      '/v1/x402/fetch',
      params,
      this.authHeaders(),
    ),
    this.retryOptions,
  );
}
```

패턴: `signTransaction` 메서드와 동일. `withRetry` 래핑 + `authHeaders()` + `http.post<T>()` 제네릭.
클래스 주석 맨 위의 메서드 카운트와 목록도 갱신한다 (13 -> 14 methods, 목록에 `x402Fetch()` 추가).

**3. index.ts에 x402 타입 export 추가:**

`export type { ... } from './types.js'` 블록 맨 끝에 추가:
```typescript
  X402FetchParams,
  X402PaymentInfo,
  X402FetchResponse,
```

**4. client.test.ts에 x402Fetch 테스트 추가:**

`setDefaultNetwork` describe 블록 이후에 추가. 기존 `signTransaction` 테스트 패턴을 정확히 따른다:

```typescript
// =========================================================================
// x402Fetch
// =========================================================================

describe('x402Fetch', () => {
  it('should call POST /v1/x402/fetch with correct body and return X402FetchResponse', async () => {
    const client = new WAIaaSClient({
      baseUrl: 'http://localhost:3000',
      sessionToken: mockToken,
    });

    const expected = {
      status: 200,
      headers: { 'content-type': 'application/json' },
      body: '{"data": "premium content"}',
      payment: {
        amount: '1000000',
        asset: 'USDC',
        network: 'eip155:8453',
        payTo: '0xPaymentReceiver',
        txId: 'tx-x402-001',
      },
    };

    fetchSpy.mockResolvedValue(mockResponse(expected));

    const result = await client.x402Fetch({ url: 'https://api.example.com/premium' });
    expect(result).toEqual(expected);

    const calledUrl = fetchSpy.mock.calls[0]![0] as string;
    expect(calledUrl).toBe('http://localhost:3000/v1/x402/fetch');

    const opts = fetchSpy.mock.calls[0]![1] as RequestInit;
    expect(opts.method).toBe('POST');
    expect(JSON.parse(opts.body as string)).toEqual({ url: 'https://api.example.com/premium' });

    const headers = opts.headers as Record<string, string>;
    expect(headers['Authorization']).toBe(`Bearer ${mockToken}`);
  });

  it('should handle passthrough response without payment field', async () => {
    const client = new WAIaaSClient({
      baseUrl: 'http://localhost:3000',
      sessionToken: mockToken,
    });

    const expected = {
      status: 200,
      headers: { 'content-type': 'text/html' },
      body: '<html>Free content</html>',
    };

    fetchSpy.mockResolvedValue(mockResponse(expected));

    const result = await client.x402Fetch({ url: 'https://free.example.com' });
    expect(result.status).toBe(200);
    expect(result.payment).toBeUndefined();
  });

  it('should include optional params (method, headers, body) when provided', async () => {
    const client = new WAIaaSClient({
      baseUrl: 'http://localhost:3000',
      sessionToken: mockToken,
    });

    fetchSpy.mockResolvedValue(mockResponse({ status: 200, headers: {}, body: '' }));

    await client.x402Fetch({
      url: 'https://api.example.com/data',
      method: 'POST',
      headers: { 'X-Custom': 'value' },
      body: '{"query": "test"}',
    });

    const opts = fetchSpy.mock.calls[0]![1] as RequestInit;
    const sentBody = JSON.parse(opts.body as string) as Record<string, unknown>;
    expect(sentBody['url']).toBe('https://api.example.com/data');
    expect(sentBody['method']).toBe('POST');
    expect(sentBody['headers']).toEqual({ 'X-Custom': 'value' });
    expect(sentBody['body']).toBe('{"query": "test"}');
  });

  it('should throw WAIaaSError on 403 (domain not allowed)', async () => {
    const client = new WAIaaSClient({
      baseUrl: 'http://localhost:3000',
      sessionToken: mockToken,
      retryOptions: { maxRetries: 0 },
    });

    fetchSpy.mockResolvedValue(
      mockErrorResponse('X402_DOMAIN_NOT_ALLOWED', 'Domain not allowed', 403),
    );

    const err = await client.x402Fetch({ url: 'https://blocked.com' }).catch((e: unknown) => e) as WAIaaSError;
    expect(err).toBeInstanceOf(WAIaaSError);
    expect(err.code).toBe('X402_DOMAIN_NOT_ALLOWED');
    expect(err.status).toBe(403);
  });
});
```

**커밋:** `feat(133-01): TS SDK x402Fetch 타입 + 메서드 + 4개 테스트`
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/sdk/src/__tests__/client.test.ts` -- 모든 테스트 통과, x402Fetch 4개 테스트 포함.
  </verify>
  <done>
TS SDK에서 `client.x402Fetch({url: 'https://...'})` 호출 시 POST /v1/x402/fetch가 올바른 body와 Authorization 헤더로 요청되고, 응답이 X402FetchResponse로 반환된다. payment 필드 Optional 처리로 비-402 passthrough도 에러 없이 동작한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Python SDK x402_fetch 모델 + 메서드 + 테스트</name>
  <files>
    python-sdk/waiaas/models.py
    python-sdk/waiaas/client.py
    python-sdk/waiaas/__init__.py
    python-sdk/tests/test_client.py
  </files>
  <action>
**1. models.py 끝에 x402 모델 추가:**

```python
# ---------------------------------------------------------------------------
# x402 models
# ---------------------------------------------------------------------------


class X402FetchRequest(BaseModel):
    """Request body for POST /v1/x402/fetch."""

    url: str
    method: Optional[str] = None
    headers: Optional[dict[str, str]] = None
    body: Optional[str] = None

    model_config = {"populate_by_name": True}


class X402PaymentInfo(BaseModel):
    """Payment details from an x402 auto-payment."""

    amount: str
    asset: str
    network: str
    pay_to: str = Field(alias="payTo")
    tx_id: str = Field(alias="txId")

    model_config = {"populate_by_name": True}


class X402FetchResponse(BaseModel):
    """Response from POST /v1/x402/fetch."""

    status: int
    headers: dict[str, str]
    body: str
    payment: Optional[X402PaymentInfo] = None

    model_config = {"populate_by_name": True}
```

핵심: `pay_to = Field(alias="payTo")`, `tx_id = Field(alias="txId")` -- camelCase JSON 필드를 snake_case로 매핑.
`model_config = {"populate_by_name": True}` -- by_alias=True일 때도 snake_case 접근 가능.

**2. client.py에 x402_fetch 메서드 추가:**

import 목록에 `X402FetchRequest`, `X402FetchResponse` 추가 (from waiaas.models import ...).
클래스 맨 끝 (`sign_transaction` 이후)에 메서드 추가:

```python
# -----------------------------------------------------------------
# x402 API
# -----------------------------------------------------------------

async def x402_fetch(
    self,
    url: str,
    *,
    method: Optional[str] = None,
    headers: Optional[dict[str, str]] = None,
    body: Optional[str] = None,
) -> X402FetchResponse:
    """POST /v1/x402/fetch -- Fetch URL with x402 auto-payment.

    If the target server responds with HTTP 402, the daemon automatically
    signs a cryptocurrency payment and retries. Policy evaluation
    (X402_ALLOWED_DOMAINS, SPENDING_LIMIT) is applied before payment.

    Args:
        url: Target URL to fetch (HTTPS required).
        method: HTTP method (GET, POST, PUT, DELETE, PATCH). Defaults to GET.
        headers: Additional HTTP headers to include.
        body: Request body string.

    Returns:
        X402FetchResponse with status, headers, body, and optional payment info.
    """
    request = X402FetchRequest(url=url, method=method, headers=headers, body=body)
    body_dict = request.model_dump(exclude_none=True, by_alias=True)
    resp = await self._request("POST", "/v1/x402/fetch", json_body=body_dict)
    return X402FetchResponse.model_validate(resp.json())
```

패턴: `sign_transaction` 메서드와 동일. `X402FetchRequest` Pydantic 모델로 직렬화, `model_dump(exclude_none=True, by_alias=True)` 로 None 필드 제외 + camelCase 출력, `_request()` 내부에서 retry + 에러 처리 자동 적용.

**3. __init__.py에 x402 모델 export 추가:**

import 블록에 추가:
```python
from waiaas.models import (
    ...기존 imports...,
    X402FetchRequest,
    X402FetchResponse,
    X402PaymentInfo,
)
```

`__all__` 리스트에 추가:
```python
    "X402FetchRequest",
    "X402FetchResponse",
    "X402PaymentInfo",
```

**4. test_client.py 끝에 x402_fetch 테스트 추가:**

import에 `X402FetchResponse` 추가 (from waiaas.models import ...).
기존 conftest.py의 `make_handler`, `make_client` 헬퍼를 사용:

```python
# ---------------------------------------------------------------------------
# x402 methods
# ---------------------------------------------------------------------------


class TestX402Fetch:
    async def test_fetch_with_payment(self):
        handler = make_handler(
            {
                ("POST", "/v1/x402/fetch"): (
                    200,
                    {
                        "status": 200,
                        "headers": {"content-type": "application/json"},
                        "body": '{"data": "premium content"}',
                        "payment": {
                            "amount": "1000000",
                            "asset": "USDC",
                            "network": "eip155:8453",
                            "payTo": "0xPaymentReceiver",
                            "txId": "tx-x402-001",
                        },
                    },
                ),
            }
        )
        client = make_client(handler)
        result = await client.x402_fetch("https://api.example.com/premium")
        assert isinstance(result, X402FetchResponse)
        assert result.status == 200
        assert result.body == '{"data": "premium content"}'
        assert result.payment is not None
        assert result.payment.amount == "1000000"
        assert result.payment.asset == "USDC"
        assert result.payment.network == "eip155:8453"
        assert result.payment.pay_to == "0xPaymentReceiver"
        assert result.payment.tx_id == "tx-x402-001"

    async def test_fetch_passthrough_without_payment(self):
        handler = make_handler(
            {
                ("POST", "/v1/x402/fetch"): (
                    200,
                    {
                        "status": 200,
                        "headers": {"content-type": "text/html"},
                        "body": "<html>Free content</html>",
                    },
                ),
            }
        )
        client = make_client(handler)
        result = await client.x402_fetch("https://free.example.com")
        assert isinstance(result, X402FetchResponse)
        assert result.status == 200
        assert result.payment is None

    async def test_fetch_with_optional_params(self):
        captured_body = {}

        def handler(request: httpx.Request) -> httpx.Response:
            if request.method == "POST" and "/v1/x402/fetch" in str(request.url):
                captured_body.update(json.loads(request.content))
                return httpx.Response(
                    200,
                    json={
                        "status": 200,
                        "headers": {},
                        "body": "",
                    },
                )
            return httpx.Response(
                404, json={"code": "NOT_FOUND", "message": "Not found"}
            )

        client = make_client(handler)
        await client.x402_fetch(
            "https://api.example.com/data",
            method="POST",
            headers={"X-Custom": "value"},
            body='{"query": "test"}',
        )
        assert captured_body["url"] == "https://api.example.com/data"
        assert captured_body["method"] == "POST"
        assert captured_body["headers"] == {"X-Custom": "value"}
        assert captured_body["body"] == '{"query": "test"}'

    async def test_fetch_excludes_none_optional_params(self):
        captured_body = {}

        def handler(request: httpx.Request) -> httpx.Response:
            if request.method == "POST" and "/v1/x402/fetch" in str(request.url):
                captured_body.update(json.loads(request.content))
                return httpx.Response(
                    200,
                    json={
                        "status": 200,
                        "headers": {},
                        "body": "",
                    },
                )
            return httpx.Response(
                404, json={"code": "NOT_FOUND", "message": "Not found"}
            )

        client = make_client(handler)
        await client.x402_fetch("https://api.example.com/data")
        assert captured_body == {"url": "https://api.example.com/data"}
        assert "method" not in captured_body
        assert "headers" not in captured_body
        assert "body" not in captured_body

    async def test_fetch_error_domain_not_allowed(self):
        handler = make_handler(
            {
                ("POST", "/v1/x402/fetch"): (
                    403,
                    {
                        "code": "X402_DOMAIN_NOT_ALLOWED",
                        "message": "Domain not allowed",
                    },
                ),
            }
        )
        client = make_client(handler)
        with pytest.raises(WAIaaSError) as exc_info:
            await client.x402_fetch("https://blocked.com")
        assert exc_info.value.code == "X402_DOMAIN_NOT_ALLOWED"
```

test_client.py에 `import json` 과 `import httpx` 가 이미 있는지 확인. 없으면 추가.
`from waiaas.models import` 블록에 `X402FetchResponse` 추가.

**커밋:** `feat(133-01): Python SDK x402_fetch 모델 + 메서드 + 5개 테스트`
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS/python-sdk && python -m pytest tests/test_client.py -v` -- 모든 테스트 통과, TestX402Fetch 5개 테스트 포함.
  </verify>
  <done>
Python SDK에서 `await client.x402_fetch("https://...")` 호출 시 POST /v1/x402/fetch가 올바른 body로 요청되고, 응답이 X402FetchResponse Pydantic 모델로 반환된다. camelCase(payTo, txId) -> snake_case(pay_to, tx_id) 매핑이 정확하다. Optional 파라미터 미전달 시 exclude_none으로 제외된다.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/sdk/src/__tests__/client.test.ts` -- TS SDK 전체 테스트 통과
2. `cd python-sdk && python -m pytest tests/test_client.py -v` -- Python SDK 전체 테스트 통과
3. `npx tsc --noEmit -p packages/sdk/tsconfig.json` -- TS SDK 타입 에러 없음
</verification>

<success_criteria>
- TS SDK: X402FetchParams/X402PaymentInfo/X402FetchResponse 타입이 정의되고 export된다
- TS SDK: client.x402Fetch({url}) 호출 시 POST /v1/x402/fetch에 올바른 body가 전송된다
- Python SDK: X402FetchRequest/X402PaymentInfo/X402FetchResponse Pydantic 모델이 정의되고 export된다
- Python SDK: client.x402_fetch(url) 호출 시 POST /v1/x402/fetch에 올바른 body가 전송된다
- 양쪽 모두 payment 필드가 Optional로 처리되어 비-402 passthrough에서 에러 없이 동작한다
- 양쪽 모두 옵셔널 파라미터 미전달 시 요청 본문에서 해당 필드가 제외된다
</success_criteria>

<output>
After completion, create `.planning/phases/133-sdk-mcp-skill-files/133-01-SUMMARY.md`
</output>
