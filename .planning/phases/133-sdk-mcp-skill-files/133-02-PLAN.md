---
phase: 133-sdk-mcp-skill-files
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp/src/tools/x402-fetch.ts
  - packages/mcp/src/server.ts
  - packages/mcp/src/__tests__/tools.test.ts
  - skills/x402.skill.md
  - skills/transactions.skill.md
  - packages/daemon/src/api/routes/skills.ts
  - packages/mcp/src/resources/skills.ts
autonomous: true

must_haves:
  truths:
    - "MCP x402_fetch 도구가 등록되어 AI 에이전트가 URL을 전달하면 POST /v1/x402/fetch가 호출된다"
    - "x402.skill.md 파일이 존재하고 GET /v1/skills/x402 엔드포인트에서 200으로 반환된다"
    - "waiaas://skills/x402 MCP 리소스가 목록에 노출된다"
    - "transactions.skill.md에 X402_PAYMENT 트랜잭션 타입과 x402 에러 코드가 반영된다"
    - "MCP x402_fetch 도구의 옵셔널 파라미터(method, headers, body) 미전달 시 요청 본문에서 제외된다"
  artifacts:
    - path: "packages/mcp/src/tools/x402-fetch.ts"
      provides: "registerX402Fetch 함수"
      contains: "registerX402Fetch"
    - path: "packages/mcp/src/server.ts"
      provides: "x402_fetch 도구 등록"
      contains: "registerX402Fetch"
    - path: "skills/x402.skill.md"
      provides: "x402 스킬 파일"
      contains: "x402"
    - path: "packages/daemon/src/api/routes/skills.ts"
      provides: "VALID_SKILLS에 'x402' 추가"
      contains: "'x402'"
    - path: "packages/mcp/src/resources/skills.ts"
      provides: "SKILL_NAMES에 'x402' 추가"
      contains: "'x402'"
  key_links:
    - from: "packages/mcp/src/tools/x402-fetch.ts"
      to: "/v1/x402/fetch"
      via: "apiClient.post"
      pattern: "apiClient\\.post.*x402/fetch"
    - from: "packages/mcp/src/server.ts"
      to: "packages/mcp/src/tools/x402-fetch.ts"
      via: "import + registerX402Fetch call"
      pattern: "registerX402Fetch"
    - from: "packages/daemon/src/api/routes/skills.ts"
      to: "skills/x402.skill.md"
      via: "VALID_SKILLS array"
      pattern: "x402"
    - from: "packages/mcp/src/resources/skills.ts"
      to: "skills/x402.skill.md"
      via: "SKILL_NAMES array"
      pattern: "x402"
---

<objective>
MCP x402_fetch 도구를 추가하고, x402.skill.md 스킬 파일을 생성하여 AI 에이전트가 MCP를 통해 유료 API를 자율적으로 호출하고, 스킬 리소스로 사용법을 학습할 수 있는 상태를 만든다.

Purpose: AI 에이전트의 MCP 도구 + 스킬 파일 통합으로 x402 유료 API 자율 호출 DX를 완성한다.
Output: MCP x402_fetch 도구 + x402.skill.md + transactions.skill.md 갱신 + VALID_SKILLS/SKILL_NAMES 등록
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/133-sdk-mcp-skill-files/133-RESEARCH.md
@packages/mcp/src/tools/sign-transaction.ts
@packages/mcp/src/server.ts
@packages/mcp/src/__tests__/tools.test.ts
@packages/mcp/src/resources/skills.ts
@packages/daemon/src/api/routes/skills.ts
@skills/transactions.skill.md
@skills/actions.skill.md
@packages/daemon/src/api/routes/x402.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP x402_fetch 도구 + server.ts 등록 + 테스트</name>
  <files>
    packages/mcp/src/tools/x402-fetch.ts
    packages/mcp/src/server.ts
    packages/mcp/src/__tests__/tools.test.ts
  </files>
  <action>
**1. packages/mcp/src/tools/x402-fetch.ts 신규 생성:**

`sign-transaction.ts` 패턴을 정확히 따른다:

```typescript
/**
 * x402_fetch tool: Fetch a URL with automatic x402 payment.
 *
 * Wraps POST /v1/x402/fetch. If the target server responds with HTTP 402,
 * the daemon automatically signs a cryptocurrency payment and retries.
 * Returns the response along with payment details if payment was made.
 */

import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { type ApiClient, toToolResult } from '../api-client.js';
import { type WalletContext, withWalletPrefix } from '../server.js';

export function registerX402Fetch(
  server: McpServer,
  apiClient: ApiClient,
  walletContext?: WalletContext,
): void {
  server.tool(
    'x402_fetch',
    withWalletPrefix(
      'Fetch a URL with automatic x402 payment. If the server responds with HTTP 402, automatically sign a cryptocurrency payment and retry. Returns the response along with payment details if payment was made.',
      walletContext?.walletName,
    ),
    {
      url: z.string().url().describe('Target URL to fetch (HTTPS required)'),
      method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).optional()
        .describe('HTTP method (default: GET)'),
      headers: z.record(z.string()).optional()
        .describe('Additional HTTP headers'),
      body: z.string().optional()
        .describe('Request body string'),
    },
    async (args) => {
      const requestBody: Record<string, unknown> = { url: args.url };
      if (args.method) requestBody['method'] = args.method;
      if (args.headers) requestBody['headers'] = args.headers;
      if (args.body) requestBody['body'] = args.body;
      const result = await apiClient.post('/v1/x402/fetch', requestBody);
      return toToolResult(result);
    },
  );
}
```

핵심 규칙:
- `server.tool(name, description, schema, handler)` 4-arg 패턴
- `withWalletPrefix()` 로 멀티월렛 지원
- `toToolResult()` 로 ApiResult -> CallToolResult 변환 (isError/expired/networkError 분기 자동 처리)
- 옵셔널 필드는 `if (args.xxx)` 패턴으로 조건부 추가 -- 미전달 시 requestBody에 포함되지 않음
- 도구 이름은 snake_case: `x402_fetch`

**2. packages/mcp/src/server.ts 수정:**

import 블록에 추가 (`registerSignTransaction` import 이후):
```typescript
import { registerX402Fetch } from './tools/x402-fetch.js';
```

`createMcpServer` 함수 내부에서, `registerSetDefaultNetwork(server, apiClient, walletContext);` 호출 이후에 추가:
```typescript
registerX402Fetch(server, apiClient, walletContext);
```

주석의 도구 개수도 갱신: `14 tools` -> `15 tools`.
함수 내부의 `// Register 14 tools` 주석도 `// Register 15 tools` 로 갱신.

**3. packages/mcp/src/__tests__/tools.test.ts 수정:**

import 블록에 추가:
```typescript
import { registerX402Fetch } from '../tools/x402-fetch.js';
```

`set_default_network tool` describe 블록 이후, `tool registration with McpServer` describe 블록 이전에 테스트 추가:

```typescript
describe('x402_fetch tool', () => {
  it('calls POST /v1/x402/fetch with url only', async () => {
    const responses = new Map<string, ApiResult<unknown>>([
      ['POST:/v1/x402/fetch', {
        ok: true,
        data: {
          status: 200,
          headers: { 'content-type': 'application/json' },
          body: '{"data": "premium"}',
          payment: {
            amount: '1000000',
            asset: 'USDC',
            network: 'eip155:8453',
            payTo: '0xReceiver',
            txId: 'tx-001',
          },
        },
      }],
    ]);
    const apiClient = createMockApiClient(responses);
    const handler = getToolHandler(registerX402Fetch, apiClient);

    const result = await handler({ url: 'https://api.example.com/premium' }) as { content: Array<{ text: string }> };

    expect(apiClient.post).toHaveBeenCalledWith('/v1/x402/fetch', {
      url: 'https://api.example.com/premium',
    });
    const parsed = JSON.parse(result.content[0]!.text) as Record<string, unknown>;
    expect(parsed['status']).toBe(200);
    expect(parsed['payment']).toBeDefined();
  });

  it('includes optional params when provided', async () => {
    const apiClient = createMockApiClient(new Map());
    const handler = getToolHandler(registerX402Fetch, apiClient);

    await handler({
      url: 'https://api.example.com/data',
      method: 'POST',
      headers: { 'Accept': 'application/json' },
      body: '{"query": "test"}',
    });

    expect(apiClient.post).toHaveBeenCalledWith('/v1/x402/fetch', {
      url: 'https://api.example.com/data',
      method: 'POST',
      headers: { 'Accept': 'application/json' },
      body: '{"query": "test"}',
    });
  });

  it('excludes undefined optional params from body', async () => {
    const apiClient = createMockApiClient(new Map());
    const handler = getToolHandler(registerX402Fetch, apiClient);

    await handler({ url: 'https://api.example.com' });

    expect(apiClient.post).toHaveBeenCalledWith('/v1/x402/fetch', {
      url: 'https://api.example.com',
    });
  });

  it('returns error with isError on domain not allowed', async () => {
    const responses = new Map<string, ApiResult<unknown>>([
      ['POST:/v1/x402/fetch', {
        ok: false,
        error: { code: 'X402_DOMAIN_NOT_ALLOWED', message: 'Domain not allowed', retryable: false },
      }],
    ]);
    const apiClient = createMockApiClient(responses);
    const handler = getToolHandler(registerX402Fetch, apiClient);

    const result = await handler({ url: 'https://blocked.com' }) as {
      content: Array<{ text: string }>;
      isError?: boolean;
    };

    expect(result.isError).toBe(true);
    const parsed = JSON.parse(result.content[0]!.text) as Record<string, unknown>;
    expect(parsed['code']).toBe('X402_DOMAIN_NOT_ALLOWED');
  });

  it('returns session_expired without isError (H-04)', async () => {
    const responses = new Map<string, ApiResult<unknown>>([
      ['POST:/v1/x402/fetch', {
        ok: false,
        expired: true,
        message: 'Token expired',
      }],
    ]);
    const apiClient = createMockApiClient(responses);
    const handler = getToolHandler(registerX402Fetch, apiClient);

    const result = await handler({ url: 'https://api.example.com' }) as {
      content: Array<{ text: string }>;
      isError?: boolean;
    };

    expect(result.isError).toBeUndefined();
    const parsed = JSON.parse(result.content[0]!.text) as Record<string, unknown>;
    expect(parsed['session_expired']).toBe(true);
  });
});
```

`tool registration with McpServer` describe 블록에도 등록 테스트 추가:
```typescript
it('registers x402_fetch tool without error', () => {
  expect(() => registerX402Fetch(server, apiClient)).not.toThrow();
});
```

**커밋:** `feat(133-02): MCP x402_fetch 도구 + 5개 테스트 + server.ts 등록`
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/mcp/src/__tests__/tools.test.ts` -- 모든 테스트 통과, x402_fetch 5개 + 등록 1개 테스트 포함.
  </verify>
  <done>
MCP x402_fetch 도구가 server.ts에 등록되어 15번째 도구로 노출된다. AI 에이전트가 x402_fetch 도구에 URL을 전달하면 POST /v1/x402/fetch가 호출되고, toToolResult()로 변환된 결과가 반환된다. 옵셔널 파라미터는 미전달 시 제외된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: x402.skill.md + transactions.skill.md 갱신 + VALID_SKILLS/SKILL_NAMES 등록</name>
  <files>
    skills/x402.skill.md
    skills/transactions.skill.md
    packages/daemon/src/api/routes/skills.ts
    packages/mcp/src/resources/skills.ts
  </files>
  <action>
**1. skills/x402.skill.md 신규 생성:**

기존 스킬 파일(actions.skill.md, transactions.skill.md) 패턴을 따른다:

```markdown
---
name: "WAIaaS x402"
description: "x402 auto-payment protocol: fetch URLs with automatic cryptocurrency payments"
category: "api"
tags: [wallet, blockchain, x402, payments, waiass]
version: "1.5.1"
dispatch:
  kind: "tool"
  allowedCommands: ["curl"]
---

# WAIaaS x402 Auto-Payment

Fetch external URLs with automatic x402 protocol payment. When a server responds with HTTP 402 Payment Required, the daemon automatically signs a cryptocurrency payment (USDC via EIP-3009 on EVM or SPL TransferChecked on Solana) and retries the request.

## Base URL / Authentication

```
http://localhost:3100
```

Requires **sessionAuth** via `Authorization: Bearer <token>` header.

## 1. Fetch with Auto-Payment

### POST /v1/x402/fetch

Proxy an HTTP request to an external URL. If the server responds with HTTP 402, automatically sign a payment and retry.

```bash
curl -s -X POST http://localhost:3100/v1/x402/fetch \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer wai_sess_eyJ...' \
  -d '{
    "url": "https://api.example.com/premium/data",
    "method": "GET",
    "headers": {"Accept": "application/json"}
  }'
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `url` | string | Yes | Target URL to fetch (HTTPS required) |
| `method` | string | No | HTTP method: GET, POST, PUT, DELETE, PATCH (default: GET) |
| `headers` | object | No | Additional HTTP headers as key-value pairs |
| `body` | string | No | Request body string |

**Response (200) -- Non-402 Passthrough:**

When the target server does not respond with 402, the response is passed through directly:

```json
{
  "status": 200,
  "headers": {"content-type": "application/json"},
  "body": "{\"data\": \"free content\"}"
}
```

**Response (200) -- After x402 Payment:**

When the target server responds with 402 and payment succeeds:

```json
{
  "status": 200,
  "headers": {"content-type": "application/json"},
  "body": "{\"data\": \"premium content\"}",
  "payment": {
    "amount": "1000000",
    "asset": "USDC",
    "network": "eip155:8453",
    "payTo": "0xPaymentReceiver",
    "txId": "01958f3c-9999-7000-8000-abcdef999999"
  }
}
```

The `payment` field is only present when an x402 payment was made. The `payment.txId` is the WAIaaS transaction record ID, queryable via `GET /v1/transactions/{txId}`.

## 2. Prerequisites

Before using x402 auto-payment, ensure:

1. **x402 enabled** in `config.toml`:
   ```toml
   [x402]
   enabled = true
   ```

2. **X402_ALLOWED_DOMAINS policy** for the wallet (default-deny):
   ```bash
   curl -s -X POST http://localhost:3100/v1/policies \
     -H 'Content-Type: application/json' \
     -H 'X-Master-Password: your-master-password' \
     -d '{
       "walletId": "01958f3a-1234-7000-8000-abcdef123456",
       "type": "X402_ALLOWED_DOMAINS",
       "rules": {
         "domains": ["api.example.com", "*.premium-apis.com"]
       },
       "priority": 0,
       "enabled": true
     }'
   ```

3. **SPENDING_LIMIT policy** (optional): Controls per-period spending. x402 payments are evaluated against the same SPENDING_LIMIT as regular transactions.

## 3. Payment Flow

1. Daemon sends the initial HTTP request to the target URL (SSRF-guarded)
2. If response is not 402, it is returned as-is (passthrough)
3. If response is 402:
   a. Parse `PAYMENT-REQUIRED` header for payment requirements
   b. Select compatible payment scheme (EIP-3009 or SPL TransferChecked)
   c. Create transaction record (type=X402_PAYMENT)
   d. Evaluate SPENDING_LIMIT policy (DELAY/APPROVAL tier handling)
   e. Sign payment with wallet's private key
   f. Retry request with `PAYMENT-SIGNATURE` header
   g. If retry succeeds, mark transaction CONFIRMED
   h. If retry returns 402 again, mark FAILED (single retry only)

## 4. SDK Usage

**TypeScript SDK:**
```typescript
const result = await client.x402Fetch({
  url: 'https://api.example.com/premium/data',
});

if (result.payment) {
  console.log(`Paid ${result.payment.amount} ${result.payment.asset}`);
}
console.log(result.body); // response from the server
```

**Python SDK:**
```python
result = await client.x402_fetch("https://api.example.com/premium/data")

if result.payment:
    print(f"Paid {result.payment.amount} {result.payment.asset}")
print(result.body)  # response from the server
```

**MCP Tool:**
- Tool name: `x402_fetch`
- Parameters: `url` (required), `method` (optional), `headers` (optional), `body` (optional)

## 5. x402 Payment Records

x402 payments are recorded as transactions with `type: "X402_PAYMENT"`. Query them using the standard transaction endpoints:

```bash
# Get specific x402 payment details
curl -s http://localhost:3100/v1/transactions/{txId} \
  -H 'Authorization: Bearer wai_sess_eyJ...'

# List all transactions (includes X402_PAYMENT type)
curl -s http://localhost:3100/v1/transactions?limit=20 \
  -H 'Authorization: Bearer wai_sess_eyJ...'
```

X402_PAYMENT transactions have:
- `type`: `"X402_PAYMENT"`
- `status`: PENDING -> CONFIRMED or FAILED
- `amount`: Payment amount in smallest unit
- `toAddress`: Payment recipient address
- `metadata`: Contains target_url, payment_amount, network, asset, scheme

## 6. Error Reference

| Code | HTTP | Description | Recovery |
|------|------|-------------|----------|
| `X402_DISABLED` | 403 | x402 payments disabled in config | Enable `[x402] enabled = true` in config.toml |
| `X402_DOMAIN_NOT_ALLOWED` | 403 | Target domain not in X402_ALLOWED_DOMAINS | Add domain to X402_ALLOWED_DOMAINS policy |
| `X402_SSRF_BLOCKED` | 403 | URL targets private/internal network | Use a public HTTPS URL |
| `X402_UNSUPPORTED_SCHEME` | 400 | No compatible payment scheme available | Target server must support EIP-3009 or SPL TransferChecked |
| `X402_PAYMENT_REJECTED` | 402 | Payment rejected by resource server | Check payment amount and wallet balance |
| `X402_DELAY_TIMEOUT` | 408 | SPENDING_LIMIT delay exceeds request timeout | Increase x402.request_timeout or adjust SPENDING_LIMIT thresholds |
| `X402_APPROVAL_REQUIRED` | 403 | Amount requires owner approval (incompatible with x402) | Lower amount or adjust SPENDING_LIMIT tiers |
| `X402_SERVER_ERROR` | 502 | Resource server error after payment | Retry; check resource server status |
| `POLICY_DENIED` | 403 | SPENDING_LIMIT policy denied the payment | Check spending limits with GET /v1/policies |

## 7. Related Skill Files

- **policies.skill.md** -- X402_ALLOWED_DOMAINS and SPENDING_LIMIT policy management
- **transactions.skill.md** -- Transaction lifecycle and query (X402_PAYMENT type)
- **wallet.skill.md** -- Wallet CRUD, sessions, balance
- **admin.skill.md** -- Daemon configuration, kill switch
```

**2. skills/transactions.skill.md 갱신:**

Section 1 (Overview)의 테이블에 X402_PAYMENT 행 추가:
```
| `X402_PAYMENT` | x402 auto-payment (USDC) | X402_ALLOWED_DOMAINS policy |
```

Section 7 (Transaction Lifecycle) Status Flow 이후에 x402 lifecycle 설명 추가:
```markdown
### X402_PAYMENT Lifecycle

x402 payments follow a simplified lifecycle:

```
PENDING -> CONFIRMED  (payment accepted by resource server)
        -> FAILED     (payment rejected or server error)
        -> CANCELLED  (policy denied before payment)
```

x402 payments are synchronous -- the API call blocks until the payment flow completes. There is no QUEUED state. DELAY tier waits within the HTTP request timeout; APPROVAL tier is immediately rejected.
```

Section 9 (Error Reference) 테이블에 x402 에러 코드 추가:
```
| `X402_DISABLED` | 403 | x402 payments disabled | Enable in config.toml |
| `X402_DOMAIN_NOT_ALLOWED` | 403 | Domain not in allowed list | Add to X402_ALLOWED_DOMAINS policy |
| `X402_SSRF_BLOCKED` | 403 | URL targets private network | Use public HTTPS URL |
| `X402_UNSUPPORTED_SCHEME` | 400 | No compatible payment scheme | Server must support EIP-3009 or SPL |
| `X402_PAYMENT_REJECTED` | 402 | Payment rejected by server | Check amount and balance |
| `X402_DELAY_TIMEOUT` | 408 | Delay exceeds request timeout | Adjust timeout or limits |
| `X402_APPROVAL_REQUIRED` | 403 | Amount requires owner approval | Lower amount or adjust tiers |
| `X402_SERVER_ERROR` | 502 | Server error after payment | Retry later |
```

transactions.skill.md의 version을 `"1.5.1"`로 갱신.

**3. packages/daemon/src/api/routes/skills.ts 수정:**

`VALID_SKILLS` 배열에 `'x402'`와 `'actions'`를 추가:
```typescript
const VALID_SKILLS = ['quickstart', 'wallet', 'transactions', 'policies', 'admin', 'actions', 'x402'] as const;
```

리서치에서 발견된 `actions.skill.md` 미등록 이슈도 함께 해결한다. `actions.skill.md` 파일은 이미 `skills/` 디렉토리에 존재하므로 배열에 추가만 하면 된다.

**4. packages/mcp/src/resources/skills.ts 수정:**

`SKILL_NAMES` 배열에 `'x402'`와 `'actions'`를 추가:
```typescript
const SKILL_NAMES = ['quickstart', 'wallet', 'transactions', 'policies', 'admin', 'actions', 'x402'] as const;
```

주석도 갱신: `5 skill files` -> `7 skill files`.

**커밋:** `feat(133-02): x402.skill.md + transactions.skill.md 갱신 + VALID_SKILLS/SKILL_NAMES 등록 (7개)`
  </action>
  <verify>
1. `ls /Users/minho.yoo/dev/wallet/WAIaaS/skills/x402.skill.md` -- 파일 존재 확인
2. `grep -c 'x402' /Users/minho.yoo/dev/wallet/WAIaaS/packages/daemon/src/api/routes/skills.ts` -- 1 이상
3. `grep -c 'x402' /Users/minho.yoo/dev/wallet/WAIaaS/packages/mcp/src/resources/skills.ts` -- 1 이상
4. `grep -c 'X402_PAYMENT' /Users/minho.yoo/dev/wallet/WAIaaS/skills/transactions.skill.md` -- 1 이상
5. `grep -c 'actions' /Users/minho.yoo/dev/wallet/WAIaaS/packages/daemon/src/api/routes/skills.ts` -- 1 이상 (미등록 이슈 해결)
  </verify>
  <done>
x402.skill.md 스킬 파일이 생성되고, daemon VALID_SKILLS와 MCP SKILL_NAMES 양쪽 모두에 'x402'가 등록되어 GET /v1/skills/x402와 waiaas://skills/x402 MCP 리소스가 동작한다. transactions.skill.md에 X402_PAYMENT 타입과 x402 에러 코드가 반영된다. 기존 미등록 이슈인 'actions'도 함께 등록되어 총 7개 스킬 파일이 노출된다.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/mcp/src/__tests__/tools.test.ts` -- MCP 전체 테스트 통과
2. `ls skills/x402.skill.md` -- 파일 존재
3. `grep 'x402' packages/daemon/src/api/routes/skills.ts` -- VALID_SKILLS에 포함
4. `grep 'x402' packages/mcp/src/resources/skills.ts` -- SKILL_NAMES에 포함
5. `grep 'X402_PAYMENT' skills/transactions.skill.md` -- X402_PAYMENT 타입 반영
6. `grep 'actions' packages/daemon/src/api/routes/skills.ts` -- actions 미등록 이슈 해결
</verification>

<success_criteria>
- MCP x402_fetch 도구가 등록되어 AI 에이전트가 URL 전달 시 POST /v1/x402/fetch가 호출된다
- x402.skill.md 스킬 파일이 존재하고 VALID_SKILLS/SKILL_NAMES에 등록되어 REST + MCP 양쪽에서 노출된다
- transactions.skill.md에 X402_PAYMENT 트랜잭션 타입과 x402 에러 코드가 반영된다
- 기존 actions.skill.md 미등록 이슈가 함께 해결된다 (7개 스킬)
- MCP 도구 테스트 전체 통과
</success_criteria>

<output>
After completion, create `.planning/phases/133-sdk-mcp-skill-files/133-02-SUMMARY.md`
</output>
