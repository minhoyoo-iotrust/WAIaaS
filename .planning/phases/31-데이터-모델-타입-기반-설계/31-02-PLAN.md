---
phase: 31-데이터-모델-타입-기반-설계
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/27-chain-adapter-interface.md
  - .planning/deliverables/33-time-lock-approval-mechanism.md
autonomous: true

must_haves:
  truths:
    - "IChainAdapter 인터페이스에 sweepAll 메서드가 20번째로 추가되어, from/to 파라미터와 Promise<SweepResult> 반환 타입이 명세되어 있다"
    - "sweepAll의 실행 순서(getAssets -> 토큰 배치 전송 -> SOL 마지막)와 정책 엔진 우회 근거가 명세되어 있다"
    - "resolveOwnerState() 유틸리티의 입력(AgentOwnerInfo)과 출력(OwnerState), 순수 함수 특성이 명세되어 있다"
    - "Grace->Locked 전이의 BEGIN IMMEDIATE 트랜잭션 원자화 설계가 명세되어 있다"
    - "markOwnerVerified()의 WHERE owner_verified = 0 조건에 의한 idempotency가 보장되어 있다"
  artifacts:
    - path: ".planning/deliverables/27-chain-adapter-interface.md"
      provides: "IChainAdapter.sweepAll (20번째 메서드) 시그니처 + 실행 순서 + JSDoc"
      contains: "[v0.8]"
    - path: ".planning/deliverables/33-time-lock-approval-mechanism.md"
      provides: "resolveOwnerState() 유틸리티 + Grace->Locked BEGIN IMMEDIATE 원자화 설계"
      contains: "[v0.8]"
  key_links:
    - from: "27-chain-adapter-interface.md sweepAll"
      to: "Phase 34 WithdrawService"
      via: "sweepAll은 WithdrawService에서 직접 호출되며 정책 엔진을 우회"
    - from: "33-time-lock-approval-mechanism.md markOwnerVerified"
      to: "Phase 32 OwnerLifecycleService"
      via: "ownerAuth 미들웨어에서 markOwnerVerified()를 호출하여 Grace->Locked 전이 트리거"
    - from: "resolveOwnerState()"
      to: "Phase 33 다운그레이드 로직"
      via: "evaluate() 내에서 resolveOwnerState()로 OwnerState를 산출하여 다운그레이드 여부 결정"
---

<objective>
IChainAdapter에 20번째 메서드인 sweepAll을 추가하고, resolveOwnerState() 유틸리티와 Grace->Locked 전이의 BEGIN IMMEDIATE 원자화 설계를 명세한다.

Purpose: Phase 34의 자금 회수(WithdrawService)가 호출할 sweepAll 시그니처를 확정하고, Phase 32/33에서 OwnerState 기반 분기를 설계할 수 있도록 resolveOwnerState() 유틸리티와 상태 전이 원자화 패턴을 확정한다.

Output: 27-chain-adapter-interface.md와 33-time-lock-approval-mechanism.md에 [v0.8] 태그로 변경 사항이 반영된 설계 문서
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/31-데이터-모델-타입-기반-설계/31-RESEARCH.md
@.planning/deliverables/27-chain-adapter-interface.md
@.planning/deliverables/33-time-lock-approval-mechanism.md
@.planning/research/v0.8-ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: IChainAdapter.sweepAll 시그니처를 27-chain-adapter-interface.md에 반영</name>
  <files>.planning/deliverables/27-chain-adapter-interface.md</files>
  <action>
27-chain-adapter-interface.md (CORE-04) 설계 문서에 sweepAll 메서드를 [v0.8] 태그로 추가한다.

**1. 문서 헤더 업데이트:**
- 기존 업데이트 이력에 `**v0.8 업데이트:** 2026-02-08` 추가
- 참조에 `objectives/v0.8-optional-owner-progressive-security.md`, `25-sqlite-schema.md (SweepResult 타입)` 추가

**2. IChainAdapter 인터페이스 메서드 목록 업데이트:**
기존 메서드 수를 19 -> 20으로 변경하고, 메서드 요약 테이블에 20번째 항목 추가:

| # | 메서드 | 카테고리 | 추가 시점 |
|---|--------|---------|----------|
| 20 | `sweepAll(from, to)` | 자금 회수 | v0.8 |

**3. IChainAdapter 인터페이스 TypeScript 정의에 sweepAll 추가:**

```typescript
/**
 * [20] 에이전트 지갑의 전체 자산을 목표 주소로 회수한다. [v0.8 추가] (WITHDRAW-06)
 *
 * 실행 순서:
 * 1. getAssets(from) -> 보유 자산 전수 조사
 * 2. 토큰별 transfer + closeAccount -> 배치 처리 (buildBatch 활용)
 * 3. 네이티브 전량 전송 (잔액 - tx fee) -- 반드시 마지막 (WITHDRAW-07)
 *
 * 정책 엔진을 우회한다 (WithdrawService에서 직접 호출).
 * 수신 주소가 agents.owner_address로 고정되므로 공격자 이득 없음.
 *
 * @param from - 에이전트 지갑 주소 (소스)
 * @param to - Owner 지갑 주소 (목적지, agents.owner_address)
 * @returns 회수 결과 (성공/실패 분리, 부분 실패 시 failed 배열 비어있지 않음)
 *
 * @throws {ChainError} code=INSUFFICIENT_BALANCE -- 잔액 부족 (fee도 없음)
 * @throws {ChainError} code=RPC_ERROR -- RPC 호출 실패
 *
 * @see WITHDRAW-06 (메서드 추가), WITHDRAW-07 (SOL 마지막 전송)
 */
sweepAll(from: string, to: string): Promise<SweepResult>
```

**4. SolanaAdapter/EvmStub에 sweepAll 구현 지침 추가:**
- SolanaAdapter.sweepAll: (1) getAssets(from)으로 SPL 토큰 목록 조회, (2) 각 SPL 토큰에 대해 transfer + closeAccount 일괄 수행 (buildBatch 활용 가능), (3) SOL 전량 전송은 반드시 마지막 -- 잔액에서 tx fee를 빼고 전송. Solana 토큰 계정 rent 회수분은 rentRecovered 필드에 기록
- EvmStub.sweepAll: `throw new ChainError('NOT_IMPLEMENTED')` (v0.8은 설계만, EVM 구현은 미래)

**5. sweepAll 설계 상세 섹션 추가:**
기존 메서드별 상세 섹션 패턴에 맞춰 sweepAll 전용 서브섹션을 추가한다:

제목: `### X.X [v0.8] sweepAll -- 자금 전량 회수`

내용:
- **호출자:** WithdrawService (정책 엔진 우회, 파이프라인 외부)
- **정책 우회 근거:** 수신 주소가 agents.owner_address로 고정되어 공격자가 자금을 탈취할 수 없음. masterAuth(OWNER_VERIFIED=1 필수)로 호출되므로 인증 충분
- **SOL 마지막 전송 근거:** SOL이 트랜잭션 fee 지불에 필요하므로, 토큰 전송이 모두 완료된 후 SOL 잔액에서 fee를 차감하여 전량 전송
- **부분 실패 처리:** 특정 토큰 전송 실패 시 failed 배열에 기록하고 나머지 토큰 계속 처리. 하나라도 실패하면 HTTP 207 (Multi-Status) 응답
- **SweepResult 타입 참조:** 25-sqlite-schema.md 섹션 X.X에서 정의된 SweepResult 타입 사용
- **scope 분기:** scope: "all"(네이티브+토큰+rent)과 scope: "native"(네이티브만) 분기는 WithdrawService 수준에서 처리. sweepAll 메서드 자체는 항상 전량 회수

**6. 인터페이스 변경 이력 테이블 업데이트:**
기존 변경 이력 테이블에 다음 행 추가:

| 버전 | 변경 | 메서드 수 | 근거 |
|------|------|----------|------|
| v0.8 | sweepAll 추가 | 19 -> 20 | 자금 전량 회수 (WITHDRAW-06) |
  </action>
  <verify>
27-chain-adapter-interface.md 파일에서 다음을 확인:
1. IChainAdapter 메서드 수가 20개로 표기
2. sweepAll(from: string, to: string): Promise&lt;SweepResult&gt; 시그니처 존재
3. JSDoc에 실행 순서(getAssets -> 토큰 배치 -> SOL 마지막)가 명시
4. 정책 엔진 우회 근거가 명시
5. SolanaAdapter와 EvmStub 구현 지침이 존재
6. [v0.8] 태그가 최소 4곳에 존재 (헤더, 메서드 테이블, 인터페이스 정의, 상세 섹션)
  </verify>
  <done>
27-chain-adapter-interface.md에 IChainAdapter.sweepAll(20번째 메서드)이 시그니처, JSDoc, 실행 순서, 정책 우회 근거, 부분 실패 처리와 함께 [v0.8] 태그로 반영되어 있다. WITHDRAW-06 요구사항이 충족된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: resolveOwnerState() 유틸리티 + Grace->Locked 원자화 설계를 33-time-lock-approval-mechanism.md에 반영</name>
  <files>.planning/deliverables/33-time-lock-approval-mechanism.md</files>
  <action>
33-time-lock-approval-mechanism.md (LOCK-MECH) 설계 문서에 resolveOwnerState() 유틸리티와 Grace->Locked BEGIN IMMEDIATE 원자화 설계를 [v0.8] 태그로 추가한다.

**1. 문서 헤더 업데이트:**
- 기존 업데이트 이력에 `**v0.8 업데이트:** 2026-02-08` 추가
- 참조에 `objectives/v0.8-optional-owner-progressive-security.md`, `25-sqlite-schema.md (OwnerState, owner_verified)` 추가
- 요구사항에 `OWNER-07 (유예->잠금 전이)`, `OWNER-08 (BEGIN IMMEDIATE 원자화)` 추가

**2. 신규 섹션: [v0.8] resolveOwnerState() 유틸리티**

제목: `### X.X [v0.8] resolveOwnerState() -- Owner 상태 파생 유틸리티`

내용:

```typescript
// packages/daemon/src/domain/owner-presence.ts
import type { OwnerState } from '@waiaas/core'

interface AgentOwnerInfo {
  ownerAddress: string | null
  ownerVerified: boolean       // Drizzle mode: 'boolean' 적용 후 값
}

/**
 * 에이전트의 Owner 상태를 산출한다.
 * DB 컬럼 2개(owner_address, owner_verified) 조합으로 3-state를 결정.
 *
 * 순수 함수(pure function): DB 접근 없이 입력값만으로 결정.
 * 호출 시점에 이미 DB에서 로드된 agent 객체를 전달받는다.
 *
 * 소비자:
 * - DatabasePolicyEngine.evaluate(): 다운그레이드 분기 (Phase 33)
 * - OwnerLifecycleService: 변경/해제 가드 (Phase 32)
 * - WithdrawService: withdraw 활성화 가드 (Phase 34)
 * - KillSwitchService: 복구 대기 시간 분기 (Phase 34)
 * - SessionService: 갱신 거부 윈도우 분기 (Phase 34)
 */
export function resolveOwnerState(agent: AgentOwnerInfo): OwnerState {
  if (agent.ownerAddress === null) return 'NONE'
  if (!agent.ownerVerified) return 'GRACE'
  return 'LOCKED'
}
```

- **파생 상태 원칙:** OwnerState는 DB에 저장하지 않는다. owner_address와 owner_verified 조합에서 런타임에 산출한다. 별도 컬럼으로 저장하면 동기화 오류 발생.
- **입력 타입:** AgentOwnerInfo는 agents 테이블에서 SELECT한 결과의 부분 집합. Drizzle ORM의 `{ mode: 'boolean' }` 적용 후 ownerVerified가 boolean으로 전달됨.
- **호출 시점:** 모든 Owner 관련 분기 지점에서 호출. 하나의 요청 처리 중 여러 번 호출될 수 있으나, agent 객체가 동일하면 결과도 동일 (순수 함수).
- **테스트 가능성:** 순수 함수이므로 단위 테스트로 3가지 상태를 완전히 커버 가능:
  - `{ ownerAddress: null, ownerVerified: false }` -> 'NONE'
  - `{ ownerAddress: 'addr', ownerVerified: false }` -> 'GRACE'
  - `{ ownerAddress: 'addr', ownerVerified: true }` -> 'LOCKED'

**3. 신규 섹션: [v0.8] Grace -> Locked 전이 원자화 (OWNER-08)**

제목: `### X.X [v0.8] Grace -> Locked 전이 -- BEGIN IMMEDIATE 원자화`

내용:

**3-1. 전이 트리거:**
ownerAuth 미들웨어에서 SIWS/SIWE 서명 검증이 성공한 직후, 해당 에이전트의 owner_verified를 확인하고 0이면 1로 전환한다.

**3-2. Race condition 시나리오와 방어:**
- 동시에 2개의 ownerAuth 요청이 들어온다
- 둘 다 owner_verified = 0을 읽고, 둘 다 1로 설정하려 한다
- BEGIN IMMEDIATE로 직렬화하면 첫 번째가 1로 설정하고, 두 번째는 이미 1인 상태를 읽어 no-op이 된다

**3-3. 구현 설계:**

```typescript
// packages/daemon/src/domain/owner-lifecycle.ts
import type Database from 'better-sqlite3'

/**
 * ownerAuth 성공 시 Grace -> Locked 전이를 원자적으로 수행한다. (OWNER-08)
 *
 * BEGIN IMMEDIATE로:
 * 1. owner_verified 상태를 읽고
 * 2. 0이면 1로 전환하고
 * 3. COMMIT한다
 *
 * WHERE owner_verified = 0 조건이 idempotency를 보장:
 * 첫 요청만 전이가 발생하고, 이후 요청은 changes = 0으로 no-op.
 *
 * @returns true면 전이 발생 (GRACE -> LOCKED), false면 이미 LOCKED 상태
 */
function markOwnerVerified(sqlite: Database, agentId: string): boolean {
  return sqlite.transaction(() => {
    const result = sqlite.prepare(
      `UPDATE agents
       SET owner_verified = 1, updated_at = ?
       WHERE id = ? AND owner_verified = 0`
    ).run(Math.floor(Date.now() / 1000), agentId)

    return result.changes > 0  // 실제 변경이 발생했는지
  }).immediate()
}
```

**3-4. 프로젝트 내 BEGIN IMMEDIATE 패턴 일관성:**
이 패턴은 프로젝트에서 이미 사용 중인 BEGIN IMMEDIATE 패턴과 동일하다:
- TOCTOU 방지 (Stage 3 evaluateAndReserve): `WHERE ... AND amount <= available` -- 33-time-lock
- DELAY 상태 전이 (processDelayedTransaction): `WHERE status = 'QUEUED'` -- 33-time-lock
- 세션 토큰 로테이션: `WHERE nonce = ?` -- 30-session-token-protocol
- Owner 승인/거절: `WHERE status = 'PENDING_APPROVAL'` -- 34-owner-wallet-connection

핵심 패턴: `UPDATE ... WHERE <current_state> = <expected_value>` + `.immediate()` -> result.changes > 0으로 성공 여부 판단

**3-5. 감사 로그:**
전이가 발생하면(result.changes > 0) audit_log에 다음 이벤트를 기록한다:
- event_type: 'OWNER_VERIFIED'
- agent_id: agentId
- details: `{ previousState: 'GRACE', newState: 'LOCKED' }`
- "언제 verified되었는가"는 이 audit_log 이벤트의 created_at으로 추적. owner_verified 컬럼에 타임스탬프를 저장하지 않는다.

**3-6. 호출 위치 설계:**
ownerAuth 미들웨어 -> SIWS/SIWE 서명 검증 성공 -> markOwnerVerified() 호출:
- Phase 32에서 OwnerLifecycleService가 이 함수를 포함하는 전체 생명주기를 설계
- ownerAuth 미들웨어의 기존 흐름(52-auth-model-redesign.md)에 markOwnerVerified() 호출이 삽입되는 지점은 Phase 32에서 명세

**4. 기존 BEGIN IMMEDIATE 패턴 목록에 v0.8 항목 추가:**
문서 내 BEGIN IMMEDIATE 사용 사례 목록에 다음 항목을 추가한다:
- `[v0.8] Grace -> Locked 전이 (markOwnerVerified): WHERE owner_verified = 0 -- OWNER-08`
  </action>
  <verify>
33-time-lock-approval-mechanism.md 파일에서 다음을 확인:
1. resolveOwnerState() 유틸리티가 입력(AgentOwnerInfo), 출력(OwnerState), 순수 함수 특성과 함께 명세
2. markOwnerVerified() 함수가 BEGIN IMMEDIATE + WHERE owner_verified = 0 패턴으로 명세
3. Race condition 시나리오와 방어가 설명됨
4. idempotency 보장 메커니즘(WHERE 조건 + changes > 0)이 명시
5. 감사 로그 OWNER_VERIFIED 이벤트가 명세
6. 기존 BEGIN IMMEDIATE 패턴 목록에 v0.8 항목이 추가
7. [v0.8] 태그가 최소 4곳에 존재
  </verify>
  <done>
33-time-lock-approval-mechanism.md에 resolveOwnerState() 유틸리티(입출력 + 순수 함수 + 소비자 목록)와 Grace->Locked BEGIN IMMEDIATE 원자화 설계(markOwnerVerified + race condition 방어 + idempotency + 감사 로그)가 [v0.8] 태그로 반영되어 있다. OWNER-07, OWNER-08 요구사항이 충족된다.
  </done>
</task>

</tasks>

<verification>
1. 27-chain-adapter-interface.md에서 IChainAdapter가 20개 메서드로 업데이트되어 있다
2. sweepAll(from: string, to: string): Promise&lt;SweepResult&gt; 시그니처가 존재하고, JSDoc에 실행 순서와 정책 우회 근거가 명시되어 있다
3. 33-time-lock-approval-mechanism.md에서 resolveOwnerState()가 순수 함수로 명세되어 있다
4. AgentOwnerInfo 입력 타입과 OwnerState 출력 타입이 명확히 정의되어 있다
5. markOwnerVerified()가 BEGIN IMMEDIATE + WHERE owner_verified = 0 + result.changes > 0 패턴으로 명세되어 있다
6. Race condition 시나리오, idempotency, 감사 로그가 모두 명세되어 있다
7. 두 문서 모두 [v0.8] 태그로 변경점이 명확히 표시되어 있다
</verification>

<success_criteria>
- WITHDRAW-06 충족: IChainAdapter에 sweepAll 메서드가 20번째로 추가
- OWNER-07 충족: resolveOwnerState()가 owner_verified 컬럼 기반으로 OwnerState를 산출하는 설계 완료
- OWNER-08 충족: Grace->Locked 전이가 BEGIN IMMEDIATE + WHERE 조건으로 원자화되어 race condition 방지
- 일관성: 기존 BEGIN IMMEDIATE 패턴과 동일한 패턴 적용으로 프로젝트 아키텍처 일관성 유지
- 후속 페이즈 의존성 해소: Phase 32(OwnerLifecycleService), Phase 33(다운그레이드), Phase 34(WithdrawService)가 참조할 기반 확보
</success_criteria>

<output>
After completion, create `.planning/phases/31-데이터-모델-타입-기반-설계/31-02-SUMMARY.md`
</output>
