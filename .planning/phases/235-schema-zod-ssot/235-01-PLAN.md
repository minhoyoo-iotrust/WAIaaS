---
phase: 235-schema-zod-ssot
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/core/src/schemas/policy.schema.ts
  - packages/core/src/__tests__/policy-superrefine.test.ts
autonomous: true
requirements:
  - SCHM-01
  - SCHM-02
  - SCHM-03
  - SCHM-04
  - SCHM-05
  - SCHM-06

must_haves:
  truths:
    - "TokenLimitSchema accepts human-readable decimal strings (e.g. '1.5', '1000') for instant_max/notify_max/delay_max"
    - "SpendingLimitRules with only USD fields (no raw, no token_limits) passes Zod validation"
    - "SpendingLimitRules with only token_limits (no raw, no USD) passes Zod validation"
    - "SpendingLimitRules with no USD, no token_limits, and no raw fields fails Zod validation"
    - "token_limits keys must be 'native', 'native:{chain}', or valid CAIP-19 format -- other keys fail"
    - "token_limits with instant_max > notify_max fails ordering validation"
  artifacts:
    - path: "packages/core/src/schemas/policy.schema.ts"
      provides: "TokenLimitSchema + updated SpendingLimitRulesSchema with superRefine"
      contains: "TokenLimitSchema"
    - path: "packages/core/src/__tests__/policy-superrefine.test.ts"
      provides: "Comprehensive SPENDING_LIMIT schema validation tests"
      contains: "token_limits"
  key_links:
    - from: "packages/core/src/schemas/policy.schema.ts"
      to: "packages/core/src/caip/caip19.ts"
      via: "Caip19AssetTypeSchema import for key validation"
      pattern: "Caip19AssetTypeSchema"
    - from: "packages/core/src/schemas/policy.schema.ts"
      to: "POLICY_RULES_SCHEMAS map"
      via: "SpendingLimitRulesSchema registered in map for CreatePolicyRequest superRefine"
      pattern: "SPENDING_LIMIT.*SpendingLimitRulesSchema"
---

<objective>
Define `TokenLimitSchema` for human-readable per-token spending limits, make raw fields optional on `SpendingLimitRulesSchema`, add `token_limits` CAIP-19-keyed record, and implement superRefine validations ensuring at least one limit source exists and ordering constraints are enforced.

Purpose: Enable token-aware spending limit policies where admins specify amounts in human-readable units (e.g., "1.5 SOL", "1000 USDC") instead of raw lamports/wei, and allow USD-only policies without requiring raw fields.

Output: Updated `policy.schema.ts` with TokenLimitSchema + superRefine, extended `policy-superrefine.test.ts` with comprehensive validation tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/core/src/schemas/policy.schema.ts
@packages/core/src/__tests__/policy-superrefine.test.ts
@packages/core/src/caip/caip19.ts
@packages/core/src/caip/asset-helpers.ts
@packages/core/src/enums/chain.ts
@internal/objectives/m27-03-token-aware-spending-limit.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for TokenLimitSchema + SpendingLimitRules changes</name>
  <files>packages/core/src/__tests__/policy-superrefine.test.ts</files>
  <action>
Extend the existing `policy-superrefine.test.ts` file. Add a new `describe('SPENDING_LIMIT token_limits')` block inside the existing `SPENDING_LIMIT` describe block (after the existing test). Write the following failing tests:

**SCHM-01: TokenLimitSchema human-readable amounts**
1. `token_limits with valid decimal strings ("1.5", "1000", "0.001") passes validation`
   - Input: `{ type: 'SPENDING_LIMIT', rules: { token_limits: { "native:solana": { instant_max: "1.5", notify_max: "10", delay_max: "100.5" } }, delay_seconds: 900 } }`
   - Expect: `result.success === true`

2. `token_limits with integer strings ("1", "100", "1000") passes validation`
   - Input: `token_limits: { "native:ethereum": { instant_max: "1", notify_max: "100", delay_max: "1000" } }`
   - Expect: success

**SCHM-02: raw fields optional**
3. `accepts SpendingLimitRules with only USD fields (no raw)`
   - Input: `{ instant_max_usd: 100, notify_max_usd: 500, delay_max_usd: 5000 }`
   - Expect: success

4. `accepts SpendingLimitRules with only token_limits (no raw, no USD)`
   - Input: `{ token_limits: { "native:solana": { instant_max: "1", notify_max: "5", delay_max: "50" } } }`
   - Expect: success

5. `still accepts legacy raw-only policies (backward compat)`
   - Input: `{ instant_max: "1000000", notify_max: "5000000", delay_max: "10000000" }`
   - Expect: success

**SCHM-03: token_limits CAIP-19 record keys**
6. `accepts CAIP-19 asset ID as token_limits key`
   - Input: key = `"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"`
   - Expect: success

7. `accepts "native" shorthand key`
   - Input: key = `"native"`
   - Expect: success

8. `accepts "native:solana" key`
   - Input: key = `"native:solana"`
   - Expect: success

9. `accepts "native:ethereum" key`
   - Input: key = `"native:ethereum"`
   - Expect: success

**SCHM-04: at least one limit source required (superRefine)**
10. `rejects when no USD, no token_limits, and no raw fields`
    - Input: `{ delay_seconds: 900 }` (or empty rules besides delay_seconds)
    - Expect: `result.success === false`, issue path includes `rules`

**SCHM-05: ordering validation within token_limits**
11. `rejects token_limits where instant_max > notify_max`
    - Input: `token_limits: { "native:solana": { instant_max: "100", notify_max: "10", delay_max: "1000" } }`
    - Expect: failure

12. `rejects token_limits where notify_max > delay_max`
    - Input: `token_limits: { "native:solana": { instant_max: "1", notify_max: "1000", delay_max: "100" } }`
    - Expect: failure

13. `accepts token_limits where instant_max == notify_max == delay_max`
    - Input: `token_limits: { "native:solana": { instant_max: "100", notify_max: "100", delay_max: "100" } }`
    - Expect: success

**SCHM-06: token_limits key format validation**
14. `rejects invalid token_limits key (random string)`
    - Input: key = `"invalid-key"`
    - Expect: failure

15. `rejects token_limits key with invalid CAIP-19 format`
    - Input: key = `"not:valid/caip:19:format"`
    - Expect: failure

16. `rejects token_limits key "native:invalid_chain"` (chain must be "solana" or "ethereum")
    - Input: key = `"native:bitcoin"`
    - Expect: failure

17. `accepts multiple token_limits entries simultaneously`
    - Input: `token_limits: { "native:solana": {...}, "solana:5eykt.../token:EPjF...": {...} }`
    - Expect: success

All tests should use `CreatePolicyRequestSchema.safeParse()` with `type: 'SPENDING_LIMIT'` wrapper, consistent with existing test patterns.

Run tests: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core test -- --run policy-superrefine`
All new tests MUST fail (RED phase). Existing tests should still pass.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core test -- --run policy-superrefine 2>&1 | tail -30`

Expected: existing SPENDING_LIMIT test passes, ALL new token_limits tests fail. This confirms schema changes are needed.
  </verify>
  <done>17 new test cases written and failing. Existing SPENDING_LIMIT test still passes. Test file compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement TokenLimitSchema + raw optional + token_limits + superRefine</name>
  <files>packages/core/src/schemas/policy.schema.ts</files>
  <action>
Modify `packages/core/src/schemas/policy.schema.ts` to make all 17 new tests pass:

**Step 1: Define TokenLimitSchema** (before SpendingLimitRulesSchema, around line 70)

```typescript
/** Per-token spending limit in human-readable units (e.g., "1.5" SOL, "1000" USDC). */
export const TokenLimitSchema = z.object({
  instant_max: z.string().regex(/^\d+(\.\d+)?$/, 'Must be a non-negative decimal string'),
  notify_max: z.string().regex(/^\d+(\.\d+)?$/, 'Must be a non-negative decimal string'),
  delay_max: z.string().regex(/^\d+(\.\d+)?$/, 'Must be a non-negative decimal string'),
});
export type TokenLimit = z.infer<typeof TokenLimitSchema>;
```

**Step 2: Define token_limits key validator** (used in superRefine)

The key validation regex must accept exactly these patterns:
- `"native"` -- exact match
- `"native:solana"` or `"native:ethereum"` -- `native:` + valid ChainType
- Valid CAIP-19 format -- reuse `Caip19AssetTypeSchema` regex

Create a helper function:
```typescript
const VALID_CHAIN_TYPES = new Set(['solana', 'ethereum']);
const CAIP19_REGEX = /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}\/[-a-z0-9]{3,8}:[-.%a-zA-Z0-9]{1,128}$/;

function isValidTokenLimitKey(key: string): boolean {
  if (key === 'native') return true;
  if (key.startsWith('native:')) {
    return VALID_CHAIN_TYPES.has(key.slice(7));
  }
  return CAIP19_REGEX.test(key);
}
```

**Step 3: Update SpendingLimitRulesSchema**

Convert the existing `z.object(...)` to a base schema, then chain `.superRefine()`:

```typescript
const SpendingLimitRulesBaseSchema = z.object({
  // raw fields: NOW OPTIONAL (deprecated)
  instant_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다').optional(),
  notify_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다').optional(),
  delay_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다').optional(),

  // USD-based (unchanged)
  instant_max_usd: z.number().nonnegative().optional(),
  notify_max_usd: z.number().nonnegative().optional(),
  delay_max_usd: z.number().nonnegative().optional(),
  daily_limit_usd: z.number().positive().optional(),
  monthly_limit_usd: z.number().positive().optional(),

  // Token-specific limits (NEW)
  token_limits: z.record(z.string(), TokenLimitSchema).optional(),

  delay_seconds: z.number().int().min(60).default(900),
});

export const SpendingLimitRulesSchema = SpendingLimitRulesBaseSchema.superRefine((data, ctx) => {
  // SCHM-04: At least one limit source must be present
  const hasRaw = data.instant_max !== undefined || data.notify_max !== undefined || data.delay_max !== undefined;
  const hasUsd = data.instant_max_usd !== undefined || data.notify_max_usd !== undefined || data.delay_max_usd !== undefined;
  const hasTokenLimits = data.token_limits !== undefined && Object.keys(data.token_limits).length > 0;

  if (!hasRaw && !hasUsd && !hasTokenLimits) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'At least one of USD limits, token_limits, or raw limits must be specified',
      path: [],
    });
  }

  // Validate token_limits if present
  if (data.token_limits) {
    for (const [key, limit] of Object.entries(data.token_limits)) {
      // SCHM-06: Key format validation
      if (!isValidTokenLimitKey(key)) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Invalid token_limits key "${key}". Must be "native", "native:{chain}", or a valid CAIP-19 asset ID`,
          path: ['token_limits', key],
        });
      }

      // SCHM-05: Ordering validation (instant_max <= notify_max <= delay_max)
      const instantMax = parseFloat(limit.instant_max);
      const notifyMax = parseFloat(limit.notify_max);
      const delayMax = parseFloat(limit.delay_max);

      if (instantMax > notifyMax) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `token_limits["${key}"]: instant_max (${limit.instant_max}) must be <= notify_max (${limit.notify_max})`,
          path: ['token_limits', key, 'instant_max'],
        });
      }
      if (notifyMax > delayMax) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `token_limits["${key}"]: notify_max (${limit.notify_max}) must be <= delay_max (${limit.delay_max})`,
          path: ['token_limits', key, 'notify_max'],
        });
      }
    }
  }
});
```

**Step 4: Keep the existing export**

`export type SpendingLimitRules = z.infer<typeof SpendingLimitRulesSchema>;` -- this should still work since the superRefine doesn't change the inferred type shape.

**Step 5: Verify POLICY_RULES_SCHEMAS map**

The map entry `SPENDING_LIMIT: SpendingLimitRulesSchema` should remain unchanged. The superRefine chain is transparent to `safeParse()`.

**Important details:**
- Do NOT import Caip19AssetTypeSchema -- instead duplicate the CAIP-19 regex inline to avoid a circular dependency risk and keep the validation self-contained. The regex is: `/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}\/[-a-z0-9]{3,8}:[-.%a-zA-Z0-9]{1,128}$/`
- The `VALID_CHAIN_TYPES` set uses the same values as `CHAIN_TYPES` from enums but is defined locally to avoid import complexity. Currently only `'solana'` and `'ethereum'` are valid.
- The `isValidTokenLimitKey` function should be a module-level function (not exported).
- Export `TokenLimitSchema` and `TokenLimit` type for downstream consumers (Phase 236/237 will use them).

Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core test -- --run policy-superrefine`
ALL tests must pass.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core test -- --run policy-superrefine`

Expected: ALL tests pass (existing + 17 new). Zero failures.

Also run typecheck: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core exec tsc --noEmit`

Expected: No type errors. `SpendingLimitRules` type is still compatible with all existing consumers.
  </verify>
  <done>TokenLimitSchema defined with human-readable decimal regex. Raw fields optional. token_limits record added. superRefine validates: (1) at least one limit source, (2) ordering within token_limits, (3) key format. All 17+ tests pass. TypeScript compiles clean.</done>
</task>

</tasks>

<verification>
1. Run full core test suite: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/core test -- --run`
   - All existing tests pass (no regressions from raw fields becoming optional)
   - All 17 new token_limits tests pass

2. Run daemon typecheck to verify downstream compatibility: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/daemon exec tsc --noEmit`
   - SpendingLimitRules type change (raw fields now optional) must not break daemon code that reads `rules.instant_max` etc.
   - If daemon code accesses raw fields without optional checks, fix with `?.` or `!== undefined` guards (this is expected -- daemon currently assumes raw fields exist)

3. Verify exported types: `TokenLimitSchema`, `TokenLimit`, `SpendingLimitRulesSchema`, `SpendingLimitRules` are all accessible from `@waiaas/core`
</verification>

<success_criteria>
- TokenLimitSchema accepts human-readable decimal string amounts (SCHM-01)
- raw fields (instant_max/notify_max/delay_max) are optional in SpendingLimitRulesSchema (SCHM-02)
- token_limits field is a z.record keyed by CAIP-19/native format (SCHM-03)
- superRefine rejects policies with no USD, no token_limits, and no raw fields (SCHM-04)
- superRefine rejects token_limits with ordering violations (SCHM-05)
- superRefine rejects token_limits with invalid key formats (SCHM-06)
- All existing SPENDING_LIMIT tests continue to pass (backward compatible)
- TypeScript compiles clean across core and daemon packages
</success_criteria>

<output>
After completion, create `.planning/phases/235-schema-zod-ssot/235-01-SUMMARY.md`
</output>
