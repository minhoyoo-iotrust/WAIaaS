---
phase: 77-evm-adapter
plan: 02
type: execute
wave: 2
depends_on: ["77-01"]
files_modified:
  - packages/adapters/evm/src/adapter.ts
  - packages/adapters/evm/src/__tests__/evm-adapter.test.ts
autonomous: true

must_haves:
  truths:
    - "EVM 네이티브 토큰(ETH) 전송이 EIP-1559 트랜잭션으로 빌드된다 — buildTransaction이 serializeTransaction으로 직렬화된 UnsignedTransaction을 반환한다"
    - "simulateTransaction이 eth_call로 트랜잭션을 시뮬레이션하고 성공/실패 결과를 반환한다"
    - "signTransaction이 viem signTransaction으로 개인키 서명을 수행하고 직렬화된 서명 트랜잭션 Uint8Array를 반환한다"
    - "submitTransaction이 eth_sendRawTransaction으로 서명된 트랜잭션을 제출하고 txHash를 반환한다"
    - "waitForConfirmation이 viem waitForTransactionReceipt으로 확인을 대기한다"
    - "estimateFee가 estimateGas * maxFeePerGas로 수수료를 추정하고, gas에 1.2x 안전 마진이 적용된다"
    - "getCurrentNonce가 viem getTransactionCount를 호출하여 정확한 nonce를 반환한다"
    - "getTokenInfo가 viem multicall로 ERC-20 decimals/symbol/name을 조회한다"
    - "buildApprove가 ERC-20 approve calldata를 인코딩하고 EIP-1559 트랜잭션을 빌드한다"
    - "getAssets가 네이티브 ETH 잔액을 반환한다 (토큰 조회는 Phase 78에서 확장)"
  artifacts:
    - path: "packages/adapters/evm/src/adapter.ts"
      provides: "EvmAdapter with 15 real implementations (5 from 77-01 + 10 new)"
      exports: ["EvmAdapter"]
    - path: "packages/adapters/evm/src/__tests__/evm-adapter.test.ts"
      provides: "Comprehensive tests with viem mocking"
      min_lines: 200
  key_links:
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "viem"
      via: "serializeTransaction for building unsigned tx"
      pattern: "serializeTransaction"
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "viem"
      via: "signTransaction for signing with private key"
      pattern: "signTransaction"
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "viem/accounts"
      via: "privateKeyToAccount for signing"
      pattern: "privateKeyToAccount"
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "packages/adapters/evm/src/abi/erc20.ts"
      via: "ERC20_ABI for approve/getTokenInfo"
      pattern: "import.*ERC20_ABI"
---

<objective>
EvmAdapter의 나머지 10개 메서드를 실제 viem 호출로 구현한다: EVM 네이티브 전송(EIP-1559 build/simulate/sign/submit), waitForConfirmation, estimateFee(gas * 1.2x), getCurrentNonce, getTokenInfo(ERC-20 metadata), buildApprove(ERC-20 approve), getAssets(네이티브 only). getTransactionFee도 구현한다.

Purpose: Phase 77의 핵심 목표인 "EVM 네이티브 전송 + ERC-20 전송/approve + gas 추정 + nonce 관리"를 완성하여, 후속 Phase 78(토큰 전송 파이프라인), 79(컨트랙트/approve 파이프라인), 81(Stage 5 통합)이 EvmAdapter를 사용할 수 있는 상태를 만든다.
Output: EvmAdapter 15/20 메서드 실제 구현 + 종합 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output
@.planning/phases/77-evm-adapter/77-01-SUMMARY.md

# EvmAdapter code from Plan 01
@packages/adapters/evm/src/adapter.ts
@packages/adapters/evm/src/abi/erc20.ts
@packages/adapters/evm/src/__tests__/evm-adapter.test.ts

# IChainAdapter types
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/interfaces/chain-adapter.types.ts

# ChainError for error mapping
@packages/core/src/errors/chain-error.ts

# SolanaAdapter for pattern reference (build/sign/submit flow)
@packages/adapters/solana/src/adapter.ts

# Design specs for EVM implementation
@docs/56-token-transfer-extension-spec.md
@docs/57-asset-query-fee-estimation-spec.md
@docs/59-approve-management-spec.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: EVM 네이티브 전송 파이프라인 (build/simulate/sign/submit/confirm) + estimateFee + nonce + getTransactionFee</name>
  <files>
    packages/adapters/evm/src/adapter.ts
  </files>
  <action>
    Replace the stub implementations in EvmAdapter with real viem calls. Import additional viem functions as needed.

    **Additional viem imports needed:**
    - `serializeTransaction`, `parseTransaction` from `viem`
    - `privateKeyToAccount` from `viem/accounts`
    - `encodeFunctionData` from `viem`
    - `type Hex` from `viem`
    - `estimateFeesPerGas` (or use client.estimateFeesPerGas)

    **1. buildTransaction(request: TransferRequest) -> UnsignedTransaction:**
    ```
    - ensureConnected()
    - Get nonce: client.getTransactionCount({ address: request.from as Address })
    - Get fee data: client.estimateFeesPerGas()
    - Estimate gas: client.estimateGas({ account: request.from, to: request.to, value: request.amount })
    - Apply 1.2x safety margin: gasLimit = (estimatedGas * 120n) / 100n
    - Build EIP-1559 tx object:
      {
        type: 'eip1559' as const,
        to: request.to as Address,
        value: request.amount,
        nonce,
        gas: gasLimit,
        maxFeePerGas: fees.maxFeePerGas,
        maxPriorityFeePerGas: fees.maxPriorityFeePerGas,
        chainId: client.chain?.id,
        data: request.memo ? ('0x' + Buffer.from(request.memo).toString('hex')) as Hex : undefined,
      }
    - Serialize: serializeTransaction(txRequest)
    - Convert hex string to Uint8Array for serialized field
    - estimatedFee = gasLimit * maxFeePerGas
    - Return UnsignedTransaction:
      {
        chain: 'ethereum',
        serialized: hexToBytes(serializedHex),
        estimatedFee,
        expiresAt: undefined,  // EVM uses nonce, no expiry
        metadata: { nonce, chainId, maxFeePerGas, maxPriorityFeePerGas, gasLimit, type: 'eip1559' },
        nonce,
      }
    - Catch errors: map to appropriate ChainError codes:
      - 'insufficient funds' -> ChainError('INSUFFICIENT_BALANCE', 'evm')
      - 'nonce too low' -> ChainError('NONCE_TOO_LOW', 'evm')
      - connection errors -> ChainError('RPC_CONNECTION_ERROR', 'evm')
      - Otherwise -> WAIaaSError('CHAIN_ERROR')
    ```

    **2. simulateTransaction(tx: UnsignedTransaction) -> SimulationResult:**
    ```
    - ensureConnected()
    - Deserialize the tx from serialized bytes back to tx params
    - Use client.call({ ...txParams }) to simulate via eth_call
    - Return { success: true/false, logs: [], unitsConsumed: gas used }
    - On error: return { success: false, logs: [], error: message }
    ```

    **3. signTransaction(tx: UnsignedTransaction, privateKey: Uint8Array) -> Uint8Array:**
    ```
    - ensureConnected()
    - Convert privateKey to hex: '0x' + Buffer.from(privateKey).toString('hex')
    - Create account: privateKeyToAccount(privateKeyHex)
    - Deserialize tx bytes back to tx object using parseTransaction
    - Use account.signTransaction(txObj) to get signed hex
    - Convert signed hex to Uint8Array
    - Return signed bytes
    ```

    **4. submitTransaction(signedTx: Uint8Array) -> SubmitResult:**
    ```
    - ensureConnected()
    - Convert bytes to hex: '0x' + Buffer.from(signedTx).toString('hex')
    - Use client.sendRawTransaction({ serializedTransaction: hex })
    - Return { txHash: result, status: 'submitted' }
    - Error mapping: nonce already used -> ChainError('NONCE_ALREADY_USED')
    ```

    **5. waitForConfirmation(txHash, timeoutMs) -> SubmitResult:**
    ```
    - ensureConnected()
    - Use client.waitForTransactionReceipt({ hash: txHash, timeout: timeoutMs })
    - Return { txHash, status: receipt.status === 'success' ? 'confirmed' : 'submitted', blockNumber: receipt.blockNumber, fee: receipt.gasUsed * receipt.effectiveGasPrice }
    - If timeout: return { txHash, status: 'submitted' }
    ```

    **6. estimateFee(request: TransferRequest | TokenTransferParams) -> FeeEstimate:**
    ```
    - ensureConnected()
    - Get fees: client.estimateFeesPerGas()
    - Determine gas estimate target based on request shape:
      - If 'token' in request (TokenTransferParams): estimate for ERC-20 transfer calldata
      - Else (TransferRequest): estimate for native transfer
    - estimatedGas = client.estimateGas({ account, to, value, data })
    - gasLimit = (estimatedGas * 120n) / 100n  // 1.2x safety margin
    - fee = gasLimit * maxFeePerGas
    - Return { fee, details: { gasLimit, maxFeePerGas, maxPriorityFeePerGas } }
    ```

    **7. getCurrentNonce(address) -> number:** (may already be implemented from 77-01)
    ```
    - ensureConnected()
    - return Number(await client.getTransactionCount({ address: address as Address }))
    ```

    **8. getTransactionFee(tx: UnsignedTransaction) -> bigint:**
    ```
    - Extract gasLimit and maxFeePerGas from tx.metadata
    - Return gasLimit * maxFeePerGas (both as bigint)
    - If metadata missing, return tx.estimatedFee
    ```

    **9. getAssets(address) -> AssetInfo[]:**
    ```
    - ensureConnected()
    - Get native balance: client.getBalance({ address })
    - Return [{ mint: 'native', symbol: 'ETH', name: 'Ethereum', balance, decimals: 18, isNative: true }]
    - Token accounts will be added in Phase 78 with ALLOWED_TOKENS-based multicall
    ```

    **10. getTokenInfo(tokenAddress) -> TokenInfo:**
    ```
    - ensureConnected()
    - Use client.multicall with ERC20_ABI to call decimals(), symbol(), name() in a single RPC
    - Return { address: tokenAddress, symbol, name, decimals }
    - If multicall fails for any field, provide defaults ('', '', 18)
    ```

    **11. buildApprove(request: ApproveParams) -> UnsignedTransaction:**
    ```
    - ensureConnected()
    - Encode approve calldata: encodeFunctionData({ abi: ERC20_ABI, functionName: 'approve', args: [request.spender, request.amount] })
    - Get nonce, fees
    - Estimate gas for approve call
    - gasLimit = (estimatedGas * 120n) / 100n
    - Build EIP-1559 tx to token contract address with approve calldata, value=0
    - Serialize and return UnsignedTransaction
    ```

    **Remaining stubs (3)** — not implemented in this plan:
    - `buildTokenTransfer` — Phase 78 (needs ALLOWED_TOKENS policy integration)
    - `buildContractCall` — Phase 79 (needs CONTRACT_WHITELIST policy integration)
    - `sweepAll` — Phase 80

    **Helper functions to add:**
    - `hexToBytes(hex: string): Uint8Array` — convert 0x-prefixed hex to bytes
    - `bytesToHex(bytes: Uint8Array): string` — convert bytes to 0x-prefixed hex
    - Note: viem may export `hexToBytes` and `toHex` — use those if available (`fromHex`, `toHex` from viem)

    **Error handling pattern:**
    - Wrap all RPC calls in try/catch
    - Map viem errors to ChainError codes where possible:
      - `InsufficientFundsError` -> `INSUFFICIENT_BALANCE`
      - `NonceTooLowError` -> `NONCE_TOO_LOW`
      - Connection refused/timeout -> `RPC_CONNECTION_ERROR` or `RPC_TIMEOUT`
      - Unknown -> `WAIaaSError('CHAIN_ERROR')`
    - Use error message pattern matching (viem does not always throw typed errors)

    Run `pnpm turbo build` to verify after changes.
  </action>
  <verify>
    - `pnpm --filter @waiaas/adapter-evm build` succeeds with no TypeScript errors
    - `pnpm turbo build` — full monorepo build succeeds
    - All method implementations satisfy IChainAdapter type signatures
  </verify>
  <done>
    EvmAdapter has 17/20 methods with real implementations (15 real + 2 passthrough + 3 stubs remaining). buildTransaction creates EIP-1559 txs, signTransaction uses privateKeyToAccount, estimateFee applies 1.2x gas margin, getCurrentNonce uses getTransactionCount, getTokenInfo uses multicall, buildApprove encodes ERC-20 approve.
  </done>
</task>

<task type="auto">
  <name>Task 2: EvmAdapter 종합 테스트 (viem mock + 에러 매핑 + ERC-20 approve)</name>
  <files>
    packages/adapters/evm/src/__tests__/evm-adapter.test.ts
  </files>
  <action>
    Extend the existing test file with comprehensive tests using vi.mock to mock viem internals.

    **Mocking strategy:**
    - Use `vi.mock('viem', ...)` to mock `createPublicClient` return value
    - Create a `mockClient` object with mocked methods: `getBalance`, `getBlockNumber`, `estimateGas`, `estimateFeesPerGas`, `getTransactionCount`, `call`, `sendRawTransaction`, `waitForTransactionReceipt`, `multicall`
    - Mock `createPublicClient` to return mockClient
    - Mock `serializeTransaction`, `parseTransaction` from viem
    - Mock `privateKeyToAccount` from `viem/accounts`

    **New test groups to add:**

    1. **buildTransaction 테스트 (4 tests):**
       - `builds EIP-1559 transaction with correct fields` — verify nonce, maxFeePerGas, maxPriorityFeePerGas, gas in metadata
       - `applies 1.2x gas safety margin` — mock estimateGas returning 21000n, verify gasLimit is 25200n
       - `throws INSUFFICIENT_BALANCE on insufficient funds error` — mock estimateGas to throw 'insufficient funds', expect ChainError
       - `includes memo as hex data when provided` — verify data field in tx

    2. **simulateTransaction 테스트 (2 tests):**
       - `returns success: true when simulation passes` — mock client.call to succeed
       - `returns success: false with error when simulation fails` — mock client.call to throw

    3. **signTransaction 테스트 (2 tests):**
       - `signs transaction with private key and returns bytes` — mock account.signTransaction
       - `handles 32-byte private key` — verify hex conversion from 32-byte Uint8Array

    4. **submitTransaction 테스트 (2 tests):**
       - `submits signed tx and returns txHash` — mock sendRawTransaction
       - `throws on NONCE_ALREADY_USED` — mock sendRawTransaction to throw nonce error

    5. **waitForConfirmation 테스트 (2 tests):**
       - `returns confirmed status with block number and fee` — mock receipt
       - `returns submitted on timeout` — mock waitForTransactionReceipt to throw timeout

    6. **estimateFee 테스트 (3 tests):**
       - `estimates native transfer fee with 1.2x margin` — verify calculation
       - `estimates ERC-20 transfer fee (TokenTransferParams)` — verify calldata included
       - `returns FeeEstimate with details` — verify details.gasLimit, details.maxFeePerGas

    7. **getCurrentNonce 테스트 (1 test):**
       - `returns nonce from getTransactionCount` — mock returning 42, verify 42

    8. **getTransactionFee 테스트 (2 tests):**
       - `calculates fee from metadata` — verify gasLimit * maxFeePerGas
       - `falls back to estimatedFee when metadata missing` — verify fallback

    9. **getAssets 테스트 (1 test):**
       - `returns native ETH balance` — verify single AssetInfo with isNative=true

    10. **getTokenInfo 테스트 (2 tests):**
        - `returns token info via multicall` — mock multicall returning decimals/symbol/name
        - `handles partial multicall failure with defaults` — mock multicall with some failures

    11. **buildApprove 테스트 (2 tests):**
        - `encodes ERC-20 approve calldata` — verify encodeFunctionData called with approve args
        - `builds EIP-1559 tx with value=0` — verify no native value in approve tx

    **Total: ~23 new tests, ~35 total with Plan 01 tests.**

    Run: `pnpm --filter @waiaas/adapter-evm test`
    Then: `pnpm turbo build && pnpm turbo test` for full monorepo verification.
  </action>
  <verify>
    - `pnpm --filter @waiaas/adapter-evm test` — all tests pass (including Plan 01 tests)
    - `pnpm turbo test` — all monorepo tests pass (no regressions)
    - Test count for adapter-evm: ~35 tests
  </verify>
  <done>
    EvmAdapter has ~35 comprehensive unit tests covering: EIP-1559 buildTransaction (gas margin, nonce, memo), simulate/sign/submit/confirm pipeline, estimateFee 1.2x margin, getCurrentNonce, getTransactionFee, getAssets native, getTokenInfo multicall, buildApprove ERC-20. All tests pass with viem mocked.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo build` — all packages build including adapter-evm
2. `pnpm --filter @waiaas/adapter-evm test` — all ~35 tests pass
3. `pnpm turbo test` — no regressions in other packages (core 124+, adapter-solana 23+, daemon 513+)
4. EvmAdapter TypeScript: no type errors, IChainAdapter 20-method contract satisfied
5. buildTransaction output metadata includes: nonce, chainId, maxFeePerGas, maxPriorityFeePerGas, gasLimit, type: 'eip1559'
6. estimateFee applies 1.2x margin: gasLimit = (estimatedGas * 120n) / 100n
7. buildApprove produces valid ERC-20 approve calldata
</verification>

<success_criteria>
- EVM 네이티브 토큰(ETH) 전송이 EIP-1559 트랜잭션으로 빌드/시뮬레이션/서명/제출된다
- Gas 추정에 1.2x 안전 마진이 적용된다 (estimateGas * 120 / 100)
- Nonce 관리가 viem getTransactionCount 기반으로 동작한다
- ERC-20 approve가 buildApprove 메서드로 동작한다
- getTokenInfo가 viem multicall로 ERC-20 메타데이터를 조회한다
- waitForConfirmation이 viem waitForTransactionReceipt으로 확인을 대기한다
- getAssets가 네이티브 ETH 잔액을 반환한다
- ChainError 매핑이 INSUFFICIENT_BALANCE, NONCE_TOO_LOW 등 올바른 코드를 사용한다
- 전체 monorepo 빌드/테스트 통과 (기존 테스트 회귀 없음)
</success_criteria>

<output>
After completion, create `.planning/phases/77-evm-adapter/77-02-SUMMARY.md`
</output>
