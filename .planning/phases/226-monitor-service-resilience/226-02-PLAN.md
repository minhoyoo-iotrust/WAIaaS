---
phase: 226-monitor-service-resilience
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/incoming/subscription-multiplexer.ts
  - packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts
autonomous: true
requirements: [SUB-05, SUB-06]

must_haves:
  truths:
    - "SubscriptionMultiplexer shares a single connection entry per chain:network key"
    - "Adding multiple wallets to the same chain:network reuses the existing connection entry"
    - "When a connection fails, reconnectLoop drives WS_ACTIVE -> RECONNECTING -> POLLING_FALLBACK transitions"
    - "On successful reconnect, gap recovery callback is invoked with the cursor from incoming_tx_cursors"
    - "removeWallet() unsubscribes the wallet and destroys the connection entry if no wallets remain"
  artifacts:
    - path: "packages/daemon/src/services/incoming/subscription-multiplexer.ts"
      provides: "SubscriptionMultiplexer class with addWallet/removeWallet/getConnectionState/stopAll"
      exports: ["SubscriptionMultiplexer", "MultiplexerDeps"]
    - path: "packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts"
      provides: "Unit tests for connection sharing, reconnection, gap recovery, cleanup"
      min_lines: 100
  key_links:
    - from: "packages/daemon/src/services/incoming/subscription-multiplexer.ts"
      to: "packages/core/src/interfaces/connection-state.ts"
      via: "reconnectLoop import for state management"
      pattern: "import.*reconnectLoop.*from.*@waiaas/core"
    - from: "packages/daemon/src/services/incoming/subscription-multiplexer.ts"
      to: "packages/core/src/interfaces/IChainSubscriber.ts"
      via: "IChainSubscriber interface for subscriber type"
      pattern: "IChainSubscriber"
---

<objective>
Implement SubscriptionMultiplexer: the connection-sharing layer that manages one IChainSubscriber instance per chain:network pair and coordinates wallets subscribing through shared connections. Integrates with reconnectLoop from Phase 225 for resilient reconnection and triggers gap recovery on reconnect.

Purpose: Without multiplexing, each wallet would need its own WebSocket connection. The multiplexer ensures Solana wallets on the same network share a single WebSocket (with per-wallet logsSubscribe calls), and EVM wallets share a single polling subscriber. When connections break, the multiplexer uses the 3-state reconnection machine to recover gracefully.

Output: SubscriptionMultiplexer class + comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/225-chain-subscriber-implementations/225-01-SUMMARY.md
@.planning/phases/225-chain-subscriber-implementations/225-02-SUMMARY.md
@.planning/phases/225-chain-subscriber-implementations/225-03-SUMMARY.md
@.planning/phases/226-monitor-service-resilience/226-RESEARCH.md

Key references:
- IChainSubscriber: packages/core/src/interfaces/IChainSubscriber.ts (6 methods)
- ConnectionState/reconnectLoop: packages/core/src/interfaces/connection-state.ts
- SolanaIncomingSubscriber: packages/adapters/solana/src/solana-incoming-subscriber.ts
- EvmIncomingSubscriber: packages/adapters/evm/src/evm-incoming-subscriber.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SubscriptionMultiplexer with connection sharing + reconnection</name>
  <files>
    packages/daemon/src/services/incoming/subscription-multiplexer.ts
  </files>
  <action>
Create `packages/daemon/src/services/incoming/subscription-multiplexer.ts`:

```typescript
import type { IChainSubscriber, IncomingTransaction, ConnectionState, ReconnectConfig } from '@waiaas/core';
import { reconnectLoop, DEFAULT_RECONNECT_CONFIG } from '@waiaas/core';
```

**Types:**

```typescript
type ConnectionKey = string; // "chain:network" e.g. "solana:mainnet"

interface ConnectionEntry {
  subscriber: IChainSubscriber;
  wallets: Set<string>; // wallet IDs subscribed through this connection
  state: ConnectionState;
  abortController: AbortController; // for cancelling reconnectLoop
}

type SubscriberFactory = (chain: string, network: string) => IChainSubscriber;
type OnTransactionCallback = (tx: IncomingTransaction) => void;
type GapRecoveryCallback = (chain: string, network: string, walletIds: string[]) => Promise<void>;

export interface MultiplexerDeps {
  subscriberFactory: SubscriberFactory;
  onTransaction: OnTransactionCallback;
  onGapRecovery?: GapRecoveryCallback;
  reconnectConfig?: ReconnectConfig;
}
```

**Class `SubscriptionMultiplexer`:**

1. **Constructor(deps: MultiplexerDeps):** Store deps. Initialize `connections = new Map<ConnectionKey, ConnectionEntry>()`.

2. **`async addWallet(chain: string, network: string, walletId: string, walletAddress: string): Promise<void>`:**
   - Compute key = `${chain}:${network}`
   - If connection entry exists: just call `entry.subscriber.subscribe(walletId, walletAddress, deps.onTransaction)` and add walletId to entry.wallets Set
   - If no entry: create subscriber via `deps.subscriberFactory(chain, network)`, create AbortController, add to connections Map. Subscribe the wallet. Call `entry.subscriber.connect()`. Then start `reconnectLoop(entry.subscriber, reconnectConfig, entry.abortController.signal)` in a fire-and-forget `void (async () => { ... })()`. In the reconnect loop's onReconnect callback (when connect succeeds after a disconnect), update `entry.state = 'WS_ACTIVE'` and call `deps.onGapRecovery?.(chain, network, [...entry.wallets])`.
   - Track state transitions: set `entry.state = 'WS_ACTIVE'` after initial connect.

3. **`async removeWallet(chain: string, network: string, walletId: string): Promise<void>`:**
   - Get entry by key. If not found, return.
   - Call `entry.subscriber.unsubscribe(walletId)`
   - Remove walletId from entry.wallets
   - If entry.wallets is empty: abort reconnectLoop, call `entry.subscriber.destroy()`, delete from connections Map.

4. **`getConnectionState(chain: string, network: string): ConnectionState | null`:**
   - Return entry?.state ?? null

5. **`getActiveConnections(): Array<{ key: string; walletCount: number; state: ConnectionState }>`:**
   - Map over connections entries and return summary array

6. **`async stopAll(): Promise<void>`:**
   - For each entry: abort the reconnectLoop, unsubscribe all wallets, destroy subscriber
   - Clear connections Map

Note: The reconnectLoop integration uses the existing `reconnectLoop()` function from @waiaas/core which manages the WS_ACTIVE -> RECONNECTING -> POLLING_FALLBACK state transitions. The multiplexer just tracks state and triggers gap recovery on successful reconnection.

Update `packages/daemon/src/services/incoming/index.ts`:
- Add re-export for `SubscriptionMultiplexer` and `MultiplexerDeps`
  </action>
  <verify>
    pnpm turbo run typecheck --filter=@waiaas/daemon
  </verify>
  <done>
    SubscriptionMultiplexer compiles with addWallet/removeWallet/getConnectionState/getActiveConnections/stopAll
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for SubscriptionMultiplexer</name>
  <files>
    packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts
  </files>
  <action>
Create tests using vitest with mock IChainSubscriber objects.

**Mock setup:**
- `createMockSubscriber()`: returns an object implementing IChainSubscriber with vi.fn() mocks for all 6 methods + pollAll(). `subscribedWallets()` returns wallets tracked internally. `connect()` resolves immediately. `waitForDisconnect()` returns a never-resolving Promise (or one that can be controlled via resolve trigger for disconnect tests). `destroy()` resolves.
- `subscriberFactory`: vi.fn() returning mock subscribers. Track created subscribers to verify sharing.
- `onTransaction`: vi.fn() callback
- `onGapRecovery`: vi.fn() callback

**Test cases:**

1. **Connection sharing:**
   - addWallet('solana', 'mainnet', 'w1', 'addr1') then addWallet('solana', 'mainnet', 'w2', 'addr2') -> subscriberFactory called ONCE (shared connection)
   - subscriber.subscribe called twice (once per wallet)
   - getActiveConnections() returns 1 entry with walletCount: 2

2. **Different networks create separate connections:**
   - addWallet('solana', 'mainnet', ...) + addWallet('solana', 'devnet', ...) -> subscriberFactory called TWICE
   - getActiveConnections() returns 2 entries

3. **removeWallet cleanup:**
   - Add 2 wallets to same connection, remove 1 -> connection still exists, walletCount: 1
   - Remove the last wallet -> connection destroyed, subscriber.destroy() called, getActiveConnections() returns []

4. **getConnectionState:**
   - Before any addWallet -> returns null
   - After addWallet -> returns 'WS_ACTIVE'

5. **stopAll:**
   - Add 3 wallets across 2 connections, call stopAll()
   - All subscribers destroyed, connections Map cleared, getActiveConnections() returns []

6. **Reconnect gap recovery:**
   - (If feasible without complex async orchestration): Verify that onGapRecovery dep is stored and would be called with correct chain/network/walletIds

Note: Testing reconnectLoop integration fully would require complex async coordination. Focus on verifying the multiplexer's connection management logic (sharing, cleanup, state tracking) rather than the reconnection loop itself (already tested in 225-03).
  </action>
  <verify>
    pnpm vitest run packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts
  </verify>
  <done>
    All tests pass covering connection sharing, separate networks, removeWallet cleanup, state tracking, stopAll
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes with 0 errors
2. `pnpm vitest run packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts` -- all tests pass
3. `pnpm turbo run lint --filter=@waiaas/daemon` passes
4. SubscriptionMultiplexer is importable from `packages/daemon/src/services/incoming/index.ts`
</verification>

<success_criteria>
- Single connection entry per chain:network key, verified by subscriberFactory call count
- addWallet subscribes wallet through shared connection
- removeWallet cleans up connection when no wallets remain
- stopAll destroys all subscribers and clears state
- Gap recovery callback stored and wired for post-reconnect invocation
</success_criteria>

<output>
After completion, create `.planning/phases/226-monitor-service-resilience/226-02-SUMMARY.md`
</output>
