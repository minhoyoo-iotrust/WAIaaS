---
phase: 115-core-types-db-migration-parsers
plan: 02
type: tdd
wave: 2
depends_on: ["115-01"]
files_modified:
  - packages/adapters/solana/src/tx-parser.ts
  - packages/adapters/solana/src/adapter.ts
  - packages/adapters/solana/src/index.ts
  - packages/adapters/solana/src/__tests__/solana-sign-only.test.ts
autonomous: true

must_haves:
  truths:
    - "SolanaAdapter.parseTransaction()이 base64 unsigned tx를 받아 ParsedTransaction으로 변환한다"
    - "SystemProgram.transfer가 NATIVE_TRANSFER로 식별되고 to/amount가 추출된다"
    - "SPL Token transferChecked가 TOKEN_TRANSFER로 식별된다"
    - "알 수 없는 프로그램은 CONTRACT_CALL로 분류된다"
    - "SolanaAdapter.signExternalTransaction()이 unsigned tx에 서명하여 SignedTransaction을 반환한다"
    - "잘못된 rawTx는 INVALID_RAW_TRANSACTION ChainError를 발생시킨다"
    - "월렛이 서명자 목록에 없으면 WALLET_NOT_SIGNER ChainError를 발생시킨다"
  artifacts:
    - path: "packages/adapters/solana/src/tx-parser.ts"
      provides: "Solana tx parsing utilities"
      contains: "parseSolanaTransaction"
    - path: "packages/adapters/solana/src/adapter.ts"
      provides: "parseTransaction + signExternalTransaction implementations"
      contains: "parseTransaction"
    - path: "packages/adapters/solana/src/__tests__/solana-sign-only.test.ts"
      provides: "Tests for parse + sign-only"
      contains: "parseTransaction"
  key_links:
    - from: "packages/adapters/solana/src/tx-parser.ts"
      to: "packages/adapters/solana/src/adapter.ts"
      via: "parseSolanaTransaction import"
      pattern: "parseSolanaTransaction"
    - from: "packages/adapters/solana/src/adapter.ts"
      to: "@waiaas/core"
      via: "ParsedTransaction/SignedTransaction type imports"
      pattern: "ParsedTransaction|SignedTransaction"
---

<objective>
SolanaAdapter에 parseTransaction()과 signExternalTransaction()을 구현한다. tx-parser.ts에 Solana unsigned tx 파싱 유틸리티를 분리하고, adapter.ts에서 IChainAdapter 인터페이스 메서드로 통합한다.

Purpose: Solana 체인에서 외부 dApp이 빌드한 unsigned tx를 파싱하여 정책 평가에 필요한 operation 정보를 추출하고, 서명할 수 있게 한다.
Output: tx-parser.ts (파싱 유틸리티), adapter.ts 확장 (2개 메서드), 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/115-core-types-db-migration-parsers/115-RESEARCH.md
@.planning/phases/115-core-types-db-migration-parsers/115-01-SUMMARY.md

@packages/adapters/solana/src/adapter.ts
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/errors/chain-error.ts
</context>

<feature>
  <name>Solana parseTransaction + signExternalTransaction</name>
  <files>
    packages/adapters/solana/src/tx-parser.ts
    packages/adapters/solana/src/adapter.ts
    packages/adapters/solana/src/index.ts
    packages/adapters/solana/src/__tests__/solana-sign-only.test.ts
  </files>
  <behavior>
    **parseTransaction(rawTx: string) -> ParsedTransaction:**

    Cases:
    - base64(SystemProgram.transfer tx) -> { operations: [{ type: 'NATIVE_TRANSFER', to: recipientAddr, amount: lamports }], rawTx }
    - base64(SPL Token transferChecked tx) -> { operations: [{ type: 'TOKEN_TRANSFER', token: mintAddr, to: destAddr, amount }], rawTx }
    - base64(SPL Token approve/approveChecked) -> { operations: [{ type: 'APPROVE', token: mintAddr, to: delegateAddr }], rawTx }
    - base64(unknown program instruction) -> { operations: [{ type: 'CONTRACT_CALL', programId: addr, method: first8bytesHex }], rawTx }
    - base64(multi-instruction tx) -> { operations: [op1, op2, ...], rawTx }  (multiple ops)
    - "invalid base64" -> throws ChainError('INVALID_RAW_TRANSACTION', 'solana')
    - base64(corrupted bytes) -> throws ChainError('INVALID_RAW_TRANSACTION', 'solana')

    **signExternalTransaction(rawTx: string, privateKey: Uint8Array) -> SignedTransaction:**

    Cases:
    - base64(valid tx with wallet as feePayer) + matching privateKey -> { signedTransaction: base64SignedTx }
    - base64(valid tx) + privateKey for non-signer wallet -> throws ChainError('WALLET_NOT_SIGNER', 'solana')
    - "invalid base64" + any key -> throws ChainError('INVALID_RAW_TRANSACTION', 'solana')
  </behavior>
  <implementation>
    **tx-parser.ts** (NEW file, ~120 lines):

    1. Import from @solana/kit: `getCompiledTransactionMessageDecoder`, `getTransactionDecoder`, `address`
    2. Import program addresses: `SYSTEM_PROGRAM_ADDRESS` from @solana-program/system, `TOKEN_PROGRAM_ADDRESS` from @solana-program/token
    3. Define TOKEN_2022 address constant: `'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'`
    4. Define instruction discriminators:
       - SystemProgram Transfer: index 2 (LE u32 at bytes 0-3), amount LE u64 at bytes 4-11
       - SPL Token TransferChecked: byte 0 = 12, amount LE u64 at bytes 1-8
       - SPL Token Approve: byte 0 = 4
       - SPL Token ApproveChecked: byte 0 = 13
    5. Export function `parseSolanaTransaction(rawTx: string): ParsedTransaction`:
       - Decode base64 to Uint8Array. Wrap in try/catch -> ChainError('INVALID_RAW_TRANSACTION') on failure.
       - Use `getTransactionDecoder().decode(bytes)` to get `{ messageBytes, signatures }`.
       - Use `getCompiledTransactionMessageDecoder().decode(messageBytes)` to get compiledMessage.
       - For each instruction in `compiledMessage.instructions`:
         - Resolve programAddress via `compiledMessage.staticAccounts[instruction.programAddressIndex]`
         - Resolve account addresses via `instruction.accountIndices.map(i => compiledMessage.staticAccounts[i])`
         - Call `identifyOperation(programAddress, instruction.data, accounts)` to get ParsedOperation
       - Return `{ operations, rawTx }`
    6. Internal function `identifyOperation(programAddress, data, accounts)`:
       - If programAddress === SYSTEM_PROGRAM_ADDRESS: parse SystemProgram instruction by index
         - Index 2 (Transfer): NATIVE_TRANSFER with amount from bytes 4-11
         - Other: CONTRACT_CALL with method = hex of first 4 bytes
       - If programAddress === TOKEN_PROGRAM_ADDRESS or TOKEN_2022:
         - Byte 0 === 12 (TransferChecked): TOKEN_TRANSFER
         - Byte 0 === 4 or 13 (Approve/ApproveChecked): APPROVE
         - Other: CONTRACT_CALL
       - Else: CONTRACT_CALL with programId and method = hex of first 8 bytes (Anchor discriminator)

    **adapter.ts** additions (~50 lines):

    1. Import `ParsedTransaction`, `SignedTransaction` from @waiaas/core
    2. Import `parseSolanaTransaction` from './tx-parser.js'
    3. Import `ChainError` from @waiaas/core (already imported)
    4. Add `parseTransaction(rawTx: string)` method: delegate to `parseSolanaTransaction(rawTx)` (no RPC needed)
    5. Add `signExternalTransaction(rawTx: string, privateKey: Uint8Array)` method:
       - Decode base64 rawTx via `Buffer.from(rawTx, 'base64')` -> bytes
       - Decode via `txDecoder.decode(bytes)` to get compiled tx (try/catch -> INVALID_RAW_TRANSACTION)
       - Create keyPair from privateKey (reuse existing pattern: 64-byte vs 32-byte detection)
       - Get signerAddress via `getAddressFromPublicKey(keyPair.publicKey)`
       - Check signerAddress exists in `Object.keys(compiled.signatures)` -- if not, throw ChainError('WALLET_NOT_SIGNER')
       - Sign with `signBytes(keyPair.privateKey, compiled.messageBytes)`
       - Place signature: `{ ...compiled, signatures: { ...compiled.signatures, [signerAddress]: signature } }`
       - Re-encode: `txEncoder.encode(signedTx)` -> base64
       - Return `{ signedTransaction: base64String }`

    **index.ts**: re-export tx-parser module's public API if needed (optional, adapter uses it internally)

    **Test fixtures strategy:**
    - Build test transactions using the existing adapter's `buildTransaction()` / `buildTokenTransfer()` methods with mock RPC
    - Serialize to base64 for parseTransaction input
    - For signExternalTransaction, use the same test key pair pattern from existing adapter tests
    - For error cases, use known-bad base64 strings and mismatched keys
  </implementation>
</feature>

<verification>
1. `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo run build --filter=@waiaas/adapter-solana` -- 빌드 성공
2. `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo run test --filter=@waiaas/adapter-solana -- --grep "sign-only"` -- 모든 테스트 통과
3. parseTransaction: SystemProgram.transfer, SPL transferChecked, CONTRACT_CALL 식별 테스트
4. signExternalTransaction: 정상 서명, WALLET_NOT_SIGNER 에러, INVALID_RAW_TRANSACTION 에러 테스트
</verification>

<success_criteria>
- SolanaAdapter가 IChainAdapter의 22개 메서드를 모두 구현 (20 기존 + 2 신규)
- parseTransaction이 NATIVE_TRANSFER, TOKEN_TRANSFER, APPROVE, CONTRACT_CALL을 정확히 식별
- signExternalTransaction이 올바른 서명을 생성하고 base64 반환
- 에러 경로 테스트: INVALID_RAW_TRANSACTION, WALLET_NOT_SIGNER
- 모든 기존 Solana adapter 테스트 계속 통과
</success_criteria>

<output>
After completion, create `.planning/phases/115-core-types-db-migration-parsers/115-02-SUMMARY.md`
</output>
