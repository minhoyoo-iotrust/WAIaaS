---
phase: 56-pipeline-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/pipeline/pipeline.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/__tests__/pipeline-integration.test.ts
autonomous: true

must_haves:
  truths:
    - "stage2Auth sets sessionId on PipelineContext from the Hono request context"
    - "stage1Validate inserts sessionId into transactions table at PENDING INSERT"
    - "stage3Policy uses evaluateAndReserve for TOCTOU-safe policy evaluation"
    - "stage3Policy calls downgradeIfNoOwner when tier is APPROVAL and owner is NONE"
    - "sessionId appears in the transactions row after stage1 completes"
  artifacts:
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "Updated stage2Auth (sessionId), stage3Policy (evaluateAndReserve + downgrade)"
      contains: "sessionId"
    - path: "packages/daemon/src/pipeline/pipeline.ts"
      provides: "Updated PipelineDeps with workflow deps and sqlite"
      contains: "sqlite"
    - path: "packages/daemon/src/__tests__/pipeline-integration.test.ts"
      provides: "TDD tests for stage2Auth sessionId and stage3Policy integration"
  key_links:
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/pipeline/stages.ts"
      via: "sessionId passed from Hono c.get('sessionId') to PipelineContext"
      pattern: "sessionId"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/pipeline/database-policy-engine.ts"
      via: "stage3Policy calls evaluateAndReserve instead of evaluate"
      pattern: "evaluateAndReserve"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/workflow/owner-state.ts"
      via: "stage3Policy calls downgradeIfNoOwner"
      pattern: "downgradeIfNoOwner"
---

<objective>
Integrate stage2Auth (session token -> sessionId) and stage3Policy (DatabasePolicyEngine.evaluateAndReserve + Owner downgrade) into the transaction pipeline, with sessionId audit trail on every transaction.

Purpose: The pipeline stages 2 and 3 are currently no-ops or use the basic evaluate() call. This plan wires them to the real auth context and TOCTOU-safe policy evaluation with owner downgrade logic, enabling proper audit trails and security tier classification.

Output: Updated stages.ts with real stage2Auth/stage3Policy, updated PipelineContext/PipelineDeps with sessionId and workflow deps, transaction INSERT includes sessionId, TDD tests proving the integration.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-workflow-owner-state/55-03-SUMMARY.md
@.planning/phases/54-policy-engine/54-01-SUMMARY.md
@.planning/phases/54-policy-engine/54-02-SUMMARY.md

# Source files to read
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/pipeline/pipeline.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/daemon/src/workflow/owner-state.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/api/middleware/session-auth.ts
@packages/core/src/interfaces/IPolicyEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED -- Failing tests for stage2Auth sessionId + stage3Policy integration</name>
  <files>packages/daemon/src/__tests__/pipeline-integration.test.ts</files>
  <action>
Create a new test file `pipeline-integration.test.ts` with TDD failing tests for:

**Setup:** Use in-memory SQLite + Drizzle + pushSchema pattern (same as pipeline.test.ts / database-policy-engine.test.ts). Create a test agent and insert a SPENDING_LIMIT policy for the agent.

**Test group 1: stage2Auth sessionId**

1. "stage2Auth sets ctx.sessionId from provided value" -- Create a PipelineContext with `sessionId: 'sess_123'`. Call `stage2Auth(ctx)`. Verify `ctx.sessionId` is still `'sess_123'` (no-op pass-through, just ensures field is on context).

2. "stage1Validate inserts sessionId into transactions table" -- Create a PipelineContext with `sessionId: 'sess_abc'`. Call `stage1Validate(ctx)`. Query the transaction row from DB and verify `sessionId === 'sess_abc'`.

3. "stage1Validate inserts null sessionId when not provided" -- Create PipelineContext without sessionId. Call `stage1Validate(ctx)`. Query row, verify sessionId is null.

**Test group 2: stage3Policy with evaluateAndReserve**

4. "stage3Policy calls evaluateAndReserve for TOCTOU-safe evaluation" -- Create a DatabasePolicyEngine instance with sqlite. Insert a SPENDING_LIMIT policy (instant_max='100', notify_max='500', delay_max='1000'). Set PipelineContext policyEngine to the DatabasePolicyEngine. Call `stage3Policy(ctx)` with amount='50'. Verify `ctx.tier === 'INSTANT'` and the transaction row has `reserved_amount = '50'`.

5. "stage3Policy sets DELAY tier with delaySeconds in metadata" -- Same setup but amount='700' (between notify_max and delay_max). Verify `ctx.tier === 'DELAY'` and the transaction row has `tier === 'DELAY'`.

6. "stage3Policy denies transaction when policy says not allowed" -- Insert a WHITELIST policy with allowed_addresses=['addr1']. Send to 'addr_not_whitelisted'. Verify stage3Policy throws WAIaaSError('POLICY_DENIED') and transaction status is 'CANCELLED'.

**Test group 3: downgradeIfNoOwner integration**

7. "stage3Policy downgrades APPROVAL to DELAY when owner is NONE" -- Create agent with no owner_address. Insert SPENDING_LIMIT policy where amount triggers APPROVAL. Call stage3Policy. Verify `ctx.tier === 'DELAY'` (not APPROVAL) and `ctx.downgraded === true`.

8. "stage3Policy keeps APPROVAL when owner exists" -- Create agent with owner_address set. Insert SPENDING_LIMIT policy where amount triggers APPROVAL. Verify `ctx.tier === 'APPROVAL'`.

All tests should FAIL because:
- PipelineContext doesn't have sessionId yet
- stage1Validate doesn't insert sessionId yet
- stage3Policy doesn't use evaluateAndReserve yet
- stage3Policy doesn't call downgradeIfNoOwner yet

Run `pnpm --filter @waiaas/daemon test -- --run pipeline-integration` and verify they fail.

Commit: `test(56-01): add failing tests for pipeline stage2Auth + stage3Policy integration`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-integration.test.ts 2>&1 | grep -E "FAIL|fail|Tests"</verify>
  <done>8 tests exist in pipeline-integration.test.ts and all FAIL (RED phase)</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN -- Implement stage2Auth + stage3Policy + sessionId audit trail</name>
  <files>
packages/daemon/src/pipeline/stages.ts
packages/daemon/src/pipeline/pipeline.ts
packages/daemon/src/api/routes/transactions.ts
packages/daemon/src/__tests__/pipeline-integration.test.ts
  </files>
  <action>
**1. Update PipelineContext in stages.ts:**

Add to PipelineContext interface:
- `sessionId?: string;` -- session ID from JWT for audit trail
- `sqlite?: SQLiteDatabase;` -- raw better-sqlite3 for evaluateAndReserve
- `delaySeconds?: number;` -- delay seconds from policy evaluation (DELAY tier)
- `downgraded?: boolean;` -- true if APPROVAL was downgraded to DELAY

Import `Database as SQLiteDatabase` from `better-sqlite3`.
Import `downgradeIfNoOwner` from `../workflow/owner-state.js`.
Import `DatabasePolicyEngine` from `./database-policy-engine.js`.
Import `agents` from the schema (needed for owner lookup in downgrade).

**2. Update stage1Validate in stages.ts:**

In the INSERT statement, add `sessionId: ctx.sessionId ?? null` to the values object. The schema already has the `sessionId` column.

**3. Update stage2Auth in stages.ts:**

Replace the no-op with a simple comment noting that sessionId is already set on the context by the route handler. Stage 2 is now effectively a passthrough that validates sessionId presence (it was set by the middleware already). The key change is that sessionId EXISTS on PipelineContext now, and the route handler sets it.

```typescript
export async function stage2Auth(ctx: PipelineContext): Promise<void> {
  // sessionId is set on PipelineContext by the route handler from Hono c.get('sessionId').
  // In v1.2 this stage validates session is still active.
  // For now, the sessionAuth middleware already validated the JWT and set sessionId.
}
```

**4. Update stage3Policy in stages.ts:**

Replace the current evaluate() call with evaluateAndReserve() when the policyEngine is a DatabasePolicyEngine instance:

```typescript
export async function stage3Policy(ctx: PipelineContext): Promise<void> {
  let evaluation;

  // Use evaluateAndReserve for TOCTOU-safe evaluation when DatabasePolicyEngine + sqlite available
  if (ctx.policyEngine instanceof DatabasePolicyEngine && ctx.sqlite) {
    evaluation = (ctx.policyEngine as DatabasePolicyEngine).evaluateAndReserve(
      ctx.agentId,
      {
        type: 'TRANSFER',
        amount: ctx.request.amount,
        toAddress: ctx.request.to,
        chain: ctx.agent.chain,
      },
      ctx.txId,
    );
  } else {
    evaluation = await ctx.policyEngine.evaluate(ctx.agentId, {
      type: 'TRANSFER',
      amount: ctx.request.amount,
      toAddress: ctx.request.to,
      chain: ctx.agent.chain,
    });
  }

  if (!evaluation.allowed) {
    await ctx.db
      .update(transactions)
      .set({ status: 'CANCELLED', error: evaluation.reason ?? 'Policy denied' })
      .where(eq(transactions.id, ctx.txId));

    throw new WAIaaSError('POLICY_DENIED', {
      message: evaluation.reason ?? 'Transaction denied by policy',
    });
  }

  let tier = evaluation.tier;
  let downgraded = false;

  // Check for APPROVAL -> DELAY downgrade when no owner registered
  if (tier === 'APPROVAL') {
    // Look up agent owner fields
    const agentRow = await ctx.db.select().from(agents).where(eq(agents.id, ctx.agentId)).get();
    if (agentRow) {
      const result = downgradeIfNoOwner(
        {
          ownerAddress: agentRow.ownerAddress ?? null,
          ownerVerified: agentRow.ownerVerified ?? false,
        },
        tier,
      );
      tier = result.tier as PolicyTier;
      downgraded = result.downgraded;
    }
  }

  // Set tier and metadata on context
  ctx.tier = tier;
  ctx.downgraded = downgraded;
  if (evaluation.delaySeconds !== undefined) {
    ctx.delaySeconds = evaluation.delaySeconds;
  }

  // Update DB with tier
  await ctx.db
    .update(transactions)
    .set({ tier })
    .where(eq(transactions.id, ctx.txId));
}
```

**5. Update PipelineDeps in pipeline.ts:**

Add `sqlite?: SQLiteDatabase` to PipelineDeps. Pass it through to PipelineContext in executeSend.

**6. Update transactionRoutes in transactions.ts:**

In the PipelineContext construction inside POST /transactions/send:
- Add `sessionId: c.get('sessionId' as never) as string | undefined` to capture from Hono context
- Add `sqlite: deps.sqlite` when available (need to add `sqlite?: SQLiteDatabase` to TransactionRouteDeps)

Also update the server.ts transactionRoutes call to pass `sqlite: deps.sqlite`.

**7. Fix any TS errors, then run tests:**

Run `pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose` to verify:
- All 8 new pipeline-integration tests pass (GREEN)
- All pre-existing tests still pass (no regressions)

Commit: `feat(56-01): implement stage2Auth sessionId + stage3Policy evaluateAndReserve + downgrade`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose 2>&1 | tail -5</verify>
  <done>All 8 pipeline-integration tests pass, all pre-existing daemon tests pass with zero regressions, stage3Policy uses evaluateAndReserve + downgradeIfNoOwner, stage1Validate inserts sessionId</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-integration.test.ts` -- all 8 tests pass
2. `pnpm --filter @waiaas/daemon exec vitest run` -- all daemon tests pass (no regressions)
3. `pnpm --filter @waiaas/daemon exec tsc --noEmit` -- zero TypeScript errors
4. Verify stage3Policy uses `evaluateAndReserve` (not just `evaluate`) when DatabasePolicyEngine is available
5. Verify stage1Validate INSERTs sessionId into transactions table
6. Verify stage3Policy calls downgradeIfNoOwner for APPROVAL tier
</verification>

<success_criteria>
- PipelineContext has sessionId, sqlite, delaySeconds, downgraded fields
- stage1Validate inserts sessionId into transactions table (audit trail)
- stage2Auth is documented as passthrough (sessionId set by route handler)
- stage3Policy uses evaluateAndReserve for TOCTOU-safe policy evaluation
- stage3Policy downgrades APPROVAL to DELAY when owner is NONE
- 8 TDD tests prove the integration
- Zero regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/56-pipeline-integration/56-01-SUMMARY.md`
</output>
