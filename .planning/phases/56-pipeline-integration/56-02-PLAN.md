---
phase: 56-pipeline-integration
plan: 02
type: tdd
wave: 2
depends_on: ["56-01"]
files_modified:
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/pipeline-stage4.test.ts
autonomous: true

must_haves:
  truths:
    - "stage4Wait queues DELAY tier transactions via DelayQueue.queueDelay() and halts pipeline"
    - "stage4Wait creates pending approval for APPROVAL tier via ApprovalWorkflow.requestApproval() and halts pipeline"
    - "stage4Wait passes through INSTANT and NOTIFY tier transactions to stage5"
    - "BackgroundWorkers process expired DELAY and APPROVAL transactions periodically"
    - "Expired DELAY transactions re-enter pipeline at stage5Execute for on-chain execution"
    - "transactions table records sessionId for audit trail on every transaction"
  artifacts:
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "stage4Wait implementation with DELAY/APPROVAL branching"
      contains: "queueDelay"
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "BackgroundWorkers registration for delay-expired and approval-expired"
      contains: "delay-expired"
    - path: "packages/daemon/src/__tests__/pipeline-stage4.test.ts"
      provides: "TDD tests for stage4Wait DELAY, APPROVAL, INSTANT, NOTIFY paths"
  key_links:
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/workflow/delay-queue.ts"
      via: "stage4Wait calls delayQueue.queueDelay()"
      pattern: "queueDelay"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/workflow/approval-workflow.ts"
      via: "stage4Wait calls approvalWorkflow.requestApproval()"
      pattern: "requestApproval"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/workflow/delay-queue.ts"
      via: "BackgroundWorkers registers processExpired handler"
      pattern: "processExpired"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/workflow/approval-workflow.ts"
      via: "BackgroundWorkers registers processExpiredApprovals handler"
      pattern: "processExpiredApprovals"
---

<objective>
Implement stage4Wait with DELAY/APPROVAL branching and wire BackgroundWorkers to process expired transactions, completing the full 6-stage pipeline integration.

Purpose: Stage 4 is the critical decision point where DELAY tier transactions get queued with a cooldown and APPROVAL tier transactions wait for owner sign-off. Without this stage, all non-INSTANT transactions have no execution path. BackgroundWorkers must also process expired delays and approvals to ensure transactions eventually complete.

Output: stage4Wait implementation, BackgroundWorkers registrations for delay-expired and approval-expired, transactionRoutes wiring for workflow deps, TDD tests proving the stage4 branching logic.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-pipeline-integration/56-01-SUMMARY.md
@.planning/phases/55-workflow-owner-state/55-01-SUMMARY.md
@.planning/phases/55-workflow-owner-state/55-02-SUMMARY.md

# Source files to read
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/pipeline/pipeline.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/lifecycle/workers.ts
@packages/daemon/src/workflow/delay-queue.ts
@packages/daemon/src/workflow/approval-workflow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED -- Failing tests for stage4Wait DELAY/APPROVAL/INSTANT branching</name>
  <files>packages/daemon/src/__tests__/pipeline-stage4.test.ts</files>
  <action>
Create a new test file `pipeline-stage4.test.ts` with TDD failing tests for stage4Wait.

**Setup:** Use in-memory SQLite + Drizzle + pushSchema pattern. Create test helpers for:
- Creating a test agent (with and without owner)
- Creating a PENDING transaction in DB
- Creating PipelineContext with tier already set (stage3 ran before stage4)
- DelayQueue and ApprovalWorkflow instances with the test sqlite

**Test group 1: INSTANT/NOTIFY passthrough**

1. "stage4Wait passes through INSTANT tier (no queue, no approval)" -- Set `ctx.tier = 'INSTANT'`. Call `stage4Wait(ctx)`. Verify transaction status remains PENDING (not QUEUED). Verify no pending_approvals row exists. Verify the function returns normally (doesn't throw).

2. "stage4Wait passes through NOTIFY tier (no queue, no approval)" -- Same as above with `ctx.tier = 'NOTIFY'`. Verify passthrough behavior.

**Test group 2: DELAY tier**

3. "stage4Wait queues DELAY tier via DelayQueue.queueDelay()" -- Set `ctx.tier = 'DELAY'` and `ctx.delaySeconds = 300`. Call `stage4Wait(ctx)`. Verify:
   - Transaction status changed to 'QUEUED' in DB
   - Transaction `queued_at` is set
   - Transaction metadata contains `delaySeconds: 300`
   - The function throws a specific "PIPELINE_HALTED" or similar sentinel (or returns void and the async pipeline checks status after stage4)

4. "stage4Wait uses default delaySeconds when not set on ctx" -- Set `ctx.tier = 'DELAY'` without delaySeconds. Verify queueDelay is called with a default (e.g., 60 seconds from config or hardcoded).

**Test group 3: APPROVAL tier**

5. "stage4Wait creates pending approval for APPROVAL tier" -- Set `ctx.tier = 'APPROVAL'`. Call `stage4Wait(ctx)`. Verify:
   - Transaction status changed to 'QUEUED' in DB
   - A pending_approvals row exists with tx_id matching
   - The pending_approvals row has expires_at set

6. "stage4Wait halts pipeline for APPROVAL tier (no stage5 execution)" -- Set ctx.tier = 'APPROVAL'. Call stage4Wait. Verify the function signals pipeline halt (throws PIPELINE_HALTED or similar).

**Test group 4: Pipeline halt mechanism**

7. "async pipeline stops at stage4 for DELAY tier" -- Simulate the full async pipeline flow (stage2->stage3->stage4->stage5->stage6) with DELAY tier. Verify stage5Execute is NOT called (transaction stays QUEUED, not SUBMITTED).

8. "async pipeline stops at stage4 for APPROVAL tier" -- Same but with APPROVAL tier.

All tests should FAIL because stage4Wait is currently a no-op.

Run tests and verify they fail.

Commit: `test(56-02): add failing tests for stage4Wait DELAY/APPROVAL branching`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-stage4.test.ts 2>&1 | grep -E "FAIL|fail|Tests"</verify>
  <done>8 tests exist in pipeline-stage4.test.ts and all FAIL (RED phase)</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN -- Implement stage4Wait + BackgroundWorkers + pipeline wiring</name>
  <files>
packages/daemon/src/pipeline/stages.ts
packages/daemon/src/api/routes/transactions.ts
packages/daemon/src/api/server.ts
packages/daemon/src/lifecycle/daemon.ts
packages/daemon/src/__tests__/pipeline-stage4.test.ts
  </files>
  <action>
**1. Add workflow deps to PipelineContext (stages.ts):**

Add to PipelineContext interface (if not already from 56-01):
- `delayQueue?: DelayQueue;`
- `approvalWorkflow?: ApprovalWorkflow;`
- `config?: { policy_defaults_delay_seconds: number; policy_defaults_approval_timeout: number };`

Import DelayQueue, ApprovalWorkflow types.

**2. Implement stage4Wait (stages.ts):**

Replace the no-op with real branching logic:

```typescript
export async function stage4Wait(ctx: PipelineContext): Promise<void> {
  const tier = ctx.tier;

  // INSTANT and NOTIFY: pass through to stage5
  if (tier === 'INSTANT' || tier === 'NOTIFY') {
    return;
  }

  // DELAY: queue with cooldown, halt pipeline
  if (tier === 'DELAY') {
    if (!ctx.delayQueue) {
      // Fallback: if no DelayQueue, treat as INSTANT (backward compat)
      return;
    }
    const delaySeconds = ctx.delaySeconds
      ?? ctx.config?.policy_defaults_delay_seconds
      ?? 60;
    ctx.delayQueue.queueDelay(ctx.txId, delaySeconds);

    // Halt pipeline -- transaction will be picked up by processExpired worker
    throw new WAIaaSError('PIPELINE_HALTED', {
      message: `Transaction ${ctx.txId} queued for ${delaySeconds}s delay`,
    });
  }

  // APPROVAL: create pending approval, halt pipeline
  if (tier === 'APPROVAL') {
    if (!ctx.approvalWorkflow) {
      // Fallback: if no ApprovalWorkflow, treat as INSTANT (backward compat)
      return;
    }
    ctx.approvalWorkflow.requestApproval(ctx.txId);

    // Halt pipeline -- transaction will be picked up by approve/reject/expire
    throw new WAIaaSError('PIPELINE_HALTED', {
      message: `Transaction ${ctx.txId} queued for owner approval`,
    });
  }
}
```

**3. Add PIPELINE_HALTED error code to @waiaas/core if needed:**

Check if `PIPELINE_HALTED` already exists in error codes. If not, add it to the PIPELINE domain errors. Alternatively, use a non-error mechanism: instead of throwing, stage4Wait could set `ctx.halted = true` and the pipeline loop checks after each stage. Choose the approach that cleanly integrates with the existing async pipeline error handler in transactions.ts.

Key consideration: the async pipeline fire-and-forget in transactions.ts catches errors and marks tx as FAILED. PIPELINE_HALTED is NOT an error -- it's an intentional stop. The error handler must recognize this:

In transactions.ts async pipeline block:
```typescript
void (async () => {
  try {
    await stage2Auth(ctx);
    await stage3Policy(ctx);
    await stage4Wait(ctx);
    await stage5Execute(ctx);
    await stage6Confirm(ctx);
  } catch (error) {
    // PIPELINE_HALTED is intentional -- do NOT mark as FAILED
    if (error instanceof WAIaaSError && error.code === 'PIPELINE_HALTED') {
      return; // Transaction is QUEUED, waiting for delay/approval
    }
    // ... existing error handling for real failures
  }
})();
```

**4. Pass workflow deps through transactionRoutes -> PipelineContext:**

In transactions.ts POST /transactions/send, add to the PipelineContext construction:
- `delayQueue: deps.delayQueue`
- `approvalWorkflow: deps.approvalWorkflow`
- `config: deps.config` (need to add config to TransactionRouteDeps)

Update TransactionRouteDeps:
- `config?: { policy_defaults_delay_seconds: number; policy_defaults_approval_timeout: number };`

**5. Update server.ts to pass config to transactionRoutes:**

In server.ts transactionRoutes call, add `config: deps.config ? { policy_defaults_delay_seconds: deps.config.policy.defaults_delay_seconds ?? 60, policy_defaults_approval_timeout: deps.config.policy.defaults_approval_timeout ?? 3600 } : undefined`. Match the config shape that transactionRoutes expects.

Actually, check the actual DaemonConfig shape first. The config may use `deps.config.policy_defaults_delay_seconds` or a nested structure. Match what exists.

**6. Register BackgroundWorkers in daemon.ts:**

In DaemonLifecycle Step 6, after the existing wal-checkpoint and session-cleanup workers, add:

```typescript
// Register delay-expired worker (every 5 seconds: check for expired DELAY transactions)
if (this.delayQueue) {
  this.workers.register('delay-expired', {
    interval: 5_000,
    handler: () => {
      if (this._isShuttingDown) return;
      const now = Math.floor(Date.now() / 1000);
      const expired = this.delayQueue!.processExpired(now);
      // For each expired tx, re-enter pipeline at stage5
      for (const tx of expired) {
        void this.executeFromStage5(tx.txId, tx.agentId);
      }
    },
  });
}

// Register approval-expired worker (every 30 seconds: expire timed-out approvals)
if (this.approvalWorkflow) {
  this.workers.register('approval-expired', {
    interval: 30_000,
    handler: () => {
      if (this._isShuttingDown) return;
      const now = Math.floor(Date.now() / 1000);
      this.approvalWorkflow!.processExpiredApprovals(now);
    },
  });
}
```

The `executeFromStage5` method needs to be added to DaemonLifecycle. It:
1. Looks up the agent for the transaction
2. Creates a minimal PipelineContext with the right deps
3. Runs stage5Execute + stage6Confirm
4. Catches errors and updates tx to FAILED

This requires DaemonLifecycle to have access to adapter, keyStore, masterPassword, db (which it already does from the init steps).

Note: Store `delayQueue` and `approvalWorkflow` as instance fields on DaemonLifecycle, created in Step 3 or Step 4 when sqlite is available.

**7. Fix tests to pass:**

Adjust test assertions based on the actual implementation (PIPELINE_HALTED throw vs halted flag). Ensure all 8 tests in pipeline-stage4.test.ts pass.

Run full test suite and verify:
- All 8 new tests pass
- All pre-existing tests pass (no regressions)

Commit: `feat(56-02): implement stage4Wait DELAY/APPROVAL + BackgroundWorkers integration`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose 2>&1 | tail -5</verify>
  <done>All 8 pipeline-stage4 tests pass, all daemon tests pass with zero regressions, stage4Wait queues DELAY and APPROVAL tiers, INSTANT/NOTIFY pass through, BackgroundWorkers registered for delay-expired and approval-expired</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-stage4.test.ts` -- all 8 tests pass
2. `pnpm --filter @waiaas/daemon exec vitest run` -- all daemon tests pass (no regressions)
3. `pnpm --filter @waiaas/daemon exec tsc --noEmit` -- zero TypeScript errors
4. Verify stage4Wait correctly branches on tier (INSTANT/NOTIFY passthrough, DELAY queueDelay, APPROVAL requestApproval)
5. Verify PIPELINE_HALTED is handled in the async pipeline error handler (not marked as FAILED)
6. Verify BackgroundWorkers in daemon.ts registers delay-expired and approval-expired workers
7. Verify DaemonLifecycle.executeFromStage5 re-enters pipeline for expired delay transactions
</verification>

<success_criteria>
- stage4Wait queues DELAY tier via DelayQueue.queueDelay() and halts pipeline
- stage4Wait creates pending approval for APPROVAL tier via ApprovalWorkflow.requestApproval() and halts pipeline
- stage4Wait passes through INSTANT and NOTIFY tiers
- PIPELINE_HALTED is not treated as a failure in the async pipeline
- BackgroundWorkers processes expired delays (every 5s) and approvals (every 30s)
- Expired delay transactions re-enter pipeline at stage5Execute
- 8 TDD tests prove the branching logic
- Zero regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/56-pipeline-integration/56-02-SUMMARY.md`
</output>
