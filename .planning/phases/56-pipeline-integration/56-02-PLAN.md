---
phase: 56-pipeline-integration
plan: 02
type: tdd
wave: 2
depends_on: ["56-01"]
files_modified:
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/pipeline-stage4.test.ts
autonomous: true

must_haves:
  truths:
    - "stage4Wait queues DELAY tier transactions via DelayQueue.queueDelay() and halts pipeline"
    - "stage4Wait creates pending approval for APPROVAL tier via ApprovalWorkflow.requestApproval() and halts pipeline"
    - "stage4Wait passes through INSTANT and NOTIFY tier transactions to stage5"
    - "BackgroundWorkers process expired DELAY and APPROVAL transactions periodically"
    - "Expired DELAY transactions re-enter pipeline at stage5Execute for on-chain execution"
    - "transactions table records sessionId for audit trail on every transaction"
  artifacts:
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "stage4Wait implementation with DELAY/APPROVAL branching"
      contains: "queueDelay"
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "BackgroundWorkers registration for delay-expired and approval-expired"
      contains: "delay-expired"
    - path: "packages/daemon/src/__tests__/pipeline-stage4.test.ts"
      provides: "TDD tests for stage4Wait DELAY, APPROVAL, INSTANT, NOTIFY paths + executeFromStage5 re-entry"
  key_links:
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/workflow/delay-queue.ts"
      via: "stage4Wait calls delayQueue.queueDelay()"
      pattern: "queueDelay"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/workflow/approval-workflow.ts"
      via: "stage4Wait calls approvalWorkflow.requestApproval()"
      pattern: "requestApproval"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/workflow/delay-queue.ts"
      via: "BackgroundWorkers registers processExpired handler"
      pattern: "processExpired"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/workflow/approval-workflow.ts"
      via: "BackgroundWorkers registers processExpiredApprovals handler"
      pattern: "processExpiredApprovals"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/pipeline/stages.ts"
      via: "executeFromStage5 constructs PipelineContext and calls stage5Execute + stage6Confirm"
      pattern: "executeFromStage5"
---

<objective>
Implement stage4Wait with DELAY/APPROVAL branching and wire BackgroundWorkers to process expired transactions, completing the full 6-stage pipeline integration.

Purpose: Stage 4 is the critical decision point where DELAY tier transactions get queued with a cooldown and APPROVAL tier transactions wait for owner sign-off. Without this stage, all non-INSTANT transactions have no execution path. BackgroundWorkers must also process expired delays and approvals to ensure transactions eventually complete.

Output: stage4Wait implementation, BackgroundWorkers registrations for delay-expired and approval-expired, transactionRoutes wiring for workflow deps, TDD tests proving the stage4 branching logic.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-pipeline-integration/56-01-SUMMARY.md
@.planning/phases/55-workflow-owner-state/55-01-SUMMARY.md
@.planning/phases/55-workflow-owner-state/55-02-SUMMARY.md

# Source files to read
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/pipeline/pipeline.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/lifecycle/workers.ts
@packages/daemon/src/workflow/delay-queue.ts
@packages/daemon/src/workflow/approval-workflow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED -- Failing tests for stage4Wait DELAY/APPROVAL/INSTANT branching</name>
  <files>packages/daemon/src/__tests__/pipeline-stage4.test.ts</files>
  <action>
Create a new test file `pipeline-stage4.test.ts` with TDD failing tests for stage4Wait.

**Setup:** Use in-memory SQLite + Drizzle + pushSchema pattern. Create test helpers for:
- Creating a test agent (with and without owner)
- Creating a PENDING transaction in DB
- Creating PipelineContext with tier already set (stage3 ran before stage4)
- DelayQueue and ApprovalWorkflow instances with the test sqlite

**Test group 1: INSTANT/NOTIFY passthrough**

1. "stage4Wait passes through INSTANT tier (no queue, no approval)" -- Set `ctx.tier = 'INSTANT'`. Call `stage4Wait(ctx)`. Verify transaction status remains PENDING (not QUEUED). Verify no pending_approvals row exists. Verify the function returns normally (doesn't throw).

2. "stage4Wait passes through NOTIFY tier (no queue, no approval)" -- Same as above with `ctx.tier = 'NOTIFY'`. Verify passthrough behavior.

**Test group 2: DELAY tier**

3. "stage4Wait queues DELAY tier via DelayQueue.queueDelay()" -- Set `ctx.tier = 'DELAY'` and `ctx.delaySeconds = 300`. Call `stage4Wait(ctx)`. Verify:
   - Transaction status changed to 'QUEUED' in DB
   - Transaction `queued_at` is set
   - Transaction metadata contains `delaySeconds: 300`
   - The function throws a specific "PIPELINE_HALTED" or similar sentinel (or returns void and the async pipeline checks status after stage4)

4. "stage4Wait uses default delaySeconds when not set on ctx" -- Set `ctx.tier = 'DELAY'` without delaySeconds. Verify queueDelay is called with a default (e.g., 60 seconds from config or hardcoded).

**Test group 3: APPROVAL tier**

5. "stage4Wait creates pending approval for APPROVAL tier" -- Set `ctx.tier = 'APPROVAL'`. Call `stage4Wait(ctx)`. Verify:
   - Transaction status changed to 'QUEUED' in DB
   - A pending_approvals row exists with tx_id matching
   - The pending_approvals row has expires_at set

6. "stage4Wait halts pipeline for APPROVAL tier (no stage5 execution)" -- Set ctx.tier = 'APPROVAL'. Call stage4Wait. Verify the function signals pipeline halt (throws PIPELINE_HALTED or similar).

**Test group 4: Pipeline halt mechanism**

7. "async pipeline stops at stage4 for DELAY tier" -- Simulate the full async pipeline flow (stage2->stage3->stage4->stage5->stage6) with DELAY tier. Verify stage5Execute is NOT called (transaction stays QUEUED, not SUBMITTED).

8. "async pipeline stops at stage4 for APPROVAL tier" -- Same but with APPROVAL tier.

**Test group 5: executeFromStage5 (delay-expired re-entry)**

9. "processExpired returns expired transactions and executeFromStage5 runs stage5+stage6" -- Insert a QUEUED transaction with `queued_at` in the past and `metadata.delaySeconds = 1`. Call `delayQueue.processExpired(now)`. Verify it returns the transaction with status changed to EXECUTING. Then call the equivalent of executeFromStage5 logic: construct a PipelineContext for stages 5-6 and invoke `stage5Execute(ctx)` + `stage6Confirm(ctx)` with a mock adapter. Verify the transaction ends in CONFIRMED status.

10. "executeFromStage5 marks transaction FAILED on stage5 error" -- Same as above but with a mock adapter that rejects `buildTransaction`. Verify the transaction is marked FAILED with an error message.

All tests should FAIL because stage4Wait is currently a no-op and executeFromStage5 does not exist yet.

Run tests and verify they fail.

Commit: `test(56-02): add failing tests for stage4Wait DELAY/APPROVAL branching`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-stage4.test.ts 2>&1 | grep -E "FAIL|fail|Tests"</verify>
  <done>10 tests exist in pipeline-stage4.test.ts and all FAIL (RED phase)</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN -- Implement stage4Wait + BackgroundWorkers + pipeline wiring</name>
  <files>
packages/daemon/src/pipeline/stages.ts
packages/daemon/src/api/routes/transactions.ts
packages/daemon/src/api/server.ts
packages/daemon/src/lifecycle/daemon.ts
packages/daemon/src/__tests__/pipeline-stage4.test.ts
  </files>
  <action>
**1. Add workflow deps to PipelineContext (stages.ts):**

Add to PipelineContext interface (if not already from 56-01):
- `delayQueue?: DelayQueue;`
- `approvalWorkflow?: ApprovalWorkflow;`
- `config?: { policy_defaults_delay_seconds: number; policy_defaults_approval_timeout: number };`

Import DelayQueue, ApprovalWorkflow types.

**2. Implement stage4Wait (stages.ts):**

Replace the no-op with real branching logic:

```typescript
export async function stage4Wait(ctx: PipelineContext): Promise<void> {
  const tier = ctx.tier;

  // INSTANT and NOTIFY: pass through to stage5
  if (tier === 'INSTANT' || tier === 'NOTIFY') {
    return;
  }

  // DELAY: queue with cooldown, halt pipeline
  if (tier === 'DELAY') {
    if (!ctx.delayQueue) {
      // Fallback: if no DelayQueue, treat as INSTANT (backward compat)
      return;
    }
    const delaySeconds = ctx.delaySeconds
      ?? ctx.config?.policy_defaults_delay_seconds
      ?? 60;
    ctx.delayQueue.queueDelay(ctx.txId, delaySeconds);

    // Halt pipeline -- transaction will be picked up by processExpired worker
    throw new WAIaaSError('PIPELINE_HALTED', {
      message: `Transaction ${ctx.txId} queued for ${delaySeconds}s delay`,
    });
  }

  // APPROVAL: create pending approval, halt pipeline
  if (tier === 'APPROVAL') {
    if (!ctx.approvalWorkflow) {
      // Fallback: if no ApprovalWorkflow, treat as INSTANT (backward compat)
      return;
    }
    ctx.approvalWorkflow.requestApproval(ctx.txId);

    // Halt pipeline -- transaction will be picked up by approve/reject/expire
    throw new WAIaaSError('PIPELINE_HALTED', {
      message: `Transaction ${ctx.txId} queued for owner approval`,
    });
  }
}
```

**3. Add PIPELINE_HALTED error code to @waiaas/core if needed:**

Check if `PIPELINE_HALTED` already exists in error codes. If not, add it to the PIPELINE domain errors. Alternatively, use a non-error mechanism: instead of throwing, stage4Wait could set `ctx.halted = true` and the pipeline loop checks after each stage. Choose the approach that cleanly integrates with the existing async pipeline error handler in transactions.ts.

Key consideration: the async pipeline fire-and-forget in transactions.ts catches errors and marks tx as FAILED. PIPELINE_HALTED is NOT an error -- it's an intentional stop. The error handler must recognize this:

In transactions.ts async pipeline block:
```typescript
void (async () => {
  try {
    await stage2Auth(ctx);
    await stage3Policy(ctx);
    await stage4Wait(ctx);
    await stage5Execute(ctx);
    await stage6Confirm(ctx);
  } catch (error) {
    // PIPELINE_HALTED is intentional -- do NOT mark as FAILED
    if (error instanceof WAIaaSError && error.code === 'PIPELINE_HALTED') {
      return; // Transaction is QUEUED, waiting for delay/approval
    }
    // ... existing error handling for real failures
  }
})();
```

**4. Pass workflow deps through transactionRoutes -> PipelineContext:**

In transactions.ts POST /transactions/send, add to the PipelineContext construction:
- `delayQueue: deps.delayQueue`
- `approvalWorkflow: deps.approvalWorkflow`
- `config: deps.config` (need to add config to TransactionRouteDeps)

Update TransactionRouteDeps:
- `config?: { policy_defaults_delay_seconds: number; policy_defaults_approval_timeout: number };`

**5. Update server.ts to pass config to transactionRoutes:**

The DaemonConfig schema (in `infrastructure/config/loader.ts`) has these fields under `security`:
- `config.security.policy_defaults_delay_seconds` (int, default 300, range 60-3600)
- `config.security.policy_defaults_approval_timeout` (int, default 3600, range 300-86400)

In `server.ts` where `transactionRoutes()` is called, pass the config projection:

```typescript
    app.route(
      '/v1',
      transactionRoutes({
        db: deps.db,
        adapter: deps.adapter,
        keyStore: deps.keyStore,
        policyEngine: deps.policyEngine,
        masterPassword: deps.masterPassword,
        approvalWorkflow: deps.approvalWorkflow,
        delayQueue: deps.delayQueue,
        ownerLifecycle: deps.ownerLifecycle,
        sqlite: deps.sqlite,
        config: deps.config ? {
          policy_defaults_delay_seconds: deps.config.security.policy_defaults_delay_seconds,
          policy_defaults_approval_timeout: deps.config.security.policy_defaults_approval_timeout,
        } : undefined,
      }),
    );
```

Update `TransactionRouteDeps` accordingly (if not already done in 56-01):

```typescript
export interface TransactionRouteDeps {
  // ... existing fields ...
  config?: {
    policy_defaults_delay_seconds: number;
    policy_defaults_approval_timeout: number;
  };
}
```

**6. Register BackgroundWorkers in daemon.ts:**

In DaemonLifecycle Step 6, after the existing wal-checkpoint and session-cleanup workers, add:

```typescript
// Register delay-expired worker (every 5 seconds: check for expired DELAY transactions)
if (this.delayQueue) {
  this.workers.register('delay-expired', {
    interval: 5_000,
    handler: () => {
      if (this._isShuttingDown) return;
      const now = Math.floor(Date.now() / 1000);
      const expired = this.delayQueue!.processExpired(now);
      // For each expired tx, re-enter pipeline at stage5
      for (const tx of expired) {
        void this.executeFromStage5(tx.txId, tx.agentId);
      }
    },
  });
}

// Register approval-expired worker (every 30 seconds: expire timed-out approvals)
if (this.approvalWorkflow) {
  this.workers.register('approval-expired', {
    interval: 30_000,
    handler: () => {
      if (this._isShuttingDown) return;
      const now = Math.floor(Date.now() / 1000);
      this.approvalWorkflow!.processExpiredApprovals(now);
    },
  });
}
```

Add `executeFromStage5` as a private async method on DaemonLifecycle. The daemon already has `this.adapter`, `this.keyStore`, `this.masterPassword`, `this._db`, and `this.sqlite` from startup steps 2-4:

```typescript
/**
 * Re-enter the pipeline at stage5 for a delay-expired transaction.
 *
 * Called by the delay-expired BackgroundWorker when processExpired()
 * returns transactions whose cooldown has elapsed.
 *
 * @param txId - Transaction ID to execute
 * @param agentId - Agent that owns the transaction
 */
private async executeFromStage5(txId: string, agentId: string): Promise<void> {
  try {
    if (!this._db || !this.adapter || !this.keyStore) {
      console.warn(`executeFromStage5(${txId}): missing deps, skipping`);
      return;
    }

    // Look up agent from DB
    const { agents } = await import('../infrastructure/database/schema.js');
    const { eq } = await import('drizzle-orm');
    const agent = this._db.select().from(agents).where(eq(agents.id, agentId)).get();
    if (!agent) {
      console.warn(`executeFromStage5(${txId}): agent ${agentId} not found`);
      return;
    }

    // Import stages
    const { stage5Execute, stage6Confirm } = await import('../pipeline/stages.js');
    const { transactions } = await import('../infrastructure/database/schema.js');

    // Look up transaction to get request data
    const tx = this._db.select().from(transactions).where(eq(transactions.id, txId)).get();
    if (!tx) {
      console.warn(`executeFromStage5(${txId}): transaction not found`);
      return;
    }

    // Construct minimal PipelineContext for stages 5-6
    const ctx: import('../pipeline/stages.js').PipelineContext = {
      db: this._db,
      adapter: this.adapter,
      keyStore: this.keyStore,
      policyEngine: null as any,  // Not needed for stages 5-6
      masterPassword: this.masterPassword,
      agentId,
      agent: {
        publicKey: agent.publicKey,
        chain: agent.chain,
        network: agent.network,
      },
      request: {
        to: tx.toAddress,
        amount: tx.amount,
        memo: undefined,
      },
      txId,
    };

    await stage5Execute(ctx);
    await stage6Confirm(ctx);
  } catch (error) {
    // Mark as FAILED if stages 5-6 throw
    try {
      if (this._db) {
        const { transactions } = await import('../infrastructure/database/schema.js');
        const { eq } = await import('drizzle-orm');
        const errorMessage = error instanceof Error ? error.message : 'Pipeline re-entry failed';
        this._db
          .update(transactions)
          .set({ status: 'FAILED', error: errorMessage })
          .where(eq(transactions.id, txId))
          .run();
      }
    } catch {
      // Swallow DB update errors in background
    }
  }
}
```

Store `delayQueue` and `approvalWorkflow` as instance fields on DaemonLifecycle, created in Step 5 or Step 6 when sqlite is available:

```typescript
private delayQueue: DelayQueue | null = null;
private approvalWorkflow: ApprovalWorkflow | null = null;
```

**7. Fix tests to pass:**

Adjust test assertions based on the actual implementation (PIPELINE_HALTED throw vs halted flag). Ensure all 8 tests in pipeline-stage4.test.ts pass.

Run full test suite and verify:
- All 10 new tests pass
- All pre-existing tests pass (no regressions)

Commit: `feat(56-02): implement stage4Wait DELAY/APPROVAL + BackgroundWorkers integration`
  </action>
  <verify>pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose 2>&1 | tail -5</verify>
  <done>All 10 pipeline-stage4 tests pass, all daemon tests pass with zero regressions, stage4Wait queues DELAY and APPROVAL tiers, INSTANT/NOTIFY pass through, BackgroundWorkers registered for delay-expired and approval-expired, executeFromStage5 re-enters pipeline for expired delays and handles errors</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/daemon exec vitest run --reporter=verbose packages/daemon/src/__tests__/pipeline-stage4.test.ts` -- all 10 tests pass
2. `pnpm --filter @waiaas/daemon exec vitest run` -- all daemon tests pass (no regressions)
3. `pnpm --filter @waiaas/daemon exec tsc --noEmit` -- zero TypeScript errors
4. Verify stage4Wait correctly branches on tier (INSTANT/NOTIFY passthrough, DELAY queueDelay, APPROVAL requestApproval)
5. Verify PIPELINE_HALTED is handled in the async pipeline error handler (not marked as FAILED)
6. Verify BackgroundWorkers in daemon.ts registers delay-expired and approval-expired workers
7. Verify DaemonLifecycle.executeFromStage5 re-enters pipeline for expired delay transactions
</verification>

<success_criteria>
- stage4Wait queues DELAY tier via DelayQueue.queueDelay() and halts pipeline
- stage4Wait creates pending approval for APPROVAL tier via ApprovalWorkflow.requestApproval() and halts pipeline
- stage4Wait passes through INSTANT and NOTIFY tiers
- PIPELINE_HALTED is not treated as a failure in the async pipeline
- BackgroundWorkers processes expired delays (every 5s) and approvals (every 30s)
- Expired delay transactions re-enter pipeline at stage5Execute
- 10 TDD tests prove the branching logic and delay-expired re-entry
- Zero regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/56-pipeline-integration/56-02-SUMMARY.md`
</output>
