---
phase: 52-auth-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["52-01"]
files_modified:
  - packages/daemon/src/api/middleware/master-auth.ts
  - packages/daemon/src/api/middleware/owner-auth.ts
  - packages/daemon/src/api/middleware/index.ts
  - packages/daemon/src/api/routes/agents.ts
  - packages/daemon/src/api/routes/wallet.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/master-auth.test.ts
  - packages/daemon/src/__tests__/owner-auth.test.ts
  - packages/daemon/src/__tests__/api-agents.test.ts
  - packages/daemon/src/__tests__/api-transactions.test.ts
autonomous: true

must_haves:
  truths:
    - "masterAuth middleware rejects requests without valid X-Master-Password header with 401"
    - "masterAuth middleware accepts correct master password verified via Argon2id"
    - "ownerAuth middleware rejects requests without valid signature with 401"
    - "ownerAuth middleware validates SIWS/SIWE signature structure against agents.owner_address"
    - "POST /v1/agents requires masterAuth (implicit) and rejects without X-Master-Password"
    - "GET /wallet/address and GET /wallet/balance require sessionAuth and reject without valid JWT"
    - "POST /transactions/send requires sessionAuth and rejects without valid JWT"
    - "GET /transactions/:id requires sessionAuth and rejects without valid JWT"
    - "GET /health remains public (no auth required)"
  artifacts:
    - path: "packages/daemon/src/api/middleware/master-auth.ts"
      provides: "masterAuth explicit Hono middleware"
      exports: ["createMasterAuth"]
    - path: "packages/daemon/src/api/middleware/owner-auth.ts"
      provides: "ownerAuth Hono middleware"
      exports: ["createOwnerAuth"]
    - path: "packages/daemon/src/api/routes/agents.ts"
      provides: "Agent routes with masterAuth protection"
    - path: "packages/daemon/src/api/routes/wallet.ts"
      provides: "Wallet routes with sessionAuth protection"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "Transaction routes with sessionAuth protection"
  key_links:
    - from: "packages/daemon/src/api/middleware/master-auth.ts"
      to: "argon2 library"
      via: "argon2.verify() for password hash comparison"
      pattern: "argon2\\.verify"
    - from: "packages/daemon/src/api/routes/agents.ts"
      to: "packages/daemon/src/api/middleware/master-auth.ts"
      via: "route-level masterAuth middleware"
      pattern: "masterAuth"
    - from: "packages/daemon/src/api/routes/wallet.ts"
      to: "packages/daemon/src/api/middleware/session-auth.ts"
      via: "route-level sessionAuth middleware"
      pattern: "sessionAuth"
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/api/middleware/session-auth.ts"
      via: "route-level sessionAuth middleware"
      pattern: "sessionAuth"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      via: "CreateAppDeps includes jwtSecretManager"
      pattern: "jwtSecretManager"
---

<objective>
Implement masterAuth and ownerAuth middleware, then apply authentication to all existing endpoints so that no API call succeeds without proper credentials.

Purpose: Complete the 3-tier auth system for Phase 52. masterAuth protects administrative endpoints (agent creation, future policy CRUD). ownerAuth protects owner-only actions (future: transaction approval, KS recovery). All existing wallet/transaction endpoints move from X-Agent-Id to sessionAuth (JWT). After this plan, every endpoint except /health requires authentication.

Output: masterAuth middleware, ownerAuth middleware, updated routes with auth, updated tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-auth-foundation/52-01-SUMMARY.md

# Existing code to modify
@packages/daemon/src/api/middleware/kill-switch-guard.ts
@packages/daemon/src/api/middleware/index.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/routes/agents.ts
@packages/daemon/src/api/routes/wallet.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/core/src/errors/error-codes.ts
@packages/daemon/src/infrastructure/database/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement masterAuth + ownerAuth middleware + tests</name>
  <files>
    packages/daemon/src/api/middleware/master-auth.ts
    packages/daemon/src/api/middleware/owner-auth.ts
    packages/daemon/src/api/middleware/index.ts
    packages/daemon/src/__tests__/master-auth.test.ts
    packages/daemon/src/__tests__/owner-auth.test.ts
  </files>
  <action>
**Part A: masterAuth explicit middleware**

Create `packages/daemon/src/api/middleware/master-auth.ts`:

Follow the `createKillSwitchGuard` factory pattern.

```typescript
export interface MasterAuthDeps {
  masterPasswordHash: string;  // Argon2id hash stored during daemon init
}

export function createMasterAuth(deps: MasterAuthDeps) {
  return createMiddleware(async (c, next) => {
    const password = c.req.header('X-Master-Password');
    if (!password) {
      throw new WAIaaSError('INVALID_MASTER_PASSWORD', {
        message: 'X-Master-Password header is required',
      });
    }

    // Verify password against stored Argon2id hash
    const argon2 = await import('argon2');
    const isValid = await argon2.verify(deps.masterPasswordHash, password);

    if (!isValid) {
      throw new WAIaaSError('INVALID_MASTER_PASSWORD', {
        message: 'Invalid master password',
      });
    }

    await next();
  });
}
```

Design notes:
- `masterPasswordHash` is the Argon2id hash of the master password (hashed at daemon startup, stored in memory)
- The middleware receives the plaintext password via X-Master-Password header (localhost-only, secured by hostGuard)
- Per v0.7 decision: "Master Password Argon2id 통일, X-Master-Password 평문 (localhost only)"
- argon2 is already in daemon package.json dependencies
- Use dynamic `import('argon2')` to avoid CJS/ESM issues, OR use static `import argon2 from 'argon2'` (check which pattern works -- argon2 package supports ESM default export in v0.44+)

Actually, argon2 v0.44 supports ESM. Use: `import argon2 from 'argon2'` at top of file (not dynamic).

However, the daemon currently uses argon2 only in keystore for KDF. Check if it's used statically elsewhere. If so, follow the same import pattern.

To hash the master password at startup for comparison, the daemon lifecycle will need to call `argon2.hash(masterPassword)` once during init and pass the hash to CreateAppDeps. But for now, the masterAuth middleware just needs the hash passed in.

**Part B: ownerAuth middleware**

Create `packages/daemon/src/api/middleware/owner-auth.ts`:

ownerAuth verifies that the request carries a valid owner wallet signature (SIWS for Solana, SIWE for EVM). Per v0.5 design: ownerAuth is required only for "자금 영향" operations (transaction approval, KS recovery).

For v1.2, implement a simplified signature verification that works without WalletConnect (per v0.5: "CLI 수동 서명으로 모든 기능 동작"). The middleware expects:
- Header `X-Owner-Signature`: base64-encoded signature
- Header `X-Owner-Message`: the signed message (includes nonce, timestamp, action)
- Header `X-Owner-Address`: the owner's wallet address

Verification flow:
1. Extract all three headers, reject 401 if missing
2. Look up agent (from route param `:id` or c.get('agentId') from prior sessionAuth) to get owner_address
3. Verify X-Owner-Address matches agent.ownerAddress
4. Verify signature against message using ed25519 (Solana) -- for v1.2, use a simplified verification: `sodium.crypto_sign_verify_detached(signature, message, publicKey)` for Solana
5. For now, if chain is not Solana, reject with CHAIN_NOT_SUPPORTED (SIWE for EVM is v1.4+)

NOTE: Full SIWS (@solana/wallet-standard) / SIWE (viem/siwe) library integration is complex. For Phase 52, implement the middleware structure with ed25519 verify for Solana. The v0.7 design mentions "SIWE viem/siwe 전환" but that's for EVM. For Solana, use sodium-native's `crypto_sign_verify_detached` which is already available.

```typescript
export interface OwnerAuthDeps {
  db: BetterSQLite3Database<typeof schema>;
}

export function createOwnerAuth(deps: OwnerAuthDeps) {
  return createMiddleware(async (c, next) => {
    const signature = c.req.header('X-Owner-Signature');
    const message = c.req.header('X-Owner-Message');
    const ownerAddress = c.req.header('X-Owner-Address');

    if (!signature || !message || !ownerAddress) {
      throw new WAIaaSError('INVALID_SIGNATURE', {
        message: 'X-Owner-Signature, X-Owner-Message, and X-Owner-Address headers are required',
      });
    }

    // Look up agent to verify owner_address match
    const agentId = c.req.param('id') || (c.get('agentId') as string | undefined);
    if (!agentId) {
      throw new WAIaaSError('AGENT_NOT_FOUND', {
        message: 'Agent ID required for owner authentication',
      });
    }

    const agent = await deps.db.select().from(agents).where(eq(agents.id, agentId)).get();
    if (!agent) {
      throw new WAIaaSError('AGENT_NOT_FOUND');
    }
    if (!agent.ownerAddress) {
      throw new WAIaaSError('OWNER_NOT_CONNECTED', {
        message: 'No owner address registered for this agent',
      });
    }
    if (agent.ownerAddress !== ownerAddress) {
      throw new WAIaaSError('INVALID_SIGNATURE', {
        message: 'Owner address does not match agent owner',
      });
    }

    // Verify the Ed25519 signature (Solana)
    // For Solana: owner_address is base58-encoded public key
    // signature is base64-encoded Ed25519 detached signature over the message bytes
    try {
      const sodium = (await import('sodium-native')).default ?? await import('sodium-native');
      // Actually use createRequire pattern like keystore
      // The executor should use the createRequire pattern from keystore.ts for sodium-native (CJS)
      const signatureBytes = Buffer.from(signature, 'base64');
      const messageBytes = Buffer.from(message, 'utf8');
      const publicKeyBytes = decodeBase58(ownerAddress); // Need base58 decode utility

      const valid = sodium.crypto_sign_verify_detached(signatureBytes, messageBytes, publicKeyBytes);
      if (!valid) {
        throw new WAIaaSError('INVALID_SIGNATURE');
      }
    } catch (err) {
      if (err instanceof WAIaaSError) throw err;
      throw new WAIaaSError('INVALID_SIGNATURE', {
        message: 'Signature verification failed',
        cause: err instanceof Error ? err : undefined,
      });
    }

    c.set('ownerAddress', ownerAddress);
    await next();
  });
}
```

For base58 decode, either:
- Extract from keystore.ts and put in a shared utility, or
- Inline a minimal decodeBase58 function in the same file

Use the `createRequire(import.meta.url)` pattern for sodium-native, consistent with keystore.ts.

**Part C: Update middleware barrel export**

Add to `packages/daemon/src/api/middleware/index.ts`:
```typescript
export { createMasterAuth, type MasterAuthDeps } from './master-auth.js';
export { createOwnerAuth, type OwnerAuthDeps } from './owner-auth.js';
```

**Part D: Write tests**

`packages/daemon/src/__tests__/master-auth.test.ts`:

RED tests first:
1. `rejects with 401 INVALID_MASTER_PASSWORD when X-Master-Password header missing`
2. `rejects with 401 INVALID_MASTER_PASSWORD when password is wrong`
3. `passes through when correct master password provided`

Use argon2.hash() in beforeAll to create a test hash, then test the middleware.

`packages/daemon/src/__tests__/owner-auth.test.ts`:

RED tests first:
1. `rejects with 401 INVALID_SIGNATURE when headers missing`
2. `rejects with 404 AGENT_NOT_FOUND when agent does not exist`
3. `rejects with 404 OWNER_NOT_CONNECTED when agent has no owner`
4. `rejects with 401 INVALID_SIGNATURE when owner address does not match`
5. `rejects with 401 INVALID_SIGNATURE when signature is invalid`
6. `passes through when valid Ed25519 signature matches owner address`

For test 6, generate an Ed25519 keypair with sodium-native, sign a message, encode the public key as base58 (owner address), and verify the middleware accepts it.

GREEN: Implement until all tests pass.
REFACTOR if needed.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test --filter @waiaas/daemon` and confirm all master-auth and owner-auth tests pass. Verify no regressions.
  </verify>
  <done>
masterAuth rejects invalid/missing passwords with 401 INVALID_MASTER_PASSWORD, accepts valid password. ownerAuth rejects invalid/missing signatures, verifies Ed25519 Solana signatures against agent owner_address. All 9+ new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply auth middleware to existing endpoints + update server factory + tests</name>
  <files>
    packages/daemon/src/api/server.ts
    packages/daemon/src/api/routes/agents.ts
    packages/daemon/src/api/routes/wallet.ts
    packages/daemon/src/api/routes/transactions.ts
    packages/daemon/src/__tests__/api-agents.test.ts
    packages/daemon/src/__tests__/api-transactions.test.ts
  </files>
  <action>
**Auth mapping for existing 6 endpoints (per AUTH-04, AUTH-05):**

| Endpoint | Current Auth | New Auth | Reason |
|----------|-------------|----------|--------|
| GET /health | None | None (public) | Health check must be accessible |
| POST /v1/agents | None (uses masterPassword internally) | masterAuth explicit | Agent creation is admin operation |
| GET /v1/wallet/address | X-Agent-Id header | sessionAuth | Wallet query needs authenticated session |
| GET /v1/wallet/balance | X-Agent-Id header | sessionAuth | Wallet query needs authenticated session |
| POST /v1/transactions/send | X-Agent-Id header | sessionAuth | Transaction submission needs session |
| GET /v1/transactions/:id | None | sessionAuth | Transaction status needs session |

**Step 1: Update CreateAppDeps in server.ts**

Add new dependency fields to `CreateAppDeps` interface:
```typescript
export interface CreateAppDeps {
  // ... existing fields ...
  jwtSecretManager?: JwtSecretManager;
  masterPasswordHash?: string;  // Argon2id hash for masterAuth
}
```

**Step 2: Update createApp() to create auth middleware instances**

Inside `createApp()`, create the middleware instances when deps are available:
```typescript
const sessionAuth = deps.jwtSecretManager && deps.db
  ? createSessionAuth({ jwtSecretManager: deps.jwtSecretManager, db: deps.db })
  : undefined;

const masterAuth = deps.masterPasswordHash
  ? createMasterAuth({ masterPasswordHash: deps.masterPasswordHash })
  : undefined;
```

Pass these into route factories.

**Step 3: Update agent routes (POST /v1/agents)**

Modify `agentRoutes()` to accept and apply masterAuth:
- Add `masterAuth?` middleware to AgentRouteDeps
- Apply as route-level middleware: `router.post('/agents', masterAuth, async (c) => { ... })`
- Remove direct use of `deps.masterPassword` for key generation. Instead, the masterAuth middleware has already verified the password. The route still needs the password for key generation (keyStore.generateKeyPair needs it). Keep `masterPassword` in deps for keystore use, but the auth check moves to middleware.
- Actually, the password is still needed for keyStore operations. So the route handler can read `c.req.header('X-Master-Password')` directly (it's guaranteed valid after masterAuth passes). Or pass `masterPassword` from deps as before. Keep it simple: deps still has `masterPassword`, but now the route is ALSO protected by masterAuth middleware.

**Step 4: Update wallet routes (GET /v1/wallet/address, GET /v1/wallet/balance)**

Modify `walletRoutes()` to accept and apply sessionAuth:
- Add `sessionAuth?` middleware to WalletRouteDeps
- Apply as route-level middleware on both routes: `router.get('/wallet/address', sessionAuth, async (c) => { ... })`
- Replace `X-Agent-Id` header reading with `c.get('agentId') as string` (set by sessionAuth middleware)
- Remove the manual `resolveAgent` X-Agent-Id check for agent identification (sessionAuth already established the agentId)
- Keep the DB agent lookup but use the agentId from context instead of header

**Step 5: Update transaction routes (POST /transactions/send, GET /transactions/:id)**

Modify `transactionRoutes()`:
- Add `sessionAuth?` middleware to TransactionRouteDeps
- Apply sessionAuth to both POST /transactions/send and GET /transactions/:id
- Replace `X-Agent-Id` header reading with `c.get('agentId') as string` from sessionAuth context
- For GET /transactions/:id, also add sessionAuth (require authenticated session to query tx status)

**Step 6: Backward compatibility for tests**

The routes need to work both WITH and WITHOUT auth middleware (for existing tests that don't pass tokens). Two approaches:
- Option A: Update all existing tests to pass auth headers (preferred, accurate)
- Option B: Make auth middleware optional and skip when not provided

Choose Option A for correctness. Update existing tests in `api-agents.test.ts` and `api-transactions.test.ts` to include proper auth headers. For tests, create helper functions that:
1. Initialize JwtSecretManager with in-memory DB
2. Hash a test master password with argon2
3. Sign test JWT tokens
4. Include proper headers in test requests

**Step 7: Update tests**

Update `packages/daemon/src/__tests__/api-agents.test.ts`:
- Add `X-Master-Password` header to POST /v1/agents requests
- Add test: `POST /v1/agents without X-Master-Password returns 401`
- Ensure existing "creates agent" test still passes with auth header

Update `packages/daemon/src/__tests__/api-transactions.test.ts`:
- Replace `X-Agent-Id` header with `Authorization: Bearer wai_sess_<token>` header
- Sign proper JWT tokens for test requests
- Add test: `POST /transactions/send without auth returns 401`
- Add test: `GET /transactions/:id without auth returns 401`
- Ensure existing send/get tests pass with session auth

Do NOT break existing passing tests. If a test currently works with X-Agent-Id, update it to use session auth instead.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test --filter @waiaas/daemon` and confirm ALL tests pass (existing + new auth tests). Run `pnpm typecheck --filter @waiaas/daemon` for TypeScript verification. Specifically verify:
- POST /v1/agents without X-Master-Password returns 401
- GET /v1/wallet/address without Authorization header returns 401
- POST /v1/transactions/send without Authorization header returns 401
- GET /transactions/:id without Authorization header returns 401
- GET /health still returns 200 without any auth
  </verify>
  <done>
All 6 endpoints have proper auth applied. /health is public. POST /agents requires masterAuth. All wallet/transaction endpoints require sessionAuth. Existing tests updated with auth headers, new auth rejection tests added. No regressions.
AUTH-02, AUTH-03, AUTH-04, AUTH-05 requirements addressed.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test --filter @waiaas/daemon` -- all tests pass (281 existing updated + ~30 new = ~310+ total)
2. `pnpm typecheck --filter @waiaas/daemon` -- no TypeScript errors
3. `pnpm build --filter @waiaas/daemon` -- builds successfully
4. No endpoint except /health is accessible without auth
5. masterAuth verifies X-Master-Password against Argon2id hash
6. ownerAuth verifies Ed25519 signatures for Solana owner addresses
7. sessionAuth validates wai_sess_ JWT tokens and checks DB session state
8. Auth errors return proper HTTP status codes (401 for auth failures, 404 for not found)
</verification>

<success_criteria>
- 3 auth middleware operational: masterAuth (Argon2id), ownerAuth (Ed25519 verify), sessionAuth (JWT)
- All existing 6 endpoints protected with appropriate auth type
- /health remains public
- Existing tests updated to include proper auth credentials
- New tests verify auth rejection scenarios
- AUTH-01 through AUTH-05 and SESS-06 fully addressed
- Phase 52 success criteria 1-5 from roadmap satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/52-auth-foundation/52-02-SUMMARY.md`
</output>
