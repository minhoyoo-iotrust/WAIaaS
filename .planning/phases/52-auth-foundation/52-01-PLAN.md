---
phase: 52-auth-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/package.json
  - pnpm-lock.yaml
  - packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
  - packages/daemon/src/infrastructure/jwt/index.ts
  - packages/daemon/src/api/middleware/session-auth.ts
  - packages/daemon/src/api/middleware/index.ts
  - packages/daemon/src/__tests__/jwt-secret-manager.test.ts
  - packages/daemon/src/__tests__/session-auth.test.ts
autonomous: true

must_haves:
  truths:
    - "JWT Secret is generated, stored in key_value_store, and loaded on daemon start"
    - "Dual-key rotation works: old key valid for 5 minutes after rotation"
    - "sessionAuth middleware rejects requests without valid wai_sess_ JWT token with 401"
    - "sessionAuth middleware extracts sessionId and agentId from valid JWT into Hono context"
    - "Expired JWT tokens are rejected with TOKEN_EXPIRED error"
    - "Revoked sessions (DB lookup) are rejected with SESSION_REVOKED error"
  artifacts:
    - path: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      provides: "JWT secret CRUD + dual-key rotation"
      exports: ["JwtSecretManager"]
    - path: "packages/daemon/src/api/middleware/session-auth.ts"
      provides: "sessionAuth Hono middleware"
      exports: ["createSessionAuth"]
    - path: "packages/daemon/src/__tests__/jwt-secret-manager.test.ts"
      provides: "JwtSecretManager unit tests"
    - path: "packages/daemon/src/__tests__/session-auth.test.ts"
      provides: "sessionAuth middleware tests"
  key_links:
    - from: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      to: "key_value_store table"
      via: "Drizzle ORM insert/select on keyValueStore"
      pattern: "keyValueStore.*jwt_secret"
    - from: "packages/daemon/src/api/middleware/session-auth.ts"
      to: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      via: "JwtSecretManager.verifyToken()"
      pattern: "jwtSecretManager\\.verifyToken"
    - from: "packages/daemon/src/api/middleware/session-auth.ts"
      to: "sessions table"
      via: "Drizzle ORM select by tokenHash to check revocation"
      pattern: "sessions.*tokenHash"
---

<objective>
Implement JWT Secret management infrastructure and sessionAuth middleware for WAIaaS daemon.

Purpose: Establish the foundation for session-based authentication. JWT Secret must be securely stored in key_value_store with dual-key 5-minute rotation window. sessionAuth middleware must validate `Authorization: Bearer wai_sess_...` tokens, verify against the JWT secret, check session revocation in DB, and set sessionId/agentId on the Hono context. This is the prerequisite for all other auth middleware (Plan 52-02) and session management (Phase 53).

Output: JwtSecretManager class, createSessionAuth middleware factory, tests for both.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@packages/daemon/src/api/middleware/kill-switch-guard.ts
@packages/daemon/src/api/middleware/host-guard.ts
@packages/daemon/src/api/middleware/index.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/core/src/errors/error-codes.ts
@packages/core/src/schemas/session.schema.ts
@packages/daemon/src/infrastructure/config/loader.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install jose + implement JwtSecretManager with dual-key rotation + tests</name>
  <files>
    packages/daemon/package.json
    pnpm-lock.yaml
    packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
    packages/daemon/src/infrastructure/jwt/index.ts
    packages/daemon/src/__tests__/jwt-secret-manager.test.ts
  </files>
  <action>
**Step 1: Install jose**
Run `pnpm add jose --filter @waiaas/daemon` to add the jose library for JWT operations.

**Step 2: Create JwtSecretManager class** at `packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts`

The class manages JWT secrets stored in the `key_value_store` SQLite table via Drizzle ORM.

Constructor: `constructor(db: BetterSQLite3Database<typeof schema>)`

Key storage format in key_value_store:
- Key `jwt_secret_current`: JSON `{ secret: string (hex), createdAt: number (epoch seconds) }`
- Key `jwt_secret_previous`: JSON `{ secret: string (hex), createdAt: number (epoch seconds) }` (only during rotation window)

Methods:
- `async initialize(): Promise<void>` - On first run, generate a 256-bit random secret using `crypto.randomBytes(32).toString('hex')`, store as `jwt_secret_current` in key_value_store. If already exists, load it. Use Drizzle `db.insert(...).onConflictDoNothing()` pattern.
- `async getCurrentSecret(): Promise<string>` - Return the current hex secret string (in-memory cache after initialize).
- `async getValidSecrets(): Promise<string[]>` - Return array of valid secrets. Normally just `[current]`. During rotation window (previous exists and is < 5 minutes old), return `[current, previous]`.
- `async rotateSecret(): Promise<void>` - Generate new secret. Move current to previous. Store new as current. Both in a single DB transaction. Throw `ROTATION_TOO_RECENT` WAIaaSError if last rotation was < 5 minutes ago.
- `async signToken(payload: JwtPayload): Promise<string>` - Use jose `new SignJWT(payload).setProtectedHeader({ alg: 'HS256' }).setExpirationTime(payload.exp).sign(secret)`. The token MUST be prefixed with `wai_sess_` after signing. Import secret with `jose.importJWK` or use `new TextEncoder().encode(hexSecret)` as symmetric key.
- `async verifyToken(token: string): Promise<JwtPayload>` - Strip the `wai_sess_` prefix. Try verification against each secret from `getValidSecrets()` using `jose.jwtVerify()`. Return decoded payload on first success. Throw `INVALID_TOKEN` WAIaaSError if all fail. Throw `TOKEN_EXPIRED` if jose throws JWTExpired.

JwtPayload interface:
```typescript
export interface JwtPayload {
  sub: string;   // sessionId
  agt: string;   // agentId
  iat: number;   // issued at (epoch seconds)
  exp: number;   // expires at (epoch seconds)
}
```

Internal details:
- Use `import { SignJWT, jwtVerify, errors as joseErrors } from 'jose'` (ESM import)
- For HS256 symmetric key, convert hex secret to Uint8Array: `new TextEncoder().encode(hexSecret)` won't work for binary key. Instead use `Buffer.from(hexSecret, 'hex')` and pass to jose as `Uint8Array`.
- Actually jose needs a `KeyLike | Uint8Array` -- Buffer extends Uint8Array so `Buffer.from(secret, 'hex')` works directly.
- Cache secrets in memory after initialize (private fields `_currentSecret`, `_previousSecret`). Reload from DB only on rotateSecret.

**Step 3: Create barrel export** at `packages/daemon/src/infrastructure/jwt/index.ts`:
```typescript
export { JwtSecretManager, type JwtPayload } from './jwt-secret-manager.js';
```

**Step 4: Write tests** at `packages/daemon/src/__tests__/jwt-secret-manager.test.ts`

Use in-memory SQLite with Drizzle (same pattern as existing `database.test.ts`). Test cases:

RED phase - write all tests first:
1. `initialize() creates jwt_secret_current in key_value_store on first call`
2. `initialize() loads existing secret on subsequent calls (idempotent)`
3. `getCurrentSecret() returns a 64-char hex string`
4. `getValidSecrets() returns single secret when no rotation`
5. `rotateSecret() creates new current, moves old to previous`
6. `getValidSecrets() returns two secrets within 5-min window after rotation`
7. `rotateSecret() throws ROTATION_TOO_RECENT if called within 5 minutes`
8. `signToken() produces a string starting with wai_sess_`
9. `verifyToken() decodes a valid token correctly (sub, agt, exp)`
10. `verifyToken() throws INVALID_TOKEN for garbage tokens`
11. `verifyToken() throws TOKEN_EXPIRED for expired tokens`
12. `verifyToken() succeeds with previous key during rotation window`

For testing the 5-min window, use `vi.useFakeTimers()` to control Date.now().

GREEN phase - implement to pass all tests.
REFACTOR if needed.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test --filter @waiaas/daemon` and confirm all jwt-secret-manager tests pass. Also run `pnpm typecheck --filter @waiaas/daemon` to verify TypeScript compilation.
  </verify>
  <done>
JwtSecretManager stores/loads secrets from key_value_store, dual-key rotation works with 5-min window, signToken produces wai_sess_ prefixed JWT, verifyToken validates against valid secrets, all 12+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement createSessionAuth middleware factory + tests</name>
  <files>
    packages/daemon/src/api/middleware/session-auth.ts
    packages/daemon/src/api/middleware/index.ts
    packages/daemon/src/__tests__/session-auth.test.ts
  </files>
  <action>
**Step 1: Create sessionAuth middleware** at `packages/daemon/src/api/middleware/session-auth.ts`

Follow the existing `createKillSwitchGuard` factory pattern from `kill-switch-guard.ts`. Use `createMiddleware` from `hono/factory`.

```typescript
export interface SessionAuthDeps {
  jwtSecretManager: JwtSecretManager;
  db: BetterSQLite3Database<typeof schema>;
}

export function createSessionAuth(deps: SessionAuthDeps) {
  return createMiddleware(async (c, next) => {
    // 1. Extract Authorization header
    const authHeader = c.req.header('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer wai_sess_')) {
      throw new WAIaaSError('INVALID_TOKEN', {
        message: 'Missing or invalid Authorization header. Expected: Bearer wai_sess_<token>',
      });
    }

    // 2. Extract the full token (including wai_sess_ prefix)
    const token = authHeader.slice('Bearer '.length);

    // 3. Verify JWT via JwtSecretManager
    const payload = await deps.jwtSecretManager.verifyToken(token);

    // 4. Check session in DB (not revoked, not expired)
    const session = await deps.db
      .select()
      .from(sessions)
      .where(eq(sessions.id, payload.sub))
      .get();

    if (!session) {
      throw new WAIaaSError('SESSION_NOT_FOUND');
    }
    if (session.revokedAt !== null) {
      throw new WAIaaSError('SESSION_REVOKED');
    }

    // 5. Set context variables (use c.set pattern from Hono)
    c.set('sessionId', payload.sub);
    c.set('agentId', payload.agt);

    await next();
  });
}
```

IMPORTANT: The Hono context typing. Existing middleware uses untyped c.set/c.get. Follow the same pattern for now (string keys). The executor should check how existing code does c.get('requestId') in error-handler.ts and follow the same approach.

**Step 2: Update middleware barrel export** in `packages/daemon/src/api/middleware/index.ts`:
Add export: `export { createSessionAuth, type SessionAuthDeps } from './session-auth.js';`

**Step 3: Write sessionAuth middleware tests** at `packages/daemon/src/__tests__/session-auth.test.ts`

Use the Hono `app.request()` testing pattern from `api-server.test.ts`. Create a test Hono app with sessionAuth middleware, a protected test route, and an in-memory SQLite DB with sessions table.

Setup: Create a JwtSecretManager instance with the in-memory DB, initialize it, sign a test token.

RED phase - tests first:
1. `returns 401 INVALID_TOKEN when no Authorization header`
2. `returns 401 INVALID_TOKEN when Authorization header has wrong format (not Bearer wai_sess_)`
3. `returns 401 INVALID_TOKEN when token is malformed JWT`
4. `returns 401 TOKEN_EXPIRED when token is expired`
5. `returns 401 SESSION_REVOKED when session is revoked in DB`
6. `returns 404 SESSION_NOT_FOUND when session ID not in DB`
7. `passes through and sets sessionId/agentId when token is valid and session active`
8. `succeeds with old secret during dual-key rotation window`

GREEN phase - the middleware implementation should pass all tests.
REFACTOR if needed.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test --filter @waiaas/daemon` and confirm all session-auth tests pass alongside existing tests. All 281+ existing tests should still pass (no regressions).
  </verify>
  <done>
sessionAuth middleware correctly validates wai_sess_ Bearer tokens, checks DB for revocation, sets sessionId/agentId context, and rejects with proper error codes. All 8+ middleware tests pass, no regressions.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test --filter @waiaas/daemon` -- all tests pass (281 existing + ~20 new)
2. `pnpm typecheck --filter @waiaas/daemon` -- no TypeScript errors
3. `jose` is in daemon package.json dependencies
4. JwtSecretManager stores jwt_secret_current in key_value_store
5. sessionAuth middleware rejects unauthorized requests with correct error codes
6. sessionAuth middleware sets sessionId and agentId on context for valid tokens
</verification>

<success_criteria>
- JwtSecretManager class operational with key_value_store persistence
- Dual-key 5-minute rotation window functional
- sessionAuth middleware rejects missing/invalid/expired tokens with 401
- sessionAuth middleware checks DB for session revocation
- All new tests pass, no regressions in existing tests
- AUTH-01 and SESS-06 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/52-auth-foundation/52-01-SUMMARY.md`
</output>
