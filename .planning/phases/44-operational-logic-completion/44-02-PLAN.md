---
phase: 44-operational-logic-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/60-batch-transaction-spec.md
  - .planning/deliverables/25-sqlite-schema.md
autonomous: true

must_haves:
  truths:
    - "60-batch-tx에 부모-자식 2계층 DB 저장 전략이 기존 §6 단일 레코드 전략을 대체하여 정의되어 있다"
    - "25-sqlite transactions 테이블에 parent_id TEXT REFERENCES transactions(id) ON DELETE CASCADE + batch_index INTEGER 컬럼이 추가되어 있다"
    - "PARTIAL_FAILURE 상태가 status CHECK에 포함되어 있고, EVM 순차 배치 전용임이 주석으로 명시되어 있다"
    - "부모-자식 상태 전이 테이블(전체 성공/Solana 원자적 실패/EVM 부분 실패)이 명시되어 있다"
  artifacts:
    - path: "docs/60-batch-transaction-spec.md"
      provides: "부모-자식 2계층 DB 저장 전략 + PARTIAL_FAILURE 상태 전이"
      contains: "parent_id"
    - path: ".planning/deliverables/25-sqlite-schema.md"
      provides: "transactions 테이블 parent_id + batch_index 컬럼 + PARTIAL_FAILURE status"
      contains: "parent_id"
  key_links:
    - from: "60-batch-tx 2계층 저장 전략"
      to: "25-sqlite transactions 스키마"
      via: "parent_id + batch_index 컬럼 정의"
      pattern: "parent_id TEXT REFERENCES transactions"
    - from: "25-sqlite status CHECK"
      to: "60-batch-tx PARTIAL_FAILURE 상태 전이"
      via: "PARTIAL_FAILURE enum 값 추가"
      pattern: "PARTIAL_FAILURE"
---

<objective>
60-batch-transaction-spec.md §6에 부모-자식 2계층 DB 저장 전략을 정의하고, 25-sqlite-schema.md의 transactions 테이블에 parent_id + batch_index 컬럼과 PARTIAL_FAILURE 상태를 추가한다.

Purpose: 구현자가 배치 트랜잭션의 DB 저장과 상태 관리를 추측 없이 구현할 수 있도록 한다.
Output: 60-batch-tx §6 2계층 저장 전략 + 25-sqlite 스키마 변경
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/60-batch-transaction-spec.md
@.planning/deliverables/25-sqlite-schema.md
@objectives/v0.10-pre-implementation-design-completion.md
@.planning/phases/41-policy-engine-completion/41-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 60-batch-tx §6 부모-자식 2계층 DB 저장 전략으로 전환</name>
  <files>docs/60-batch-transaction-spec.md</files>
  <action>
60-batch-transaction-spec.md §6 "감사 로그 전략"을 "부모-자식 2계층 저장 + 감사 로그 전략"으로 제목을 변경하고, 기존 §6.1 "단일 레코드" 전략을 v0.10의 "부모-자식 2계층" 전략으로 교체한다.

**§6.1 제목 변경:** "transactions 테이블 기록" -> "부모-자식 2계층 저장 전략 [v0.10]"

기존 §6.1의 단일 레코드 코드 블록을 다음으로 교체:

1. **2계층 구조 설명** -- 기존 "단일 레코드" 첫 문단을 교체:
```
배치 트랜잭션은 transactions 테이블에 **부모-자식 2계층**으로 기록한다 [v0.10 변경: 기존 단일 레코드 -> 2계층].
- 부모 레코드: type='BATCH', 배치 전체를 대표하는 1건
- 자식 레코드: 개별 instruction별 N건, parent_id로 부모 참조, batch_index로 순서 보장
```

2. **부모 레코드 코드 예시:**
```typescript
// 부모 레코드 (배치 전체)
const parentRecord = {
  id: generateUUIDv7(),
  agentId: agent.id,
  sessionId: session.id,
  chain: 'solana',
  txHash: submitResult.txHash,  // Solana: 단일 TX 해시 (자식과 공유)
  type: 'BATCH',
  amount: batchTotalAmount.toString(),  // 합산 네이티브 금액
  toAddress: null,                       // 배치는 단일 수신자 없음
  status: 'CONFIRMED',                  // 또는 FAILED, PARTIAL_FAILURE
  tier: finalTier,
  parentId: null,                        // 부모 자신은 parent_id NULL
  batchIndex: null,                      // 부모 자신은 batch_index NULL
  // 감사 컬럼은 기존 §6.3 규칙 적용 (대표값 저장)
  contractAddress: findFirst(instructions, 'CONTRACT_CALL')?.programId ?? null,
  methodSignature: null,
  tokenAddress: findFirstToken(instructions)?.token?.address ?? null,
  spenderAddress: findFirst(instructions, 'APPROVE')?.spender ?? null,
  metadata: JSON.stringify({
    batch_size: instructions.length,
    total_native_amount: batchTotalAmount.toString(),
    ata_created: ataCreatedCount,
    compute_units_consumed: simResult.unitsConsumed,
  }),
  createdAt: new Date(),
}
```

3. **자식 레코드 코드 예시:**
```typescript
// 자식 레코드 (개별 instruction별 N건)
const childRecords = instructions.map((instr, index) => ({
  id: generateUUIDv7(),
  agentId: agent.id,
  sessionId: session.id,
  chain: 'solana',
  txHash: submitResult.txHash,  // Solana 원자적 배치: 부모와 동일 해시 공유
  type: instr.type,             // TRANSFER, TOKEN_TRANSFER, CONTRACT_CALL, APPROVE
  amount: resolveInstructionAmount(instr),
  toAddress: 'to' in instr ? instr.to : null,
  status: 'CONFIRMED',          // Solana 원자적: 부모와 동일
  tier: finalTier,
  parentId: parentRecord.id,    // 부모 배치 참조
  batchIndex: index,            // 0-based 순서
  // 개별 감사 컬럼
  contractAddress: instr.type === 'CONTRACT_CALL' ? instr.programId : null,
  tokenAddress: ('token' in instr) ? instr.token.address : null,
  spenderAddress: instr.type === 'APPROVE' ? instr.spender : null,
  approvedAmount: instr.type === 'APPROVE' ? instr.amount.toString() : null,
  metadata: null,               // 자식은 개별 metadata 불필요 (부모에 요약)
  createdAt: new Date(),
}))
```

4. **상태 전이 테이블** (§6 내 새로운 하위 섹션 추가, 기존 §6.2 이전):

| 시나리오 | 부모 상태 | 자식 상태 | tx_hash |
|----------|----------|----------|---------|
| 전체 성공 (Solana 원자적) | CONFIRMED | 전체 CONFIRMED | 부모-자식 동일 해시 공유 |
| Solana 원자적 실패 | FAILED | 전체 FAILED (원자적 롤백) | 실패한 TX 해시 또는 NULL |
| EVM 순차 부분 실패 | **PARTIAL_FAILURE** | 성공분 CONFIRMED + 실패분 FAILED | 자식별 독립 해시 |

> **PARTIAL_FAILURE 적용 범위:** PARTIAL_FAILURE는 EVM 순차 배치 전용 상태이다. 현재 Solana-only 배치에서는 원자적 실행이므로 CONFIRMED 또는 FAILED만 발생한다. PARTIAL_FAILURE는 향후 EVM 배치 지원 시를 위한 예비 상태이며, v0.10에서 status CHECK에 미리 포함한다.

5. **Solana vs EVM 자식 tx_hash 차이:**
- Solana 원자적 배치: 자식 레코드 전체가 부모와 동일한 tx_hash를 공유 (단일 트랜잭션)
- EVM 순차 배치(향후): 자식별 독립 tx_hash (개별 트랜잭션)

6. **기존 §6.2 metadata JSON 구조 수정:** batch_instructions 배열을 metadata에서 제거 (자식 레코드로 정규화되었으므로). metadata에는 요약 정보만 유지:
```json
{
  "batch_size": 3,
  "total_native_amount": "1000000000",
  "ata_created": 1,
  "compute_units_consumed": 45000
}
```

7. **기존 §6.3 감사 컬럼 채우기 규칙 보완:** "부모 레코드에 대표값 저장 (기존 규칙 동일), 자식 레코드에 개별값 저장" 문구 추가. 자식 레코드가 있으므로 metadata 내 batch_instructions로의 fallback 조회는 더 이상 필요 없음을 명시.

8. **기존 §6.4 감사 쿼리 패턴에 자식 조회 쿼리 추가:**
```sql
-- 배치의 자식 instruction 조회 (부모-자식 관계)
SELECT * FROM transactions
WHERE parent_id = :batchId
ORDER BY batch_index ASC;

-- 특정 에이전트의 배치 부모만 조회
SELECT * FROM transactions
WHERE agent_id = :agentId AND type = 'BATCH' AND parent_id IS NULL
ORDER BY created_at DESC;
```

주의: 기존 §6.3, §6.4의 핵심 내용은 유지하되 2계층 컨텍스트에 맞게 보완한다. 삭제하지 않고 확장한다.
  </action>
  <verify>
60-batch-transaction-spec.md에서 다음을 확인:
1. §6.1 제목에 "[v0.10]" 표기 존재
2. "부모-자식 2계층" 문구 존재
3. parentRecord 코드 블록에 parentId: null 존재
4. childRecords 코드 블록에 parentId: parentRecord.id, batchIndex: index 존재
5. 상태 전이 테이블에 PARTIAL_FAILURE 포함
6. "EVM 순차 배치 전용" 문구 존재
7. 자식 조회 SQL 쿼리 존재 (parent_id = :batchId)
  </verify>
  <done>
60-batch-tx §6에 부모-자식 2계층 DB 저장 전략이 정의되어 있고, PARTIAL_FAILURE 상태 전이가 EVM 전용으로 명시되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: 25-sqlite transactions 테이블에 parent_id + batch_index 컬럼 및 PARTIAL_FAILURE 상태 추가</name>
  <files>.planning/deliverables/25-sqlite-schema.md</files>
  <action>
25-sqlite-schema.md §2.3 "transactions 테이블"의 Drizzle ORM 정의와 CREATE TABLE DDL, 컬럼 설명 테이블을 수정한다. 또한 §4에 새로운 마이그레이션 섹션을 추가한다.

**1. Drizzle ORM 정의에 컬럼 추가** (§2.3 내, `metadata` 컬럼 직전 또는 에러/메타데이터 섹션):

기존 `error` 컬럼 앞에 배치 관련 컬럼 추가:
```typescript
  // ── 배치 관련 [v0.10 추가] ──
  parentId: text('parent_id')
    .references(() => transactions.id, { onDelete: 'cascade' }),  // 부모 배치 TX (NULL = 단독 TX)
  batchIndex: integer('batch_index'),                              // 배치 내 순서 (0-based, NULL = 단독 TX)
```

**2. status enum에 PARTIAL_FAILURE 추가:**

기존:
```typescript
  status: text('status', {
    enum: ['PENDING', 'QUEUED', 'EXECUTING', 'SUBMITTED', 'CONFIRMED', 'FAILED', 'CANCELLED', 'EXPIRED']
  }).notNull().default('PENDING'),
```

변경:
```typescript
  status: text('status', {
    enum: ['PENDING', 'QUEUED', 'EXECUTING', 'SUBMITTED', 'CONFIRMED', 'FAILED', 'CANCELLED', 'EXPIRED', 'PARTIAL_FAILURE']  // (v0.10 추가) PARTIAL_FAILURE: EVM 순차 배치 부분 실패
  }).notNull().default('PENDING'),
```

**3. 인덱스 추가** (테이블 정의의 인덱스 배열에):
```typescript
  index('idx_transactions_parent_id').on(table.parentId),  // (v0.10 추가) 배치 자식 조회용
```

**4. CREATE TABLE DDL 수정:**

parent_id, batch_index 컬럼 추가 (metadata 앞):
```sql
  parent_id TEXT REFERENCES transactions(id) ON DELETE CASCADE,   -- (v0.10 추가) 부모 배치 TX (NULL = 단독 TX)
  batch_index INTEGER,                                             -- (v0.10 추가) 배치 내 순서 (0-based, NULL = 단독 TX)
```

status CHECK 변경:
```sql
  status TEXT NOT NULL DEFAULT 'PENDING'
    CHECK (status IN ('PENDING', 'QUEUED', 'EXECUTING', 'SUBMITTED', 'CONFIRMED', 'FAILED', 'CANCELLED', 'EXPIRED', 'PARTIAL_FAILURE')),
```

인덱스 추가:
```sql
CREATE INDEX idx_transactions_parent_id ON transactions(parent_id)
  WHERE parent_id IS NOT NULL;                                     -- (v0.10 추가) partial index
```

**5. 컬럼 설명 테이블에 2행 추가:**

| `parent_id` | TEXT (FK, self-ref) | NULL | - | (v0.10 추가) 부모 배치 트랜잭션 ID. 자기 참조 FK. NULL = 단독 트랜잭션. ON DELETE CASCADE |
| `batch_index` | INTEGER | NULL | - | (v0.10 추가) 배치 내 순서 (0-based). NULL = 단독 트랜잭션 |

기존 status 컬럼 설명 업데이트: "CHECK 제약" -> "CHECK 제약 9개: ... + PARTIAL_FAILURE(v0.10)"

**6. §4에 v0.10 마이그레이션 섹션 추가** (§4.13 이후, "### 4.14 [v0.10] 마이그레이션: parent_id + batch_index 추가 + PARTIAL_FAILURE 상태"):

```sql
-- v0.10 마이그레이션: 배치 부모-자식 2계층 지원

-- 1. parent_id + batch_index 컬럼 추가
ALTER TABLE transactions ADD COLUMN parent_id TEXT REFERENCES transactions(id) ON DELETE CASCADE;
ALTER TABLE transactions ADD COLUMN batch_index INTEGER;

-- 2. 인덱스 추가
CREATE INDEX idx_transactions_parent_id ON transactions(parent_id) WHERE parent_id IS NOT NULL;

-- 3. status CHECK 변경: PARTIAL_FAILURE 추가
-- 주의: SQLite는 ALTER TABLE으로 CHECK 변경 불가.
-- drizzle-kit이 테이블 재생성(CREATE new -> INSERT INTO -> DROP old -> ALTER RENAME)으로 처리.
-- 기존 데이터의 status 값은 모두 유효(기존 8개 값)이므로 재생성 시 CHECK 위반 없음.
```

주의:
- Phase 41에서 이미 §4.4의 rules 컬럼 SSoT 참조를 수정했으므로, §2.4 policies 테이블은 건드리지 않는다.
- ON DELETE CASCADE 선택 근거를 주석으로 명시: "부모-자식은 논리적 단위이므로 함께 관리. 거래 기록 보존은 agents RESTRICT에서 보장."
- §6 전체 스키마 export 블록이 있다면, 해당 블록에도 새 컬럼을 반영한다.
  </action>
  <verify>
25-sqlite-schema.md에서 다음을 확인:
1. Drizzle ORM 정의에 parentId, batchIndex 컬럼 존재
2. status enum에 'PARTIAL_FAILURE' 포함
3. DDL에 parent_id, batch_index 컬럼 존재
4. DDL의 status CHECK에 'PARTIAL_FAILURE' 포함
5. idx_transactions_parent_id 인덱스 존재
6. 컬럼 설명 테이블에 parent_id, batch_index 행 존재
7. §4.14 마이그레이션 섹션 존재
8. ON DELETE CASCADE 근거 주석 존재
  </verify>
  <done>
25-sqlite transactions 테이블에 parent_id TEXT REFERENCES transactions(id) ON DELETE CASCADE + batch_index INTEGER 컬럼이 추가되어 있고, PARTIAL_FAILURE가 status CHECK에 포함되어 있다. 마이그레이션 가이드가 §4.14에 존재한다.
  </done>
</task>

</tasks>

<verification>
1. grep "parent_id" docs/60-batch-transaction-spec.md -- 부모-자식 관계 존재
2. grep "parent_id" .planning/deliverables/25-sqlite-schema.md -- 컬럼 추가 확인
3. grep "batch_index" .planning/deliverables/25-sqlite-schema.md -- 컬럼 추가 확인
4. grep "PARTIAL_FAILURE" docs/60-batch-transaction-spec.md -- 상태 전이 존재
5. grep "PARTIAL_FAILURE" .planning/deliverables/25-sqlite-schema.md -- status CHECK 포함
6. grep "ON DELETE CASCADE" .planning/deliverables/25-sqlite-schema.md -- FK 정책 명시
7. grep "4.14" .planning/deliverables/25-sqlite-schema.md -- 마이그레이션 섹션 존재
</verification>

<success_criteria>
- 60-batch-tx §6에 부모-자식 2계층 저장 전략이 정의되어 있다
- 25-sqlite transactions 테이블에 parent_id + batch_index 컬럼이 추가되어 있다
- PARTIAL_FAILURE 상태가 EVM 순차 배치 전용으로 문서화되어 있다
- 상태 전이 테이블이 3가지 시나리오(전체 성공/Solana 실패/EVM 부분 실패)를 커버한다
- 마이그레이션 가이드가 SQLite CHECK 변경 제약을 고려하여 작성되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/44-operational-logic-completion/44-02-SUMMARY.md`
</output>
