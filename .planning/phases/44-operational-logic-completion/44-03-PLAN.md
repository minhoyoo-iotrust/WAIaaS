---
phase: 44-operational-logic-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/61-price-oracle-spec.md
autonomous: true

must_haves:
  truths:
    - "61-price-oracle §3.6 OracleChain.getPrice()에 교차 검증이 동기적으로 인라인되어 있고, 10% 초과 괴리 시 Math.max(primaryPrice, fallbackPrice) 채택 로직이 반환값에 반영된다"
    - "§3.6 또는 §5에 가격 나이별 3단계(FRESH/AGING/STALE) 처리 테이블이 단일 테이블로 존재한다"
    - ">30분(STALE) 가격 시 USD 평가 스킵 -> 네이티브 금액 전용 평가 정책이 resolveEffectiveAmountUsd()와 연결되어 명시되어 있다"
    - "PRICE_DEVIATION_WARNING 감사 로그 + SYSTEM_WARNING 알림이 교차 검증 코드에 포함되어 있다"
  artifacts:
    - path: "docs/61-price-oracle-spec.md"
      provides: "교차 검증 인라인 + 3단계 stale 처리 + USD 스킵 정책"
      contains: "PRICE_DEVIATION_WARNING"
  key_links:
    - from: "OracleChain.getPrice() 교차 검증"
      to: "resolveEffectiveAmountUsd() §6.2"
      via: "isStale 플래그 + PriceNotAvailableError"
      pattern: "resolveEffectiveAmountUsd"
    - from: "§5 STALE(>30분) 정책"
      to: "applyFallbackStrategy() §5.4"
      via: "PriceNotAvailableError catch"
      pattern: "applyFallbackStrategy"
---

<objective>
61-price-oracle-spec.md §3.6에 다중 소스 10% 괴리 시 보수적 선택(높은 가격 채택) 로직을 OracleChain.getPrice()에 동기적으로 인라인하고, §5에 가격 나이별 3단계(FRESH/AGING/STALE) 처리를 단일 테이블로 정리하여 >30분 시 USD 평가 스킵 정책을 명시한다.

Purpose: 구현자가 다중 가격 소스 충돌 해결과 stale 가격 처리를 추측 없이 구현할 수 있도록 한다.
Output: 61-price-oracle-spec.md §3.6 교차 검증 인라인 + §5 STALE 정책 보완
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/61-price-oracle-spec.md
@objectives/v0.10-pre-implementation-design-completion.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: §3.6 OracleChain.getPrice() 교차 검증 동기 인라인 + §5 가격 나이별 3단계 정책 테이블</name>
  <files>docs/61-price-oracle-spec.md</files>
  <action>
61-price-oracle-spec.md에서 두 곳을 수정한다.

**변경 A: §3.6 OracleChain.getPrice() 교차 검증 인라인 [v0.10]**

기존 §3.6의 OracleChain 클래스 코드 블록에서 getPrice() 메서드를 교체한다. 기존 코드의 "다중 소스 교차 검증 (섹션 7 참조)" 주석 부분을 실제 교차 검증 로직으로 교체한다.

기존 getPrice() (교체 대상):
```typescript
  async getPrice(token: TokenRef): Promise<PriceInfo> {
    let lastError: Error | undefined

    for (const oracle of this.oracles) {
      try {
        const price = await oracle.getPrice(token)

        // 다중 소스 교차 검증 (섹션 7 참조)
        // Primary 성공 후 다른 소스와 +-10% 이내 일치 확인은
        // 선택적 비동기 백그라운드 검증으로 수행
        return price
      } catch (error) {
        lastError = error as Error
        // 다음 소스로 fallback
        continue
      }
    }

    // 모든 소스 실패: stale 캐시 최종 시도
    const cacheKey = `${token.chain}:${token.address}`
    const stale = this.sharedCache.getStale(cacheKey)
    if (stale) {
      return { ...stale.price, source: 'cache', isStale: true }
    }

    throw new PriceNotAvailableError(token, lastError)
  }
```

교체할 getPrice() [v0.10 교차 검증 인라인]:
```typescript
  /**
   * [v0.10] 교차 검증이 동기적으로 인라인된 getPrice().
   *
   * 기존: Primary 성공 시 즉시 반환, 교차 검증은 비동기 백그라운드
   * 변경: Primary 성공 후 Fallback으로 동기적 교차 검증 수행
   *
   * 교차 검증 플로우:
   * 1. Primary(CoinGecko) 조회
   * 2. Primary 성공 + Fallback 존재 → Fallback으로 교차 검증
   * 3. 10% 초과 괴리 → 높은 가격 채택 (보수적) + 감사 로그 + 알림
   * 4. 10% 이내 또는 Fallback 실패 → Primary 가격 채택
   */
  async getPrice(token: TokenRef): Promise<PriceInfo> {
    let lastError: Error | undefined
    let primaryPrice: PriceInfo | undefined

    for (let i = 0; i < this.oracles.length; i++) {
      try {
        const price = await this.oracles[i].getPrice(token)

        if (i === 0) {
          // Primary 성공: 교차 검증 시도
          primaryPrice = price

          if (this.oracles.length > 1) {
            try {
              const fallbackPrice = await this.oracles[1].getPrice(token)
              const deviation = Math.abs(
                (price.usdPrice - fallbackPrice.usdPrice) / price.usdPrice
              ) * 100

              if (deviation > 10) {
                // 10% 초과 괴리: 높은 가격 채택 (보수적)
                // 높은 가격 = 정책 평가에서 더 높은 USD 금액 = 더 높은 보안 티어
                const conservativePrice = price.usdPrice >= fallbackPrice.usdPrice
                  ? price : fallbackPrice

                // 감사 로그 기록
                await this.auditLog.record({
                  event: 'PRICE_DEVIATION_WARNING',
                  details: {
                    token: `${token.chain}:${token.address}`,
                    primarySource: price.source,
                    primaryPrice: price.usdPrice,
                    fallbackSource: fallbackPrice.source,
                    fallbackPrice: fallbackPrice.usdPrice,
                    deviationPercent: deviation.toFixed(2),
                    adoptedSource: conservativePrice.source,
                    adoptedPrice: conservativePrice.usdPrice,
                  },
                })

                // SYSTEM_WARNING 알림 이벤트 발송
                this.notifier?.emit('SYSTEM_WARNING', {
                  type: 'PRICE_DEVIATION',
                  message: `Price deviation ${deviation.toFixed(1)}% detected for ${token.chain}:${token.address}`,
                })

                return conservativePrice
              }
            } catch {
              // 교차 검증 실패 (Fallback 소스 장애): Primary 신뢰
              // Fallback 호출 타임아웃(5초)은 각 오라클 구현체에서 설정
            }
          }

          return price
        }

        // i > 0: Primary 실패 후 Fallback 성공
        return price
      } catch (error) {
        lastError = error as Error
        continue
      }
    }

    // 모든 소스 실패: stale 캐시 최종 시도
    const cacheKey = `${token.chain}:${token.address}`
    const stale = this.sharedCache.getStale(cacheKey)
    if (stale) {
      return { ...stale.price, source: 'cache', isStale: true }
    }

    throw new PriceNotAvailableError(token, lastError)
  }
```

§3.6 코드 블록 직후에 설명 문단 추가:

> **[v0.10 변경] 교차 검증 동기 전환 근거:** 기존 §7.1.1의 비동기 백그라운드 교차 검증을 동기적 인라인으로 전환했다. 보수적 가격 채택을 getPrice() 반환값에 반영하려면, 교차 검증 결과가 반환 전에 확정되어야 한다. Fallback 호출 타임아웃(5초)은 각 오라클 구현체에 이미 설정되어 있어, 최악의 경우 추가 5초의 latency가 발생한다. 이는 트랜잭션 파이프라인의 전체 타임아웃(INSTANT/NOTIFY=30초)에 비해 허용 범위이다.

**변경 B: §5에 가격 나이별 3단계 처리 통합 테이블 [v0.10]**

§5.2 "Stale 데이터 허용 조건" 직후(§5.3 직전)에 새로운 하위 섹션 "### 5.2.1 가격 나이별 3단계 정책 평가 동작 [v0.10]"을 삽입한다:

```markdown
### 5.2.1 가격 나이별 3단계 정책 평가 동작 [v0.10]

| 상태 | 가격 나이 | USD 평가 | 정책 평가 동작 | 로그/알림 |
|------|----------|---------|---------------|---------|
| **FRESH** | < 5분 | 정상 수행 | resolveEffectiveAmountUsd() 정상 실행 | 없음 |
| **AGING** | 5분~30분 | 정상 수행 + 보수적 상향 | resolveEffectiveAmountUsd() 실행 + adjustTierForStalePrice() (INSTANT→NOTIFY) | PRICE_STALE 경고 로그 |
| **STALE** | > 30분 | **스킵** | resolveEffectiveAmountUsd() → PriceNotAvailableError → applyFallbackStrategy() → 네이티브 금액만으로 티어 결정 | PRICE_UNAVAILABLE 감사 로그 |
| **UNAVAILABLE** | 오라클 전체 실패 | **스킵** | applyFallbackStrategy() → 네이티브 금액만으로 티어 결정 (§5.4 Phase 22-23 과도기 전략) | PRICE_UNAVAILABLE 감사 로그 + 알림 |

> **FRESH vs AGING vs STALE 구분:** "stale"이라는 용어가 5분(TTL 만료)과 30분(staleMaxAge 초과) 양쪽에 사용되어 혼동될 수 있다. 5분~30분 구간은 **AGING**(가격을 사용하되 보수적 상향)이고, 30분 초과는 **STALE**(가격 자체를 버리고 네이티브 전용 평가)이다. 구현 시 `isStale` 플래그는 TTL 만료(>5분) 시 true가 되지만, **STALE(>30분) 처리는 PriceNotAvailableError를 통해** 별도로 처리된다 (staleMaxAge 초과 시 캐시에서 삭제 → 조회 실패).

> **[v0.10] STALE(>30분) 가격 USD 평가 스킵 근거:** stale 가격으로 잘못된 INSTANT 판정을 내리는 것보다, USD 평가를 스킵하고 네이티브 금액 기준으로만 평가하는 것이 더 안전하다. 네이티브 금액 기준 SPENDING_LIMIT는 항상 유효하므로 최소한의 보호를 보장한다.
```

**변경 C: §6.2 resolveEffectiveAmountUsd()에 STALE 연결 주석 추가 [v0.10]**

§6.2의 resolveEffectiveAmountUsd() 함수의 catch 블록(마지막 부분)에 주석을 보강한다. 기존:
```typescript
  } catch {
    // 오라클 완전 장애: Phase 22-23 과도기 전략으로 fallback
    return { usdAmount: 0, fallbackToNative: true, isStale: false }
  }
```

이 주석을 확장:
```typescript
  } catch {
    // 오라클 완전 장애 또는 STALE(>30분) 가격:
    // PriceNotAvailableError 발생 → Phase 22-23 과도기 전략으로 fallback
    // → applyFallbackStrategy() (§5.4) → 네이티브 금액만으로 티어 결정
    // [v0.10] §5.2.1 가격 나이별 3단계 참조
    return { usdAmount: 0, fallbackToNative: true, isStale: false }
  }
```

**변경 D: §7.1.1 교차 검증 주석 업데이트 [v0.10]**

기존 §7.1.1에 "비동기 백그라운드 검증"으로 기술된 crossValidatePrice()가 있다면, "[v0.10] 교차 검증은 §3.6 OracleChain.getPrice()에 동기적으로 인라인됨. 이 섹션의 비동기 백그라운드 검증은 폐기." 주석을 추가한다. 기존 코드/텍스트는 참고용으로 유지하되 ~~취소선~~ 없이 "[v0.10 폐기]" 접두어를 붙인다.

주의:
- getNativePrice()는 교차 검증 대상이 아님 (네이티브 토큰은 단일 가격 소스로 충분)
- getPrices() 배치 조회도 교차 검증 미적용 (Primary에서 최대한 조회 후 실패분만 Fallback)
- 교차 검증은 getPrice() 단건 조회에만 적용
  </action>
  <verify>
61-price-oracle-spec.md에서 다음을 확인:
1. §3.6 getPrice()에 "교차 검증" 주석과 deviation > 10 조건 존재
2. "Math.abs" 또는 "보수적 선택" 또는 "높은 가격 채택" 문구 존재
3. "PRICE_DEVIATION_WARNING" 감사 이벤트 존재
4. "SYSTEM_WARNING" 알림 이벤트 존재
5. §5.2.1에 "FRESH", "AGING", "STALE" 3단계 테이블 존재
6. "> 30분" + "USD 평가 스킵" 또는 "네이티브 금액만으로" 문구 존재
7. §6.2 catch 블록에 "[v0.10] §5.2.1" 참조 존재
8. §7.1.1에 "[v0.10 폐기]" 표기 존재
  </verify>
  <done>
61-price-oracle §3.6에 10% 괴리 시 보수적 선택(높은 가격 채택) 로직이 동기적으로 인라인되어 있고, §5에 가격 나이별 3단계(FRESH/AGING/STALE) 처리 테이블이 존재하며, >30분 시 USD 평가 스킵 -> 네이티브 금액 전용 평가 정책이 resolveEffectiveAmountUsd()와 연결되어 있다.
  </done>
</task>

</tasks>

<verification>
1. grep "PRICE_DEVIATION_WARNING" docs/61-price-oracle-spec.md -- 교차 검증 감사 로그 존재
2. grep "보수적" docs/61-price-oracle-spec.md -- 높은 가격 채택 로직 존재
3. grep "FRESH" docs/61-price-oracle-spec.md -- 3단계 테이블 존재
4. grep "AGING" docs/61-price-oracle-spec.md -- 3단계 테이블 존재
5. grep "STALE" docs/61-price-oracle-spec.md -- 3단계 테이블 존재
6. grep "USD 평가 스킵" docs/61-price-oracle-spec.md -- >30분 정책 존재
7. grep "§5.2.1" docs/61-price-oracle-spec.md -- 교차 참조 존재
8. grep "v0.10 폐기" docs/61-price-oracle-spec.md -- §7.1.1 업데이트 확인
</verification>

<success_criteria>
- §3.6 OracleChain.getPrice()에 교차 검증이 동기적으로 인라인되어 있다
- 10% 초과 괴리 시 높은 가격 채택이 반환값에 반영된다
- §5에 가격 나이별 3단계(FRESH/AGING/STALE) 처리가 단일 테이블로 존재한다
- STALE(>30분) 시 USD 평가 스킵 정책이 resolveEffectiveAmountUsd()와 연결되어 있다
- §7.1.1의 비동기 교차 검증이 폐기 표기되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/44-operational-logic-completion/44-03-SUMMARY.md`
</output>
