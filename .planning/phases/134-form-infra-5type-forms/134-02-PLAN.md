---
phase: 134-form-infra-5type-forms
plan: 02
type: execute
wave: 2
depends_on: ["134-01"]
files_modified:
  - packages/admin/src/components/policy-forms/spending-limit-form.tsx
  - packages/admin/src/components/policy-forms/whitelist-form.tsx
  - packages/admin/src/components/policy-forms/rate-limit-form.tsx
  - packages/admin/src/components/policy-forms/approve-amount-limit-form.tsx
  - packages/admin/src/components/policy-forms/approve-tier-override-form.tsx
  - packages/admin/src/components/policy-forms/index.ts
  - packages/admin/src/pages/policies.tsx
  - packages/admin/src/__tests__/policy-forms.test.tsx
autonomous: true

must_haves:
  truths:
    - "SPENDING_LIMIT 타입 선택 시 3개 네이티브 금액(instant_max/notify_max/delay_max) + 3개 USD 금액(선택, instant_max_usd/notify_max_usd/delay_max_usd) + delay_seconds 필드가 렌더링된다"
    - "WHITELIST 타입 선택 시 주소 동적 행 목록이 렌더링되고 [+ 추가]/[x] 동작이 작동한다"
    - "RATE_LIMIT 타입 선택 시 max_requests + window_seconds 숫자 입력 필드가 렌더링된다"
    - "APPROVE_AMOUNT_LIMIT 타입 선택 시 maxAmount 텍스트 입력 + blockUnlimited 체크박스가 렌더링된다"
    - "APPROVE_TIER_OVERRIDE 타입 선택 시 INSTANT/NOTIFY/DELAY/APPROVAL 셀렉트가 렌더링된다"
    - "필수 필드 미입력, 숫자 형식 오류, 빈 목록(행 0개) 생성 시도 시 필드 하단에 에러 메시지가 표시된다"
    - "5개 타입 전용 폼으로 정책 생성이 가능하고 올바른 rules 객체가 API에 전달된다"
  artifacts:
    - path: "packages/admin/src/components/policy-forms/spending-limit-form.tsx"
      provides: "SPENDING_LIMIT 전용 폼"
      exports: ["SpendingLimitForm"]
    - path: "packages/admin/src/components/policy-forms/whitelist-form.tsx"
      provides: "WHITELIST 전용 폼 (DynamicRowList 사용)"
      exports: ["WhitelistForm"]
    - path: "packages/admin/src/components/policy-forms/rate-limit-form.tsx"
      provides: "RATE_LIMIT 전용 폼"
      exports: ["RateLimitForm"]
    - path: "packages/admin/src/components/policy-forms/approve-amount-limit-form.tsx"
      provides: "APPROVE_AMOUNT_LIMIT 전용 폼"
      exports: ["ApproveAmountLimitForm"]
    - path: "packages/admin/src/components/policy-forms/approve-tier-override-form.tsx"
      provides: "APPROVE_TIER_OVERRIDE 전용 폼"
      exports: ["ApproveTierOverrideForm"]
    - path: "packages/admin/src/__tests__/policy-forms.test.tsx"
      provides: "5개 타입 폼 렌더링 + 유효성 검증 + 생성 통합 테스트"
      min_lines: 100
  key_links:
    - from: "packages/admin/src/components/policy-forms/index.ts"
      to: "5개 type-specific form"
      via: "switch/case in PolicyFormRouter"
      pattern: "case.*SPENDING_LIMIT.*SpendingLimitForm"
    - from: "packages/admin/src/components/policy-forms/whitelist-form.tsx"
      to: "packages/admin/src/components/dynamic-row-list.tsx"
      via: "import DynamicRowList"
      pattern: "DynamicRowList"
    - from: "packages/admin/src/pages/policies.tsx"
      to: "PolicyFormRouter"
      via: "handleCreate가 formRulesObj를 API에 전달"
      pattern: "formRulesObj\\.value"
---

<objective>
5개 핵심 타입(SPENDING_LIMIT, WHITELIST, RATE_LIMIT, APPROVE_AMOUNT_LIMIT, APPROVE_TIER_OVERRIDE) 전용 폼 구현 + 실시간 유효성 검증 + PolicyFormRouter 통합 + 테스트.

Purpose: 운영자가 JSON 직접 입력 없이 구조화된 폼으로 5개 핵심 정책을 생성할 수 있다.
Output: 5개 타입 전용 폼 컴포넌트, PolicyFormRouter 통합, 유효성 검증, 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/134-form-infra-5type-forms/134-01-SUMMARY.md
@objectives/v1.5.2-admin-policy-form-ux.md
@packages/core/src/schemas/policy.schema.ts
@packages/core/src/enums/policy.ts
@packages/admin/src/pages/policies.tsx
@packages/admin/src/components/form.tsx
@packages/admin/src/components/dynamic-row-list.tsx
@packages/admin/src/components/policy-forms/index.ts
@packages/admin/src/__tests__/policies.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: 5개 타입 전용 폼 컴포넌트 + PolicyFormRouter 연결</name>
  <files>packages/admin/src/components/policy-forms/spending-limit-form.tsx, packages/admin/src/components/policy-forms/whitelist-form.tsx, packages/admin/src/components/policy-forms/rate-limit-form.tsx, packages/admin/src/components/policy-forms/approve-amount-limit-form.tsx, packages/admin/src/components/policy-forms/approve-tier-override-form.tsx, packages/admin/src/components/policy-forms/index.ts</files>
  <action>
5개 타입 전용 폼 컴포넌트를 생성한다. 모든 폼은 `PolicyFormProps` 인터페이스(`{ rules, onChange, errors }`)를 받는다. 각 폼에서 필드 변경 시 `onChange({...rules, [field]: newValue})`를 호출하여 부모에게 전체 rules 객체를 전달한다.

**A. SpendingLimitForm (`spending-limit-form.tsx`):**

SPENDING_LIMIT 스키마 필드: instant_max(string, 양의 정수), notify_max(string), delay_max(string), instant_max_usd(number, 선택), notify_max_usd(number, 선택), delay_max_usd(number, 선택), delay_seconds(number int, 최소 60).

레이아웃:
```
<div class="policy-form-fields">
  <h4>Native Amount Tiers</h4>
  <div class="policy-form-grid">
    <FormField label="Instant Max (lamports/wei)" name="instant_max" value={rules.instant_max || ''} onChange={...} error={errors.instant_max} required />
    <FormField label="Notify Max (lamports/wei)" name="notify_max" value={rules.notify_max || ''} onChange={...} error={errors.notify_max} required />
    <FormField label="Delay Max (lamports/wei)" name="delay_max" value={rules.delay_max || ''} onChange={...} error={errors.delay_max} required />
  </div>
  <h4>USD Amount Tiers (Optional)</h4>
  <div class="policy-form-grid">
    <FormField label="Instant Max USD" name="instant_max_usd" type="number" value={rules.instant_max_usd ?? ''} onChange={...} placeholder="Optional" />
    <FormField label="Notify Max USD" name="notify_max_usd" type="number" value={rules.notify_max_usd ?? ''} onChange={...} placeholder="Optional" />
    <FormField label="Delay Max USD" name="delay_max_usd" type="number" value={rules.delay_max_usd ?? ''} onChange={...} placeholder="Optional" />
  </div>
  <FormField label="Delay Duration (seconds, min 60)" name="delay_seconds" type="number" value={rules.delay_seconds ?? 900} onChange={...} error={errors.delay_seconds} required min={60} />
</div>
```

금액 필드(instant_max/notify_max/delay_max)는 text 타입으로 렌더링 (lamports/wei 문자열이므로 큰 수 지원). onChange에서 숫자가 아닌 문자 입력 시 rules는 업데이트하되 부모의 validation에서 에러를 표시한다.

USD 필드는 number 타입. 빈 값이면 onChange에서 해당 키를 rules 객체에서 제거한다 (optional이므로). 즉:
```ts
const handleUsdChange = (field: string) => (v: string | number | boolean) => {
  const num = Number(v);
  const next = { ...rules };
  if (v === '' || v === 0 || Number.isNaN(num)) {
    delete next[field];
  } else {
    next[field] = num;
  }
  onChange(next);
};
```

**B. WhitelistForm (`whitelist-form.tsx`):**

WHITELIST 스키마: `{ allowed_addresses: string[] }`. DynamicRowList를 사용.

```tsx
import { DynamicRowList } from '../dynamic-row-list';
import { FormField } from '../form';
import type { PolicyFormProps } from './index';

export function WhitelistForm({ rules, onChange, errors }: PolicyFormProps) {
  const addresses = (rules.allowed_addresses as string[]) || [];

  return (
    <div class="policy-form-fields">
      <DynamicRowList
        items={addresses}
        onAdd={() => onChange({ ...rules, allowed_addresses: [...addresses, ''] })}
        onRemove={(i) => onChange({ ...rules, allowed_addresses: addresses.filter((_, idx) => idx !== i) })}
        onChange={(i, val) => {
          const next = [...addresses];
          next[i] = val;
          onChange({ ...rules, allowed_addresses: next });
        }}
        renderRow={(addr, i, onRowChange) => (
          <FormField
            label={`Address ${i + 1}`}
            name={`address-${i}`}
            value={addr}
            onChange={(v) => onRowChange(i, v as string)}
            placeholder="Wallet address"
            error={errors[`allowed_addresses.${i}`]}
            required
          />
        )}
        addLabel="+ Add Address"
        error={errors.allowed_addresses}
      />
    </div>
  );
}
```

**C. RateLimitForm (`rate-limit-form.tsx`):**

RATE_LIMIT 스키마: `{ max_requests: number, window_seconds: number }`. 간단한 숫자 2개 폼.

```tsx
<div class="policy-form-fields">
  <FormField label="Max Requests" name="max_requests" type="number" value={rules.max_requests ?? 100} onChange={...} error={errors.max_requests} required min={1} />
  <FormField label="Window (seconds)" name="window_seconds" type="number" value={rules.window_seconds ?? 3600} onChange={...} error={errors.window_seconds} required min={1} />
</div>
```

**D. ApproveAmountLimitForm (`approve-amount-limit-form.tsx`):**

APPROVE_AMOUNT_LIMIT 스키마: `{ maxAmount?: string(digits), blockUnlimited: boolean }`.

```tsx
<div class="policy-form-fields">
  <FormField label="Max Amount (lamports/wei, optional)" name="maxAmount" value={rules.maxAmount ?? ''} onChange={...} error={errors.maxAmount} placeholder="Leave empty for no limit" />
  <FormField label="Block Unlimited Approvals" name="blockUnlimited" type="checkbox" value={rules.blockUnlimited ?? true} onChange={...} />
</div>
```

maxAmount는 text 타입 (큰 수 문자열). 빈 값이면 rules에서 제거 (optional).

**E. ApproveTierOverrideForm (`approve-tier-override-form.tsx`):**

APPROVE_TIER_OVERRIDE 스키마: `{ tier: 'INSTANT' | 'NOTIFY' | 'DELAY' | 'APPROVAL' }`.

```tsx
<div class="policy-form-fields">
  <FormField
    label="Override Tier"
    name="tier"
    type="select"
    value={rules.tier ?? 'DELAY'}
    onChange={(v) => onChange({ ...rules, tier: v as string })}
    options={[
      { label: 'Instant', value: 'INSTANT' },
      { label: 'Notify', value: 'NOTIFY' },
      { label: 'Delay', value: 'DELAY' },
      { label: 'Approval', value: 'APPROVAL' },
    ]}
    error={errors.tier}
  />
</div>
```

**F. PolicyFormRouter 업데이트 (`index.ts`):**

Plan 01에서 생성된 placeholder PolicyFormRouter를 업데이트. 5개 타입에 대해 import + switch/case 분기:

```ts
import { SpendingLimitForm } from './spending-limit-form';
import { WhitelistForm } from './whitelist-form';
import { RateLimitForm } from './rate-limit-form';
import { ApproveAmountLimitForm } from './approve-amount-limit-form';
import { ApproveTierOverrideForm } from './approve-tier-override-form';

export function PolicyFormRouter({ type, rules, onChange, errors }: { type: string } & PolicyFormProps) {
  switch (type) {
    case 'SPENDING_LIMIT': return <SpendingLimitForm rules={rules} onChange={onChange} errors={errors} />;
    case 'WHITELIST': return <WhitelistForm rules={rules} onChange={onChange} errors={errors} />;
    case 'RATE_LIMIT': return <RateLimitForm rules={rules} onChange={onChange} errors={errors} />;
    case 'APPROVE_AMOUNT_LIMIT': return <ApproveAmountLimitForm rules={rules} onChange={onChange} errors={errors} />;
    case 'APPROVE_TIER_OVERRIDE': return <ApproveTierOverrideForm rules={rules} onChange={onChange} errors={errors} />;
    default: return <p class="policy-form-placeholder">This policy type uses JSON editor. Toggle to JSON mode.</p>;
  }
}
```

**G. policies.tsx에 유효성 검증 로직 추가:**

handleCreate에서 jsonMode === false(구조화 폼)일 때 실시간 유효성 검증을 수행한다:

```ts
// 유효성 검증 함수
function validateRules(type: string, rules: Record<string, unknown>): Record<string, string> {
  const errors: Record<string, string> = {};

  if (type === 'SPENDING_LIMIT') {
    if (!rules.instant_max || !/^\d+$/.test(rules.instant_max as string)) errors.instant_max = 'Positive integer required';
    if (!rules.notify_max || !/^\d+$/.test(rules.notify_max as string)) errors.notify_max = 'Positive integer required';
    if (!rules.delay_max || !/^\d+$/.test(rules.delay_max as string)) errors.delay_max = 'Positive integer required';
    const ds = Number(rules.delay_seconds);
    if (!rules.delay_seconds || Number.isNaN(ds) || ds < 60) errors.delay_seconds = 'Minimum 60 seconds';
  } else if (type === 'WHITELIST') {
    const addrs = (rules.allowed_addresses as string[]) || [];
    if (addrs.length === 0) errors.allowed_addresses = 'At least one address required';
    addrs.forEach((a, i) => { if (!a || a.trim() === '') errors[`allowed_addresses.${i}`] = 'Address required'; });
  } else if (type === 'RATE_LIMIT') {
    const mr = Number(rules.max_requests);
    if (!rules.max_requests || Number.isNaN(mr) || mr < 1 || !Number.isInteger(mr)) errors.max_requests = 'Positive integer required';
    const ws = Number(rules.window_seconds);
    if (!rules.window_seconds || Number.isNaN(ws) || ws < 1 || !Number.isInteger(ws)) errors.window_seconds = 'Positive integer required';
  } else if (type === 'APPROVE_AMOUNT_LIMIT') {
    if (rules.maxAmount && !/^\d+$/.test(rules.maxAmount as string)) errors.maxAmount = 'Must be a positive integer string';
  }
  // APPROVE_TIER_OVERRIDE는 셀렉트이므로 항상 유효

  return errors;
}
```

handleCreate 수정 (jsonMode === false 분기):
```ts
if (!jsonMode.value) {
  const validationErrors = validateRules(formType.value, formRulesObj.value);
  if (Object.keys(validationErrors).length > 0) {
    formErrors.value = validationErrors;
    return;
  }
  formErrors.value = {};
  parsedRules = formRulesObj.value;
}
```

실시간 검증: formRulesObj가 변경될 때 디바운스 없이 즉시 formErrors를 업데이트하는 것은 피한다. 대신 Create 버튼 클릭 시 검증하고, 에러가 있으면 formErrors를 설정하여 각 폼 컴포넌트의 errors prop으로 전달한다. 사용자가 필드를 수정하면 해당 필드의 에러만 제거한다 — 이를 위해 PolicyFormRouter의 onChange에서 formErrors에서 변경된 필드의 키를 삭제한다:

```ts
// PolicyFormRouter onChange wrapper in policies.tsx
const handleRulesChange = (newRules: Record<string, unknown>) => {
  formRulesObj.value = newRules;
  // 에러가 있으면 재검증하여 수정된 필드 에러 제거
  if (Object.keys(formErrors.value).length > 0) {
    formErrors.value = validateRules(formType.value, newRules);
  }
};
```

validateRules 함수를 policies.tsx 상단에 정의한다 (컴포넌트 바깥, handleCreate 이전).
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter admin run build` 빌드 성공.
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter admin run test` 기존 + 신규 테스트 통과.
  </verify>
  <done>
- PolicyFormRouter에서 5개 타입(SPENDING_LIMIT, WHITELIST, RATE_LIMIT, APPROVE_AMOUNT_LIMIT, APPROVE_TIER_OVERRIDE) 선택 시 각 전용 폼이 렌더링됨
- WHITELIST 폼이 DynamicRowList를 사용하여 [+ 추가]/[x] 동작 제공
- 필수 필드 미입력, 숫자 형식 오류, 빈 목록 시 에러 메시지 표시됨
- 5개 타입 폼으로 정책 생성이 가능하고 올바른 rules가 API에 전달됨
- admin 빌드/테스트 통과
  </done>
</task>

<task type="auto">
  <name>Task 2: 폼 렌더링 + 유효성 검증 + 생성 통합 테스트</name>
  <files>packages/admin/src/__tests__/policy-forms.test.tsx</files>
  <action>
`packages/admin/src/__tests__/policy-forms.test.tsx`에 테스트를 작성한다. 기존 `policies.test.tsx`의 mock 패턴(vi.mock('../api/client'), vi.mock('../components/toast'), vi.mock('../auth/store'), vi.mock('../components/empty-state'), vi.mock('../utils/error-messages'))을 동일하게 사용한다.

테스트 구성:

**1. PolicyFormRouter 렌더링 테스트:**
```ts
describe('PolicyFormRouter', () => {
  // 타입별 전용 폼 렌더링 확인 테스트를 PoliciesPage 전체를 render하여 검증
});
```

**2. 타입 변경 시 폼 전환:**
- 렌더 → Create Policy 클릭 → 기본(SPENDING_LIMIT) 폼 필드(Instant Max) 존재 확인
- 타입을 WHITELIST로 변경 → "Add Address" 버튼 존재 확인, Instant Max 필드 부재 확인
- 타입을 RATE_LIMIT로 변경 → "Max Requests" 필드 존재 확인

**3. JSON 토글:**
- Create Policy → 기본 폼 모드 → "JSON Direct Edit" 버튼 클릭 → textarea 렌더링 확인
- "Switch to Form" 클릭 → 구조화 폼 복원 확인

**4. DynamicRowList 동작 (WHITELIST):**
- WHITELIST 선택 → [+ Add Address] 클릭 → 행 1개 추가 확인 (Address 1 label)
- 추가 클릭 → 행 2개 확인
- [x] 클릭 → 행 1개로 감소 확인

**5. SPENDING_LIMIT 폼 → 생성:**
- 3개 네이티브 금액 필드에 값 입력 (fireEvent.input) + delay_seconds 입력
- Create 클릭 → apiPost 호출 시 rules에 instant_max, notify_max, delay_max, delay_seconds 포함 확인

**6. 유효성 검증:**
- SPENDING_LIMIT: instant_max를 비워둔 채 Create → 에러 메시지 "Positive integer required" 표시 확인
- WHITELIST: 행 0개 상태에서 Create → "At least one address required" 에러 확인
- RATE_LIMIT: max_requests를 0으로 → 에러 확인

**7. APPROVE_TIER_OVERRIDE 생성:**
- 셀렉트에서 DELAY 선택 → Create → rules.tier === 'DELAY' 확인

mockWallets, mockPolicies는 기존 policies.test.tsx와 동일하게 사용. apiGet는 wallets + policies 로드 mock, apiPost는 생성 mock.

최소 7개 테스트 케이스.
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter admin run test -- --run src/__tests__/policy-forms.test.tsx` 전체 통과.
  </verify>
  <done>
- policy-forms.test.tsx에 7개 이상 테스트 케이스가 존재하고 전체 통과
- 타입 전환, JSON 토글, DynamicRowList 동작, 유효성 검증, 생성 통합이 검증됨
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter admin run build` 빌드 성공
2. `pnpm --filter admin run test` 전체 테스트 통과 (기존 + 신규 policy-forms)
3. 5개 타입 전용 폼 파일 존재: spending-limit-form.tsx, whitelist-form.tsx, rate-limit-form.tsx, approve-amount-limit-form.tsx, approve-tier-override-form.tsx
4. PolicyFormRouter의 switch/case에 5개 타입 분기 존재
5. policies.tsx의 validateRules에서 SPENDING_LIMIT, WHITELIST, RATE_LIMIT, APPROVE_AMOUNT_LIMIT 검증 로직 존재
6. policy-forms.test.tsx에서 폼 렌더링/전환/유효성/생성 테스트 통과
</verification>

<success_criteria>
- 운영자가 SPENDING_LIMIT/WHITELIST/RATE_LIMIT/APPROVE_AMOUNT_LIMIT/APPROVE_TIER_OVERRIDE 타입 선택 시 전용 폼이 렌더링됨
- WHITELIST 폼에서 [+ Add Address]/[x] 동적 행 추가/삭제 가능
- 필수 필드 미입력, 숫자 형식 오류, 빈 목록 시 에러 메시지 표시
- 5개 타입 폼으로 정책 생성이 가능하고 올바른 rules가 POST /v1/policies에 전달됨
- 7개 이상 테스트 전체 통과
- admin 빌드 성공
</success_criteria>

<output>
After completion, create `.planning/phases/134-form-infra-5type-forms/134-02-SUMMARY.md`
</output>
