---
phase: 81-pipeline-integration-stage5
plan: 02
type: tdd
wave: 2
depends_on: ["81-01"]
files_modified:
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts
autonomous: true

must_haves:
  truths:
    - "Stage 5가 build->simulate->sign->submit 루프를 실행하고, PERMANENT ChainError는 즉시 FAILED, TRANSIENT는 지수 백오프(1s,2s,4s, max 3회), STALE는 buildLoop 복귀(max 1회) 분기를 수행한다"
    - "Stage 5가 request.type에 따라 올바른 adapter 메서드를 호출한다 (TRANSFER->buildTransaction, TOKEN_TRANSFER->buildTokenTransfer, CONTRACT_CALL->buildContractCall, APPROVE->buildApprove, BATCH->buildBatch)"
    - "ChainError가 Stage 5에서 WAIaaSError로 변환되어 API 응답에 적절한 httpStatus를 반환한다"
    - "MAX_RETRIES=3 초과 시 FAILED로 마킹하고 더 이상 재시도하지 않는다"
    - "retryCount는 TRANSIENT과 STALE을 합산하여 전체 재시도 횟수를 제한한다"
  artifacts:
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "stage5Execute CONC-01 완전 구현 + buildByType type별 라우팅"
      contains: "buildByType"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "POST /transactions/send route에서 type별 DB INSERT + 알림에 type 전달"
      contains: "TransactionRequestSchema"
    - path: "packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts"
      provides: "Stage 5 CONC-01 재시도 로직 + type별 adapter 라우팅 TDD 테스트"
  key_links:
    - from: "packages/daemon/src/pipeline/stages.ts stage5Execute"
      to: "IChainAdapter buildTransaction/buildTokenTransfer/buildContractCall/buildApprove/buildBatch"
      via: "buildByType switch on request.type"
      pattern: "buildByType|switch.*request\\.type"
    - from: "packages/daemon/src/pipeline/stages.ts stage5Execute"
      to: "ChainError category"
      via: "catch block switch on err.category"
      pattern: "err\\.category|PERMANENT|TRANSIENT|STALE"
    - from: "packages/daemon/src/pipeline/stages.ts stage5Execute"
      to: "WAIaaSError"
      via: "ChainError -> WAIaaSError conversion in stage5Execute"
      pattern: "new WAIaaSError.*CHAIN_ERROR"
---

<objective>
Stage 5가 CONC-01 완전 의사코드를 구현하여 build->simulate->sign->submit 루프를 실행하고, ChainError 카테고리별 재시도/실패 분기(PERMANENT 즉시 실패/TRANSIENT 지수 백오프/STALE 재빌드)와 type별 adapter 메서드 라우팅(buildByType)을 수행한다.

Purpose: 현재 stage5Execute는 TRANSFER만 처리하고 ChainError 재시도 로직이 없다. CONC-01 의사코드를 구현하여 5가지 트랜잭션 타입 모두가 Stage 5를 완주할 수 있고, 체인 에러 시 지능적인 재시도가 동작해야 v1.4 파이프라인이 완성된다.
Output: stage5Execute CONC-01 구현 + buildByType + TDD 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/core/src/errors/chain-error.ts
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/interfaces/chain-adapter.types.ts

# Design doc with CONC-01 pseudocode
@.planning/deliverables/32-transaction-pipeline-api.md (섹션 Stage 5, CONC-01)

# Prior plan summary (Stage 1 + Stage 3 구현)
@.planning/phases/81-pipeline-integration-stage5/81-01-SUMMARY.md
@.planning/phases/80-batch-transactions/80-01-SUMMARY.md
@.planning/phases/56-pipeline-integration/56-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED -- Stage 5 CONC-01 재시도 로직 + type별 adapter 라우팅 실패 테스트</name>
  <files>packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts</files>
  <action>
  새 테스트 파일 `pipeline-stage5-execute.test.ts` 생성. in-memory SQLite + mock adapter + mock keyStore 환경 구성.

  **buildByType 라우팅 테스트 (5개):**
  1. TRANSFER request -> `adapter.buildTransaction()` 호출 확인
  2. TOKEN_TRANSFER request -> `adapter.buildTokenTransfer()` 호출 확인 (올바른 TokenTransferParams 전달)
  3. CONTRACT_CALL request -> `adapter.buildContractCall()` 호출 확인 (올바른 ContractCallParams 전달)
  4. APPROVE request -> `adapter.buildApprove()` 호출 확인 (올바른 ApproveParams 전달)
  5. BATCH request -> `adapter.buildBatch()` 호출 확인 (올바른 BatchParams 전달)

  **ChainError 카테고리별 재시도 테스트 (7개):**
  1. PERMANENT ChainError 발생 시 즉시 FAILED 마킹, 재시도 없음
  2. TRANSIENT ChainError 발생 시 지수 백오프 후 재시도 (simulate에서 발생 -> simulate만 재시도)
  3. TRANSIENT ChainError 3회 초과 시 FAILED 마킹
  4. STALE ChainError 발생 시 buildLoop 복귀 (rebuild from Stage 5a)
  5. STALE ChainError 1회 후 재시도 성공 확인
  6. STALE ChainError 재빌드 후 또 STALE 시 FAILED (retryCount 합산)
  7. ChainError가 WAIaaSError('CHAIN_ERROR')로 변환되어 throw

  **통합 테스트 (3개):**
  1. TOKEN_TRANSFER 요청이 Stage 5에서 buildTokenTransfer -> simulate -> sign -> submit 전체 플로우 완주
  2. BATCH 요청이 Stage 5에서 buildBatch -> simulate -> sign -> submit 전체 플로우 완주
  3. 정상 플로우에서 DB 상태가 PENDING -> SUBMITTED 갱신 확인 + TX_SUBMITTED 알림 발송

  **mock adapter 설정:**
  - buildTokenTransfer, buildContractCall, buildApprove, buildBatch를 vi.fn()으로 mock
  - simulate/sign/submit도 vi.fn()으로 mock (기본 성공)
  - ChainError 발생 시나리오를 위해 특정 호출에서 ChainError throw하도록 설정

  **재시도 타이밍:**
  - vi.useFakeTimers()로 지수 백오프 타이밍 제어 (실제 대기하지 않음)
  - 또는 sleep 함수를 mock하여 즉시 반환

  테스트 커밋: `test(81-02): add failing tests for Stage 5 CONC-01 retry logic + type-based adapter routing`
  </action>
  <verify>
  `pnpm vitest run packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts` -- 모든 신규 테스트 FAIL (RED)
  기존 테스트 통과 확인: `pnpm vitest run packages/daemon/src/__tests__/pipeline.test.ts`
  </verify>
  <done>15개 신규 테스트가 모두 FAIL하고, 기존 pipeline 테스트는 PASS</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN -- Stage 5 CONC-01 완전 구현 + buildByType + ChainError 변환</name>
  <files>
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/api/routes/transactions.ts
  </files>
  <action>
  **stage5Execute 완전 재작성 -- stages.ts:**

  CONC-01 의사코드를 기반으로 stage5Execute 함수를 재작성.

  1. **buildByType 헬퍼 함수 추가:**
     ```typescript
     async function buildByType(
       adapter: IChainAdapter,
       request: TransactionRequest | SendTransactionRequest,
       agentPublicKey: string,
     ): Promise<UnsignedTransaction> {
       const type = ('type' in request && request.type) || 'TRANSFER';
       switch (type) {
         case 'TRANSFER':
           return adapter.buildTransaction({
             from: agentPublicKey,
             to: request.to,
             amount: BigInt(request.amount),
             memo: 'memo' in request ? request.memo : undefined,
           });
         case 'TOKEN_TRANSFER':
           return adapter.buildTokenTransfer({
             from: agentPublicKey,
             to: request.to,
             amount: BigInt(request.amount),
             token: (request as TokenTransferRequest).token,
             memo: 'memo' in request ? (request as TokenTransferRequest).memo : undefined,
           });
         case 'CONTRACT_CALL':
           // ContractCallParams: from, to, calldata?, abi?, value?, programId?, instructionData?, accounts?
           const ccReq = request as ContractCallRequest;
           return adapter.buildContractCall({
             from: agentPublicKey,
             to: ccReq.to,
             calldata: ccReq.calldata,
             abi: ccReq.abi as Record<string, unknown>[] | undefined,
             value: ccReq.value ? BigInt(ccReq.value) : undefined,
             programId: ccReq.programId,
             instructionData: ccReq.instructionData ? Buffer.from(ccReq.instructionData, 'base64') : undefined,
             accounts: ccReq.accounts,
           });
         case 'APPROVE':
           const appReq = request as ApproveRequest;
           return adapter.buildApprove({
             from: agentPublicKey,
             spender: appReq.spender,
             token: appReq.token,
             amount: BigInt(appReq.amount),
           });
         case 'BATCH':
           // BatchParams: from, instructions[]
           const batchReq = request as BatchRequest;
           // Map instructions to adapter params (each instruction lacks `from`)
           return adapter.buildBatch({
             from: agentPublicKey,
             instructions: batchReq.instructions.map(instr => {
               // Classify by field presence (same logic as classifyInstruction in Phase 80)
               if ('spender' in instr) {
                 return { from: agentPublicKey, spender: instr.spender, token: instr.token, amount: BigInt(instr.amount) };
               }
               if ('token' in instr) {
                 return { from: agentPublicKey, to: instr.to, amount: BigInt(instr.amount), token: instr.token, memo: instr.memo };
               }
               if ('programId' in instr || 'calldata' in instr) {
                 return {
                   from: agentPublicKey, to: instr.to,
                   calldata: (instr as any).calldata, programId: (instr as any).programId,
                   instructionData: (instr as any).instructionData ? Buffer.from((instr as any).instructionData, 'base64') : undefined,
                   accounts: (instr as any).accounts,
                   value: (instr as any).value ? BigInt((instr as any).value) : undefined,
                 };
               }
               return { from: agentPublicKey, to: instr.to, amount: BigInt(instr.amount), memo: instr.memo };
             }),
           });
         default:
           throw new WAIaaSError('INVALID_REQUEST', { message: `Unknown transaction type: ${type}` });
       }
     }
     ```

  2. **stage5Execute에 CONC-01 재시도 루프 추가:**
     - `const MAX_RETRIES = 3;`
     - import `ChainError` from `@waiaas/core`
     - 외부 buildLoop: `while (retryCount < MAX_RETRIES)`
     - buildByType -> simulate -> sign -> submit 순서
     - catch 블록에서 `err instanceof ChainError` 확인
     - switch(err.category):
       - PERMANENT: DB FAILED 마킹 + `throw new WAIaaSError('CHAIN_ERROR', { message: err.message, cause: err })`
       - TRANSIENT: retryCount < MAX_RETRIES면 `await sleep(1000 * 2**retryCount)` 후 continue (실패 단계 재시도). MAX_RETRIES 초과면 FAILED + throw
       - STALE: retryCount 증가 + continue buildLoop (Stage 5a 복귀). 이미 max이면 FAILED + throw
     - ChainError가 아닌 일반 에러는 기존 로직 유지 (WAIaaSError 그대로 throw)

  3. **sleep 헬퍼 추가:**
     ```typescript
     function sleep(ms: number): Promise<void> {
       return new Promise(resolve => setTimeout(resolve, ms));
     }
     ```
     테스트에서 mock 가능하도록 모듈 레벨 함수로 정의.

  4. **DB 상태 갱신:**
     - simulate 성공 후: PENDING -> EXECUTING (생략 가능, 현재는 SUBMITTED 직행)
     - submit 성공 후: SUBMITTED + txHash (기존 유지)
     - 에러 시: FAILED + error 메시지

  5. **알림 통합:**
     - ChainError PERMANENT: TX_FAILED 알림 (기존 simulation failed 패턴 재활용)
     - submit 성공: TX_SUBMITTED 알림 (기존 유지)

  6. **POST /transactions/send route 업데이트 -- transactions.ts:**
     - route handler 인라인 Stage 1에서도 type 동적 설정 (81-01에서 이미 일부 처리, 여기서 Stage 5 호출 부분 확인)
     - 비동기 파이프라인(Stages 2-6)의 catch 블록에서 ChainError도 적절히 처리

  구현 커밋: `feat(81-02): implement Stage 5 CONC-01 retry loop + buildByType adapter routing`
  </action>
  <verify>
  `pnpm vitest run packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts` -- 모든 신규 테스트 PASS (GREEN)
  `pnpm vitest run packages/daemon/` -- 전체 daemon 테스트 통과 (기존 테스트 회귀 없음)
  `pnpm turbo build` -- 빌드 성공
  </verify>
  <done>
  Stage 5가 CONC-01 완전 구현:
  - buildByType로 5-type adapter 메서드 라우팅
  - PERMANENT 즉시 FAILED, TRANSIENT 지수 백오프(max 3), STALE 재빌드(max 1, 합산)
  - ChainError -> WAIaaSError 변환
  - retryCount = TRANSIENT + STALE 합산
  15+ 테스트 PASS, 기존 테스트 회귀 없음.
  </done>
</task>

</tasks>

<verification>
1. `pnpm vitest run packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts` -- 15+ 테스트 PASS
2. `pnpm vitest run packages/daemon/` -- 전체 daemon 테스트 PASS (회귀 없음)
3. `pnpm turbo build` -- 전체 빌드 성공
4. Stage 5: buildByType switch문에서 5-type 라우팅 확인
5. Stage 5: ChainError catch -> category별 분기 (PERMANENT/TRANSIENT/STALE) 확인
6. Stage 5: retryCount 합산 + MAX_RETRIES=3 제한 확인
7. Stage 5: ChainError -> WAIaaSError('CHAIN_ERROR') 변환 확인
</verification>

<success_criteria>
- Stage 5가 CONC-01 의사코드를 완전 구현
- buildByType가 5가지 type에 따라 올바른 adapter 메서드 호출
- PERMANENT ChainError -> 즉시 FAILED, 0회 재시도
- TRANSIENT ChainError -> 지수 백오프(1s,2s,4s), max 3회 재시도
- STALE ChainError -> buildLoop 복귀, max 1회 (retryCount 합산)
- ChainError가 WAIaaSError('CHAIN_ERROR')로 변환되어 API에 전달
- 15+ TDD 테스트 통과
- 기존 pipeline 테스트 회귀 없음
</success_criteria>

<output>
After completion, create `.planning/phases/81-pipeline-integration-stage5/81-02-SUMMARY.md`
</output>
