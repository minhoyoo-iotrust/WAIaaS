---
phase: 23-transaction-type-extension
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - docs/60-batch-transaction-spec.md
autonomous: true

must_haves:
  truths:
    - "BatchRequest로 Solana 다중 instruction을 원자적 배치로 표현할 수 있고, InstructionRequest가 TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE 4가지 type을 지원한다"
    - "EVM BATCH 요청 시 BATCH_NOT_SUPPORTED 에러가 명확히 반환된다"
    - "배치 정책 평가에서 개별 instruction 각각의 정책 평가 + 금액 합산 티어 결정이 명세되어 있다"
    - "All-or-Nothing 정책 위반 처리가 명세되어 있다 (하나라도 위반 시 전체 배치 거부)"
    - "Solana 트랜잭션 크기 제한(1232 bytes)과 instruction 수 제한(20개)이 사전 검증 로직에 포함되어 있다"
    - "approve + transferFrom 콤보 배치의 보안 시나리오가 정의되어 있다"
    - "배치 트랜잭션 테스트 시나리오가 정상/정책거부/에러/보안을 포함한다"
  artifacts:
    - path: "docs/60-batch-transaction-spec.md"
      provides: "CHAIN-EXT-05 배치 트랜잭션 스펙"
      contains: "BatchRequest"
  key_links:
    - from: "docs/60-batch-transaction-spec.md"
      to: "docs/58-contract-call-spec.md"
      via: "Stage 1 BATCH variant, Stage 3 batchTotalAmount/batchInstructions, Stage 5 buildBatch"
    - from: "docs/60-batch-transaction-spec.md"
      to: "docs/31-solana-adapter-detail.md"
      via: "appendTransactionMessageInstruction 다중 instruction 패턴"
---

<objective>
BatchRequest와 InstructionRequest 인터페이스를 설계하고, Solana 원자적 배치 빌드 로직, EVM 미지원 분기, 배치 정책 합산 평가(금액 합산 + All-or-Nothing)를 정의한다.

Purpose: Solana는 단일 트랜잭션에 다수 instruction을 원자적으로 포함하는 것을 네이티브로 지원한다. ATA 생성 + approve + transfer 같은 복합 작업을 원자적으로 실행하려면 배치가 필수이며, 정책 우회를 방지하기 위해 합산 평가가 필요하다.
Output: docs/60-batch-transaction-spec.md (CHAIN-EXT-05)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-transaction-type-extension/23-RESEARCH.md
@.planning/phases/23-transaction-type-extension/23-01-SUMMARY.md
@docs/58-contract-call-spec.md
@docs/56-token-transfer-extension-spec.md
@docs/31-solana-adapter-detail.md
@docs/32-transaction-pipeline-api.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: BatchRequest 인터페이스 + 배치 정책 평가 + Solana 빌드 로직 설계</name>
  <files>docs/60-batch-transaction-spec.md</files>
  <action>
docs/60-batch-transaction-spec.md 파일을 생성한다. 한글로 작성하며, 다음 섹션을 포함한다:

**섹션 1: 개요** (~40줄)
- 문서 메타데이터: 문서 ID(CHAIN-EXT-05), 작성일, Phase 23, 참조 문서 목록 (CHAIN-EXT-03 포함)
- 요구사항 매핑: BATCH-01, BATCH-02, BATCH-03
- 핵심 설계 원칙: (1) Solana 원자적 배치 네이티브 지원, (2) EVM 배치 명시적 미지원, (3) 합산 정책 평가, (4) All-or-Nothing 위반 처리
- CHAIN-EXT-03 크로스커팅 참조: Stage 1 BATCH variant, Stage 3 batchTotalAmount, Stage 5 buildBatch, DB type='BATCH'

**섹션 2: BatchRequest + InstructionRequest 인터페이스** (~120줄)
- TypeScript 인터페이스 정의:
  ```typescript
  interface BatchRequest {
    from: string           // 에이전트 주소
    chain: ChainType       // 체인 (현재 'solana'만 지원)
    instructions: InstructionRequest[]  // 개별 instruction 목록 (min 2, max 20)
  }

  type InstructionRequest =
    | TransferInstruction
    | TokenTransferInstruction
    | ContractCallInstruction
    | ApproveInstruction

  interface TransferInstruction {
    type: 'TRANSFER'
    to: string
    amount: bigint
    memo?: string
  }

  interface TokenTransferInstruction {
    type: 'TOKEN_TRANSFER'
    to: string
    amount: bigint
    token: TokenInfo
  }

  interface ContractCallInstruction {
    type: 'CONTRACT_CALL'
    programId: string
    instructionData: string    // Base64
    accounts: AccountMetaInput[]
    value?: bigint
  }

  interface ApproveInstruction {
    type: 'APPROVE'
    spender: string
    token: TokenInfo
    amount: bigint
  }
  ```
- InstructionRequest가 discriminated union인 이유: type별 필수 필드가 다름
- BatchRequest 제약 조건:
  - instructions.length >= 2 (1개는 배치 아님, 단일 요청으로 처리)
  - instructions.length <= 20 (Solana 트랜잭션 크기 실질 한계)
  - chain === 'solana' 필수 (EVM 미지원)
- Zod 스키마 정의 (BatchRequestSchema, InstructionRequestSchema)

**섹션 3: EVM 미지원 분기** (~50줄)
- EVM에서 BATCH 타입 요청 시 즉시 거부:
  - 에러 코드: BATCH_NOT_SUPPORTED (400)
  - 에러 메시지: "Batch transactions are only supported on Solana. EVM chains execute one call per transaction."
  - 검증 시점: Stage 1 (RECEIVE)에서 chain 검증 후 즉시 에러 반환
- 향후 확장 포인트:
  - Multicall3: 외부 컨트랙트 의존, EOA 직접 사용 불가 (ERC-4337 필요)
  - ERC-4337: Smart Account 전환 시 지원 가능 (별도 마일스톤)
  - 설계 확장 포인트만 기록하고, v0.6에서는 미구현

**섹션 4: Solana 원자적 배치 빌드 로직** (~150줄)
- @solana/kit pipe 패턴으로 다중 instruction 구성:
  ```
  1. createTransactionMessage({ version: 0 })
  2. setTransactionMessageFeePayer(from)
  3. setTransactionMessageLifetimeUsingBlockhash(blockhash)
  4. for each instruction in batchInstructions:
     appendTransactionMessageInstruction(instruction)
  ```
- InstructionRequest -> Solana Instruction 변환:
  - TRANSFER: System Program transfer instruction
  - TOKEN_TRANSFER: SPL TransferChecked instruction (CHAIN-EXT-01 로직 재사용)
  - CONTRACT_CALL: 임의 프로그램 instruction (CHAIN-EXT-03 로직 재사용)
  - APPROVE: SPL ApproveChecked instruction (CHAIN-EXT-04 로직 재사용)
- 각 instruction type별 변환 pseudo-code
- ATA 자동 생성: TOKEN_TRANSFER/APPROVE에서 수신자 ATA가 없으면 createAssociatedTokenAccountInstruction을 배치 앞에 자동 삽입
- 트랜잭션 크기 사전 검증:
  - instruction 추가 후 직렬화 크기 계산
  - 1232 bytes 초과 시 BATCH_SIZE_EXCEEDED 에러 (400)
  - 검증 시점: Stage 5 빌드 직전
- compute unit 최적화:
  - setComputeUnitLimit instruction 자동 추가 (시뮬레이션 CU의 1.2배)
  - priority fee 설정 (선택적)
- 원자성 보장: Solana 런타임이 보장 (하나라도 실패 시 전체 롤백)
- 서명: 에이전트 키로 단일 서명 (모든 instruction의 fee payer = from)

**섹션 5: 배치 정책 평가 규칙** (~120줄)
- 2단계 평가 알고리즘:
  **Phase A: 개별 instruction 정책 평가**
  - 배치 내 각 instruction을 독립적으로 정책 평가
  - TRANSFER: WHITELIST, TIME_RESTRICTION, RATE_LIMIT 적용
  - TOKEN_TRANSFER: WHITELIST, TIME_RESTRICTION, RATE_LIMIT, ALLOWED_TOKENS 적용
  - CONTRACT_CALL: CONTRACT_WHITELIST, METHOD_WHITELIST 적용
  - APPROVE: APPROVED_SPENDERS, APPROVE_AMOUNT_LIMIT 적용
  - **All-or-Nothing:** 하나라도 DENY면 전체 배치 거부 (BATCH_POLICY_VIOLATION)
  - 거부 응답에 어느 instruction(인덱스)이 어떤 정책에 위반했는지 상세 포함

  **Phase B: 합산 금액 티어 결정**
  - 모든 instruction의 금액을 합산 (네이티브 토큰 기준):
    - TRANSFER: amount (네이티브)
    - TOKEN_TRANSFER: Phase 24 USD 통합 전까지 0으로 간주 (토큰 금액 비교 불가)
    - CONTRACT_CALL: value (네이티브 첨부량)
    - APPROVE: 0 (approve는 직접 자금 이동 아님)
  - 합산 금액으로 SPENDING_LIMIT 평가 -> 4-tier 분류
  - APPROVE가 포함된 배치: APPROVE_TIER_OVERRIDE도 적용, 두 티어 중 높은 쪽 채택
  - 최종 티어: max(합산 금액 티어, APPROVE 포함 시 override 티어)

- 정책 우회 방지:
  - 배치를 다수의 소액 전송으로 분할하는 공격 차단 (합산 평가)
  - approve + transferFrom 콤보: APPROVE 포함 배치는 별도 정책 평가
  - 배치 내 중복 instruction 감지는 하지 않음 (정책 엔진의 범위 아님, 감사 로그로 추적)

- 정책 평가 입력 (CHAIN-EXT-03 섹션 6의 PolicyEvaluationInput 확장):
  ```typescript
  // BATCH 타입일 때 추가 입력
  {
    type: 'BATCH',
    batchTotalAmount: bigint,         // 합산 네이티브 금액
    batchInstructions: Array<{
      index: number
      type: TransactionType
      // 각 instruction의 개별 정책 입력
    }>
  }
  ```

**섹션 6: 감사 로그 전략** (~60줄)
- 배치 트랜잭션의 transactions 테이블 기록:
  - 배치 자체: type='BATCH', amount=합산금액, tx_hash=최종 트랜잭션 해시
  - metadata JSON에 개별 instruction 요약 포함:
    ```json
    {
      "batch_instructions": [
        { "index": 0, "type": "TRANSFER", "to": "...", "amount": "..." },
        { "index": 1, "type": "APPROVE", "spender": "...", "token": "...", "amount": "..." }
      ],
      "batch_size": 2,
      "total_native_amount": "1500000000"
    }
    ```
  - contract_address, method_signature: 배치 내 첫 번째 CONTRACT_CALL의 값 (복수면 metadata에 전체 기록)
  - spender_address: 배치 내 첫 번째 APPROVE의 spender (복수면 metadata에 전체 기록)
- 감사 쿼리: metadata JSON 검색으로 배치 내 특정 instruction 추적

**섹션 7: 보안 위험 매트릭스 + 테스트 시나리오** (~100줄)
- BATCH 보안 위험 매트릭스 (4개 위험 + 완화 방안) -- 23-RESEARCH.md 참조
- 테스트 레벨:
  - Level 1 (Unit): BatchRequest/InstructionRequest Zod 검증, 합산 금액 계산, 크기 검증
  - Level 2 (Integration): 파이프라인 배치 흐름 (Mock Adapter), All-or-Nothing 정책
  - Level 3 (Chain Mock): Solana Validator 다중 instruction 실행, 부분 실패 원자성 확인
  - Level 4 (Security): 합산 금액 정책 우회, approve+transferFrom 콤보, 크기 초과, EVM 미지원
- Mock 경계: IChainAdapter.buildBatch, DatabasePolicyEngine.evaluate(BATCH), Solana TX serializer
- 시나리오 12개 이상:
  - 정상: 2-instruction 배치, 3-instruction 복합 배치 (transfer+approve+contractCall) (2-3)
  - 정책 거부: 합산 금액 APPROVAL 티어, 개별 instruction 화이트리스트 위반, All-or-Nothing (3-4)
  - 에러: EVM BATCH_NOT_SUPPORTED, instruction 수 초과(>20), 크기 초과(>1232 bytes), instruction 수 부족(<2) (3-4)
  - 보안: approve+transferFrom 콤보, 소액 분할 우회 시도 (2)

**섹션 8: 향후 확장 포인트** (~30줄)
- EVM 배치: ERC-4337 Smart Account, Multicall3 (별도 마일스톤)
- Solana Versioned Transactions: Address Lookup Table (ALT) 활용 시 더 많은 accounts 가능
- 배치 내 조건부 실행: 선행 instruction 결과에 따른 후행 instruction 분기 (현재 미지원)
- 크로스체인 배치: Solana + EVM 혼합 배치 (현재 미지원, 동일 체인 내에서만)

문서 총 분량 목표: 약 700-900줄.
문서 작성 언어: 한글.
코드 블록 내 주석은 한글.
  </action>
  <verify>
- docs/60-batch-transaction-spec.md 파일이 존재한다
- 파일 분량이 650줄 이상이다 (`wc -l docs/60-batch-transaction-spec.md`)
- BatchRequest, InstructionRequest 인터페이스가 정의되어 있다 (grep 'BatchRequest')
- EVM BATCH_NOT_SUPPORTED 에러가 명세되어 있다
- 2단계 평가 알고리즘(Phase A 개별 + Phase B 합산)이 있다
- All-or-Nothing 위반 처리가 있다
- Solana 1232 bytes 크기 제한 검증이 있다
- instruction 수 제한(2-20)이 있다
- 테스트 시나리오가 12개 이상 정의되어 있다
  </verify>
  <done>
BATCH-01(BatchRequest/InstructionRequest), BATCH-02(배치 정책 합산 평가), BATCH-03(테스트 시나리오)가 모두 커버되고, Solana 원자적 배치 빌드와 EVM 미지원 분기가 명세되어 있다.
  </done>
</task>

</tasks>

<verification>
1. docs/60-batch-transaction-spec.md 파일 존재 및 분량 확인 (650줄+)
2. 요구사항 커버리지 확인:
   - BATCH-01: BatchRequest + InstructionRequest 인터페이스 (섹션 2)
   - BATCH-02: 배치 정책 합산 평가 (섹션 5)
   - BATCH-03: 테스트 시나리오 (섹션 7)
3. CHAIN-EXT-03 참조 확인:
   - Stage 1 BATCH variant 참조
   - Stage 3 batchTotalAmount/batchInstructions 참조
   - Stage 5 buildBatch 분기 참조
4. 체인별 분기 확인:
   - Solana: 원자적 배치 빌드 (pipe 패턴, 크기 검증)
   - EVM: BATCH_NOT_SUPPORTED 명시적 에러
5. 정책 우회 방지: 합산 평가 + All-or-Nothing + approve 콤보 처리
</verification>

<success_criteria>
- BatchRequest로 Solana 다중 instruction을 min 2 / max 20 범위로 표현한다
- InstructionRequest가 4가지 type(TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE)을 지원한다
- EVM BATCH 요청 시 BATCH_NOT_SUPPORTED 에러가 명확히 반환된다
- 배치 정책이 개별 instruction 평가 + 합산 금액 티어를 모두 수행한다
- All-or-Nothing: 하나라도 정책 위반이면 전체 배치 거부
- Solana 1232 bytes 크기 제한과 instruction 수 제한이 사전 검증된다
- 보안 테스트 시나리오 12개+와 Mock 경계가 정의되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/23-transaction-type-extension/23-03-SUMMARY.md`
</output>
