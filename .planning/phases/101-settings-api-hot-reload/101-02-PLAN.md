---
phase: 101-settings-api-hot-reload
plan: 02
type: execute
wave: 2
depends_on: ["101-01"]
files_modified:
  - packages/daemon/src/notifications/notification-service.ts
  - packages/daemon/src/infrastructure/adapter-pool.ts
  - packages/daemon/src/infrastructure/settings/hot-reload.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/settings-hot-reload.test.ts
autonomous: true

must_haves:
  truths:
    - "Changing notification credentials via PUT /admin/settings triggers channel instance recreation with new credentials"
    - "Changing RPC URL via PUT /admin/settings triggers adapter eviction and reconnection with new URL"
    - "Changing security parameters via PUT /admin/settings takes effect on next request without daemon restart"
    - "Hot-reload is triggered only for categories that have changed keys, not on every PUT"
    - "Errors during hot-reload are caught and logged, never crash the daemon"
  artifacts:
    - path: "packages/daemon/src/infrastructure/settings/hot-reload.ts"
      provides: "HotReloadOrchestrator that dispatches changed keys to subsystem reloaders"
      contains: "HotReloadOrchestrator|reloadNotifications|reloadRpc|reloadSecurity"
    - path: "packages/daemon/src/notifications/notification-service.ts"
      provides: "replaceChannels method for hot-swapping notification channels"
      contains: "replaceChannels"
    - path: "packages/daemon/src/infrastructure/adapter-pool.ts"
      provides: "evict method for forcing adapter reconnection"
      contains: "evict"
    - path: "packages/daemon/src/__tests__/settings-hot-reload.test.ts"
      provides: "Tests for hot-reload orchestrator and subsystem reloaders"
      min_lines: 100
  key_links:
    - from: "packages/daemon/src/infrastructure/settings/hot-reload.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "replaceChannels() called during notification reload"
      pattern: "notificationService\\.replaceChannels"
    - from: "packages/daemon/src/infrastructure/settings/hot-reload.ts"
      to: "packages/daemon/src/infrastructure/adapter-pool.ts"
      via: "evict() called during RPC reload"
      pattern: "adapterPool\\.evict"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/infrastructure/settings/hot-reload.ts"
      via: "onSettingsChanged callback wired to HotReloadOrchestrator"
      pattern: "onSettingsChanged.*hotReload"
---

<objective>
Implement hot-reload for notification channels, RPC adapters, and security parameters when settings are changed via the admin API.

Purpose: Admin changes to operational settings take effect immediately without daemon restart. Notification credential changes recreate channel instances, RPC URL changes force adapter reconnection, and security parameter changes are reflected on next request evaluation.

Output: HotReloadOrchestrator module, NotificationService.replaceChannels(), AdapterPool.evict(), daemon.ts onSettingsChanged wiring, comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-settings-infra/100-02-SUMMARY.md
@.planning/phases/101-settings-api-hot-reload/101-01-PLAN.md
@packages/daemon/src/notifications/notification-service.ts
@packages/daemon/src/infrastructure/adapter-pool.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/infrastructure/settings/settings-service.ts
@packages/daemon/src/infrastructure/settings/setting-keys.ts
@packages/daemon/src/notifications/channels/telegram.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Subsystem reload methods + HotReloadOrchestrator</name>
  <files>
    packages/daemon/src/notifications/notification-service.ts
    packages/daemon/src/infrastructure/adapter-pool.ts
    packages/daemon/src/infrastructure/settings/hot-reload.ts
    packages/daemon/src/infrastructure/settings/index.ts
  </files>
  <action>
**1. NotificationService.replaceChannels()** (notification-service.ts):

Add a method to the NotificationService class that atomically replaces all channels:

```typescript
/**
 * Replace all notification channels with new instances.
 * Used by hot-reload when notification credentials change.
 * Old channels are discarded (no cleanup needed -- they're stateless HTTP clients).
 */
replaceChannels(newChannels: INotificationChannel[]): void {
  this.channels = [...newChannels];
  // Reset rate limiter for all channels (fresh start with new credentials)
  this.rateLimitMap.clear();
}

/**
 * Update config (locale, rateLimitRpm) without replacing channels.
 */
updateConfig(config: Partial<NotificationServiceConfig>): void {
  this.config = { ...this.config, ...config };
}
```

**2. AdapterPool.evict()** (adapter-pool.ts):

Add an evict method that disconnects and removes a specific adapter from the pool, forcing lazy re-creation on next `resolve()`:

```typescript
/**
 * Evict a cached adapter for a given chain:network.
 * Disconnects the existing adapter and removes it from pool.
 * Next resolve() call will create a fresh adapter with the new RPC URL.
 */
async evict(chain: ChainType, network: NetworkType): Promise<void> {
  const key = this.cacheKey(chain, network);
  const existing = this._pool.get(key);
  if (existing) {
    try {
      await existing.disconnect();
    } catch (err) {
      console.warn(`AdapterPool evict disconnect warning (${key}):`, err);
    }
    this._pool.delete(key);
  }
}

/**
 * Evict all cached adapters. Used when multiple RPC URLs change at once.
 */
async evictAll(): Promise<void> {
  await this.disconnectAll(); // Existing method already disconnects + clears
}
```

**3. HotReloadOrchestrator** (hot-reload.ts):

Create a new module that coordinates hot-reload across subsystems based on which setting keys changed.

```typescript
/**
 * HotReloadOrchestrator: dispatches settings changes to subsystem reloaders.
 *
 * When PUT /admin/settings modifies keys, this orchestrator determines which
 * subsystems need reloading and triggers the appropriate reload functions.
 *
 * Subsystem reload is fire-and-forget: errors are caught and logged,
 * never propagated to the API response (settings are already saved to DB).
 */

import type { NotificationService } from '../../notifications/notification-service.js';
import type { AdapterPool } from '../adapter-pool.js';
import type { SettingsService } from './settings-service.js';

export interface HotReloadDeps {
  settingsService: SettingsService;
  notificationService?: NotificationService | null;
  adapterPool?: AdapterPool | null;
}

// Category to key prefix mapping for change detection
const NOTIFICATION_KEYS = new Set(
  ['notifications.enabled', 'notifications.telegram_bot_token', 'notifications.telegram_chat_id',
   'notifications.discord_webhook_url', 'notifications.ntfy_server', 'notifications.ntfy_topic',
   'notifications.locale', 'notifications.rate_limit_rpm']
);

const RPC_KEYS_PREFIX = 'rpc.';

const SECURITY_KEYS = new Set(
  ['security.session_ttl', 'security.max_sessions_per_wallet', 'security.max_pending_tx',
   'security.rate_limit_global_ip_rpm', 'security.rate_limit_session_rpm', 'security.rate_limit_tx_rpm',
   'security.policy_defaults_delay_seconds', 'security.policy_defaults_approval_timeout']
);

export class HotReloadOrchestrator {
  private deps: HotReloadDeps;

  constructor(deps: HotReloadDeps) {
    this.deps = deps;
  }

  /**
   * Handle changed settings keys. Determines affected subsystems and triggers reload.
   * Fire-and-forget: errors logged but never thrown.
   */
  async handleChangedKeys(changedKeys: string[]): Promise<void> {
    const hasNotificationChanges = changedKeys.some(k => NOTIFICATION_KEYS.has(k));
    const hasRpcChanges = changedKeys.some(k => k.startsWith(RPC_KEYS_PREFIX));
    const hasSecurityChanges = changedKeys.some(k => SECURITY_KEYS.has(k));

    const reloads: Promise<void>[] = [];

    if (hasNotificationChanges) {
      reloads.push(this.reloadNotifications().catch(err => {
        console.warn('Hot-reload notifications failed:', err);
      }));
    }

    if (hasRpcChanges) {
      reloads.push(this.reloadRpc(changedKeys.filter(k => k.startsWith(RPC_KEYS_PREFIX))).catch(err => {
        console.warn('Hot-reload RPC failed:', err);
      }));
    }

    if (hasSecurityChanges) {
      // Security reload is synchronous (just read new values on next request)
      // No action needed -- SettingsService.get() already reads from DB first
      console.log('Hot-reload: Security parameters updated (effective on next request)');
    }

    await Promise.all(reloads);
  }

  /**
   * Reload notification channels with current settings from SettingsService.
   */
  private async reloadNotifications(): Promise<void> {
    const svc = this.deps.notificationService;
    if (!svc) return;

    const ss = this.deps.settingsService;
    const enabled = ss.get('notifications.enabled') === 'true';

    if (!enabled) {
      svc.replaceChannels([]);
      console.log('Hot-reload: Notifications disabled, channels cleared');
      return;
    }

    // Dynamically import channel constructors (same pattern as daemon.ts Step 4d)
    const { TelegramChannel, DiscordChannel, NtfyChannel } =
      await import('../../notifications/index.js');

    const newChannels: import('@waiaas/core').INotificationChannel[] = [];

    // Telegram
    const tgToken = ss.get('notifications.telegram_bot_token');
    const tgChatId = ss.get('notifications.telegram_chat_id');
    if (tgToken && tgChatId) {
      const telegram = new TelegramChannel();
      await telegram.initialize({ telegram_bot_token: tgToken, telegram_chat_id: tgChatId });
      newChannels.push(telegram);
    }

    // Discord
    const discordUrl = ss.get('notifications.discord_webhook_url');
    if (discordUrl) {
      const discord = new DiscordChannel();
      await discord.initialize({ discord_webhook_url: discordUrl });
      newChannels.push(discord);
    }

    // Ntfy
    const ntfyTopic = ss.get('notifications.ntfy_topic');
    if (ntfyTopic) {
      const ntfyServer = ss.get('notifications.ntfy_server');
      const ntfy = new NtfyChannel();
      await ntfy.initialize({ ntfy_server: ntfyServer, ntfy_topic: ntfyTopic });
      newChannels.push(ntfy);
    }

    svc.replaceChannels(newChannels);

    // Update config (locale, rate limit)
    const locale = ss.get('notifications.locale') as 'en' | 'ko';
    const rateLimitRpm = parseInt(ss.get('notifications.rate_limit_rpm'), 10) || 20;
    svc.updateConfig({ locale, rateLimitRpm });

    console.log(`Hot-reload: Notifications reloaded (${newChannels.length} channels: ${newChannels.map(c => c.name).join(', ') || 'none'})`);
  }

  /**
   * Reload RPC adapters by evicting changed network adapters from the pool.
   * Next request for that chain:network will lazy-create a new adapter with the new URL.
   */
  private async reloadRpc(changedRpcKeys: string[]): Promise<void> {
    const pool = this.deps.adapterPool;
    if (!pool) return;

    for (const key of changedRpcKeys) {
      // key format: 'rpc.solana_mainnet' or 'rpc.evm_ethereum_sepolia' or 'rpc.evm_default_network'
      const field = key.replace('rpc.', '');

      if (field === 'evm_default_network') continue; // No adapter to evict for this key

      if (field.startsWith('solana_')) {
        const network = field.replace('solana_', '');
        await pool.evict('solana' as any, network as any);
        console.log(`Hot-reload: Evicted solana:${network} adapter`);
      } else if (field.startsWith('evm_')) {
        // Convert evm_ethereum_sepolia -> ethereum-sepolia
        const network = field.replace('evm_', '').replace(/_/g, '-');
        await pool.evict('ethereum' as any, network as any);
        console.log(`Hot-reload: Evicted ethereum:${network} adapter`);
      }
    }
  }
}
```

**4. Barrel export** (settings/index.ts):

Add to the barrel export:
```typescript
export { HotReloadOrchestrator } from './hot-reload.js';
export type { HotReloadDeps } from './hot-reload.js';
```
  </action>
  <verify>
    - `npx tsc --noEmit -p packages/daemon/tsconfig.json` passes
    - Review that NotificationService has replaceChannels + updateConfig methods
    - Review that AdapterPool has evict + evictAll methods
    - Review that HotReloadOrchestrator handles all 3 categories
  </verify>
  <done>
    NotificationService.replaceChannels() swaps channels atomically, AdapterPool.evict() forces adapter reconnection, HotReloadOrchestrator categorizes changed keys and dispatches to appropriate subsystem reloaders, all with fire-and-forget error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Daemon wiring + hot-reload tests</name>
  <files>
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/__tests__/settings-hot-reload.test.ts
  </files>
  <action>
**1. daemon.ts onSettingsChanged wiring:**

In Step 5 (HTTP server), replace the placeholder `onSettingsChanged: undefined` with an actual callback that uses HotReloadOrchestrator:

```typescript
// Import at top of the async block (dynamic import pattern like other deps):
const { HotReloadOrchestrator } = await import('../infrastructure/settings/index.js');

const hotReloader = new HotReloadOrchestrator({
  settingsService: this._settingsService!,
  notificationService: this.notificationService,
  adapterPool: this.adapterPool,
});
```

Then in the createApp call:
```typescript
onSettingsChanged: (changedKeys: string[]) => {
  void hotReloader.handleChangedKeys(changedKeys);
},
```

This is fire-and-forget (void): hot-reload errors don't affect the API response.

**2. Test file** (settings-hot-reload.test.ts):

Create tests for HotReloadOrchestrator and the subsystem reload methods.

**Setup:**
- Import HotReloadOrchestrator, SettingsService, SETTING_DEFINITIONS
- Import NotificationService from notifications
- Import AdapterPool from infrastructure
- Use in-memory SQLite DB
- Create mock/spy instances for testing

**Test cases (~15 tests):**

NotificationService.replaceChannels:
1. replaceChannels replaces all channels with new array
2. replaceChannels clears rate limit state
3. replaceChannels with empty array effectively disables notifications
4. updateConfig changes locale and rateLimitRpm

AdapterPool.evict:
5. evict disconnects and removes a specific adapter
6. evict on non-existent key is a no-op (no error)
7. evict allows re-resolve with new URL (evict + resolve creates fresh adapter)
8. evict handles disconnect errors gracefully (fail-soft)

HotReloadOrchestrator.handleChangedKeys:
9. Notification key changes trigger notification reload
10. RPC key changes trigger adapter eviction
11. Security key changes log message (no subsystem call needed)
12. Mixed keys trigger multiple reloaders
13. Unrecognized keys trigger nothing
14. Errors in notification reload don't prevent RPC reload (independence)
15. Empty changedKeys array triggers nothing

**Mock patterns:**
- For NotificationService: Create real instance, spy on replaceChannels
- For AdapterPool: Create real instance, spy on evict
- For SettingsService: Create real instance with in-memory DB, pre-populate with test values
- Use `vi.spyOn()` for method interception
- Use `vi.fn()` for channel constructors where needed

**Important:** For notification reload tests, the HotReloadOrchestrator will try to dynamically import real channel classes. Mock the channel constructors if needed, or test at integration level by verifying that `replaceChannels` was called with the right number of channels based on settings.
  </action>
  <verify>
    - `npx vitest run packages/daemon/src/__tests__/settings-hot-reload.test.ts` all tests pass
    - `npx vitest run packages/daemon/src/__tests__/` -- existing tests not broken
    - `npx tsc --noEmit -p packages/daemon/tsconfig.json` passes
  </verify>
  <done>
    daemon.ts creates HotReloadOrchestrator and wires onSettingsChanged callback. Test file covers replaceChannels, evict, and HotReloadOrchestrator dispatch logic with 12+ tests. Fire-and-forget error handling verified.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/daemon/tsconfig.json` -- TypeScript compilation
2. `npx vitest run packages/daemon/src/__tests__/settings-hot-reload.test.ts` -- New hot-reload tests pass
3. `npx vitest run packages/daemon/src/__tests__/admin-settings-api.test.ts` -- Plan 01 tests still pass
4. `npx vitest run packages/daemon/src/__tests__/` -- All existing tests not broken
5. Verify NotificationService has replaceChannels and updateConfig methods
6. Verify AdapterPool has evict method
7. Verify HotReloadOrchestrator categorizes keys into 3 subsystems
8. Verify daemon.ts wires onSettingsChanged -> HotReloadOrchestrator
</verification>

<success_criteria>
- NotificationService.replaceChannels() atomically swaps channel instances
- AdapterPool.evict() disconnects and removes cached adapter for re-creation
- HotReloadOrchestrator dispatches changed keys to correct subsystem reloaders
- daemon.ts wires onSettingsChanged callback through HotReloadOrchestrator
- Security parameter changes take effect on next request (DB-first reads)
- All reload operations are fire-and-forget (errors logged, never crash daemon)
- 12+ hot-reload tests passing
- All existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/101-settings-api-hot-reload/101-02-SUMMARY.md`
</output>
