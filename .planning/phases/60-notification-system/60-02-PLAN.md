---
phase: 60-notification-system
plan: 02
type: tdd
wave: 2
depends_on: ["60-01"]
files_modified:
  - packages/daemon/src/notifications/notification-service.ts
  - packages/daemon/src/notifications/index.ts
  - packages/core/src/schemas/config.schema.ts
  - packages/daemon/src/infrastructure/config/loader.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/notification-service.test.ts
  - packages/daemon/src/__tests__/config-loader.test.ts
autonomous: true

must_haves:
  truths:
    - "NotificationService sends notification via primary channel, falling back to secondary on failure"
    - "broadcast() sends to ALL configured channels simultaneously (Kill Switch, Auto-Stop events)"
    - "When all channels fail, audit_log receives a CRITICAL severity record"
    - "config.toml notification keys (6 new) are parsed and channels are auto-initialized from config"
    - "Channel-level rate limiting prevents flooding (configurable per-channel RPM)"
    - "NotificationService is injected into daemon lifecycle and available to route handlers"
  artifacts:
    - path: "packages/daemon/src/notifications/notification-service.ts"
      provides: "NotificationService orchestrator"
      exports: ["NotificationService"]
    - path: "packages/daemon/src/notifications/index.ts"
      provides: "Barrel export for notification module"
      exports: ["NotificationService", "TelegramChannel", "DiscordChannel", "NtfyChannel"]
    - path: "packages/daemon/src/__tests__/notification-service.test.ts"
      provides: "NotificationService tests"
  key_links:
    - from: "packages/daemon/src/notifications/notification-service.ts"
      to: "packages/core/src/interfaces/INotificationChannel.ts"
      via: "composes INotificationChannel instances"
      pattern: "INotificationChannel"
    - from: "packages/daemon/src/notifications/notification-service.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "inserts CRITICAL audit_log on total failure"
      pattern: "auditLog"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "creates NotificationService during startup"
      pattern: "NotificationService"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "receives NotificationService via CreateAppDeps"
      pattern: "notificationService"
---

<objective>
Implement the NotificationService orchestrator that composes the 3 channel adapters (from plan 60-01) into a priority-based delivery system with fallback chain, broadcast mode for critical events, per-channel rate limiting, CRITICAL audit_log on total failure, and integration with daemon lifecycle and config.toml.

Purpose: Complete the notification system so the daemon can automatically notify Owners of transaction, security, session, and operational events through configured channels with reliable delivery.

Output: NotificationService class, config.toml 6-key expansion, daemon lifecycle integration, 30+ tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-notification-system/60-01-SUMMARY.md
@objectives/v1.3-sdk-mcp-notifications.md (notification system section)
@packages/core/src/interfaces/INotificationChannel.ts
@packages/daemon/src/notifications/channels/telegram.ts (from 60-01)
@packages/daemon/src/notifications/channels/discord.ts (from 60-01)
@packages/daemon/src/notifications/channels/ntfy.ts (from 60-01)
@packages/daemon/src/notifications/templates/message-templates.ts (from 60-01)
@packages/daemon/src/infrastructure/config/loader.ts
@packages/daemon/src/infrastructure/database/schema.ts (auditLog table)
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/api/server.ts (CreateAppDeps)
</context>

<tasks>

<task type="auto">
  <name>Task 1: NotificationService orchestrator + config expansion + rate limiter</name>
  <files>
    packages/daemon/src/notifications/notification-service.ts
    packages/daemon/src/notifications/index.ts
    packages/core/src/schemas/config.schema.ts
  </files>
  <action>
**1a. Expand config.toml schema (packages/core/src/schemas/config.schema.ts):**

The DaemonConfig already has a `notifications` section in the daemon config loader with the 6 notification keys. However, the @waiaas/core ConfigSchema (which is a simpler/flatter schema) needs `notification_locale` added. Check if ConfigSchema needs updating -- the DaemonConfigSchema in loader.ts already has:
- `notifications.enabled`, `notifications.telegram_bot_token`, `notifications.telegram_chat_id`
- `notifications.discord_webhook_url`, `notifications.ntfy_server`, `notifications.ntfy_topic`

Add `notification_locale` to the DaemonConfigSchema notifications section (not in loader.ts -- add it there):
```typescript
locale: z.enum(['en', 'ko']).default('en'),
```

Also add rate limit configuration per channel:
```typescript
rate_limit_rpm: z.number().int().min(1).max(60).default(20),
```

This gives the notifications section: enabled, min_channels, health_check_interval, log_retention_days, dedup_ttl, telegram_bot_token, telegram_chat_id, discord_webhook_url, ntfy_server, ntfy_topic, locale, rate_limit_rpm.

**1b. NotificationService (packages/daemon/src/notifications/notification-service.ts):**

```typescript
import type { INotificationChannel, NotificationPayload } from '@waiaas/core';
import type { NotificationEventType, SupportedLocale } from '@waiaas/core';
import type { BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import { getNotificationMessage } from './templates/message-templates.js';
import type * as schema from '../infrastructure/database/schema.js';

// Broadcast event types -- sent to ALL channels simultaneously
const BROADCAST_EVENTS: Set<string> = new Set([
  'KILL_SWITCH_ACTIVATED',
  'KILL_SWITCH_RECOVERED',
  'AUTO_STOP_TRIGGERED',
]);

export interface NotificationServiceConfig {
  locale: SupportedLocale;
  rateLimitRpm: number; // per-channel rate limit (requests per minute)
}

export class NotificationService {
  private channels: INotificationChannel[] = [];
  private db: BetterSQLite3Database<typeof schema> | null = null;
  private config: NotificationServiceConfig = { locale: 'en', rateLimitRpm: 20 };

  // Rate limiter: Map<channelName, timestamps[]>
  private rateLimitMap = new Map<string, number[]>();

  constructor(opts?: {
    db?: BetterSQLite3Database<typeof schema>;
    config?: Partial<NotificationServiceConfig>;
  }) {
    if (opts?.db) this.db = opts.db;
    if (opts?.config) this.config = { ...this.config, ...opts.config };
  }

  /** Add initialized channel to the service. */
  addChannel(channel: INotificationChannel): void {
    this.channels.push(channel);
  }

  /** Get list of configured channel names. */
  getChannelNames(): string[] {
    return this.channels.map(c => c.name);
  }

  /**
   * Send notification via priority-based delivery with fallback.
   * Tries channels in order; on failure, falls back to next channel.
   * For broadcast events, sends to ALL channels.
   */
  async notify(
    eventType: NotificationEventType,
    agentId: string,
    vars?: Record<string, string>,
    details?: Record<string, unknown>,
  ): Promise<void> {
    if (this.channels.length === 0) return; // No channels configured

    const { title, body } = getNotificationMessage(eventType, this.config.locale, vars);
    const payload: NotificationPayload = {
      eventType,
      agentId,
      message: `${title}\n${body}`,
      details,
      timestamp: Math.floor(Date.now() / 1000),
    };

    if (BROADCAST_EVENTS.has(eventType)) {
      await this.broadcast(payload);
    } else {
      await this.sendWithFallback(payload);
    }
  }

  /**
   * Send to ALL channels simultaneously (for critical events).
   * If ALL channels fail, logs CRITICAL to audit_log.
   */
  private async broadcast(payload: NotificationPayload): Promise<void> {
    const results = await Promise.allSettled(
      this.channels.map(ch => this.sendToChannel(ch, payload)),
    );

    const allFailed = results.every(r => r.status === 'rejected');
    if (allFailed) {
      await this.logCriticalFailure(payload, results);
    }
  }

  /**
   * Priority-based fallback: try channels in order, stop on first success.
   * If all fail, log CRITICAL to audit_log.
   */
  private async sendWithFallback(payload: NotificationPayload): Promise<void> {
    for (const channel of this.channels) {
      try {
        await this.sendToChannel(channel, payload);
        return; // Success -- stop trying
      } catch {
        // Channel failed, try next
        continue;
      }
    }
    // All channels failed
    await this.logCriticalFailure(payload);
  }

  /**
   * Send to a single channel with rate limit check.
   */
  private async sendToChannel(
    channel: INotificationChannel,
    payload: NotificationPayload,
  ): Promise<void> {
    if (this.isRateLimited(channel.name)) {
      throw new Error(`Rate limited: ${channel.name}`);
    }
    await channel.send(payload);
    this.recordSend(channel.name);
  }

  /** Check if channel is rate limited (sliding window). */
  private isRateLimited(channelName: string): boolean {
    const now = Date.now();
    const windowMs = 60_000; // 1 minute
    const timestamps = this.rateLimitMap.get(channelName) ?? [];
    // Remove entries older than window
    const recent = timestamps.filter(t => now - t < windowMs);
    this.rateLimitMap.set(channelName, recent);
    return recent.length >= this.config.rateLimitRpm;
  }

  /** Record a successful send for rate limiting. */
  private recordSend(channelName: string): void {
    const timestamps = this.rateLimitMap.get(channelName) ?? [];
    timestamps.push(Date.now());
    this.rateLimitMap.set(channelName, timestamps);
  }

  /**
   * Log CRITICAL failure to audit_log when all channels fail.
   */
  private async logCriticalFailure(
    payload: NotificationPayload,
    results?: PromiseSettledResult<void>[],
  ): Promise<void> {
    if (!this.db) {
      console.error('CRITICAL: All notification channels failed, no DB for audit log', {
        eventType: payload.eventType,
        agentId: payload.agentId,
      });
      return;
    }

    try {
      // Dynamic import to avoid circular deps
      const { auditLog } = await import('../infrastructure/database/schema.js');

      const errorDetails = results
        ? results
            .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
            .map(r => String(r.reason))
            .join('; ')
        : 'All channels failed';

      this.db.insert(auditLog).values({
        timestamp: new Date(payload.timestamp * 1000),
        eventType: 'NOTIFICATION_TOTAL_FAILURE',
        actor: 'system',
        agentId: payload.agentId,
        details: JSON.stringify({
          originalEvent: payload.eventType,
          message: payload.message,
          errors: errorDetails,
        }),
        severity: 'critical',
      }).run();
    } catch (err) {
      console.error('CRITICAL: Failed to write audit log for notification failure', err);
    }
  }
}
```

**1c. Barrel export (packages/daemon/src/notifications/index.ts):**

```typescript
export { NotificationService } from './notification-service.js';
export type { NotificationServiceConfig } from './notification-service.js';
export { TelegramChannel } from './channels/telegram.js';
export { DiscordChannel } from './channels/discord.js';
export { NtfyChannel } from './channels/ntfy.js';
export { getNotificationMessage } from './templates/message-templates.js';
export type { NotificationMessage } from './templates/message-templates.js';
```
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx tsc -p packages/daemon/tsconfig.json --noEmit` to verify types.
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx tsc -p packages/core/tsconfig.json --noEmit` to verify core types.
  </verify>
  <done>
NotificationService orchestrator created with: priority-based fallback (notify), broadcast mode for critical events, per-channel rate limiting (sliding window), CRITICAL audit_log logging on total failure. Config expanded with locale and rate_limit_rpm. Barrel exports created. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Daemon lifecycle integration + tests</name>
  <files>
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/__tests__/notification-service.test.ts
    packages/daemon/src/__tests__/config-loader.test.ts
  </files>
  <action>
**2a. Integrate NotificationService into DaemonLifecycle (packages/daemon/src/lifecycle/daemon.ts):**

Add a `notificationService` field to DaemonLifecycle. In the startup sequence, after Step 4c (JWT Secret Manager) and before Step 5 (HTTP server):

```typescript
// Step 4d: Notification Service initialization (fail-soft)
try {
  if (this._config!.notifications.enabled) {
    const { NotificationService, TelegramChannel, DiscordChannel, NtfyChannel } =
      await import('../notifications/index.js');

    this.notificationService = new NotificationService({
      db: this._db ?? undefined,
      config: {
        locale: (this._config!.notifications.locale ?? 'en') as 'en' | 'ko',
        rateLimitRpm: this._config!.notifications.rate_limit_rpm ?? 20,
      },
    });

    // Initialize configured channels from config
    const notifConfig = this._config!.notifications;

    if (notifConfig.telegram_bot_token && notifConfig.telegram_chat_id) {
      const telegram = new TelegramChannel();
      await telegram.initialize({
        telegram_bot_token: notifConfig.telegram_bot_token,
        telegram_chat_id: notifConfig.telegram_chat_id,
      });
      this.notificationService.addChannel(telegram);
    }

    if (notifConfig.discord_webhook_url) {
      const discord = new DiscordChannel();
      await discord.initialize({
        discord_webhook_url: notifConfig.discord_webhook_url,
      });
      this.notificationService.addChannel(discord);
    }

    if (notifConfig.ntfy_topic) {
      const ntfy = new NtfyChannel();
      await ntfy.initialize({
        ntfy_server: notifConfig.ntfy_server,
        ntfy_topic: notifConfig.ntfy_topic,
      });
      this.notificationService.addChannel(ntfy);
    }

    const channelNames = this.notificationService.getChannelNames();
    console.log(`Step 4d: NotificationService initialized (${channelNames.length} channels: ${channelNames.join(', ') || 'none'})`);
  } else {
    console.log('Step 4d: Notifications disabled');
  }
} catch (err) {
  console.warn('Step 4d (fail-soft): NotificationService init warning:', err);
  this.notificationService = null;
}
```

Add the `notificationService` private field to the class:
```typescript
private notificationService: import('../notifications/notification-service.js').NotificationService | null = null;
```

Pass `notificationService` to createApp in Step 5:
```typescript
notificationService: this.notificationService ?? undefined,
```

**2b. Update CreateAppDeps (packages/daemon/src/api/server.ts):**

Add `notificationService` field to CreateAppDeps interface:
```typescript
import type { NotificationService } from '../notifications/notification-service.js';
// ...
export interface CreateAppDeps {
  // ... existing fields ...
  notificationService?: NotificationService;
}
```

This makes NotificationService available to route handlers for future integration (e.g., pipeline emitting TX_CONFIRMED events). The actual event emission wiring in route handlers is NOT part of this plan -- it will be wired when individual features emit events (the service is ready and injectable).

**2c. Tests (packages/daemon/src/__tests__/notification-service.test.ts):**

Comprehensive tests for NotificationService. Use mock INotificationChannel implementations:

```typescript
// Mock channel factory
function createMockChannel(name: string, shouldFail = false): INotificationChannel {
  return {
    name,
    initialize: vi.fn().mockResolvedValue(undefined),
    send: shouldFail
      ? vi.fn().mockRejectedValue(new Error(`${name} failed`))
      : vi.fn().mockResolvedValue(undefined),
  };
}
```

Test structure (30+ tests):

1. **Priority delivery tests (5+ tests):**
   - notify() with single channel sends to it
   - notify() with 2 channels sends to first only (on success)
   - No channels configured -- no error (silent no-op)
   - getChannelNames() returns configured channel names
   - notify() passes correct payload structure to channel

2. **Fallback chain tests (5+ tests):**
   - First channel fails -> second channel receives
   - First two fail -> third succeeds
   - Channel failure is caught and retried on next channel
   - Fallback preserves same payload across attempts

3. **Broadcast tests (5+ tests):**
   - KILL_SWITCH_ACTIVATED sends to ALL channels
   - KILL_SWITCH_RECOVERED sends to ALL channels
   - AUTO_STOP_TRIGGERED sends to ALL channels
   - Non-broadcast event does NOT send to all channels
   - Broadcast with partial failure still sends to working channels

4. **Total failure + audit_log tests (4+ tests):**
   - All channels fail in fallback -> CRITICAL audit_log entry
   - All channels fail in broadcast -> CRITICAL audit_log entry
   - Audit log entry contains originalEvent, message, errors
   - Audit log severity = 'critical'
   - No DB available -> logs to console.error (no crash)

5. **Rate limiter tests (5+ tests):**
   - Channel under limit -> sends successfully
   - Channel at limit -> throws rate limit error -> triggers fallback
   - Rate limit resets after window passes (use vi.advanceTimersByTime)
   - Different channels have independent rate limits
   - Rate limit config is respected (custom RPM)

6. **Message template integration tests (3+ tests):**
   - notify() with locale='en' produces English message
   - notify() with locale='ko' produces Korean message
   - notify() interpolates vars into message body

7. **Config integration tests (3+ tests):**
   - Update existing config-loader.test.ts to verify `locale` and `rate_limit_rpm` defaults
   - Verify notifications section parses correctly with all new fields

Use `vi.useFakeTimers()` for rate limit tests. Use in-memory SQLite (via better-sqlite3 + drizzle) for audit_log assertions -- follow the pattern from existing daemon tests.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/daemon/src/__tests__/notification-service.test.ts` -- all tests pass.
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/daemon/src/__tests__/config-loader.test.ts` -- all tests pass.
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run` -- full test suite passes (regression check).
  </verify>
  <done>
NotificationService fully integrated: priority delivery, fallback chain, broadcast for KILL_SWITCH/AUTO_STOP events, per-channel rate limiting, CRITICAL audit_log on total failure. DaemonLifecycle creates and injects NotificationService from config. CreateAppDeps exposes it to route handlers. 30+ tests pass covering all delivery modes, failure scenarios, rate limiting, and config parsing.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all packages without errors
2. `npx vitest run packages/daemon/src/__tests__/notification-service.test.ts` -- 30+ tests pass
3. `npx vitest run packages/daemon/src/__tests__/notification-channels.test.ts` -- passes (from 60-01)
4. `npx vitest run packages/daemon/src/__tests__/config-loader.test.ts` -- passes with new fields
5. `npx vitest run` -- full suite passes (no regressions)
6. audit_log table receives 'critical' severity record when all channels fail
7. DaemonConfig.notifications has locale and rate_limit_rpm fields
8. NotificationService is available via CreateAppDeps.notificationService
</verification>

<success_criteria>
- NotificationService.notify() delivers via priority fallback chain
- broadcast() sends KILL_SWITCH_ACTIVATED/RECOVERED, AUTO_STOP_TRIGGERED to ALL channels
- All-channel failure writes CRITICAL audit_log entry with error details
- Per-channel rate limiting (sliding window, configurable RPM)
- config.toml notifications section has locale and rate_limit_rpm
- DaemonLifecycle creates NotificationService from config, passes to createApp
- 30+ tests pass covering delivery, fallback, broadcast, rate limiting, audit_log
- Full test suite regression passes
</success_criteria>

<output>
After completion, create `.planning/phases/60-notification-system/60-02-SUMMARY.md`
</output>
