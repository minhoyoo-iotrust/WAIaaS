---
phase: 60-notification-system
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/core/src/enums/notification.ts
  - packages/core/src/enums/index.ts
  - packages/core/src/i18n/en.ts
  - packages/core/src/i18n/ko.ts
  - packages/core/src/i18n/index.ts
  - packages/core/src/index.ts
  - packages/daemon/src/notifications/channels/telegram.ts
  - packages/daemon/src/notifications/channels/discord.ts
  - packages/daemon/src/notifications/channels/ntfy.ts
  - packages/daemon/src/notifications/templates/message-templates.ts
  - packages/daemon/src/__tests__/notification-channels.test.ts
autonomous: true

must_haves:
  truths:
    - "TelegramChannel sends MarkdownV2 formatted messages via Bot API using native fetch"
    - "DiscordChannel sends Embed formatted messages via Webhook URL using native fetch"
    - "NtfyChannel sends plain text messages with Priority mapping via ntfy.sh using native fetch"
    - "21 NotificationEventType enum values exist (16 existing + 5 new)"
    - "en/ko message templates exist for all 21 event types with title and body"
    - "Each channel implements INotificationChannel interface from @waiaas/core"
  artifacts:
    - path: "packages/core/src/enums/notification.ts"
      provides: "21 NotificationEventType SSoT enum"
      contains: "TX_APPROVAL_REQUIRED"
    - path: "packages/daemon/src/notifications/channels/telegram.ts"
      provides: "TelegramChannel class"
      exports: ["TelegramChannel"]
    - path: "packages/daemon/src/notifications/channels/discord.ts"
      provides: "DiscordChannel class"
      exports: ["DiscordChannel"]
    - path: "packages/daemon/src/notifications/channels/ntfy.ts"
      provides: "NtfyChannel class"
      exports: ["NtfyChannel"]
    - path: "packages/daemon/src/notifications/templates/message-templates.ts"
      provides: "21 event type message templates (en/ko)"
      exports: ["getNotificationMessage"]
    - path: "packages/daemon/src/__tests__/notification-channels.test.ts"
      provides: "Channel adapter tests"
  key_links:
    - from: "packages/daemon/src/notifications/channels/telegram.ts"
      to: "packages/core/src/interfaces/INotificationChannel.ts"
      via: "implements INotificationChannel"
      pattern: "INotificationChannel"
    - from: "packages/daemon/src/notifications/templates/message-templates.ts"
      to: "packages/core/src/enums/notification.ts"
      via: "uses NotificationEventType as keys"
      pattern: "NotificationEventType"
---

<objective>
Implement the 3 notification channel adapters (Telegram, Discord, ntfy) that implement the existing INotificationChannel interface from @waiaas/core, expand NotificationEventType from 16 to 21, and create en/ko message templates for all 21 event types.

Purpose: Enable the daemon to send formatted notifications through 3 external channels. This plan delivers the channel layer that the NotificationService orchestrator (plan 60-02) will compose.

Output: 3 channel adapter classes, 21 event type enums, en/ko message template function, comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@objectives/v1.3-sdk-mcp-notifications.md (notification system section)
@packages/core/src/interfaces/INotificationChannel.ts (existing interface)
@packages/core/src/enums/notification.ts (existing 16 event types)
@packages/core/src/i18n/en.ts (existing i18n pattern)
@packages/core/src/i18n/ko.ts (existing i18n pattern)
@packages/core/src/i18n/index.ts (getMessages function)
@packages/daemon/src/infrastructure/config/loader.ts (DaemonConfig notifications section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand NotificationEventType to 21 + en/ko message templates</name>
  <files>
    packages/core/src/enums/notification.ts
    packages/core/src/i18n/en.ts
    packages/core/src/i18n/ko.ts
    packages/core/src/i18n/index.ts
    packages/daemon/src/notifications/templates/message-templates.ts
  </files>
  <action>
**1a. Expand NotificationEventType enum (packages/core/src/enums/notification.ts):**

Add 5 new event types to the existing 16, making 21 total. Insert after the existing entries:
- `TX_APPROVAL_REQUIRED` (after TX_CANCELLED)
- `TX_APPROVAL_EXPIRED` (after TX_APPROVAL_REQUIRED)
- `AUTO_STOP_TRIGGERED` (after KILL_SWITCH_RECOVERED)
- `SESSION_CREATED` (after SESSION_EXPIRED)
- `DAILY_SUMMARY` (at the end)

Keep the existing `as const` + `z.enum()` SSoT pattern. The array must contain exactly 21 entries.

**1b. Add notification message templates to i18n (packages/core/src/i18n/en.ts and ko.ts):**

Add a new `notifications` section to the `Messages` interface (in en.ts where interface is defined). Each event type gets `title` and `body` keys. Body uses template literal syntax with `{variable}` placeholders (NOT JS template literals -- plain string with `{agentId}`, `{amount}`, `{txId}` etc.).

The `notifications` section structure:
```typescript
notifications: Record<NotificationEventType, { title: string; body: string }>;
```

Import `NotificationEventType` from the enums to use as the Record key. Update the `Messages` interface to include the `notifications` field.

**English titles/bodies (en.ts):**
- TX_REQUESTED: title="Transaction Requested", body="Agent {agentId} requested {amount} transfer to {to}"
- TX_QUEUED: title="Transaction Queued", body="Transaction {txId} queued for processing"
- TX_SUBMITTED: title="Transaction Submitted", body="Transaction {txId} submitted to blockchain"
- TX_CONFIRMED: title="Transaction Confirmed", body="Transaction {txId} confirmed. Amount: {amount}"
- TX_FAILED: title="Transaction Failed", body="Transaction {txId} failed: {error}"
- TX_CANCELLED: title="Transaction Cancelled", body="Transaction {txId} cancelled"
- TX_DOWNGRADED_DELAY: title="Transaction Delayed", body="Transaction {txId} downgraded to delay queue ({seconds}s cooldown)"
- TX_APPROVAL_REQUIRED: title="Approval Required", body="Transaction {txId} requires owner approval. Amount: {amount} to {to}"
- TX_APPROVAL_EXPIRED: title="Approval Expired", body="Approval for transaction {txId} has expired"
- POLICY_VIOLATION: title="Policy Violation", body="Agent {agentId} policy violation: {reason}"
- AGENT_SUSPENDED: title="Agent Suspended", body="Agent {agentId} has been suspended: {reason}"
- KILL_SWITCH_ACTIVATED: title="Kill Switch Activated", body="Kill switch activated by {activatedBy}. All operations halted"
- KILL_SWITCH_RECOVERED: title="Kill Switch Recovered", body="Kill switch deactivated. Normal operations resumed"
- AUTO_STOP_TRIGGERED: title="Auto-Stop Triggered", body="Daemon auto-stopped after {failures} consecutive failures"
- SESSION_EXPIRING_SOON: title="Session Expiring Soon", body="Session {sessionId} for agent {agentId} expires in {minutes} minutes"
- SESSION_EXPIRED: title="Session Expired", body="Session {sessionId} for agent {agentId} has expired"
- SESSION_CREATED: title="Session Created", body="New session created for agent {agentId}"
- OWNER_SET: title="Owner Registered", body="Owner registered for agent {agentId}: {ownerAddress}"
- OWNER_REMOVED: title="Owner Removed", body="Owner removed from agent {agentId}"
- OWNER_VERIFIED: title="Owner Verified", body="Owner verified for agent {agentId}"
- DAILY_SUMMARY: title="Daily Summary", body="Agents: {agentCount}, Transactions: {txCount}, Sessions: {sessionCount}"

**Korean titles/bodies (ko.ts):** Mirror all 21 entries in Korean. Follow the existing ko.ts translation style. Examples:
- TX_REQUESTED: title="거래 요청", body="에이전트 {agentId}가 {to}로 {amount} 전송을 요청했습니다"
- KILL_SWITCH_ACTIVATED: title="Kill Switch 발동", body="{activatedBy}에 의해 Kill Switch가 발동되었습니다. 모든 작업이 중단됩니다"
- TX_APPROVAL_REQUIRED: title="승인 필요", body="거래 {txId}에 Owner 승인이 필요합니다. 금액: {amount}, 수신: {to}"
(Translate all 21 -- keep variable placeholders identical in both languages)

**1c. Create getNotificationMessage helper (packages/daemon/src/notifications/templates/message-templates.ts):**

```typescript
import type { NotificationEventType } from '@waiaas/core';
import { getMessages, type SupportedLocale } from '@waiaas/core';

export interface NotificationMessage {
  title: string;
  body: string;
}

/**
 * Get a notification message for a given event type and locale,
 * with template variables interpolated.
 */
export function getNotificationMessage(
  eventType: NotificationEventType,
  locale: SupportedLocale,
  vars?: Record<string, string>,
): NotificationMessage {
  const messages = getMessages(locale);
  const template = messages.notifications[eventType];
  let { title, body } = template;

  // Interpolate {variable} placeholders
  if (vars) {
    for (const [key, value] of Object.entries(vars)) {
      title = title.replaceAll(`{${key}}`, value);
      body = body.replaceAll(`{${key}}`, value);
    }
  }

  return { title, body };
}
```

Create directory `packages/daemon/src/notifications/templates/` as needed.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx tsc -p packages/core/tsconfig.json --noEmit` to verify type correctness.
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx tsc -p packages/daemon/tsconfig.json --noEmit` to verify daemon types.
Grep notification.ts to confirm exactly 21 entries in the NOTIFICATION_EVENT_TYPES array.
  </verify>
  <done>
21 NotificationEventType values defined in SSoT enum. Messages interface extended with `notifications` section. All 21 event types have en/ko title+body templates. getNotificationMessage() interpolates variables correctly. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 3 channel adapters + tests</name>
  <files>
    packages/daemon/src/notifications/channels/telegram.ts
    packages/daemon/src/notifications/channels/discord.ts
    packages/daemon/src/notifications/channels/ntfy.ts
    packages/daemon/src/__tests__/notification-channels.test.ts
  </files>
  <action>
All 3 channels implement the existing `INotificationChannel` interface from `@waiaas/core` (methods: `initialize(config)`, `send(payload)`, readonly `name`). All use native `fetch` (Node.js 22 built-in) -- no external HTTP libraries or Bot frameworks per project decisions.

**2a. TelegramChannel (packages/daemon/src/notifications/channels/telegram.ts):**

```typescript
import type { INotificationChannel, NotificationPayload } from '@waiaas/core';

export class TelegramChannel implements INotificationChannel {
  readonly name = 'telegram';
  private botToken = '';
  private chatId = '';

  async initialize(config: Record<string, unknown>): Promise<void> {
    this.botToken = String(config.telegram_bot_token ?? '');
    this.chatId = String(config.telegram_chat_id ?? '');
    if (!this.botToken || !this.chatId) {
      throw new Error('TelegramChannel: telegram_bot_token and telegram_chat_id required');
    }
  }

  async send(payload: NotificationPayload): Promise<void> {
    // Format as MarkdownV2 (escape special chars)
    const text = this.formatMarkdownV2(payload);
    const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: this.chatId,
        text,
        parse_mode: 'MarkdownV2',
      }),
    });

    if (!response.ok) {
      const body = await response.text();
      throw new Error(`TelegramChannel: ${response.status} ${body}`);
    }
  }

  private formatMarkdownV2(payload: NotificationPayload): string {
    // MarkdownV2 requires escaping: _ * [ ] ( ) ~ ` > # + - = | { } . !
    const escape = (s: string) =>
      s.replace(/([_*\[\]()~`>#+\-=|{}.!\\])/g, '\\$1');

    const title = `*${escape(payload.message.split('\n')[0] ?? payload.eventType)}*`;
    const body = escape(payload.message);
    const agent = escape(`Agent: ${payload.agentId}`);
    const time = escape(new Date(payload.timestamp * 1000).toISOString());

    return `${title}\n\n${body}\n\n${agent}\n${time}`;
  }
}
```

**2b. DiscordChannel (packages/daemon/src/notifications/channels/discord.ts):**

```typescript
import type { INotificationChannel, NotificationPayload } from '@waiaas/core';

export class DiscordChannel implements INotificationChannel {
  readonly name = 'discord';
  private webhookUrl = '';

  async initialize(config: Record<string, unknown>): Promise<void> {
    this.webhookUrl = String(config.discord_webhook_url ?? '');
    if (!this.webhookUrl) {
      throw new Error('DiscordChannel: discord_webhook_url required');
    }
  }

  async send(payload: NotificationPayload): Promise<void> {
    // Discord Webhook with Embed format
    const color = this.getColor(payload.eventType);

    const embed = {
      title: payload.eventType.replace(/_/g, ' '),
      description: payload.message,
      color,
      fields: [
        { name: 'Agent', value: payload.agentId, inline: true },
        { name: 'Event', value: payload.eventType, inline: true },
      ],
      timestamp: new Date(payload.timestamp * 1000).toISOString(),
    };

    // Add details fields if present
    if (payload.details) {
      for (const [key, value] of Object.entries(payload.details)) {
        embed.fields.push({ name: key, value: String(value), inline: true });
      }
    }

    const response = await fetch(this.webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ embeds: [embed] }),
    });

    if (!response.ok) {
      const body = await response.text();
      throw new Error(`DiscordChannel: ${response.status} ${body}`);
    }
  }

  /** Map event severity to Discord embed color (hex integer). */
  private getColor(eventType: string): number {
    if (eventType.includes('KILL_SWITCH') || eventType.includes('AUTO_STOP') || eventType.includes('SUSPENDED')) {
      return 0xff0000; // Red for critical/security events
    }
    if (eventType.includes('FAILED') || eventType.includes('VIOLATION') || eventType.includes('EXPIRED')) {
      return 0xff8c00; // Orange for failures/warnings
    }
    if (eventType.includes('CONFIRMED') || eventType.includes('RECOVERED') || eventType.includes('VERIFIED')) {
      return 0x00ff00; // Green for success
    }
    return 0x0099ff; // Blue for informational
  }
}
```

**2c. NtfyChannel (packages/daemon/src/notifications/channels/ntfy.ts):**

```typescript
import type { INotificationChannel, NotificationPayload } from '@waiaas/core';

export class NtfyChannel implements INotificationChannel {
  readonly name = 'ntfy';
  private server = 'https://ntfy.sh';
  private topic = '';

  async initialize(config: Record<string, unknown>): Promise<void> {
    this.server = String(config.ntfy_server ?? 'https://ntfy.sh');
    this.topic = String(config.ntfy_topic ?? '');
    if (!this.topic) {
      throw new Error('NtfyChannel: ntfy_topic required');
    }
  }

  async send(payload: NotificationPayload): Promise<void> {
    // ntfy.sh: POST plain text with headers for title, priority, tags
    const priority = this.mapPriority(payload.eventType);
    const tags = this.mapTags(payload.eventType);
    const url = `${this.server}/${this.topic}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Title': `[WAIaaS] ${payload.eventType.replace(/_/g, ' ')}`,
        'Priority': String(priority),
        'Tags': tags,
      },
      body: `${payload.message}\n\nAgent: ${payload.agentId}\nTime: ${new Date(payload.timestamp * 1000).toISOString()}`,
    });

    if (!response.ok) {
      const body = await response.text();
      throw new Error(`NtfyChannel: ${response.status} ${body}`);
    }
  }

  /** Map event type to ntfy priority (1-5, where 5=max). */
  private mapPriority(eventType: string): number {
    if (eventType.includes('KILL_SWITCH') || eventType.includes('AUTO_STOP')) return 5; // urgent
    if (eventType.includes('SUSPENDED') || eventType.includes('FAILED') || eventType.includes('VIOLATION')) return 4; // high
    if (eventType.includes('APPROVAL') || eventType.includes('EXPIR')) return 3; // default
    return 2; // low for informational
  }

  /** Map event type to ntfy tags (emoji shortcodes). */
  private mapTags(eventType: string): string {
    if (eventType.includes('KILL_SWITCH') || eventType.includes('AUTO_STOP')) return 'rotating_light,warning';
    if (eventType.includes('FAILED') || eventType.includes('VIOLATION')) return 'x,warning';
    if (eventType.includes('CONFIRMED') || eventType.includes('RECOVERED')) return 'white_check_mark';
    if (eventType.includes('APPROVAL')) return 'bell';
    if (eventType.includes('SESSION')) return 'key';
    if (eventType.includes('OWNER')) return 'bust_in_silhouette';
    return 'speech_balloon';
  }
}
```

**2d. Tests (packages/daemon/src/__tests__/notification-channels.test.ts):**

Write comprehensive tests for all 3 channels. Mock `global.fetch` to capture requests without making real HTTP calls. Use the TDD RED-GREEN cycle:

Test structure:
1. **TelegramChannel tests (6+ tests):**
   - initialize() with valid config succeeds
   - initialize() with missing token throws
   - send() calls Telegram Bot API with correct URL, headers, MarkdownV2 parse_mode
   - send() formats message as MarkdownV2 (escapes special chars)
   - send() throws on non-ok response
   - send() includes chat_id in body

2. **DiscordChannel tests (6+ tests):**
   - initialize() with valid webhook_url succeeds
   - initialize() with missing URL throws
   - send() calls webhook URL with Embed payload
   - send() maps critical events to red color
   - send() maps success events to green color
   - send() includes details as embed fields
   - send() throws on non-ok response

3. **NtfyChannel tests (6+ tests):**
   - initialize() with valid topic succeeds
   - initialize() with missing topic throws
   - send() calls ntfy server with correct topic URL
   - send() sets Priority header (5 for kill switch)
   - send() sets Tags header (rotating_light for kill switch)
   - send() sends plain text body
   - send() throws on non-ok response

4. **NotificationEventType tests (2+ tests):**
   - 21 event types exist
   - 5 new types are present (TX_APPROVAL_REQUIRED, TX_APPROVAL_EXPIRED, AUTO_STOP_TRIGGERED, SESSION_CREATED, DAILY_SUMMARY)

5. **Message template tests (3+ tests):**
   - getNotificationMessage returns en template for TX_CONFIRMED
   - getNotificationMessage returns ko template for KILL_SWITCH_ACTIVATED
   - getNotificationMessage interpolates variables

Mock fetch pattern:
```typescript
const mockFetch = vi.fn().mockResolvedValue({ ok: true, text: async () => '{}' });
vi.stubGlobal('fetch', mockFetch);
```

Use `afterEach(() => vi.restoreAllMocks())` for cleanup.

Aim for 25-30 test cases total across all describe blocks.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/daemon/src/__tests__/notification-channels.test.ts` -- all tests pass.
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/core/src/__tests__/` -- existing core tests still pass.
  </verify>
  <done>
3 channel adapter classes (TelegramChannel, DiscordChannel, NtfyChannel) implement INotificationChannel using native fetch. All tests pass (25+ test cases). Each channel: validates config in initialize(), formats messages per channel spec, throws on API errors. No external HTTP libraries used.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` across both packages compiles without errors
2. `npx vitest run packages/daemon/src/__tests__/notification-channels.test.ts` -- all 25+ tests pass
3. `npx vitest run packages/core/src/__tests__/` -- existing tests pass (regression check)
4. Grep `NOTIFICATION_EVENT_TYPES` array has exactly 21 entries
5. Grep en.ts and ko.ts both have `notifications:` section with 21 event keys
</verification>

<success_criteria>
- 21 NotificationEventType values in SSoT enum (packages/core)
- en/ko message templates for all 21 event types
- TelegramChannel sends MarkdownV2 via Bot API
- DiscordChannel sends Embed via Webhook
- NtfyChannel sends plain text with Priority mapping via ntfy.sh
- All channels use native fetch only (no external HTTP lib)
- 25+ passing tests covering all 3 channels + templates + event types
</success_criteria>

<output>
After completion, create `.planning/phases/60-notification-system/60-01-SUMMARY.md`
</output>
