---
phase: 06-core-architecture-design
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - .planning/deliverables/26-keystore-spec.md
autonomous: true

must_haves:
  truths:
    - "키스토어 파일 포맷이 바이트 수준(nonce 12B, ciphertext NB, tag 16B, salt 16B)으로 정의됨"
    - "Argon2id 키 파생 프로토콜이 입력/출력/파라미터 모두 명시됨 (m=64MiB, t=3, p=4)"
    - "AES-256-GCM 암호화/복호화 절차가 nonce 생성부터 인증 태그 검증까지 단계별로 정의됨"
    - "sodium-native guarded memory 프로토콜이 할당->잠금->해제->서명->제로화->잠금 전체 수명주기로 정의됨"
    - "키스토어 백업/복원/내보내기 절차가 정의됨"
    - "에이전트 키 생성 프로토콜이 체인별(Solana Ed25519, EVM secp256k1) 차이까지 명시됨"
  artifacts:
    - path: ".planning/deliverables/26-keystore-spec.md"
      provides: "암호화 키스토어 파일 포맷, 키 파생, 메모리 안전성 프로토콜 전체 스펙"
      contains: "aes-256-gcm"
  key_links:
    - from: "26-keystore-spec.md"
      to: "24-monorepo-data-directory.md"
      via: "키스토어 파일 경로 ~/.waiaas/keystore/<agent-id>.json"
      pattern: "keystore/"
    - from: "26-keystore-spec.md"
      to: "25-sqlite-schema.md"
      via: "agents 테이블 publicKey 컬럼과 키스토어 파일의 publicKey 필드 매핑"
      pattern: "publicKey"
---

<objective>
암호화 키스토어의 완전한 기술 스펙을 설계한다 -- Ethereum Keystore V3를 AES-256-GCM + Argon2id로 확장한 파일 포맷, 키 생성/파생/암호화/복호화 프로토콜, sodium-native guarded memory 사용 프로토콜, 백업/복원/내보내기 절차.

Purpose: 키스토어는 에이전트 자산의 핵심 보안 계층. 바이트 수준 스펙이 없으면 구현 시 암호학적 오류(nonce 재사용, 약한 KDF 등) 위험이 높다.
Output: 설계 문서 1개 -- 26-keystore-spec.md
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-architecture-design/06-CONTEXT.md
@.planning/phases/06-core-architecture-design/06-RESEARCH.md

# 06-01 SUMMARY (데이터 디렉토리, 패키지 구조 참조)
@.planning/phases/06-core-architecture-design/06-01-SUMMARY.md

# v0.1 참조 문서
@.planning/deliverables/08-dual-key-architecture.md (ARCH-01: Owner/Agent 키 구조)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 키스토어 파일 포맷 + 키 파생 프로토콜 설계</name>
  <files>.planning/deliverables/26-keystore-spec.md</files>
  <action>
  설계 문서 `26-keystore-spec.md`를 작성한다. 문서 ID는 `CORE-03`.

  **섹션 1: 키스토어 파일 포맷 (WAIaaS Keystore v1)**
  - Ethereum Keystore V3 기반 확장 JSON 포맷 정의 (06-RESEARCH.md Pattern 1 기반)
  - 전체 JSON 구조 예시:
    ```json
    {
      "version": 1,
      "id": "<uuid-v4>",
      "chain": "solana",
      "network": "mainnet-beta",
      "publicKey": "<base58-or-hex>",
      "crypto": {
        "cipher": "aes-256-gcm",
        "cipherparams": { "iv": "<hex-96bit>" },
        "ciphertext": "<hex>",
        "authTag": "<hex-128bit>",
        "kdf": "argon2id",
        "kdfparams": {
          "salt": "<hex-128bit>",
          "memoryCost": 65536,
          "timeCost": 3,
          "parallelism": 4,
          "hashLength": 32
        }
      },
      "metadata": {
        "name": "<agent-name>",
        "createdAt": "<ISO8601>",
        "lastUnlockedAt": "<ISO8601>"
      }
    }
    ```
  - 각 필드의 타입, 바이트 크기, 인코딩 방식, 생성 방법을 테이블로 정의
  - Ethereum V3와의 차이점 비교 테이블 (cipher, kdf, mac 제거 이유, 추가 필드)
  - 바이너리 레이아웃: nonce(12B) + ciphertext(NB) + authTag(16B) -- ciphertext 내부 구조

  **섹션 2: 키 파생 프로토콜 (Argon2id)**
  - 입력: 마스터 패스워드 (UTF-8 인코딩), 16바이트 CSPRNG salt
  - 출력: 32바이트 (256비트) 대칭 키
  - 파라미터: m=65536 (64MiB), t=3, p=4 (06-CONTEXT.md 잠긴 결정)
  - `argon2` npm 라이브러리 사용 코드 패턴 (06-RESEARCH.md 기반)
  - 마스터 패스워드 입력 경로:
    1. 대화형: stdin에서 읽기 (TTY 감지)
    2. 비대화형: `WAIAAS_MASTER_PASSWORD` 환경변수
    3. 비대화형: `WAIAAS_MASTER_PASSWORD_FILE` 파일 경로 (Docker secrets 패턴)
  - 우선순위: 환경변수 > 파일 > 대화형
  - 보안 주의: 패스워드 문자열도 사용 후 제로화 (가능한 범위에서)

  **섹션 3: AES-256-GCM 암호화/복호화 프로토콜**
  - 암호화 절차 (step-by-step):
    1. `crypto.randomBytes(12)` -> 96비트 nonce 생성 (매 암호화마다 새로!)
    2. Argon2id 파생 키로 `createCipheriv('aes-256-gcm', key, nonce)` 생성
    3. 평문 개인키를 암호화
    4. `cipher.getAuthTag()` -> 128비트 인증 태그 추출
    5. nonce, ciphertext, authTag를 키스토어 JSON에 hex 인코딩하여 저장
  - 복호화 절차 (step-by-step):
    1. JSON에서 nonce, ciphertext, authTag 추출 (hex -> Buffer)
    2. 패스워드로 Argon2id 키 파생 (salt는 JSON에서 추출)
    3. `createDecipheriv('aes-256-gcm', key, nonce)` + `setAuthTag(tag)`
    4. 복호화 수행 -- authTag 불일치 시 에러 (잘못된 패스워드)
    5. 복호화된 키를 sodium_malloc 버퍼로 즉시 복사
    6. 원본 Buffer를 fill(0)으로 제로화 (sodium_malloc 외부이므로 최선의 노력)
  - 06-RESEARCH.md의 Pitfall 1 (C-01) nonce 재사용 방지 전략 명시
  - 재암호화 시나리오: 패스워드 변경 시 새 salt + 새 nonce로 전체 재암호화

  **섹션 4: 에이전트 키 생성 프로토콜**
  - Solana: Ed25519 키쌍 생성 (`@solana/kit`의 `generateKeyPairSigner()` 또는 `sodium-native`의 `crypto_sign_keypair`)
    - 개인키 64바이트 (seed 32B + pubkey 32B), 공개키 32바이트
    - 공개키 인코딩: Base58 (Solana 주소)
  - EVM: secp256k1 키쌍 생성 (`viem`의 `generatePrivateKey()`)
    - 개인키 32바이트, 공개키 -> Keccak256 -> 하위 20바이트 = 주소
    - 주소 인코딩: 0x-prefixed hex (EIP-55 checksummed)
  - 전체 키 생성 -> 암호화 -> 저장 워크플로우 (시퀀스 다이어그램)
  - 생성 시 agents 테이블 레코드 동시 삽입 (publicKey, chain, network, status=CREATING->ACTIVE)
  </action>
  <verify>
  문서에 다음이 모두 포함되어 있는지 확인:
  - 키스토어 JSON 전체 구조 (모든 필드 설명 테이블)
  - Ethereum V3 vs WAIaaS v1 비교 테이블
  - Argon2id 파라미터 + 코드 패턴
  - 마스터 패스워드 3가지 입력 경로 (대화형, 환경변수, 파일)
  - AES-256-GCM 암호화/복호화 step-by-step
  - Solana Ed25519 + EVM secp256k1 키 생성 프로토콜
  - 키 생성 시퀀스 다이어그램
  </verify>
  <done>
  키스토어 파일 포맷이 바이트 수준으로 정의됨. Argon2id 키 파생, AES-256-GCM 암호화/복호화, 체인별 키 생성 프로토콜이 구현 가능한 수준으로 문서화됨. 요구사항 KEYS-01 완전 커버.
  </done>
</task>

<task type="auto">
  <name>Task 2: sodium-native 메모리 안전성 프로토콜 + 백업/복원 설계</name>
  <files>.planning/deliverables/26-keystore-spec.md</files>
  <action>
  기존 `26-keystore-spec.md`에 섹션 5, 6, 7을 추가한다.

  **섹션 5: sodium-native Guarded Memory 프로토콜**
  - 06-RESEARCH.md Pattern 5 기반
  - 키 자료의 전체 수명주기를 상태 다이어그램으로 정의:
    ```
    [Allocated] -> sodium_mprotect_noaccess -> [Locked]
    [Locked] -> sodium_mprotect_readwrite -> [Unlocked]
    [Unlocked] -> (write key data) -> [Loaded]
    [Loaded] -> sodium_mprotect_readonly -> [ReadOnly]
    [ReadOnly] -> (sign transaction) -> [ReadOnly]
    [ReadOnly] -> sodium_mprotect_readwrite -> [Unlocked]
    [Unlocked] -> sodium_memzero -> [Zeroed]
    [Zeroed] -> sodium_mprotect_noaccess -> [Locked]
    ```
  - 데몬 실행 중 키 상태: Loaded (ReadOnly) -- 06-CONTEXT.md 결정 "데몬 실행 중 = 상시 열림"
  - 서명 시 일시적으로 ReadWrite 전환 불필요 -- 이미 ReadOnly로 서명 가능 (읽기만 필요)
  - 데몬 종료 시: sodium_memzero -> sodium_mprotect_noaccess
  - KeyStore 서비스 인터페이스 (TypeScript):
    ```typescript
    interface ILocalKeyStore {
      unlock(password: string): Promise<void>
      lock(): void
      sign(agentId: string, message: Uint8Array): Uint8Array
      getPublicKey(agentId: string): string
      addAgent(agentId: string, chain: ChainType, network: NetworkType): Promise<AgentKeyInfo>
      exportKeyFile(agentId: string, exportPassword: string): Promise<Buffer>
      importKeyFile(keyFilePath: string, importPassword: string, masterPassword: string): Promise<AgentKeyInfo>
      listAgents(): AgentKeyInfo[]
      isUnlocked(): boolean
    }
    ```
  - 각 메서드의 파라미터, 반환값, 에러 케이스, sodium 호출 순서 정의

  **섹션 6: 키스토어 백업/복원/내보내기**
  - 전체 백업: ~/.waiaas/keystore/ 디렉토리 전체를 tar.gz으로 아카이빙
    - `waiaas backup create` -> `~/.waiaas/backups/backup-<timestamp>.tar.gz`
    - 키파일은 이미 마스터 패스워드로 암호화되어 있으므로 추가 암호화 불필요
  - 복원: `waiaas backup restore <path>` -> keystore/ 디렉토리 복원 + agents 테이블 동기화
  - 개별 에이전트 내보내기 (06-CONTEXT.md 결정):
    - `exportKeyFile(agentId, exportPassword)`: 별도 패스워드로 재암호화한 키파일 생성
    - 내보내기 파일은 원본과 동일한 WAIaaS Keystore v1 포맷
    - 용도: 다른 WAIaaS 인스턴스로 에이전트 이전
  - 가져오기: `importKeyFile(path, importPassword, masterPassword)`: 내보내기 파일을 마스터 패스워드로 재암호화하여 keystore/에 저장
  - 요구사항 KEYS-04 커버

  **섹션 7: 보안 고려사항 종합**
  - 위협 모델: 키파일 탈취, 메모리 덤프, 패스워드 브루트포스
  - 각 위협에 대한 방어 메커니즘 매핑 (AES-256-GCM, Argon2id, sodium guarded memory)
  - 06-RESEARCH.md Pitfall 1(C-01), 2(C-02), 3(C-03) 대응 전략 요약
  - 키 손실 시 복구 불가 -- Owner가 온체인에서 자산 직접 회수 (06-CONTEXT.md)
  - 패스워드 변경 절차 (전체 키 재암호화)
  </action>
  <verify>
  문서에 다음이 모두 포함되어 있는지 확인:
  - sodium-native 키 수명주기 상태 다이어그램
  - ILocalKeyStore 인터페이스 전체 (9개 메서드)
  - 각 메서드의 파라미터/반환/에러/sodium 호출 순서
  - 백업/복원/내보내기/가져오기 4가지 절차
  - 보안 위협 모델 + 방어 매핑 테이블
  - Pitfall C-01, C-02, C-03 대응 전략
  </verify>
  <done>
  sodium-native guarded memory 프로토콜이 전체 수명주기로 정의됨. ILocalKeyStore 인터페이스가 9개 메서드의 시그니처/에러/호출순서까지 설계됨. 백업/복원/내보내기가 절차 수준으로 정의됨. 요구사항 KEYS-01, KEYS-02, KEYS-04 완전 커버.
  </done>
</task>

</tasks>

<verification>
- 26-keystore-spec.md가 7개 섹션을 모두 포함함
- 바이트 수준 포맷 정의: nonce 12B, tag 16B, salt 16B 명시
- Argon2id 파라미터가 CONTEXT.md 잠긴 결정(m=64MiB, t=3, p=4)과 일치
- sodium-native API 사용이 RESEARCH.md Pattern 5와 일치
- 요구사항 KEYS-01, KEYS-02, KEYS-04 모두 커버됨
</verification>

<success_criteria>
1. 키스토어 JSON 포맷이 모든 필드의 바이트 크기/인코딩까지 정의됨
2. AES-256-GCM 암호화/복호화가 step-by-step으로 문서화됨
3. sodium-native guarded memory 수명주기가 상태 다이어그램으로 정의됨
4. ILocalKeyStore 인터페이스가 메서드 시그니처 수준으로 설계됨
5. 백업/복원/내보내기 절차가 CLI 커맨드까지 연결되어 정의됨
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-architecture-design/06-02-SUMMARY.md`
</output>
