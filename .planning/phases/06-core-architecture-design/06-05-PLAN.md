---
phase: 06-core-architecture-design
plan: 05
type: execute
wave: 4
depends_on: ["06-01", "06-04"]
files_modified:
  - .planning/deliverables/29-api-framework-design.md
autonomous: true

must_haves:
  truths:
    - "Hono 서버 설정이 OpenAPIHono + @hono/node-server + 127.0.0.1 바인딩으로 정의됨"
    - "미들웨어 스택이 실행 순서와 함께 정의됨 (secureHeaders, CORS, Host 검증, 세션 인증, 요청 로깅)"
    - "Zod 스키마 -> OpenAPI 3.0 자동 생성 파이프라인이 설계됨 (createRoute 패턴)"
    - "localhost 보안 전략이 0.0.0.0 Day 방지까지 포함하여 정의됨"
    - "에러 응답 포맷이 코드/메시지/상세정보 구조로 통일됨"
    - "라우트 구조가 /v1/ 하위 그룹별로 정의됨 (엔드포인트 목록 + Zod 스키마 패턴)"
  artifacts:
    - path: ".planning/deliverables/29-api-framework-design.md"
      provides: "Hono API 프레임워크 + localhost 보안 + Zod/OpenAPI 통합 설계"
      contains: "OpenAPIHono"
  key_links:
    - from: "29-api-framework-design.md"
      to: "28-daemon-lifecycle-cli.md"
      via: "데몬 시작 시퀀스 5단계에서 HTTP 서버 초기화"
      pattern: "serve"
    - from: "29-api-framework-design.md"
      to: "25-sqlite-schema.md"
      via: "API 응답이 SQLite 테이블 데이터 모델 기반"
      pattern: "agents|sessions|transactions"
    - from: "29-api-framework-design.md"
      to: "27-chain-adapter-interface.md"
      via: "지갑 API가 ChainAdapter를 호출하여 잔액 조회/거래 수행"
      pattern: "getBalance|buildTransaction"
---

<objective>
Hono 기반 API 프레임워크의 전체 설계를 작성한다 -- OpenAPIHono 설정, 미들웨어 스택, localhost 보안 전략, Zod 스키마 -> OpenAPI 3.0 자동 생성 파이프라인, 라우트 구조, 에러 처리 체계.

Purpose: API 프레임워크는 에이전트/SDK/MCP가 데몬과 통신하는 유일한 인터페이스. 미들웨어 순서, 보안 설정, 스키마 패턴이 Phase 7-9의 모든 엔드포인트 설계의 기반이 된다.
Output: 설계 문서 1개 -- 29-api-framework-design.md
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-architecture-design/06-CONTEXT.md
@.planning/phases/06-core-architecture-design/06-RESEARCH.md

# 선행 플랜 SUMMARY
@.planning/phases/06-core-architecture-design/06-01-SUMMARY.md
@.planning/phases/06-core-architecture-design/06-04-SUMMARY.md

# v0.1 참조 문서
@.planning/deliverables/21-openapi-spec.md (v0.1 API 스펙 -- 라우트 구조 참조)
@.planning/deliverables/20-error-codes.md (v0.1 에러 코드 -- 재사용 + 확장)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hono 서버 설정 + 미들웨어 스택 + localhost 보안 설계</name>
  <files>.planning/deliverables/29-api-framework-design.md</files>
  <action>
  설계 문서 `29-api-framework-design.md`를 작성한다. 문서 ID는 `CORE-06`.

  **섹션 1: Hono 서버 아키텍처**
  - `OpenAPIHono` 인스턴스 기반 (06-RESEARCH.md Pattern 3)
  - `@hono/node-server`의 `serve()` API (06-RESEARCH.md Pattern 4)
  - 서버 설정 코드 패턴:
    ```typescript
    const app = new OpenAPIHono()
    // ... 미들웨어 + 라우트 등록 ...
    serve({ fetch: app.fetch, port: config.daemon.port, hostname: '127.0.0.1' })
    ```
  - config.toml [daemon] 섹션에서 port 로드

  **섹션 2: 미들웨어 스택 (실행 순서)**
  미들웨어 실행 순서가 보안에 직접 영향을 미치므로, 정확한 순서를 정의:

  | 순서 | 미들웨어 | 역할 | 적용 범위 |
  |------|----------|------|-----------|
  | 1 | `requestId` | 요청 ID 부여 (X-Request-ID) | 전체 |
  | 2 | `requestLogger` | 요청/응답 로깅 (method, path, status, duration) | 전체 |
  | 3 | `secureHeaders` | 보안 헤더 설정 (X-Content-Type-Options 등) | 전체 |
  | 4 | `hostValidation` | Host 헤더 검증 (localhost/127.0.0.1만 허용) | 전체 |
  | 5 | `cors` | CORS 설정 (origin: localhost만) | 전체 |
  | 6 | `rateLimiter` | 요청 속도 제한 (IP 기반, lru-cache) | 전체 |
  | 7 | `sessionAuth` | 세션 토큰 검증 (Bearer wai_sess_...) | /v1/* (인증 필요 엔드포인트) |
  | 8 | `ownerAuth` | Owner 서명 검증 (SIWS/SIWE) | /v1/owner/* |

  각 미들웨어의:
  - 입력/출력 (어떤 헤더를 읽고, 어떤 context를 설정하는지)
  - 에러 응답 (401, 403, 429 등)
  - 설정 파라미터
  - Hono 코드 패턴 (`app.use('*', middleware)`)

  **섹션 3: localhost 보안 전략 (0.0.0.0 Day 방지)**
  06-RESEARCH.md Pitfall 4 (C-04) 대응:

  1. 바인딩 강제: `hostname: '127.0.0.1'` (IPv4만, `::1` 제외 -- 단순화)
  2. Host 헤더 검증 미들웨어:
     ```typescript
     app.use('*', async (c, next) => {
       const host = c.req.header('host')
       const allowed = ['localhost', '127.0.0.1', `localhost:${port}`, `127.0.0.1:${port}`]
       if (host && !allowed.some(h => host === h)) {
         return c.json({ error: { code: 'INVALID_HOST', message: 'Forbidden' } }, 403)
       }
       await next()
     })
     ```
  3. CORS 엄격 설정:
     ```typescript
     cors({
       origin: [`http://localhost:${port}`, `http://127.0.0.1:${port}`],
       allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
       allowHeaders: ['Authorization', 'Content-Type'],
       maxAge: 600,
     })
     ```
  4. 모든 엔드포인트 세션 토큰 인증 (공개 엔드포인트 최소화)
  5. 추가 방어: Tauri WebView에서 접근 시 Origin 검증

  - 보안 수준 매트릭스:
    | 공격 벡터 | 방어 | 계층 |
    |-----------|------|------|
    | 외부 네트워크 접근 | 127.0.0.1 바인딩 | 네트워크 |
    | 브라우저 0.0.0.0 Day | Host 헤더 검증 | 미들웨어 |
    | CSRF/악성 페이지 | CORS + 세션 토큰 | 미들웨어 |
    | 무차별 대입 | Rate limiter | 미들웨어 |

  **섹션 4: 에러 처리 체계**
  - 통일된 에러 응답 포맷:
    ```json
    {
      "error": {
        "code": "INSUFFICIENT_BALANCE",
        "message": "잔액이 부족합니다",
        "details": { "required": "1000000000", "available": "500000000" },
        "requestId": "req_abc123"
      }
    }
    ```
  - HTTP 상태 코드 매핑:
    | 상태 | 용도 |
    |------|------|
    | 200 | 성공 |
    | 201 | 리소스 생성 |
    | 400 | 잘못된 요청 (Zod 검증 실패) |
    | 401 | 인증 필요/실패 |
    | 403 | 권한 없음 |
    | 404 | 리소스 미존재 |
    | 409 | 충돌 (중복 생성 등) |
    | 429 | 속도 제한 초과 |
    | 500 | 내부 서버 에러 |
  - v0.1 에러 코드(20-error-codes.md) 재사용 + 새 코드 추가
  - Hono의 `app.onError()` 글로벌 에러 핸들러 패턴
  - Zod 검증 실패 시 상세 에러 메시지 포맷
  </action>
  <verify>
  문서에 다음이 모두 포함되어 있는지 확인:
  - OpenAPIHono 서버 설정 코드 패턴
  - 미들웨어 스택 순서 테이블 (8개)
  - 각 미들웨어의 입력/출력/에러/설정
  - localhost 보안 전략 4가지 방어층
  - Host 헤더 검증 코드 패턴
  - CORS 설정 코드 패턴
  - 에러 응답 JSON 포맷
  - HTTP 상태 코드 매핑 테이블
  </verify>
  <done>
  Hono 서버 설정, 8개 미들웨어 스택, localhost 4중 보안, 에러 처리 체계가 설계됨. 요구사항 API-01 완전 커버.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zod/OpenAPI 통합 + 라우트 구조 설계</name>
  <files>.planning/deliverables/29-api-framework-design.md</files>
  <action>
  기존 `29-api-framework-design.md`에 섹션 5, 6, 7을 추가한다.

  **섹션 5: Zod 스키마 -> OpenAPI 3.0 파이프라인**
  - 06-RESEARCH.md Pattern 3 기반
  - SSoT (Single Source of Truth) 패턴:
    1. Zod 스키마 정의 (packages/core/src/schemas/)
    2. `z.infer<typeof schema>`로 TypeScript 타입 자동 추출
    3. `.openapi()` 메서드로 OpenAPI 메타데이터 첨부
    4. `createRoute()`로 라우트 정의 (요청/응답 스키마 포함)
    5. `app.openapi(route, handler)`로 라우트 등록
    6. `app.doc('/doc', {...})`로 OpenAPI JSON 엔드포인트 자동 생성

  - 구체적 코드 패턴 (balance 엔드포인트 예시):
    ```typescript
    // 1. Zod 스키마 (packages/core/src/schemas/wallet.ts)
    const BalanceResponseSchema = z.object({
      address: z.string().openapi({ example: 'So11...' }),
      balance: z.string().openapi({ description: '최소 단위 (lamports/wei)', example: '1000000000' }),
      chain: z.string().openapi({ example: 'solana' }),
      decimals: z.number().openapi({ example: 9 }),
      symbol: z.string().openapi({ example: 'SOL' }),
    }).openapi('BalanceResponse')

    // 2. 타입 추출
    type BalanceResponse = z.infer<typeof BalanceResponseSchema>

    // 3. 라우트 정의 (packages/daemon/src/server/routes/wallet.ts)
    const getBalanceRoute = createRoute({
      method: 'get',
      path: '/v1/wallet/balance',
      tags: ['Wallet'],
      summary: '지갑 잔액 조회',
      security: [{ bearerAuth: [] }],
      responses: {
        200: {
          content: { 'application/json': { schema: BalanceResponseSchema } },
          description: 'Wallet balance',
        },
        401: { content: { 'application/json': { schema: ErrorSchema } }, description: 'Unauthorized' },
      },
    })

    // 4. 핸들러 등록
    app.openapi(getBalanceRoute, async (c) => {
      // 타입 안전한 응답
      return c.json({ ... }, 200)
    })
    ```

  - OpenAPI 3.0 스펙 자동 생성:
    - 엔드포인트: `GET /doc` -> OpenAPI JSON
    - Swagger UI: `GET /swagger` (선택적, 개발 모드만)
    - 인증 스키마: Bearer token (securitySchemes 정의)

  - Zod 스키마 관리 규칙:
    - 모든 Zod 스키마는 `packages/core/src/schemas/`에 위치 (SSoT)
    - daemon/adapters는 core의 스키마를 import
    - 스키마 파일 구조: wallet.ts, session.ts, transaction.ts, agent.ts, error.ts

  **섹션 6: 라우트 구조**
  Phase 6에서 정의하는 라우트 (프레임워크 수준):

  | Method | Path | 역할 | Auth | Phase |
  |--------|------|------|------|-------|
  | GET | /health | 헬스 체크 | None | 6 |
  | GET | /doc | OpenAPI JSON 스펙 | None | 6 |
  | GET | /v1/wallet/balance | 잔액 조회 | Session | 7 |
  | GET | /v1/wallet/address | 주소 조회 | Session | 7 |
  | POST | /v1/sessions | 세션 생성 | Owner | 7 |
  | GET | /v1/sessions | 세션 목록 | Owner | 7 |
  | DELETE | /v1/sessions/:id | 세션 폐기 | Owner | 7 |
  | POST | /v1/transactions/send | 거래 전송 | Session | 7 |
  | GET | /v1/transactions | 거래 목록 | Session | 7 |
  | GET | /v1/transactions/pending | 대기 중 거래 | Session | 7 |
  | POST | /v1/owner/approve/:txId | 거래 승인 | Owner | 8 |
  | POST | /v1/owner/reject/:txId | 거래 거부 | Owner | 8 |
  | POST | /v1/owner/kill-switch | 비상 정지 | Owner | 8 |

  - Phase 6에서는 /health, /doc 엔드포인트만 상세 설계
  - 나머지는 라우트 목록 + 인증 레벨 + 담당 Phase만 정리
  - 라우트 그룹화 패턴 (Hono `app.route('/v1/wallet', walletRoutes)`)

  **`GET /health` 엔드포인트 상세 설계:**
  ```json
  {
    "status": "healthy",
    "version": "0.2.0",
    "uptime": 9234,
    "services": {
      "database": { "status": "healthy", "size": "4.2MB" },
      "keystore": { "status": "unlocked", "agents": 3 },
      "adapters": {
        "solana": { "status": "connected", "latency": 45 },
        "ethereum": { "status": "disconnected" }
      }
    }
  }
  ```
  - waiaas status CLI 커맨드가 이 엔드포인트를 호출 (28-daemon-lifecycle-cli.md 연결)

  **섹션 7: Rate Limiter 설계**
  - lru-cache 기반 토큰 버킷/슬라이딩 윈도우
  - 설정 (config.toml [security]):
    - 전역: 100 req/min per IP
    - 인증된 세션: 300 req/min per session
    - 엔드포인트별 오버라이드 (거래 전송은 10 req/min)
  - 429 응답에 Retry-After 헤더 포함
  - 코드 패턴:
    ```typescript
    const rateLimitCache = new LRUCache<string, number[]>({
      max: 10000,
      ttl: 60_000,
    })
    ```

  **섹션 8: API 버전 관리 전략**
  - URL 기반 버전: `/v1/...`
  - v2 도입 시: `/v2/...` 추가, v1 deprecated 헤더
  - Breaking change 정의 기준
  - Content negotiation은 사용하지 않음 (단순화)
  </action>
  <verify>
  문서에 다음이 모두 포함되어 있는지 확인:
  - Zod -> TypeScript -> OpenAPI SSoT 파이프라인 코드 패턴
  - createRoute + app.openapi 전체 예시 (balance 엔드포인트)
  - Zod 스키마 파일 구조 (5개 파일)
  - 라우트 구조 테이블 (13개 엔드포인트, Phase 매핑)
  - /health 엔드포인트 응답 스키마
  - Rate limiter 설계 (전역/세션/엔드포인트별)
  - API 버전 관리 전략
  - OpenAPI JSON 엔드포인트 (/doc)
  </verify>
  <done>
  Zod/OpenAPI SSoT 파이프라인이 코드 패턴 수준으로 설계됨. 라우트 구조가 13개 엔드포인트 + Phase 매핑으로 정리됨. Rate limiter + API 버전 관리가 정의됨. 요구사항 API-01, API-06 완전 커버.
  </done>
</task>

</tasks>

<verification>
- 29-api-framework-design.md가 8개 섹션을 모두 포함함
- OpenAPIHono 사용이 06-RESEARCH.md Pattern 3과 일치
- localhost 보안이 06-RESEARCH.md Pitfall 4 (C-04) 대응 포함
- Zod 스키마가 packages/core/src/schemas/에 SSoT로 배치됨
- 라우트 구조가 v0.1 API 스펙(21-openapi-spec.md)과 호환됨
- 요구사항 API-01, API-06 커버 확인
</verification>

<success_criteria>
1. OpenAPIHono 서버 설정이 코드 패턴 수준으로 정의됨
2. 8개 미들웨어가 정확한 실행 순서로 정의됨
3. localhost 4중 보안이 공격 벡터별로 매핑됨
4. Zod -> OpenAPI SSoT 파이프라인이 완전한 예시와 함께 설계됨
5. 13개 라우트가 인증 레벨 + Phase 매핑으로 정리됨
6. /health 엔드포인트가 상세 응답 스키마까지 설계됨
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-architecture-design/06-05-SUMMARY.md`
</output>
