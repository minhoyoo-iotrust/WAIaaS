---
phase: 127-usd-policy-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/pipeline/resolve-effective-amount-usd.ts
  - packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts
  - packages/daemon/src/pipeline/index.ts
autonomous: true

must_haves:
  truths:
    - "PriceResult가 success/oracleDown/notListed 3-state discriminated union으로 구분된다"
    - "resolveEffectiveAmountUsd가 TRANSFER 요청의 네이티브 금액을 USD로 환산한다"
    - "resolveEffectiveAmountUsd가 TOKEN_TRANSFER 요청의 토큰 금액을 USD로 환산한다"
    - "resolveEffectiveAmountUsd가 CONTRACT_CALL 요청의 value를 USD로 환산한다"
    - "resolveEffectiveAmountUsd가 APPROVE 요청에서 usdAmount=0을 반환한다"
    - "resolveEffectiveAmountUsd가 BATCH 요청에서 개별 instruction USD를 합산한다"
    - "토큰 가격 조회 실패 시 notListed를 반환한다 (oracleDown이 아님)"
    - "네이티브 가격 조회 실패 시 oracleDown을 반환한다"
    - "BATCH 내 일부 instruction notListed 시 failedCount를 포함하는 notListed를 반환한다"
  artifacts:
    - path: "packages/daemon/src/pipeline/resolve-effective-amount-usd.ts"
      provides: "PriceResult type + resolveEffectiveAmountUsd function"
      exports: ["PriceResult", "PriceResultSuccess", "PriceResultOracleDown", "PriceResultNotListed", "resolveEffectiveAmountUsd"]
    - path: "packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts"
      provides: "resolveEffectiveAmountUsd 단위 테스트"
      min_lines: 100
    - path: "packages/daemon/src/pipeline/index.ts"
      provides: "resolve-effective-amount-usd barrel re-export"
  key_links:
    - from: "packages/daemon/src/pipeline/resolve-effective-amount-usd.ts"
      to: "@waiaas/core IPriceOracle"
      via: "getPrice/getNativePrice 호출"
      pattern: "priceOracle\\.get(Native)?Price"
    - from: "packages/daemon/src/pipeline/resolve-effective-amount-usd.ts"
      to: "packages/daemon/src/infrastructure/oracle/oracle-errors.ts"
      via: "PriceNotAvailableError catch"
      pattern: "PriceNotAvailableError"
---

<objective>
PriceResult 3-state discriminated union 타입과 resolveEffectiveAmountUsd() 함수를 TDD로 구현한다.

Purpose: 5-type 트랜잭션(TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE/BATCH)의 금액을 IPriceOracle을 통해 USD로 환산하는 핵심 로직을 제공한다. "가격 불명 != 가격 0" 보안 원칙을 PriceResult 3-state로 구현한다.
Output: resolve-effective-amount-usd.ts (PriceResult + resolveEffectiveAmountUsd), 단위 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/127-usd-policy-integration/127-RESEARCH.md
@packages/core/src/interfaces/price-oracle.types.ts
@packages/daemon/src/infrastructure/oracle/oracle-errors.ts
@packages/daemon/src/infrastructure/oracle/oracle-chain.ts
@packages/daemon/src/pipeline/stages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED -- resolveEffectiveAmountUsd 테스트 작성</name>
  <files>packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts</files>
  <action>
resolveEffectiveAmountUsd()의 5-type 분기 + 에러 핸들링 테스트를 작성한다.

mock IPriceOracle을 vi.fn()으로 생성하여 getPrice/getNativePrice/getCacheStats를 모킹한다.

테스트 케이스 (최소 15개):
1. TRANSFER: amount '1000000000' (1 SOL, 9 decimals), nativePrice $100 -> success, usdAmount=100
2. TRANSFER: amount '1000000000000000000' (1 ETH, 18 decimals), nativePrice $3000 -> success, usdAmount=3000
3. TOKEN_TRANSFER: amount '1000000' (1 USDC, 6 decimals), tokenPrice $1 -> success, usdAmount=1
4. TOKEN_TRANSFER: getPrice throws PriceNotAvailableError -> notListed (tokenAddress, chain 포함)
5. CONTRACT_CALL: value '500000000' (0.5 SOL), nativePrice $100 -> success, usdAmount=50
6. CONTRACT_CALL: value undefined or '0' -> success, usdAmount=0, isStale=false
7. APPROVE: -> success, usdAmount=0, isStale=false (항상)
8. BATCH: 2x TRANSFER (각 1 SOL $100) -> success, usdAmount=200
9. BATCH: TRANSFER + TOKEN_TRANSFER(notListed) -> notListed (failedCount=1)
10. BATCH: 전체 oracleDown -> oracleDown
11. TRANSFER: getNativePrice throws -> oracleDown
12. 알 수 없는 type -> oracleDown
13. TRANSFER: isStale=true인 가격 -> success, isStale=true
14. TOKEN_TRANSFER: getPrice가 비-PriceNotAvailableError throw -> oracleDown (외부 catch)
15. BATCH: 모든 instruction이 성공 + APPROVE 포함 -> success (APPROVE는 $0)

모든 테스트가 RED (구현 파일 미존재)이어야 한다.
커밋: `test(127-01): resolveEffectiveAmountUsd 단위 테스트 15개 작성 (RED)`
  </action>
  <verify>npx vitest run packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts -- 모든 테스트 FAIL (RED)</verify>
  <done>15개 이상의 테스트가 존재하고 모두 RED 상태</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN -- PriceResult 3-state + resolveEffectiveAmountUsd 구현</name>
  <files>
    packages/daemon/src/pipeline/resolve-effective-amount-usd.ts
    packages/daemon/src/pipeline/index.ts
  </files>
  <action>
resolve-effective-amount-usd.ts를 생성하여 PriceResult 타입과 resolveEffectiveAmountUsd()를 구현한다.

**PriceResult 3-state discriminated union:**
```typescript
export interface PriceResultSuccess {
  type: 'success';
  usdAmount: number;
  isStale: boolean;
}
export interface PriceResultOracleDown {
  type: 'oracleDown';
}
export interface PriceResultNotListed {
  type: 'notListed';
  tokenAddress: string;
  chain: string;
  failedCount?: number; // BATCH 전용: notListed instruction 수
}
export type PriceResult = PriceResultSuccess | PriceResultOracleDown | PriceResultNotListed;
```

**resolveEffectiveAmountUsd() 구현 (연구 127-RESEARCH.md Pattern 1 참조):**
- import IPriceOracle from '@waiaas/core'
- import PriceNotAvailableError from '../infrastructure/oracle/oracle-errors.js'
- NATIVE_DECIMALS: Record<string, number> = { solana: 9, ethereum: 18 }
- 5-type switch:
  - TRANSFER: getNativePrice -> humanAmount * usdPrice
  - TOKEN_TRANSFER: getPrice -> humanAmount * usdPrice. PriceNotAvailableError catch -> notListed
  - CONTRACT_CALL: value가 없거나 '0'이면 success(0), 아니면 getNativePrice로 환산
  - APPROVE: 항상 success(usdAmount=0, isStale=false)
  - BATCH: 개별 instruction을 순회. TRANSFER/CONTRACT_CALL -> getNativePrice, TOKEN_TRANSFER -> getPrice. 각 결과 합산. notListed 발생 시 failedCount 기록하고 notListed 반환. 전체 getNativePrice 실패 시 oracleDown
  - default: oracleDown
- 외부 try-catch: 예상 외 에러 -> oracleDown

**request 타입 접근:** 설계 결정에 따라 as 캐스팅으로 필드 접근 (stages.ts의 buildTransactionParam과 동일 패턴).

**BATCH 상세 로직:**
1. 먼저 getNativePrice로 네이티브 가격 확보 (실패 시 oracleDown 반환)
2. 각 instruction 순회:
   - TRANSFER: nativeDecimals로 환산 후 합산
   - TOKEN_TRANSFER: getPrice 시도. PriceNotAvailableError -> failedCount++, 나머지 합산
   - CONTRACT_CALL: value 있으면 nativeDecimals로 환산 후 합산
   - APPROVE: $0 (합산에 영향 없음)
3. failedCount > 0 -> notListed 반환 (첫 notListed 토큰 정보 포함)
4. 전체 성공 -> success 반환

**pipeline/index.ts에 re-export 추가:**
```typescript
export { resolveEffectiveAmountUsd, type PriceResult } from './resolve-effective-amount-usd.js';
```

커밋: `feat(127-01): PriceResult 3-state + resolveEffectiveAmountUsd 5-type 구현 (GREEN)`
  </action>
  <verify>npx vitest run packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts -- 모든 테스트 PASS (GREEN). npx tsc --noEmit -p packages/daemon -- 타입 체크 통과</verify>
  <done>15개 이상의 테스트가 모두 GREEN이고 기존 daemon 테스트 회귀 없음</done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/daemon/src/__tests__/resolve-effective-amount-usd.test.ts` -- 모든 테스트 PASS
2. `npx tsc --noEmit -p packages/daemon` -- 타입 체크 통과
3. `npx vitest run packages/daemon` -- 기존 daemon 테스트 회귀 없음
</verification>

<success_criteria>
- PriceResult 3-state discriminated union이 success/oracleDown/notListed를 구분한다
- resolveEffectiveAmountUsd가 TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE/BATCH 5-type을 처리한다
- 토큰 가격 미등록은 notListed, 오라클 전체 장애는 oracleDown으로 올바르게 분류된다
- BATCH 내 일부 notListed 시 failedCount와 함께 notListed를 반환한다
- 15개 이상의 단위 테스트가 모두 PASS
</success_criteria>

<output>
After completion, create `.planning/phases/127-usd-policy-integration/127-01-SUMMARY.md`
</output>
