---
phase: 127-usd-policy-integration
plan: 02
type: execute
wave: 2
depends_on: ["127-01"]
files_modified:
  - packages/core/src/schemas/policy.schema.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
autonomous: true

must_haves:
  truths:
    - "SpendingLimitRulesSchema가 instant_max_usd/notify_max_usd/delay_max_usd optional 필드를 Zod로 검증한다"
    - "SPENDING_LIMIT 정책 생성 시 rules가 SpendingLimitRulesSchema로 검증된다"
    - "evaluateSpendingLimit이 usdAmount 파라미터를 받아 USD 기준 티어를 산출한다"
    - "네이티브 티어와 USD 티어 중 더 보수적인(높은) 티어를 채택한다"
    - "USD 필드 미설정 시 기존 네이티브 전용 평가가 그대로 동작한다 (하위 호환)"
    - "evaluateAndReserve 내부의 인라인 SPENDING_LIMIT 코드가 evaluateSpendingLimit()을 호출하도록 통일된다"
  artifacts:
    - path: "packages/core/src/schemas/policy.schema.ts"
      provides: "SpendingLimitRulesSchema Zod SSoT + POLICY_RULES_SCHEMAS 등록"
      contains: "SpendingLimitRulesSchema"
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateSpendingLimit USD 분기 + maxTier 헬퍼 + evaluateAndReserve 통일"
      contains: "usdAmount"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "USD SPENDING_LIMIT 평가 테스트"
  key_links:
    - from: "packages/core/src/schemas/policy.schema.ts"
      to: "POLICY_RULES_SCHEMAS"
      via: "SPENDING_LIMIT 키로 등록"
      pattern: "SPENDING_LIMIT.*SpendingLimitRulesSchema"
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "evaluateSpendingLimit"
      via: "evaluateAndReserve에서 호출"
      pattern: "this\\.evaluateSpendingLimit"
---

<objective>
SpendingLimitRulesSchema를 Zod SSoT로 정의하고, evaluateSpendingLimit에 USD 분기를 추가하며, evaluateAndReserve 내부의 인라인 SPENDING_LIMIT 코드를 evaluateSpendingLimit() 호출로 통일한다.

Purpose: 네이티브 금액 전용이던 SPENDING_LIMIT 정책에 USD 기준 평가를 추가하여, 토큰 전송의 실제 달러 가치 기반 보안 분류를 가능하게 한다. Zod SSoT 원칙에 따라 rules 검증을 추가한다.
Output: policy.schema.ts (SpendingLimitRulesSchema), database-policy-engine.ts (USD 분기 + evaluateAndReserve 통일), 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/127-usd-policy-integration/127-RESEARCH.md
@.planning/phases/127-usd-policy-integration/127-01-SUMMARY.md
@packages/core/src/schemas/policy.schema.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SpendingLimitRulesSchema Zod SSoT + evaluateSpendingLimit USD 분기</name>
  <files>
    packages/core/src/schemas/policy.schema.ts
    packages/daemon/src/pipeline/database-policy-engine.ts
  </files>
  <action>
**1. packages/core/src/schemas/policy.schema.ts 확장:**

SpendingLimitRulesSchema를 기존 POLICY_RULES_SCHEMAS 근처에 추가한다:
```typescript
/** SPENDING_LIMIT: 금액 기반 4-티어 보안 분류. */
const SpendingLimitRulesSchema = z.object({
  /** INSTANT 티어 최대 금액 (lamports/wei 문자열) */
  instant_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다'),
  /** NOTIFY 티어 최대 금액 */
  notify_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다'),
  /** DELAY 티어 최대 금액 */
  delay_max: z.string().regex(/^\d+$/, '양의 정수 문자열이어야 합니다'),
  /** INSTANT 티어 최대 USD 금액 (optional, 미설정 시 네이티브만 사용) */
  instant_max_usd: z.number().nonnegative().optional(),
  /** NOTIFY 티어 최대 USD 금액 */
  notify_max_usd: z.number().nonnegative().optional(),
  /** DELAY 티어 최대 USD 금액 */
  delay_max_usd: z.number().nonnegative().optional(),
  /** DELAY 티어 쿨다운 시간 (초) */
  delay_seconds: z.number().int().min(60).default(900),
});
```

POLICY_RULES_SCHEMAS에 SPENDING_LIMIT 키로 등록:
```typescript
SPENDING_LIMIT: SpendingLimitRulesSchema,
```

이로써 POST /v1/policies에서 type=SPENDING_LIMIT인 정책 생성 시 superRefine이 SpendingLimitRulesSchema로 rules를 검증한다.

SpendingLimitRulesSchema를 named export하여 daemon 패키지에서 타입 추론에 사용할 수 있도록 한다. core/src/index.ts에도 re-export 추가.

**2. packages/daemon/src/pipeline/database-policy-engine.ts 확장:**

a) SpendingLimitRules 인터페이스에 USD 필드 추가:
```typescript
interface SpendingLimitRules {
  instant_max: string;
  notify_max: string;
  delay_max: string;
  delay_seconds: number;
  // Phase 127: USD 기준 (optional)
  instant_max_usd?: number;
  notify_max_usd?: number;
  delay_max_usd?: number;
}
```

b) TIER_ORDER 상수와 maxTier 헬퍼 추가 (클래스 외부 또는 private static):
```typescript
const TIER_ORDER: PolicyTier[] = ['INSTANT', 'NOTIFY', 'DELAY', 'APPROVAL'];

function maxTier(a: PolicyTier, b: PolicyTier): PolicyTier {
  const aIdx = TIER_ORDER.indexOf(a);
  const bIdx = TIER_ORDER.indexOf(b);
  return TIER_ORDER[Math.max(aIdx, bIdx)]!;
}
```

c) hasUsdThresholds 헬퍼 추가:
```typescript
private hasUsdThresholds(rules: SpendingLimitRules): boolean {
  return rules.instant_max_usd !== undefined
    || rules.notify_max_usd !== undefined
    || rules.delay_max_usd !== undefined;
}
```

d) evaluateUsdTier private 메서드 추가:
```typescript
private evaluateUsdTier(usdAmount: number, rules: SpendingLimitRules): PolicyTier {
  if (rules.instant_max_usd !== undefined && usdAmount <= rules.instant_max_usd) {
    return 'INSTANT';
  }
  if (rules.notify_max_usd !== undefined && usdAmount <= rules.notify_max_usd) {
    return 'NOTIFY';
  }
  if (rules.delay_max_usd !== undefined && usdAmount <= rules.delay_max_usd) {
    return 'DELAY';
  }
  return 'APPROVAL';
}
```

e) evaluateSpendingLimit 시그니처에 usdAmount 추가:
```typescript
private evaluateSpendingLimit(
  resolved: PolicyRow[],
  amount: string,
  usdAmount?: number,  // Phase 127 추가
): PolicyEvaluation | null {
```
기존 네이티브 티어 로직 유지. usdAmount가 존재하고 hasUsdThresholds(rules)이면 evaluateUsdTier 호출. maxTier(nativeTier, usdTier)로 보수적 선택.

f) evaluateAndReserve 내부 인라인 SPENDING_LIMIT 코드(라인 ~525-576)를 evaluateSpendingLimit 호출로 교체:
- effectiveAmount(reserved + current)를 계산한 후 `this.evaluateSpendingLimit(resolved, effectiveAmount.toString(), usdAmount)` 호출
- evaluateAndReserve 시그니처에 usdAmount?: number 추가
- reserved_amount UPDATE는 evaluateSpendingLimit 호출 후 별도 유지

주의: evaluateAndReserve 내부의 resolveOverrides, whitelist 등 Step 3-4g는 그대로 유지. Step 5(SPENDING_LIMIT)만 evaluateSpendingLimit 호출로 교체. evaluateSpendingLimit은 resolved PolicyRow[]를 받으므로 evaluateAndReserve 내부에서 이미 로드한 resolved를 전달하면 된다.

g) evaluateBatch의 Phase B에서도 evaluateSpendingLimit에 usdAmount를 전달할 수 있도록 시그니처 확장. 현재는 네이티브만 합산하므로 usdAmount 파라미터를 추가하되, 실제 값 전달은 127-03에서 stage3Policy 통합 시 처리. evaluateBatch 시그니처에 batchUsdAmount?: number를 추가한다.
  </action>
  <verify>
npx tsc --noEmit -p packages/core -- core 타입 체크 통과
npx tsc --noEmit -p packages/daemon -- daemon 타입 체크 통과
npx vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts -- 기존 테스트 회귀 없음
  </verify>
  <done>SpendingLimitRulesSchema가 POLICY_RULES_SCHEMAS에 등록되고, evaluateSpendingLimit이 usdAmount를 받아 maxTier를 반환하며, evaluateAndReserve 인라인 코드가 evaluateSpendingLimit 호출로 통일됨</done>
</task>

<task type="auto">
  <name>Task 2: USD SPENDING_LIMIT 단위 테스트 추가</name>
  <files>packages/daemon/src/__tests__/database-policy-engine.test.ts</files>
  <action>
기존 database-policy-engine.test.ts에 "USD SPENDING_LIMIT" describe 블록을 추가한다.

테스트 케이스 (최소 8개):
1. **USD만 설정, 네이티브 INSTANT 이내**: instant_max='10000000000', instant_max_usd=10 + amount '1000000000' (1 SOL) + usdAmount=150 -> usdTier APPROVAL > nativeTier INSTANT -> APPROVAL
2. **네이티브 DELAY, USD INSTANT**: 네이티브 금액이 delay 범위이지만 USD는 instant 범위 -> 네이티브 tier(DELAY)가 보수적이므로 DELAY 유지
3. **USD 필드 미설정 (하위 호환)**: instant_max_usd 등 없음 + amount 기존 테스트와 동일 -> 기존 결과와 동일
4. **USD NOTIFY**: usdAmount가 instant_max_usd 초과, notify_max_usd 이내 -> maxTier 반영
5. **USD DELAY + delay_seconds**: usdAmount가 notify_max_usd 초과, delay_max_usd 이내 -> DELAY + delaySeconds
6. **evaluateAndReserve에서 USD 티어 적용**: sqlite transaction 내 evaluateAndReserve + usdAmount -> 올바른 tier + reserved_amount
7. **evaluateBatch Phase B에서 USD 합산**: BATCH + batchUsdAmount -> maxTier 반영
8. **SpendingLimitRulesSchema 검증**: POST /v1/policies body에 instant_max_usd: -1 -> Zod validation error

테스트는 기존 database-policy-engine.test.ts의 패턴을 따른다:
- 인메모리 SQLite DB 생성, pushSchema, 정책 삽입
- DatabasePolicyEngine 생성, evaluate/evaluateAndReserve 호출, tier 검증

커밋: `test(127-02): SpendingLimitRulesSchema Zod SSoT + evaluateSpendingLimit USD 분기 테스트 8개`
  </action>
  <verify>
npx vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts -- 모든 테스트 PASS (기존 + 신규)
npx vitest run packages/daemon -- 전체 daemon 테스트 회귀 없음
  </verify>
  <done>8개 이상의 USD SPENDING_LIMIT 테스트가 추가되어 모두 PASS이고, 기존 테스트에 회귀 없음</done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts` -- 기존 + 신규 모든 테스트 PASS
2. `npx tsc --noEmit -p packages/core` -- SpendingLimitRulesSchema 타입 체크
3. `npx tsc --noEmit -p packages/daemon` -- evaluateSpendingLimit usdAmount 타입 체크
4. `npx vitest run packages/daemon` -- 전체 daemon 회귀 없음
</verification>

<success_criteria>
- SpendingLimitRulesSchema가 instant_max_usd/notify_max_usd/delay_max_usd optional 필드를 Zod로 검증한다
- POLICY_RULES_SCHEMAS에 SPENDING_LIMIT이 등록되어 정책 생성 시 rules 검증이 동작한다
- evaluateSpendingLimit이 네이티브 + USD 병행 평가 후 보수적 티어를 반환한다
- evaluateAndReserve 내부 인라인 SPENDING_LIMIT 코드가 evaluateSpendingLimit() 호출로 통일되었다
- USD 필드 미설정 시 기존 동작과 100% 하위 호환된다
- 8개 이상의 신규 테스트가 PASS
</success_criteria>

<output>
After completion, create `.planning/phases/127-usd-policy-integration/127-02-SUMMARY.md`
</output>
