---
phase: 55-workflow-owner-state
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/workflow/delay-queue.ts
  - packages/daemon/src/__tests__/delay-queue.test.ts
  - packages/daemon/src/workflow/index.ts
autonomous: true

must_haves:
  truths:
    - "DELAY tier transaction is queued with cooldown seconds and queuedAt timestamp"
    - "DELAY transaction can be cancelled during cooldown, setting status to CANCELLED"
    - "DELAY transaction auto-executes after cooldown elapses (status QUEUED -> EXECUTING)"
    - "Cancel on non-QUEUED transaction returns appropriate error"
    - "Already expired DELAY transaction is not re-executed"
  artifacts:
    - path: "packages/daemon/src/workflow/delay-queue.ts"
      provides: "DelayQueue class with queueDelay(), cancelDelay(), processExpired()"
      exports: ["DelayQueue"]
    - path: "packages/daemon/src/__tests__/delay-queue.test.ts"
      provides: "TDD tests for delay queue behavior"
      min_lines: 80
    - path: "packages/daemon/src/workflow/index.ts"
      provides: "Barrel export for workflow module"
      exports: ["DelayQueue"]
  key_links:
    - from: "packages/daemon/src/workflow/delay-queue.ts"
      to: "transactions table"
      via: "Drizzle ORM queries"
      pattern: "transactions.*status.*QUEUED"
---

<objective>
Implement the DelayQueue service that manages DELAY tier transactions: queue with cooldown, cancel during wait, auto-execute after expiry.

Purpose: DELAY tier is the second layer of the 3-tier security model -- transactions above a threshold must wait before execution, giving the owner time to cancel suspicious activity.

Output: DelayQueue class with queueDelay(), cancelDelay(), processExpired() + TDD tests
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/daemon/src/pipeline/stages.ts -- stage4Wait (currently passthrough, will be wired in Phase 56)
@packages/daemon/src/pipeline/database-policy-engine.ts -- evaluateAndReserve returns delaySeconds for DELAY tier
@packages/daemon/src/infrastructure/database/schema.ts -- transactions table with queuedAt, status fields
@packages/daemon/src/infrastructure/database/migrate.ts -- transactions DDL with queued_at, status CHECK
@packages/core/src/enums/transaction.ts -- TRANSACTION_STATUSES includes QUEUED, CANCELLED, EXPIRED
@packages/core/src/errors/error-codes.ts -- TX_NOT_FOUND, TX_ALREADY_PROCESSED, TX_EXPIRED
@packages/daemon/src/infrastructure/config/loader.ts -- security.policy_defaults_delay_seconds (default 300)
</context>

<feature>
  <name>DelayQueue: DELAY tier cooldown queue management</name>
  <files>
    packages/daemon/src/workflow/delay-queue.ts
    packages/daemon/src/__tests__/delay-queue.test.ts
    packages/daemon/src/workflow/index.ts
  </files>
  <behavior>
    DelayQueue manages DELAY tier transactions through their cooldown lifecycle.

    **queueDelay(txId, delaySeconds):**
    - Sets transaction status to 'QUEUED'
    - Sets queuedAt to current timestamp (Unix seconds)
    - Stores delaySeconds in metadata JSON ({"delaySeconds": N})
    - Returns { queuedAt, expiresAt } (expiresAt = queuedAt + delaySeconds)

    **cancelDelay(txId):**
    - Reads transaction, checks status === 'QUEUED'
    - If QUEUED: sets status to 'CANCELLED', clears reserved_amount (calls releaseReservation pattern)
    - If not QUEUED: throws TX_ALREADY_PROCESSED
    - If not found: throws TX_NOT_FOUND

    **processExpired(now):**
    - Queries transactions WHERE status = 'QUEUED' AND queuedAt + delaySeconds <= now
    - For each expired: sets status to 'EXECUTING'
    - Returns array of { txId, agentId } for the pipeline to pick up and execute stages 5-6
    - Uses BEGIN IMMEDIATE to prevent concurrent processing of same transaction
    - The delaySeconds is read from metadata JSON

    **isExpired(txId):**
    - Returns true if QUEUED transaction's cooldown has elapsed

    Test cases (TDD RED first):
    - queueDelay sets QUEUED status + queuedAt + metadata
    - cancelDelay on QUEUED tx sets CANCELLED
    - cancelDelay on non-QUEUED tx throws TX_ALREADY_PROCESSED
    - cancelDelay on non-existent tx throws TX_NOT_FOUND
    - processExpired returns expired QUEUED txs and sets them to EXECUTING
    - processExpired ignores QUEUED txs whose cooldown hasn't elapsed
    - processExpired is idempotent (already EXECUTING txs not returned)
    - cancelDelay clears reserved_amount (calls releaseReservation or sets NULL)
  </behavior>
  <implementation>
    1. Create packages/daemon/src/workflow/ directory
    2. Write delay-queue.test.ts with RED tests using in-memory SQLite + Drizzle (same pattern as database-policy-engine.test.ts)
    3. Implement DelayQueue class in delay-queue.ts:
       - Constructor takes { db: BetterSQLite3Database, sqlite: Database } (same dual-DB pattern as DatabasePolicyEngine)
       - queueDelay: Drizzle update to set status/queuedAt/metadata
       - cancelDelay: read + validate status + update to CANCELLED + clear reserved_amount
       - processExpired: raw SQL in BEGIN IMMEDIATE -- SELECT queued txs WHERE expired, UPDATE status to EXECUTING, return list
       - Timestamp math uses Unix seconds (Math.floor(Date.now() / 1000))
    4. Create workflow/index.ts barrel export
    5. Run tests GREEN
    6. Refactor if needed
  </implementation>
</feature>

<verification>
1. `pnpm --filter @waiaas/daemon test -- --run packages/daemon/src/__tests__/delay-queue.test.ts` -- all tests pass
2. `pnpm typecheck` -- no TS errors
3. At least 8 test cases covering queue, cancel, processExpired, edge cases
</verification>

<success_criteria>
- DelayQueue class exists with queueDelay(), cancelDelay(), processExpired() methods
- All TDD tests pass (8+ test cases)
- QUEUED transactions correctly track queuedAt and delaySeconds in metadata
- Cancel during cooldown works, cancel after expiry or on wrong status throws correct error
- processExpired atomically transitions QUEUED -> EXECUTING for expired transactions
- reserved_amount is cleared on cancellation
</success_criteria>

<output>
After completion, create `.planning/phases/55-workflow-owner-state/55-01-SUMMARY.md`
</output>
