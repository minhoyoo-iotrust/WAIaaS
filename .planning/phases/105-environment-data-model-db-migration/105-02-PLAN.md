---
phase: 105-environment-data-model-db-migration
plan: 02
type: execute
wave: 2
depends_on: ["105-01"]
files_modified:
  - docs/69-db-migration-v6-design.md
autonomous: true

must_haves:
  truths:
    - "v6a(version 6) 마이그레이션의 transactions.network ADD COLUMN + UPDATE 역참조 SQL이 완전하게 작성되어 있다"
    - "v6b(version 7) 마이그레이션의 wallets 12-step 재생성 SQL이 전체 단계(CREATE NEW -> INSERT CASE -> DROP -> RENAME -> FK tables -> indexes -> verify)로 작성되어 있다"
    - "13개 NETWORK_TYPES -> environment CASE 분기가 전수 매핑되어 누락 없다"
    - "v6a -> v6b 순서 의존성이 다이어그램과 근거로 명시되어 있다"
    - "pushSchema DDL 동기화 계획이 LATEST_SCHEMA_VERSION=7 포함하여 명시되어 있다"
    - "PRAGMA foreign_key_check 검증 쿼리가 v6b에 포함되어 있다"
  artifacts:
    - path: "docs/69-db-migration-v6-design.md"
      provides: "DB 마이그레이션 v6a+v6b 전략, 데이터 변환 SQL, 순서 의존성, pushSchema 동기화"
      contains: "v6a"
  key_links:
    - from: "v6a transactions.network UPDATE"
      to: "wallets.network (현재)"
      via: "SELECT w.network FROM wallets w WHERE w.id = transactions.wallet_id"
      pattern: "역참조 before wallets.network 제거"
    - from: "v6b wallets CASE 분기"
      to: "docs/68 deriveEnvironment()"
      via: "동일 매핑 로직의 SQL 변환"
      pattern: "13개 네트워크 전수 CASE WHEN"
    - from: "pushSchema DDL"
      to: "v6b 마이그레이션 결과"
      via: "동일 스키마 보장"
      pattern: "LATEST_SCHEMA_VERSION 동기화"
---

<objective>
DB 마이그레이션 v6a(transactions.network ADD COLUMN) + v6b(wallets 12-step 재생성) 전략을 설계 문서로 작성한다.

Purpose: v1.4.6 구현자가 이 문서만으로 마이그레이션 코드를 작성할 수 있도록, 모든 SQL 문, 데이터 변환 로직, 순서 의존성, 검증 쿼리를 명시한다. v2/v3 마이그레이션의 검증된 패턴을 그대로 따른다.
Output: docs/69-db-migration-v6-design.md
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-environment-data-model-db-migration/105-RESEARCH.md

# Plan 105-01 산출물 참조 (환경-네트워크 매핑, deriveEnvironment 로직)
@.planning/phases/105-environment-data-model-db-migration/105-01-SUMMARY.md

# 기존 마이그레이션 패턴 참조
@packages/daemon/src/infrastructure/database/migrate.ts
@packages/daemon/src/infrastructure/database/schema.ts

# v2/v3 마이그레이션 선례 (85/89 SUMMARY)
@.planning/phases/85-db-migration/85-01-SUMMARY.md
@.planning/phases/89-db-migration/89-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: v6a 마이그레이션 설계 (transactions.network ADD COLUMN)</name>
  <files>docs/69-db-migration-v6-design.md</files>
  <action>
설계 문서 69번의 전반부를 작성한다. 다음 섹션을 포함한다:

**섹션 1: 마이그레이션 전략 개요**
- 2단계 분리 근거: v6a(비파괴적 ADD COLUMN) + v6b(파괴적 12-step 재생성)
- 버전 번호: v6a = version 6, v6b = version 7
- LATEST_SCHEMA_VERSION: 5 -> 7 (v6b 완료 후)
- 순서 의존성 다이어그램:
  ```
  현재(v5) -> v6a(transactions.network ADD + UPDATE) -> v6b(wallets 12-step)
                    |                                        |
                    |-- wallets.network 아직 존재 ----------|-- wallets.network 제거
                    |-- UPDATE ... FROM wallets.network      |-- CASE 분기로 environment 변환
  ```
- v6a가 v6b보다 먼저 실행되어야 하는 이유: v6a의 UPDATE가 wallets.network을 참조하는데, v6b에서 해당 컬럼이 제거됨

**섹션 2: v6a 마이그레이션 상세 (version: 6)**
- `managesOwnTransaction: false` (표준 마이그레이션, 트랜잭션 관리 불필요)
- SQL 1: `ALTER TABLE transactions ADD COLUMN network TEXT`
- SQL 2: `UPDATE transactions SET network = (SELECT w.network FROM wallets w WHERE w.id = transactions.wallet_id)`
- NULL 허용 근거: 기존 레코드는 ON DELETE RESTRICT로 보호되어 wallets가 항상 존재하므로 실제 NULL 발생 안 함. 하지만 스키마 레벨에서는 nullable로 유지 (향후 외부 트랜잭션 기록 등 유연성)
- 검증 쿼리: `SELECT COUNT(*) FROM transactions WHERE network IS NULL` = 0 (기존 데이터 전부 역참조 성공)
- 이 시점에서 CHECK 제약은 미추가 (v6b에서 transactions 재생성 시 함께 추가)
  </action>
  <verify>
- docs/69-db-migration-v6-design.md가 존재한다
- 섹션 1의 순서 의존성 다이어그램이 v6a -> v6b 순서를 시각적으로 명시한다
- 섹션 2의 v6a SQL 2개(ALTER + UPDATE)가 완전하다
- managesOwnTransaction: false가 명시되어 있다
  </verify>
  <done>
- v6a 마이그레이션 설계가 SQL 레벨로 완성됨
- 순서 의존성이 다이어그램으로 시각화됨
- v6a가 v6b 이전 실행 필수인 근거가 명시됨
  </done>
</task>

<task type="auto">
  <name>Task 2: v6b 마이그레이션 설계 (wallets 12-step 재생성) + pushSchema 동기화</name>
  <files>docs/69-db-migration-v6-design.md</files>
  <action>
설계 문서 69번의 후반부를 작성한다. Task 1에서 작성한 파일에 이어서 작성한다.

**섹션 3: v6b 마이그레이션 상세 (version: 7, managesOwnTransaction: true)**

12-step 재생성 절차를 단계별로 SQL과 함께 작성한다:

Step 1: `BEGIN` (up() 내부에서 직접 관리)

Step 2: wallets_new 테이블 생성
```sql
CREATE TABLE wallets_new (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  chain TEXT NOT NULL CHECK (chain IN ({CHAIN_TYPES})),
  environment TEXT NOT NULL CHECK (environment IN ('testnet', 'mainnet')),
  default_network TEXT CHECK (default_network IS NULL OR default_network IN ({NETWORK_TYPES})),
  public_key TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'CREATING' CHECK (status IN ({WALLET_STATUSES})),
  owner_address TEXT,
  owner_verified INTEGER NOT NULL DEFAULT 0 CHECK (owner_verified IN (0, 1)),
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  suspended_at INTEGER,
  suspension_reason TEXT
)
```
- `network` 컬럼 제거, `environment` + `default_network` 추가
- `default_network` nullable (NULL = 환경 기본값 사용)

Step 3: 데이터 변환 INSERT
```sql
INSERT INTO wallets_new (id, name, chain, environment, default_network, public_key, status, owner_address, owner_verified, created_at, updated_at, suspended_at, suspension_reason)
SELECT id, name, chain,
  CASE
    -- Solana mainnet
    WHEN network = 'mainnet' THEN 'mainnet'
    -- Solana testnet networks
    WHEN network = 'devnet' THEN 'testnet'
    WHEN network = 'testnet' THEN 'testnet'
    -- EVM mainnet networks
    WHEN network = 'ethereum-mainnet' THEN 'mainnet'
    WHEN network = 'polygon-mainnet' THEN 'mainnet'
    WHEN network = 'arbitrum-mainnet' THEN 'mainnet'
    WHEN network = 'optimism-mainnet' THEN 'mainnet'
    WHEN network = 'base-mainnet' THEN 'mainnet'
    -- EVM testnet networks
    WHEN network = 'ethereum-sepolia' THEN 'testnet'
    WHEN network = 'polygon-amoy' THEN 'testnet'
    WHEN network = 'arbitrum-sepolia' THEN 'testnet'
    WHEN network = 'optimism-sepolia' THEN 'testnet'
    WHEN network = 'base-sepolia' THEN 'testnet'
    ELSE 'testnet'  -- safety fallback (should never hit due to CHECK)
  END AS environment,
  network AS default_network,  -- 기존 network 값을 default_network에 보존
  public_key, status, owner_address, owner_verified, created_at, updated_at, suspended_at, suspension_reason
FROM wallets
```
- 13개 NETWORK_TYPES 전수 CASE 매핑 -- **docs/68 섹션 3의 deriveEnvironment() 매핑 테이블을 참조하여 CASE 분기를 작성한다.** 각 네트워크 이름과 환경 값 쌍이 deriveEnvironment()의 매핑과 1:1 일치해야 한다.
- ELSE 분기: 안전 fallback (기존 CHECK가 13개 값만 허용하므로 실행되지 않음)
- `default_network = network`: 기존 1:1 모델의 network 값을 그대로 보존

Step 4: `DROP TABLE wallets`

Step 5: `ALTER TABLE wallets_new RENAME TO wallets`

Step 6: wallets 인덱스 재생성
```sql
DROP INDEX IF EXISTS idx_wallets_chain_network;
CREATE INDEX idx_wallets_chain_environment ON wallets(chain, environment);
CREATE UNIQUE INDEX idx_wallets_public_key ON wallets(public_key);
```

Step 7: sessions 테이블 재생성 (FK 무결성)
- sessions의 `REFERENCES wallets(id)` FK를 새 wallets 테이블에 연결
- v3 선례를 따라 FK dependent 테이블도 함께 재생성 (안전 우선)
- sessions 스키마는 변경 없음 (컬럼 동일, FK 재연결만)

Step 8: transactions 테이블 재생성
- v6a에서 추가된 `network` 컬럼 포함
- CHECK 제약 추가: `CHECK (network IS NULL OR network IN ({NETWORK_TYPES}))`
- FK를 새 wallets 테이블에 연결
- 기존 데이터 INSERT SELECT (network 컬럼 포함)

Step 9: policies 테이블 재생성
- FK를 새 wallets 테이블에 연결
- 주의: policies.network 컬럼은 Phase 107 범위이므로 v6b에서 추가하지 않음 (스코프 분리)
- 기존 스키마 그대로, FK만 재연결

Step 10: audit_log 테이블 재생성 (FK dependent 테이블)
- 기존 스키마 그대로, FK 재연결

Step 11: `COMMIT`

Step 12: FK 무결성 검증
```typescript
sqlite.pragma('foreign_keys = ON');
const fkErrors = sqlite.pragma('foreign_key_check') as unknown[];
if (fkErrors.length > 0) throw new Error(`FK integrity violation after v6b: ${JSON.stringify(fkErrors)}`);
```

**마이그레이션 후 검증 쿼리 (테스트에서 실행):**
```sql
-- 환경 값 검증
SELECT COUNT(*) FROM wallets WHERE environment NOT IN ('testnet', 'mainnet');  -- = 0
-- default_network 보존 검증
SELECT COUNT(*) FROM wallets WHERE default_network IS NULL;  -- = 0 (마이그레이션 직후)
-- transactions.network 보존 검증
SELECT COUNT(*) FROM transactions WHERE network IS NULL;  -- = 0 (v6a에서 이미 채워짐)
-- FK 무결성
PRAGMA foreign_key_check;  -- empty result
-- 인덱스 존재 확인
SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='wallets';
```

**섹션 4: pushSchema DDL 동기화 계획**
- getCreateTableStatements()의 wallets 테이블 DDL 업데이트:
  - `network TEXT NOT NULL CHECK (...)` -> `environment TEXT NOT NULL CHECK (environment IN ('testnet', 'mainnet'))`
  - `default_network TEXT CHECK (default_network IS NULL OR default_network IN ({NETWORK_TYPES}))` 추가
- getCreateTableStatements()의 transactions 테이블 DDL 업데이트:
  - `network TEXT CHECK (network IS NULL OR network IN ({NETWORK_TYPES}))` 추가
- getCreateIndexStatements() 업데이트:
  - `idx_wallets_chain_network` -> `idx_wallets_chain_environment`
- LATEST_SCHEMA_VERSION: 5 -> 7
- pushSchema()가 version 1~7 모두 기록하도록 기존 패턴 유지

**섹션 5: Drizzle ORM 스키마 변경 계획**
- `packages/daemon/src/infrastructure/database/schema.ts`의 wallets 테이블:
  - `network: text('network').notNull()` -> `environment: text('environment').notNull()`
  - `defaultNetwork: text('default_network')` 추가
  - `check_network` -> `check_environment`
- transactions 테이블: `network: text('network')` 추가
- 인덱스: `idx_wallets_chain_network` -> `idx_wallets_chain_environment`

**섹션 6: 테스트 전략**
- v5 DB 생성 -> v6a 적용 -> v6b 적용 -> 검증 (기존 85/89 패턴)
- 테스트 케이스:
  1. v6a: transactions.network이 wallets.network에서 올바르게 역참조됨
  2. v6b: Solana mainnet 월렛 -> environment='mainnet', default_network='mainnet'
  3. v6b: EVM testnet 월렛 -> environment='testnet', default_network='ethereum-sepolia'
  4. v6b: FK 무결성 (sessions/transactions/policies)
  5. v6b: idx_wallets_chain_environment 인덱스 존재
  6. 새 DB: pushSchema로 생성한 DB와 마이그레이션된 DB의 스키마 동일
- 마이그레이션 테스트 version 번호: 기존 테스트 v10+ 유지, 새 테스트는 v6/v7 실제 마이그레이션 대상

**섹션 7: 위험 요소 + 완화 전략**
- CASE 분기 누락: 13개 전수 매핑 + ELSE fallback + 마이그레이션 후 환경 값 검증 쿼리
- FK 깨짐: managesOwnTransaction=true + PRAGMA foreign_key_check
- pushSchema/마이그레이션 불일치: LATEST_SCHEMA_VERSION=7 동기화 + 테스트 케이스 6
- v6a/v6b 순서 역전: MIGRATIONS 배열에 version 6 < 7 순서 강제 (runMigrations가 순서대로 실행)
  </action>
  <verify>
- docs/69-db-migration-v6-design.md가 섹션 3~7을 포함한다
- v6b 12-step 절차가 Step 1~12로 완전하다
- 13개 CASE WHEN 분기가 빠짐없이 나열되어 있다
- v6b CASE WHEN 13개 분기가 docs/68 섹션 3의 deriveEnvironment() 매핑 테이블과 1:1 일치한다 (네트워크 이름과 환경 값 쌍이 동일)
- pushSchema DDL 변경 계획이 wallets + transactions + indexes + LATEST_SCHEMA_VERSION을 모두 포함한다
- Drizzle 스키마 변경 계획이 명시되어 있다
- 테스트 케이스 6개가 나열되어 있다
- 위험 요소 4개와 완화 전략이 명시되어 있다
  </verify>
  <done>
- v6a 마이그레이션(version 6): ALTER + UPDATE 2개 SQL 완전
- v6b 마이그레이션(version 7): 12-step 재생성 SQL 완전 (wallets + sessions + transactions + policies + audit_log)
- 13개 NETWORK_TYPES CASE 분기 전수 매핑
- pushSchema DDL + Drizzle 스키마 동기화 계획 명시
- 테스트 전략 6개 케이스 + 위험 완화 4개 전략
- 구현자가 이 문서만으로 마이그레이션 코드를 작성할 수 있는 수준의 완전성
  </done>
</task>

</tasks>

<verification>
1. docs/69-db-migration-v6-design.md가 존재하고 7개 섹션을 포함한다
2. v6a(version 6)와 v6b(version 7)의 모든 SQL이 실행 가능한 수준으로 작성되어 있다
3. 13개 CASE WHEN 분기가 docs/68의 deriveEnvironment() 매핑과 일치한다
4. v6a -> v6b 순서 의존성이 명시적이다
5. pushSchema DDL이 v6b 결과와 동일한 스키마를 생성한다
6. PRAGMA foreign_key_check가 v6b 절차에 포함되어 있다
7. 새 DB와 마이그레이션된 DB의 스키마 동일성 테스트가 설계되어 있다
</verification>

<success_criteria>
- v1.4.6 구현자가 이 문서만으로 packages/daemon/src/infrastructure/database/migrate.ts에 v6a+v6b 마이그레이션을 추가할 수 있다
- 모든 SQL이 copy-paste 수준으로 완전하다 (placeholder 없음)
- v2(Phase 85)/v3(Phase 89) 선례의 managesOwnTransaction 패턴을 정확히 따른다
- pushSchema/Drizzle 동기화 누락 없이 설계되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/105-environment-data-model-db-migration/105-02-SUMMARY.md`
</output>
