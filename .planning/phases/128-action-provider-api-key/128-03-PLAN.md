---
phase: 128-action-provider-api-key
plan: 03
type: execute
wave: 2
depends_on: ["128-01", "128-02"]
files_modified:
  - packages/daemon/src/api/routes/actions.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/api-actions.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/actions/:provider/:action이 resolve() 결과를 기존 파이프라인(Stage 1-6)으로 실행한다"
    - "requiresApiKey=true 프로바이더가 키 미설정 시 403 API_KEY_REQUIRED를 반환한다"
    - "DaemonLifecycle Step 4f에서 ActionProviderRegistry + ApiKeyStore가 초기화된다"
    - "sessionAuth로 인증된 요청만 /v1/actions/* 경로에 접근할 수 있다"
    - "GET /v1/actions/providers가 등록된 프로바이더 목록과 액션 정보를 반환한다"
  artifacts:
    - path: "packages/daemon/src/api/routes/actions.ts"
      provides: "POST /v1/actions/:provider/:action, GET /v1/actions/providers 라우트"
      exports: ["actionRoutes"]
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "Step 4f: ActionProviderRegistry + ApiKeyStore 초기화"
      contains: "Step 4f"
    - path: "packages/daemon/src/__tests__/api-actions.test.ts"
      provides: "Actions REST API 통합 테스트"
  key_links:
    - from: "packages/daemon/src/api/routes/actions.ts"
      to: "packages/daemon/src/infrastructure/action/action-provider-registry.ts"
      via: "ActionProviderRegistry.executeResolve() -> ContractCallRequest"
      pattern: "executeResolve"
    - from: "packages/daemon/src/api/routes/actions.ts"
      to: "packages/daemon/src/pipeline/stages.ts"
      via: "기존 파이프라인에 ContractCallRequest 주입 (type: CONTRACT_CALL)"
      pattern: "executePipeline|stage1"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/infrastructure/action/index.ts"
      via: "import ActionProviderRegistry, ApiKeyStore"
      pattern: "import.*infrastructure/action"
---

<objective>
POST /v1/actions/:provider/:action REST API + DaemonLifecycle 초기화 + 파이프라인 연동

Purpose: Action Provider의 resolve() 결과를 기존 6-stage 파이프라인에 ContractCallRequest로 주입하여 정책 평가와 서명/제출을 수행한다.
Output: actions.ts 라우트 + DaemonLifecycle Step 4f + 통합 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/128-action-provider-api-key/128-RESEARCH.md
@.planning/phases/128-action-provider-api-key/128-01-SUMMARY.md
@.planning/phases/128-action-provider-api-key/128-02-SUMMARY.md
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/pipeline/stages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DaemonLifecycle Step 4f + CreateAppDeps 확장 + actions.ts 라우트</name>
  <files>
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/api/routes/actions.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
  </files>
  <action>
    1. **DaemonLifecycle Step 4f 추가** (`packages/daemon/src/lifecycle/daemon.ts`):
       - Step 4e (PriceOracle) 아래에 Step 4f 추가:
       ```typescript
       // Step 4f: ActionProviderRegistry + ApiKeyStore (fail-soft)
       try {
         const { ActionProviderRegistry, ApiKeyStore } =
           await import('../infrastructure/action/index.js');

         this.apiKeyStore = new ApiKeyStore(this._db!, masterPassword);
         this.actionProviderRegistry = new ActionProviderRegistry();

         // Load plugins from ~/.waiaas/actions/ (if exists)
         const actionsDir = join(dataDir, 'actions');
         if (existsSync(actionsDir)) {
           const result = await this.actionProviderRegistry.loadPlugins(actionsDir);
           console.log(`Step 4f: ActionProviderRegistry initialized (${result.loaded.length} plugins loaded, ${result.failed.length} failed)`);
         } else {
           console.log('Step 4f: ActionProviderRegistry initialized (no plugins directory)');
         }
       } catch (err) {
         console.warn('Step 4f (fail-soft): ActionProviderRegistry init warning:', err);
       }
       ```
       - DaemonLifecycle 클래스에 private 멤버 추가:
         - `private actionProviderRegistry: InstanceType<typeof import('../infrastructure/action/action-provider-registry.js').ActionProviderRegistry> | null = null;`
         - `private apiKeyStore: InstanceType<typeof import('../infrastructure/action/api-key-store.js').ApiKeyStore> | null = null;`
         - 또는 간단히 `private actionProviderRegistry: any = null; private apiKeyStore: any = null;` (DI 경유이므로 타입 안전성은 server.ts에서 보장)
       - getter 추가: `get registry()`, `get keyStore()` (createApp deps로 전달하기 위함)
       - Step 5 (HTTP server start)의 createApp() 호출에 actionProviderRegistry와 apiKeyStore를 deps로 전달

    2. **CreateAppDeps 확장** (`packages/daemon/src/api/server.ts`):
       - import 추가: `import type { ActionProviderRegistry } from '../infrastructure/action/action-provider-registry.js';`
       - import 추가: `import type { ApiKeyStore } from '../infrastructure/action/api-key-store.js';`
       - CreateAppDeps interface에 추가:
         ```typescript
         actionProviderRegistry?: ActionProviderRegistry;
         apiKeyStore?: ApiKeyStore;
         ```
       - import 추가: `import { actionRoutes } from './routes/actions.js';`
       - sessionAuth 미들웨어 등록 블록에 추가:
         ```typescript
         app.use('/v1/actions/*', sessionAuth);
         ```
       - actionRoutes 등록 블록 추가 (transactionRoutes 블록 아래):
         ```typescript
         if (deps.actionProviderRegistry && deps.apiKeyStore && deps.db && deps.keyStore && deps.masterPassword !== undefined && deps.adapterPool && deps.policyEngine && deps.config) {
           app.route('/v1', actionRoutes({
             registry: deps.actionProviderRegistry,
             apiKeyStore: deps.apiKeyStore,
             db: deps.db,
             adapterPool: deps.adapterPool,
             config: deps.config,
             keyStore: deps.keyStore,
             policyEngine: deps.policyEngine,
             masterPassword: deps.masterPassword,
             approvalWorkflow: deps.approvalWorkflow,
             delayQueue: deps.delayQueue,
             ownerLifecycle: deps.ownerLifecycle,
             sqlite: deps.sqlite,
             notificationService: deps.notificationService,
             priceOracle: deps.priceOracle,
             settingsService: deps.settingsService,
           }));
         }
         ```
       - adminRoutes deps에도 actionProviderRegistry 전달 추가:
         ```typescript
         actionProviderRegistry: deps.actionProviderRegistry,
         apiKeyStore: deps.apiKeyStore,
         ```

    3. **actions.ts 라우트** (`packages/daemon/src/api/routes/actions.ts`) 신규 생성:
       - ActionRouteDeps interface: registry, apiKeyStore + 기존 파이프라인 deps (db, adapterPool, config, keyStore, policyEngine, masterPassword, approvalWorkflow?, delayQueue?, ownerLifecycle?, sqlite?, notificationService?, priceOracle?, settingsService?)
       - `GET /actions/providers` 라우트:
         - registry.listProviders()로 프로바이더 목록 반환
         - 각 프로바이더에 대해 apiKeyStore.has(name)으로 키 설정 여부 포함
         - 200 응답: { providers: [{ ...metadata, hasApiKey: boolean, actions: ActionDefinition[] }] }
       - `POST /actions/{provider}/{action}` 라우트:
         - params에서 provider, action 추출
         - actionKey = `${provider}/${action}`
         - entry = registry.getAction(actionKey) -- 없으면 404 ACTION_NOT_FOUND
         - requiresApiKey 확인: entry.provider.metadata.requiresApiKey이면 apiKeyStore.has(entry.provider.metadata.name) 확인 -- 없으면 403 API_KEY_REQUIRED (message에 "Admin > Settings에서 {provider} API 키를 설정하세요")
         - body에서 params 추출 + ActionContext 구성 (c.get('walletId'), c.get('walletAddress') 등 세션 컨텍스트 활용). 주의: sessionAuth 미들웨어가 c.set('sessionPayload', ...)로 세션 정보를 설정함. 기존 transactions.ts의 세션 컨텍스트 추출 패턴 참조
         - contractCall = await registry.executeResolve(actionKey, body, context)
         - 기존 파이프라인에 ContractCallRequest 주입: transactions.ts의 sendTransaction 핸들러와 동일하게 executePipeline() 호출 (또는 stages.ts의 stage1Validate부터 순서대로). contractCall 자체가 type: 'CONTRACT_CALL'이므로 파이프라인이 그대로 처리.
         - 주의: 기존 sendTransaction 핸들러의 파이프라인 호출 코드를 참조하여 동일 패턴으로 구현. db, keyStore, adapterPool, policyEngine, config, masterPassword, approvalWorkflow, delayQueue, ownerLifecycle, sqlite, notificationService, priceOracle, settingsService를 모두 전달.
         - 201 응답: 파이프라인 결과 (transactionId, status 등)
       - OpenAPI 스키마는 createRoute() + z 스키마로 정의. buildErrorResponses(['ACTION_NOT_FOUND', 'API_KEY_REQUIRED', 'ACTION_VALIDATION_FAILED', 'ACTION_RESOLVE_FAILED', 'ACTION_RETURN_INVALID']) 사용.

    4. **openapi-schemas.ts 확장** (필요시):
       - API_KEY_REQUIRED 에러 코드가 buildErrorResponses()에서 인식되도록 확인 (error-codes.ts에 추가되었으므로 자동 작동해야 함)
  </action>
  <verify>
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS/packages/daemon && npx tsc --noEmit` 타입 체크 통과
    - `grep 'Step 4f' packages/daemon/src/lifecycle/daemon.ts` 존재
    - `grep 'actionRoutes' packages/daemon/src/api/server.ts` 존재
    - `grep 'actionProviderRegistry' packages/daemon/src/api/server.ts` 존재
  </verify>
  <done>DaemonLifecycle Step 4f가 ActionProviderRegistry+ApiKeyStore를 초기화하고, POST /v1/actions/:provider/:action 라우트가 resolve()->파이프라인 흐름을 구현하며, sessionAuth로 보호된다</done>
</task>

<task type="auto">
  <name>Task 2: Actions REST API 통합 테스트</name>
  <files>
    packages/daemon/src/__tests__/api-actions.test.ts
  </files>
  <action>
    1. `packages/daemon/src/__tests__/api-actions.test.ts` 신규 생성:
       - 기존 api-transactions.test.ts 또는 api-server.test.ts 패턴 참조 (createApp + testClient 구조)
       - Mock IActionProvider 생성:
         - metadata: { name: 'test_provider', description: 'Test action provider for tests', version: '1.0.0', chains: ['solana'], mcpExpose: false, requiresApiKey: false }
         - actions: [{ name: 'test_action', description: 'A test action that returns a contract call', chain: 'solana', inputSchema: z.object({ amount: z.string() }), riskLevel: 'low', defaultTier: 'INSTANT' }]
         - resolve: vi.fn() -> ContractCallRequest 반환 (type: 'CONTRACT_CALL', to: '...', programId: '...', ...)
       - Mock requiresApiKey IActionProvider 생성:
         - metadata.requiresApiKey = true, name: 'paid_provider'
       - 테스트 케이스:
         a. GET /v1/actions/providers -- 등록된 프로바이더 목록 반환 (200)
         b. POST /v1/actions/test_provider/test_action -- 정상 실행 (201 또는 파이프라인 결과)
           - 주의: 파이프라인 전체 실행은 adapter mock이 필요하므로, resolve() 호출 확인에 집중하거나 adapter mock을 설정
         c. POST /v1/actions/nonexistent/action -- 404 ACTION_NOT_FOUND
         d. POST /v1/actions/paid_provider/action -- 키 미설정 시 403 API_KEY_REQUIRED
         e. POST /v1/actions/paid_provider/action -- ApiKeyStore에 키 설정 후 resolve() 호출됨
         f. POST /v1/actions/test_provider/test_action -- 잘못된 입력 시 400 ACTION_VALIDATION_FAILED
         g. 인증 없이 POST /v1/actions/* -- 401 반환

       주의: 테스트에서 createApp()에 actionProviderRegistry와 apiKeyStore를 deps로 전달. 파이프라인 전체 실행이 어려우면 resolve() 호출까지만 검증하고 파이프라인 주입 코드의 존재를 확인. 또는 파이프라인 deps를 mock으로 구성하여 stage1까지 실행 확인.

       기존 daemon 테스트 회귀 확인.
  </action>
  <verify>
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS/packages/daemon && npx vitest run src/__tests__/api-actions.test.ts --reporter=verbose` 전체 통과
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS/packages/daemon && npx vitest run --reporter=verbose` 기존 테스트 회귀 없음
  </verify>
  <done>Actions REST API가 정상/에러 경로를 모두 처리하고, 7개 이상 통합 테스트가 통과한다</done>
</task>

</tasks>

<verification>
- POST /v1/actions/:provider/:action이 resolve() -> ContractCallRequestSchema.parse() -> 파이프라인 실행 흐름을 완성
- requiresApiKey=true + 키 미설정 시 403 반환
- sessionAuth 미들웨어로 보호
- DaemonLifecycle Step 4f에서 초기화 완료
- GET /v1/actions/providers가 프로바이더 목록 반환
- 7개 이상 통합 테스트 통과
- 기존 daemon 테스트 회귀 없음
</verification>

<success_criteria>
POST /v1/actions/:provider/:action이 Action Provider resolve -> 기존 파이프라인 실행 흐름을 완성하고, DaemonLifecycle에서 초기화되며, REST API 통합 테스트가 통과한다
</success_criteria>

<output>
After completion, create `.planning/phases/128-action-provider-api-key/128-03-SUMMARY.md`
</output>
