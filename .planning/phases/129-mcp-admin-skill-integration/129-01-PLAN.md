---
phase: 129-mcp-admin-skill-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp/src/tools/action-provider.ts
  - packages/mcp/src/index.ts
  - packages/mcp/src/__tests__/action-provider.test.ts
autonomous: true

must_haves:
  truths:
    - "mcpExpose=true Action Provider의 액션이 MCP 도구로 자동 변환되어 AI 에이전트가 사용할 수 있다"
    - "프로바이더 등록/해제 시 MCP 도구가 동적으로 추가/제거되고 기존 14개 내장 도구가 유지된다"
    - "Action Provider 조회 실패 시 MCP 서버가 정상 시작되고 14개 내장 도구만 사용 가능하다 (degraded mode)"
  artifacts:
    - path: "packages/mcp/src/tools/action-provider.ts"
      provides: "registerActionProviderTools 함수 -- Action Provider -> MCP Tool 자동 변환"
      exports: ["registerActionProviderTools"]
    - path: "packages/mcp/src/__tests__/action-provider.test.ts"
      provides: "Action Provider MCP 도구 변환 단위 테스트"
      min_lines: 80
  key_links:
    - from: "packages/mcp/src/tools/action-provider.ts"
      to: "/v1/actions/providers"
      via: "ApiClient.get() REST 호출"
      pattern: "apiClient\\.get.*actions/providers"
    - from: "packages/mcp/src/tools/action-provider.ts"
      to: "/v1/actions/:provider/:action"
      via: "ApiClient.post() REST 호출 (MCP 도구 핸들러)"
      pattern: "apiClient\\.post.*actions/"
    - from: "packages/mcp/src/index.ts"
      to: "packages/mcp/src/tools/action-provider.ts"
      via: "main()에서 sessionManager.start() 후 registerActionProviderTools() 호출"
      pattern: "registerActionProviderTools"
---

<objective>
ActionDefinition -> MCP Tool 자동 변환 + 동적 등록/해제 (ACTNP-05, ACTNP-06)

Purpose: mcpExpose=true Action Provider의 액션을 MCP 도구로 자동 등록하여 AI 에이전트가 REST API를 알지 않아도 DeFi 액션을 실행할 수 있게 한다. MCP 서버 시작 시 GET /v1/actions/providers를 호출하여 mcpExpose=true 프로바이더를 필터링하고, 각 액션을 action_{provider}_{action} 이름의 MCP 도구로 등록한다. RegisteredTool 참조를 보관하여 향후 remove() 호출이 가능하게 한다.
Output: packages/mcp/src/tools/action-provider.ts (신규), packages/mcp/src/index.ts (수정), 테스트 파일
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/129-mcp-admin-skill-integration/129-RESEARCH.md

@packages/mcp/src/server.ts
@packages/mcp/src/index.ts
@packages/mcp/src/api-client.ts
@packages/mcp/src/tools/send-token.ts
@packages/mcp/src/__tests__/tools.test.ts
@packages/mcp/src/__tests__/server.test.ts
@packages/daemon/src/api/routes/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: registerActionProviderTools 구현</name>
  <files>packages/mcp/src/tools/action-provider.ts</files>
  <action>
신규 파일 `packages/mcp/src/tools/action-provider.ts`를 생성한다.

**함수 시그니처:**
```typescript
export async function registerActionProviderTools(
  server: McpServer,
  apiClient: ApiClient,
  walletContext?: WalletContext,
): Promise<Map<string, RegisteredTool>>
```

**구현 내용:**

1. `apiClient.get<{ providers: Array<...> }>('/v1/actions/providers')`를 호출하여 등록된 프로바이더 목록을 가져온다.

2. 응답이 `!result.ok`이면 `console.error('[waiaas-mcp] Failed to fetch action providers, skipping dynamic tool registration')`를 로그하고 빈 Map을 반환한다 (degraded mode -- 14개 내장 도구는 정상 동작).

3. 응답의 `providers` 배열에서 `mcpExpose === true`인 프로바이더만 필터링한다.

4. 각 프로바이더의 각 액션에 대해:
   - 도구명: `action_${provider.name}_${action.name}` (MCP 네임스페이스 충돌 방지 -- 기존 14개 내장 도구와 겹치지 않음)
   - 설명: `withWalletPrefix(`[${provider.name}] ${action.description} (chain: ${action.chain}, risk: ${action.riskLevel})`, walletContext?.walletName)` -- 500자 이내
   - inputSchema: `{ params: z.record(z.unknown()).optional().describe('Action-specific parameters as key-value pairs'), network: z.string().optional().describe('Target network. Defaults to wallet default network.') }`
   - handler: `POST /v1/actions/${provider.name}/${action.name}`를 `apiClient.post()`로 호출. body에 `params`와 `network`를 포함 (있는 경우에만). 결과를 `toToolResult()`로 변환하여 반환.

5. `server.tool()` 반환값(RegisteredTool)을 Map<string, RegisteredTool>에 toolName -> tool로 저장.

6. 등록된 도구 수가 >0이면 `console.error(`[waiaas-mcp] Registered ${count} action provider tools`)`를 로그.

7. Map을 반환.

**Import 패턴:**
- `import { z } from 'zod';`
- `import type { McpServer, RegisteredTool } from '@modelcontextprotocol/sdk/server/mcp.js';` -- RegisteredTool 타입은 SDK 1.26.0에서 export됨. 만약 export되지 않으면 `server.tool()` 반환 타입을 `ReturnType<McpServer['tool']>`로 대체.
- `import { type ApiClient, toToolResult } from '../api-client.js';`
- `import { type WalletContext, withWalletPrefix } from '../server.js';`

**주의사항:**
- MCP 도구명에 슬래시 사용 금지. `action_{provider}_{action}` 형식 사용 (밑줄 구분).
- createMcpServer()는 동기 함수로 유지. 이 함수는 index.ts의 main()에서 connect() 후 비동기로 호출됨.
- REST 응답에 inputSchema가 포함되지 않으므로 generic `params: Record<string, unknown>` 패턴 사용. Zod 스키마를 재현하려는 시도 금지.
- RegisteredTool 타입이 SDK에서 직접 export되지 않는 경우, `server.tool()`의 반환 타입을 추론하여 사용. 예: `type RegisteredToolRef = ReturnType<McpServer['tool']>;`
  </action>
  <verify>
1. `pnpm --filter @waiaas/mcp build` -- TypeScript 컴파일 성공
2. `pnpm --filter @waiaas/mcp test` -- 기존 테스트 회귀 없음
  </verify>
  <done>
- registerActionProviderTools 함수가 export되고 빌드 성공
- mcpExpose=true 프로바이더의 액션을 action_{provider}_{action} 이름의 MCP 도구로 등록
- 프로바이더 조회 실패 시 degraded mode (빈 Map 반환, 에러 로그)
- RegisteredTool 참조가 Map에 저장되어 향후 remove() 호출 가능
  </done>
</task>

<task type="auto">
  <name>Task 2: index.ts 통합 + 단위 테스트</name>
  <files>packages/mcp/src/index.ts, packages/mcp/src/__tests__/action-provider.test.ts</files>
  <action>
**A. index.ts 수정:**

`packages/mcp/src/index.ts`의 `main()` 함수를 수정한다.

1. import 추가: `import { registerActionProviderTools } from './tools/action-provider.js';`

2. `await sessionManager.start()` 이후에 다음 코드를 추가:
```typescript
// Register action provider tools (async, failure = degraded mode)
// Must be after sessionManager.start() so API calls have valid token.
// server.tool() after connect() automatically fires sendToolListChanged().
registerActionProviderTools(server, apiClient, { walletName: WALLET_NAME })
  .catch((err: unknown) => {
    console.error('[waiaas-mcp] Action provider tool registration failed:', err instanceof Error ? err.message : String(err));
  });
```

**핵심:** `registerActionProviderTools`를 `await` 하지 않는다. fire-and-forget 패턴으로, 실패해도 MCP 서버는 계속 동작한다. SDK가 `server.tool()` 호출 시 자동으로 `sendToolListChanged()`를 발동하므로, 연결 후 등록해도 클라이언트에 도구 목록 변경이 통보된다.

**createMcpServer()는 수정하지 않는다.** 동기 함수로 유지. action provider 도구 등록은 index.ts에서 connect() + sessionManager.start() 이후에 수행.

**B. 단위 테스트:**

`packages/mcp/src/__tests__/action-provider.test.ts`를 신규 생성한다.

테스트 케이스:

1. **mcpExpose=true 액션이 MCP 도구로 등록된다:**
   - Mock ApiClient: `GET /v1/actions/providers`가 mcpExpose=true 프로바이더 1개 + 액션 2개를 반환
   - Mock McpServer: `tool()` 호출을 캡처
   - `registerActionProviderTools()` 호출 후 Map.size === 2 확인
   - `server.tool()`이 2번 호출되었는지 확인
   - 도구명이 `action_{providerName}_{actionName}` 형식인지 확인

2. **mcpExpose=false 프로바이더는 무시된다:**
   - Mock: mcpExpose=false 프로바이더 1개 + mcpExpose=true 프로바이더 1개 (액션 1개)
   - Map.size === 1 확인 (mcpExpose=true 것만)

3. **API 호출 실패 시 빈 Map 반환 (degraded mode):**
   - Mock: `apiClient.get()` returns `{ ok: false, error: { code: 'HTTP_500', message: 'fail', retryable: false } }`
   - Map.size === 0 확인
   - console.error 호출 확인

4. **도구 핸들러가 올바른 REST API를 호출한다:**
   - Mock 프로바이더 'defi'/액션 'swap' 등록
   - 캡처된 handler를 직접 호출: `handler({ params: { amount: '100' }, network: 'devnet' })`
   - `apiClient.post('/v1/actions/defi/swap', { params: { amount: '100' }, network: 'devnet' })` 호출 확인

5. **walletContext가 설명에 prefix로 추가된다:**
   - walletName='trading-bot'으로 호출
   - 도구 설명이 `[trading-bot] [provider] ...` 형식인지 확인

**테스트 패턴:** 기존 `tools.test.ts`의 getToolHandler 패턴을 참고하되, `registerActionProviderTools`는 async 함수이므로 `await`로 호출. Mock server.tool()이 RegisteredTool 객체 (또는 빈 객체)를 반환하도록 설정.
  </action>
  <verify>
1. `pnpm --filter @waiaas/mcp build` -- 컴파일 성공
2. `pnpm --filter @waiaas/mcp test` -- 신규 5개 테스트 + 기존 테스트 모두 패스
  </verify>
  <done>
- index.ts에서 sessionManager.start() 후 registerActionProviderTools() 호출됨
- fire-and-forget 패턴으로 실패 시에도 MCP 서버 정상 동작
- 5개 이상 단위 테스트가 mcpExpose 필터링, degraded mode, 핸들러 REST 호출, 도구명 형식을 검증
- ACTNP-05: ActionDefinition -> MCP Tool 자동 변환 충족
- ACTNP-06: 프로바이더 등록/해제 시 MCP 서버 재시작으로 변경 반영 (시작 시 1회 등록 패턴, 설계 문서 62 준수)
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/mcp build` -- TypeScript 컴파일 성공
2. `pnpm --filter @waiaas/mcp test` -- 모든 테스트 패스 (기존 + 신규)
3. **ACTNP-05**: registerActionProviderTools가 mcpExpose=true 액션을 MCP 도구로 변환
4. **ACTNP-06**: MCP 서버 재시작 시 변경사항 반영 (시작 시 1회 등록 + RegisteredTool 참조 보관)
5. 기존 14개 내장 도구가 tools.test.ts/server.test.ts에서 회귀 없음
</verification>

<success_criteria>
- action-provider.ts가 registerActionProviderTools를 export하고 빌드 성공
- index.ts main()이 sessionManager.start() 후 registerActionProviderTools()를 fire-and-forget으로 호출
- 5개 이상 단위 테스트 패스
- 기존 MCP 테스트 회귀 없음
- ACTNP-05, ACTNP-06 요구사항 충족
</success_criteria>

<output>
After completion, create `.planning/phases/129-mcp-admin-skill-integration/129-01-SUMMARY.md`
</output>
