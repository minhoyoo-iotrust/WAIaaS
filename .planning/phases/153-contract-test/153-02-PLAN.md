---
phase: 153-contract-test
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/__tests__/contracts/policy-engine.contract.ts
  - packages/core/src/__tests__/contracts/policy-engine.contract.test.ts
  - packages/core/src/__tests__/contracts/notification-channel.contract.ts
  - packages/core/src/__tests__/contracts/notification-channel.contract.test.ts
  - packages/core/src/__tests__/contracts/clock.contract.ts
  - packages/core/src/__tests__/contracts/clock.contract.test.ts
  - packages/core/src/__tests__/contracts/price-oracle.contract.ts
  - packages/core/src/__tests__/contracts/price-oracle.contract.test.ts
  - packages/core/src/__tests__/contracts/action-provider.contract.ts
  - packages/core/src/__tests__/contracts/action-provider.contract.test.ts
autonomous: true

must_haves:
  truths:
    - "MockPolicyEngine과 DatabasePolicyEngine이 동일한 Contract Test를 통과하여 evaluate() 동작 동일성이 보장된다"
    - "MockNotificationChannel과 TelegramChannel이 동일한 Contract Test를 통과하여 initialize/send 동작 동일성이 보장된다"
    - "FakeClock과 SystemClock이 동일한 Contract Test를 통과하여 now() 반환 타입 동일성이 보장된다"
    - "MockPriceOracle과 OracleChain이 동일한 Contract Test를 통과하여 getPrice/getPrices/getNativePrice 동작 동일성이 보장된다"
    - "MockActionProvider와 TestESMPlugin(fixture)이 동일한 Contract Test를 통과하여 metadata/actions/resolve 동작 동일성이 보장된다"
  artifacts:
    - path: "packages/core/src/__tests__/contracts/policy-engine.contract.ts"
      provides: "IPolicyEngine 공유 Contract Test 스위트"
      exports: ["policyEngineContractTests"]
    - path: "packages/core/src/__tests__/contracts/notification-channel.contract.ts"
      provides: "INotificationChannel 공유 Contract Test 스위트"
      exports: ["notificationChannelContractTests"]
    - path: "packages/core/src/__tests__/contracts/clock.contract.ts"
      provides: "IClock 공유 Contract Test 스위트"
      exports: ["clockContractTests"]
    - path: "packages/core/src/__tests__/contracts/price-oracle.contract.ts"
      provides: "IPriceOracle 공유 Contract Test 스위트"
      exports: ["priceOracleContractTests"]
    - path: "packages/core/src/__tests__/contracts/action-provider.contract.ts"
      provides: "IActionProvider 공유 Contract Test 스위트"
      exports: ["actionProviderContractTests"]
  key_links:
    - from: "policy-engine.contract.ts"
      to: "IPolicyEngine"
      via: "import type"
      pattern: "import.*IPolicyEngine"
    - from: "price-oracle.contract.ts"
      to: "IPriceOracle"
      via: "import type"
      pattern: "import.*IPriceOracle"
    - from: "action-provider.contract.ts"
      to: "IActionProvider"
      via: "import type"
      pattern: "import.*IActionProvider"
---

<objective>
IPolicyEngine, INotificationChannel, IClock, IPriceOracle, IActionProvider 5개 인터페이스에 대한 Contract Test 공유 스위트를 작성하고, 각 Mock 구현체와 실제 구현체가 동일한 계약을 통과하도록 검증한다.

Purpose: 5개 핵심 인터페이스의 Mock-실제 구현 동작 일치를 보장하여 Mock 기반 테스트의 신뢰성을 확보한다.
Output: 공유 Contract Test 스위트 5개 + 실행 테스트 5개
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/core/src/interfaces/IPolicyEngine.ts
@packages/core/src/interfaces/INotificationChannel.ts
@packages/core/src/interfaces/price-oracle.types.ts
@packages/core/src/interfaces/action-provider.types.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/daemon/src/pipeline/default-policy-engine.ts
@packages/daemon/src/notifications/channels/telegram.ts
@packages/daemon/src/infrastructure/oracle/oracle-chain.ts
@packages/daemon/src/infrastructure/action/action-provider-registry.ts
@packages/daemon/src/__tests__/mocks/mock-price-oracle.ts
@packages/daemon/src/__tests__/mocks/mock-action-provider.ts
@docs/v0.4/42-mock-boundaries-interfaces-contracts.md (섹션 4 IClock 스펙, 섹션 5 Contract Test)
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPolicyEngine + INotificationChannel + IClock Contract Test</name>
  <files>
    packages/core/src/__tests__/contracts/policy-engine.contract.ts
    packages/core/src/__tests__/contracts/policy-engine.contract.test.ts
    packages/core/src/__tests__/contracts/notification-channel.contract.ts
    packages/core/src/__tests__/contracts/notification-channel.contract.test.ts
    packages/core/src/__tests__/contracts/clock.contract.ts
    packages/core/src/__tests__/contracts/clock.contract.test.ts
  </files>
  <action>
**1. IPolicyEngine Contract Test (CT-3)**

공유 스위트 `policyEngineContractTests(factory)` 작성:

```typescript
export function policyEngineContractTests(
  factory: () => IPolicyEngine | Promise<IPolicyEngine>,
  options?: { setupPolicies?: (engine: IPolicyEngine) => Promise<void> }
): void
```

테스트 케이스:
- `evaluate()는 PolicyEvaluation 형태를 반환해야 한다`: `{ tier: PolicyTier, allowed: boolean }` 구조 검증
- `PolicyEvaluation.tier는 유효한 PolicyTier여야 한다`: `['INSTANT', 'NOTIFY', 'DELAY', 'APPROVAL']` 중 하나
- `PolicyEvaluation.allowed는 boolean이어야 한다`
- `정책 없는 기본 상태에서 INSTANT allowed를 반환해야 한다`: 기본 허용 동작 검증
- `allowed=false일 때 reason 문자열이 존재해야 한다` (선택적 -- DENY 케이스용)
- `delaySeconds는 DELAY 티어에서만 존재해야 한다` (형태 검증)

테스트 입력값 (Contract Test 표준 요청):
```typescript
const CONTRACT_TEST_REQUEST = {
  type: 'TRANSFER',
  amount: '1000000000',  // 1 SOL in lamports
  toAddress: 'So11111111111111111111111111111112',
  chain: 'solana',
};
```

실행 테스트 (`policy-engine.contract.test.ts`):

**MockPolicyEngine 인라인 구현** (설계 문서 42 기반, 코드베이스에 아직 없으므로):
```typescript
class MockPolicyEngine implements IPolicyEngine {
  private defaultDecision: PolicyEvaluation = { tier: 'INSTANT', allowed: true };
  private nextDecisions: PolicyEvaluation[] = [];

  async evaluate(walletId: string, transaction: { type: string; amount: string; toAddress: string; chain: string }): Promise<PolicyEvaluation> {
    if (this.nextDecisions.length > 0) return this.nextDecisions.shift()!;
    return { ...this.defaultDecision };
  }

  setNextDecision(...decisions: PolicyEvaluation[]): void { this.nextDecisions.push(...decisions); }
  setDefaultDecision(decision: PolicyEvaluation): void { this.defaultDecision = decision; }
  reset(): void { this.nextDecisions.length = 0; this.defaultDecision = { tier: 'INSTANT', allowed: true }; }
}
```

**DatabasePolicyEngine 실행**: 실제 SQLite DB가 필요하므로, `better-sqlite3` + `drizzle-orm`으로 in-memory 또는 tmpdir DB를 생성하여 테스트한다. `createRequire` 패턴으로 better-sqlite3를 CJS import한다 (152-01 decision 참조).

```typescript
describe('CT-3: IPolicyEngine Contract Tests', () => {
  describe('MockPolicyEngine', () => {
    policyEngineContractTests(() => new MockPolicyEngine());
  });

  describe('DatabasePolicyEngine', () => {
    policyEngineContractTests(async () => {
      // tmpdir에 SQLite DB 생성 -> pushSchema -> DatabasePolicyEngine 인스턴스 반환
      // 정책이 없는 기본 상태이므로 INSTANT passthrough
    });
  });
});
```

**2. INotificationChannel Contract Test (CT-4)**

공유 스위트 `notificationChannelContractTests(factory)` 작성:

```typescript
export function notificationChannelContractTests(
  factory: () => INotificationChannel | Promise<INotificationChannel>
): void
```

테스트 케이스:
- `name이 비어있지 않은 문자열이어야 한다`
- `initialize()는 void를 반환하는 Promise여야 한다` (에러 없이 완료)
- `send()는 void를 반환하는 Promise여야 한다`
- `send()에 NotificationPayload를 전달할 수 있어야 한다`

테스트 입력값:
```typescript
const CONTRACT_TEST_PAYLOAD: NotificationPayload = {
  eventType: 'TRANSACTION_SUBMITTED',
  walletId: 'wallet-contract-test',
  message: 'Contract test notification',
  timestamp: Math.floor(Date.now() / 1000),
};
```

실행 테스트 (`notification-channel.contract.test.ts`):

**MockNotificationChannel 인라인 구현** (코드베이스에 아직 없으므로):
```typescript
class MockNotificationChannel implements INotificationChannel {
  readonly name = 'mock-channel';
  readonly sentPayloads: NotificationPayload[] = [];

  async initialize(_config: Record<string, unknown>): Promise<void> { /* no-op */ }
  async send(payload: NotificationPayload): Promise<void> { this.sentPayloads.push(payload); }
  reset(): void { this.sentPayloads.length = 0; }
}
```

**TelegramChannel 실행**: TelegramChannel은 외부 서비스(Telegram API)에 의존하므로, msw로 Telegram Bot API를 모킹한다.

```typescript
const telegramHandlers = [
  http.post('https://api.telegram.org/bot*/sendMessage', () => {
    return HttpResponse.json({ ok: true, result: { message_id: 1 } });
  }),
];

describe('TelegramChannel', () => {
  const server = setupServer(...telegramHandlers);
  beforeAll(() => server.listen());
  afterAll(() => server.close());

  notificationChannelContractTests(async () => {
    const ch = new TelegramChannel();
    await ch.initialize({ telegram_bot_token: 'test-bot-token', telegram_chat_id: '12345' });
    return ch;
  });
});
```

**3. IClock Contract Test (CT-5)**

IClock 인터페이스와 구현체(FakeClock, SystemClock)가 코드베이스에 아직 없다. 설계 문서 42 기반으로 테스트 파일 내에 인라인 구현한다.

```typescript
// IClock 인터페이스 (test-local, 코어에 아직 없으므로)
interface IClock {
  now(): Date;
}

class FakeClock implements IClock {
  private currentTime: Date;
  constructor(initialTime: Date = new Date('2026-01-01T00:00:00Z')) {
    this.currentTime = new Date(initialTime.getTime());
  }
  now(): Date { return new Date(this.currentTime.getTime()); }
  advance(ms: number): void {
    if (ms < 0) throw new Error('FakeClock.advance(): ms must be non-negative');
    this.currentTime = new Date(this.currentTime.getTime() + ms);
  }
  setTime(time: Date): void { this.currentTime = new Date(time.getTime()); }
}

class SystemClock implements IClock {
  now(): Date { return new Date(); }
}
```

공유 스위트 `clockContractTests(factory)` 작성:

테스트 케이스:
- `now()는 Date 인스턴스를 반환해야 한다`: `expect(result).toBeInstanceOf(Date)`
- `now().getTime()이 유효해야 한다 (NaN 아님, > 0)`: `expect(Number.isNaN(time)).toBe(false); expect(time).toBeGreaterThan(0)`
- `연속 호출 시 시간이 역행하지 않아야 한다 (t2 >= t1)`: `expect(t2.getTime()).toBeGreaterThanOrEqual(t1.getTime())`
- `now()는 호출할 때마다 새 인스턴스를 반환해야 한다 (참조 독립)`: `expect(d1).not.toBe(d2)`

실행 테스트 (`clock.contract.test.ts`):
```typescript
describe('CT-5: IClock Contract Tests', () => {
  describe('FakeClock', () => {
    clockContractTests(() => new FakeClock());
  });
  describe('SystemClock', () => {
    clockContractTests(() => new SystemClock());
  });
});
```
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/core/src/__tests__/contracts/policy-engine.contract.test.ts packages/core/src/__tests__/contracts/notification-channel.contract.test.ts packages/core/src/__tests__/contracts/clock.contract.test.ts` -- 모든 테스트 통과
  </verify>
  <done>
IPolicyEngine(MockPolicyEngine vs DatabasePolicyEngine), INotificationChannel(MockNotificationChannel vs TelegramChannel), IClock(FakeClock vs SystemClock) 3개 인터페이스의 Contract Test가 모두 통과하여 Mock-실제 구현 동작 동일성이 검증된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: IPriceOracle + IActionProvider Contract Test</name>
  <files>
    packages/core/src/__tests__/contracts/price-oracle.contract.ts
    packages/core/src/__tests__/contracts/price-oracle.contract.test.ts
    packages/core/src/__tests__/contracts/action-provider.contract.ts
    packages/core/src/__tests__/contracts/action-provider.contract.test.ts
  </files>
  <action>
**1. IPriceOracle Contract Test (CT-6)**

공유 스위트 `priceOracleContractTests(factory)` 작성:

```typescript
export function priceOracleContractTests(
  factory: () => IPriceOracle | Promise<IPriceOracle>
): void
```

테스트 케이스 (getPrice, getPrices, getNativePrice, getCacheStats 4개 메서드):

**getPrice:**
- `getPrice()는 PriceInfo 형태를 반환해야 한다`: `{ usdPrice: number, source: string, fetchedAt: number, expiresAt: number, isStale: boolean }` 구조 검증
- `PriceInfo.usdPrice는 0 이상이어야 한다`: `expect(result.usdPrice).toBeGreaterThanOrEqual(0)`
- `PriceInfo.source는 유효한 값이어야 한다`: `expect(['pyth', 'coingecko', 'cache']).toContain(result.source)`
- `PriceInfo.fetchedAt은 양수 정수여야 한다`: `expect(Number.isInteger(result.fetchedAt)).toBe(true); expect(result.fetchedAt).toBeGreaterThan(0)`
- `PriceInfo.expiresAt은 fetchedAt 이후여야 한다`: `expect(result.expiresAt).toBeGreaterThanOrEqual(result.fetchedAt)`
- `PriceInfo.isStale은 boolean이어야 한다`

**getPrices:**
- `getPrices()는 Map<string, PriceInfo>를 반환해야 한다`: `expect(result).toBeInstanceOf(Map)`
- `빈 배열 입력 시 빈 Map을 반환해야 한다`
- `복수 토큰 입력 시 모든 토큰에 대한 PriceInfo가 Map에 존재해야 한다`

**getNativePrice:**
- `getNativePrice('solana')는 PriceInfo를 반환해야 한다`
- `getNativePrice('ethereum')는 PriceInfo를 반환해야 한다`

**getCacheStats:**
- `getCacheStats()는 CacheStats 형태를 반환해야 한다`: `{ hits: number, misses: number, staleHits: number, size: number, evictions: number }`
- `모든 필드가 0 이상의 정수여야 한다`

테스트 입력값:
```typescript
const CONTRACT_TEST_TOKEN: TokenRef = {
  address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
  symbol: 'USDC',
  decimals: 6,
  chain: 'solana',
};
```

실행 테스트 (`price-oracle.contract.test.ts`):

**MockPriceOracle**: 기존 `packages/daemon/src/__tests__/mocks/mock-price-oracle.ts`의 `MockPriceOracle`을 import하여 사용.

**OracleChain**: OracleChain은 primary/fallback IPriceOracle + InMemoryPriceCache 의존성이 필요하다. MockPriceOracle을 primary로, 빈 fallback으로 OracleChain을 생성한다.

```typescript
import { MockPriceOracle } from '@waiaas/daemon/src/__tests__/mocks/mock-price-oracle.js';
// OracleChain과 InMemoryPriceCache import

describe('CT-6: IPriceOracle Contract Tests', () => {
  describe('MockPriceOracle', () => {
    priceOracleContractTests(() => new MockPriceOracle());
  });

  describe('OracleChain (MockPriceOracle as primary)', () => {
    priceOracleContractTests(() => {
      const primary = new MockPriceOracle();
      const cache = new InMemoryPriceCache({ ttlMs: 300_000, maxEntries: 100 });
      return new OracleChain({ primary, cache });
    });
  });
});
```

주의: `@waiaas/daemon` 패키지에서 직접 import이 어려울 수 있다. 이 경우 상대 경로 import 또는 테스트 파일을 daemon 패키지 내로 이동한다.

**실용적 접근:** Contract Test 공유 스위트(`price-oracle.contract.ts`)는 `@waiaas/core`의 `__tests__/contracts/`에 작성하지만, OracleChain 실행 테스트는 daemon 패키지 소속이므로 `packages/daemon/src/__tests__/contracts/price-oracle-impl.contract.test.ts`에 별도 작성한다. `price-oracle.contract.test.ts`에서는 MockPriceOracle만 테스트하고, OracleChain 테스트는 daemon 패키지에 위치시킨다.

최종 파일 구조:
- `packages/core/src/__tests__/contracts/price-oracle.contract.ts` -- 공유 스위트
- `packages/core/src/__tests__/contracts/price-oracle.contract.test.ts` -- MockPriceOracle 검증
- `packages/daemon/src/__tests__/contracts/price-oracle-impl.contract.test.ts` -- OracleChain 검증

**2. IActionProvider Contract Test (CT-7)**

공유 스위트 `actionProviderContractTests(factory)` 작성:

```typescript
export function actionProviderContractTests(
  factory: () => IActionProvider | Promise<IActionProvider>
): void
```

테스트 케이스 (metadata, actions, resolve 3개 계약):

**metadata:**
- `metadata는 ActionProviderMetadata 형태여야 한다`: `{ name: string, description: string, version: string, chains: ChainType[], mcpExpose: boolean }`
- `metadata.name은 3-50자 소문자 alphanumeric+underscore여야 한다`
- `metadata.version은 SemVer 형식이어야 한다`
- `metadata.chains는 최소 1개 요소를 가져야 한다`

**actions:**
- `actions는 readonly ActionDefinition[] 형태여야 한다`
- `최소 1개 action이 있어야 한다`
- `각 action은 { name, description, chain, inputSchema, riskLevel, defaultTier } 형태여야 한다`
- `action.riskLevel은 ['low', 'medium', 'high'] 중 하나여야 한다`
- `action.defaultTier는 ['INSTANT', 'NOTIFY', 'DELAY', 'APPROVAL'] 중 하나여야 한다`

**resolve:**
- `유효한 actionName + params로 resolve()를 호출하면 ContractCallRequest를 반환해야 한다`: `{ type: 'CONTRACT_CALL', to: string, calldata: string }`
- `존재하지 않는 actionName으로 resolve()를 호출하면 에러를 throw해야 한다`
- `잘못된 params(inputSchema 위반)로 resolve()를 호출하면 에러를 throw해야 한다`

실행 테스트 (`action-provider.contract.test.ts`):

**MockActionProvider**: 기존 `packages/daemon/src/__tests__/mocks/mock-action-provider.ts`의 `MockActionProvider`를 import.

**TestESMPlugin (fixture)**: JupiterSwapProvider는 v2.3.1로 이연이므로, 테스트용 간단한 IActionProvider 구현체를 fixture로 작성한다.

```typescript
class TestESMPlugin implements IActionProvider {
  readonly metadata: ActionProviderMetadata = {
    name: 'test_esm_plugin',
    description: 'Test ESM plugin for contract test validation',
    version: '1.0.0',
    chains: ['ethereum'],
    mcpExpose: false,
    requiresApiKey: false,
    requiredApis: [],
  };

  readonly actions: readonly ActionDefinition[] = [{
    name: 'test_action',
    description: 'A test action that returns a contract call request',
    chain: 'ethereum',
    inputSchema: z.object({ amount: z.string(), recipient: z.string() }),
    riskLevel: 'low',
    defaultTier: 'INSTANT',
  }];

  async resolve(
    actionName: string,
    params: Record<string, unknown>,
    _context: ActionContext,
  ): Promise<ContractCallRequest> {
    const action = this.actions.find(a => a.name === actionName);
    if (!action) throw new Error(`ACTION_NOT_FOUND: ${actionName}`);
    action.inputSchema.parse(params);
    return {
      type: 'CONTRACT_CALL',
      to: String(params.recipient),
      calldata: '0xdeadbeef',
      value: String(params.amount),
    };
  }
}
```

최종 파일 구조:
- `packages/core/src/__tests__/contracts/action-provider.contract.ts` -- 공유 스위트
- `packages/core/src/__tests__/contracts/action-provider.contract.test.ts` -- MockActionProvider + TestESMPlugin 검증

MockActionProvider import 시 daemon 패키지 의존 문제가 있으면, 테스트 파일 내에 MockActionProvider를 인라인으로 재구현한다 (기존 `packages/daemon/src/__tests__/mocks/mock-action-provider.ts`의 로직을 복사).

OracleChain 실행 테스트도 마찬가지로 daemon 패키지에서만 접근 가능하므로, `packages/daemon/src/__tests__/contracts/` 디렉토리에 위치시킨다.

**추가 파일 생성:**
- `packages/daemon/src/__tests__/contracts/price-oracle-impl.contract.test.ts` -- OracleChain Contract Test
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/core/src/__tests__/contracts/price-oracle.contract.test.ts packages/core/src/__tests__/contracts/action-provider.contract.test.ts packages/daemon/src/__tests__/contracts/` -- 모든 테스트 통과
  </verify>
  <done>
IPriceOracle(MockPriceOracle vs OracleChain), IActionProvider(MockActionProvider vs TestESMPlugin) 2개 인터페이스의 Contract Test가 모두 통과한다. 5개 인터페이스 전체(IPolicyEngine, INotificationChannel, IClock, IPriceOracle, IActionProvider) Contract Test 완료.
  </done>
</task>

</tasks>

<verification>
1. `pnpm vitest run packages/core/src/__tests__/contracts/policy-engine.contract.test.ts` -- CT-3 통과
2. `pnpm vitest run packages/core/src/__tests__/contracts/notification-channel.contract.test.ts` -- CT-4 통과
3. `pnpm vitest run packages/core/src/__tests__/contracts/clock.contract.test.ts` -- CT-5 통과
4. `pnpm vitest run packages/core/src/__tests__/contracts/price-oracle.contract.test.ts` -- CT-6 Mock 통과
5. `pnpm vitest run packages/daemon/src/__tests__/contracts/price-oracle-impl.contract.test.ts` -- CT-6 OracleChain 통과
6. `pnpm vitest run packages/core/src/__tests__/contracts/action-provider.contract.test.ts` -- CT-7 통과
7. 모든 테스트 실패 시 "Interface.methodName: 설명" 형식의 명확한 에러 메시지 출력
</verification>

<success_criteria>
- CTST-03: MockPolicyEngine vs DatabasePolicyEngine 4-tier 평가 동일성 검증 완료
- CTST-04: MockNotificationChannel vs TelegramChannel 전송 동일성 검증 완료
- CTST-05: FakeClock vs SystemClock now() 반환 타입 동일성 검증 완료
- CTST-06: MockPriceOracle vs OracleChain getPrice/getPrices/getNativePrice 동일성 검증 완료
- CTST-07: MockActionProvider vs TestESMPlugin metadata/actions/resolve 동일성 검증 완료
- 5개 인터페이스 전체 Contract Test가 `pnpm vitest run`으로 통과
</success_criteria>

<output>
After completion, create `.planning/phases/153-contract-test/153-02-SUMMARY.md`
</output>
