---
phase: 38-sessionmanager-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/38-sdk-mcp-interface.md
autonomous: true

must_haves:
  truths:
    - "ApiClient 클래스의 인터페이스(get/post/put/request, handle401, getState 의존)와 ApiResult<T> discriminated union이 설계 문서에 정의되어 있다"
    - "모든 6개 tool handler가 apiClient.get()/post() + toToolResult() 공통 변환을 사용하는 리팩토링 패턴이 정의되어 있다"
    - "3개 resource handler도 동일한 ApiClient + toResourceResult() 패턴으로 통합되어 있다"
    - "SessionManager에 getState() public 메서드 추가가 설계 문서에 반영되어 있다"
  artifacts:
    - path: ".planning/deliverables/38-sdk-mcp-interface.md"
      provides: "섹션 6.5 ApiClient + tool/resource handler 통합 설계"
      contains: "ApiResult"
  key_links:
    - from: "ApiClient.request()"
      to: "SessionManager.getToken()"
      via: "동적 토큰 획득"
      pattern: "sessionManager\\.getToken\\(\\)"
    - from: "tool handler"
      to: "ApiClient.get/post()"
      via: "registerXxx factory 패턴"
      pattern: "apiClient\\.(get|post)"
    - from: "toToolResult()"
      to: "ApiResult"
      via: "expired/networkError/error/ok 분기"
      pattern: "toToolResult"
---

<objective>
38-sdk-mcp-interface.md에 ApiClient 래퍼 클래스 설계와 tool/resource handler 통합 패턴을 정의한다.

Purpose: Phase 37에서 확정된 SessionManager(getToken/start/dispose)를 MCP tool/resource handler가 실제로 사용하는 방법을 설계하여, 9개 handler의 인증/재시도/에러 처리를 ApiClient 한 곳에 캡슐화한다. SMGI-01 요구사항을 충족한다.
Output: 38-sdk-mcp-interface.md 섹션 6.5~6.5.4 신설 (ApiClient 클래스, ApiResult 타입, tool handler 리팩토링, resource handler 통합)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/deliverables/38-sdk-mcp-interface.md
@.planning/phases/38-sessionmanager-mcp-integration/38-RESEARCH.md
@.planning/phases/37-sessionmanager-core-design/37-01-SUMMARY.md
@.planning/phases/37-sessionmanager-core-design/37-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ApiClient 래퍼 클래스 + ApiResult 타입 + getState() 추가 설계</name>
  <files>.planning/deliverables/38-sdk-mcp-interface.md</files>
  <action>
38-sdk-mcp-interface.md에 다음 섹션을 추가한다. 기존 섹션 6.4.7(Lazy 401 Reload) 뒤에 이어서 작성한다.

**섹션 6.5 신설: `[v0.9] SessionManager MCP 통합 설계 (Phase 38)`**

도입부에 Phase 38 목표 간략 설명: SessionManager를 MCP tool/resource handler와 통합하는 ApiClient 래퍼 + 동시성 + 프로세스 생명주기 + 에러 처리 설계.

**섹션 6.5.1 신설: `[v0.9] SessionManager.getState() 추가 (Phase 38 확장)`**

Phase 37에서 `state` 필드가 private으로 정의되었으나(SM-03), ApiClient가 세션 상태를 사전 확인하려면 public 접근이 필요하다. 다음을 정의:

1. `getState(): SessionState` public 메서드 추가
   - 반환: `'active' | 'expired' | 'error'`
   - 동작: 현재 내부 state 필드를 그대로 반환 (순수 getter)
   - 호출자: ApiClient.request()에서 API 호출 전 세션 상태 확인용
2. 설계 결정 SMGI-D01: `getState()를 4번째 public 메서드로 추가. Phase 37의 3-public(getToken/start/dispose)에서 4-public(getToken/getState/start/dispose)으로 확장.`
3. 섹션 6.4.1의 Public 메서드 테이블 업데이트 안내 노트 (Phase 38에서 getState 추가됨)

**섹션 6.5.2 신설: `[v0.9] ApiClient 래퍼 클래스 설계 (SMGI-01)`**

Research의 Pattern 1 (ApiClient 래퍼 패턴)을 기반으로 다음을 설계 문서 수준으로 정의:

1. **ApiResult&lt;T&gt; discriminated union 타입 정의:**
   ```
   type ApiResult<T = unknown> =
     | { ok: true; data: T; status: number }        // 성공 (2xx)
     | { ok: false; error: { code: string; message: string }; status: number }  // API 에러 (4xx/5xx)
     | { ok: false; expired: true }                  // 세션 만료/에러 상태
     | { ok: false; networkError: true }             // 네트워크 에러 (ECONNREFUSED 등)
   ```

2. **ApiClient 클래스 인터페이스:**
   - `constructor(sessionManager: SessionManager, baseUrl: string)`
   - `async get<T>(path: string): Promise<ApiResult<T>>` -- GET 요청
   - `async post<T>(path: string, body?: unknown): Promise<ApiResult<T>>` -- POST 요청
   - `async put<T>(path: string, body?: unknown): Promise<ApiResult<T>>` -- PUT 요청 (세션 갱신 등)
   - `private async request<T>(method, path, body?): Promise<ApiResult<T>>` -- 공통 요청 처리
   - `private async handle401<T>(method, path, originalToken, body?): Promise<ApiResult<T>>` -- 401 재시도
   - `private async doFetch(method, path, token, body?): Promise<Response>` -- 실제 fetch 호출
   - `private parseResponse<T>(res: Response): Promise<ApiResult<T>>` -- 응답 파싱

3. **request() 메서드 7-step 절차 테이블:**
   Step 1: getState() 확인 (expired/error이면 즉시 { ok: false, expired: true } 반환)
   Step 2: getToken()으로 현재 토큰 획득
   Step 3: doFetch()로 API 호출
   Step 4: 401 응답이면 handle401() 호출
   Step 5: 기타 응답이면 parseResponse() 호출
   Step 6: fetch 실패(ECONNREFUSED 등)이면 { ok: false, networkError: true } 반환
   Step 7: 결과 반환

4. **handle401() 3-step 재시도 절차:**
   Step 1: 50ms 대기 (갱신 중일 수 있음, SM-14에서 갱신 중 getToken()은 구 토큰 반환이므로 갱신 완료를 대기)
   Step 2: getToken() 재호출, originalToken과 비교. 다르면 새 토큰으로 doFetch() 1회 재시도.
   Step 3: 동일하면 sessionManager.handleUnauthorized() 호출. recovered=true이면 새 토큰으로 재시도. false이면 { ok: false, expired: true }.
   - 참조: SM-12(handleUnauthorized 4-step), SM-14(갱신 중 구 토큰), H-05(401 재시도)

5. **parseResponse() 동작:**
   - 2xx: JSON 파싱 후 { ok: true, data, status }
   - 4xx/5xx: JSON 파싱 후 { ok: false, error: { code, message }, status }
   - JSON 파싱 실패: { ok: false, error: { code: 'PARSE_ERROR', message }, status }

6. **doFetch() 동작:**
   - `fetch(${baseUrl}${path}, { method, headers: { Authorization: Bearer ${token}, Content-Type: application/json }, body: body ? JSON.stringify(body) : undefined })`
   - fetch 자체가 throw하면 상위 request()에서 catch → networkError

7. **TypeScript 의사 코드** -- Research Example 1의 ApiClient 핵심 구조를 기반으로, 위 7-step/3-step을 포함한 전체 의사 코드 작성

8. **console.error 통일 규칙:**
   - ApiClient 내부의 모든 로그는 `console.error`로 출력 (stdout 오염 방지, Pitfall 4)
   - 로그 접두사: `[waiaas-mcp:api-client]`

참조: 38-RESEARCH.md Pattern 1, 2. SM-12, SM-14. v0.9-PITFALLS.md H-04, H-05.
  </action>
  <verify>
38-sdk-mcp-interface.md에서 다음을 확인:
1. `grep -c "ApiResult" .planning/deliverables/38-sdk-mcp-interface.md` -- ApiResult 타입 정의 존재
2. `grep -c "ApiClient" .planning/deliverables/38-sdk-mcp-interface.md` -- ApiClient 클래스 정의 존재
3. `grep -c "getState" .planning/deliverables/38-sdk-mcp-interface.md` -- getState 메서드 정의 존재
4. `grep -c "handle401" .planning/deliverables/38-sdk-mcp-interface.md` -- 401 처리 정의 존재
5. `grep -c "6.5.1" .planning/deliverables/38-sdk-mcp-interface.md` -- 섹션 6.5.1 존재
6. `grep -c "6.5.2" .planning/deliverables/38-sdk-mcp-interface.md` -- 섹션 6.5.2 존재
  </verify>
  <done>
섹션 6.5, 6.5.1, 6.5.2가 38-sdk-mcp-interface.md에 존재하고, ApiResult discriminated union, ApiClient 클래스 인터페이스(7개 메서드), request() 7-step, handle401() 3-step, getState() public 메서드 추가가 모두 설계 문서에 정의되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tool handler + Resource handler 통합 패턴 설계</name>
  <files>.planning/deliverables/38-sdk-mcp-interface.md</files>
  <action>
38-sdk-mcp-interface.md에 다음 섹션을 추가한다.

**섹션 6.5.3 신설: `[v0.9] Tool Handler 통합 패턴 (SMGI-01)`**

Research의 Pattern 2 (Tool Handler에서 ApiClient 사용)를 기반으로 다음을 정의:

1. **toToolResult() 공통 변환 함수 설계:**
   - 입력: `ApiResult<T>`
   - 출력: `CallToolResult` (MCP SDK 타입)
   - 4가지 분기:
     (a) `expired` → isError 미설정, JSON { status: 'session_expired', message: '...', retryable: true }
     (b) `networkError` → isError 미설정, JSON { status: 'daemon_unavailable', message: '...', retryable: true }
     (c) `!ok` (API 에러) → isError: true, JSON { error: true, code, message }
     (d) `ok` (성공) → JSON.stringify(data)
   - 핵심: (a), (b)에서 isError 미설정 = Claude Desktop 연결 해제 방지 (H-04)
   - TypeScript 의사 코드 (Research Example 3 기반)

2. **Tool handler factory 패턴:**
   - 각 tool을 `registerXxx(server: McpServer, apiClient: ApiClient): void` 함수로 모듈화
   - 기존 6개 tool handler 리팩토링 전후 비교 테이블:

     | Tool | Before (환경변수 + 직접 fetch) | After (ApiClient + toToolResult) |
     |------|-------------------------------|----------------------------------|
     | send_token | process.env.WAIAAS_SESSION_TOKEN + fetch + 인라인 에러 | apiClient.post('/v1/transactions', body) + toToolResult |
     | get_balance | 동일 | apiClient.get('/v1/wallet/balance') + toToolResult |
     | get_address | 동일 | apiClient.get('/v1/wallet/address') + toToolResult |
     | list_transactions | 동일 | apiClient.get('/v1/transactions?...') + toToolResult |
     | get_transaction | 동일 | apiClient.get(`/v1/transactions/${id}`) + toToolResult |
     | get_nonce | 동일 | apiClient.get('/v1/wallet/nonce') + toToolResult |

   - send_token tool handler 리팩토링 예시 의사 코드 (가장 복잡한 케이스):
     ```
     export function registerSendToken(server: McpServer, apiClient: ApiClient): void {
       server.tool('send_token', '...', { to: z.string(), amount: z.string(), ... }, async (args) => {
         const result = await apiClient.post('/v1/transactions', {
           type: 'NATIVE_TRANSFER',
           to: args.to,
           amount: args.amount,
           ...
         })
         return toToolResult(result)
       })
     }
     ```

3. **server.ts createMcpServer() 함수 설계:**
   - `createMcpServer(apiClient: ApiClient): McpServer`
   - 내부에서 6개 registerXxx() 호출 + 3개 resource 등록
   - ApiClient를 DI 패턴으로 전달

4. **기존 섹션 5.3 코드와의 관계 노트:**
   - 기존 5.3.2~5.3.7의 개별 tool 구현 코드는 v0.2 원본 설계
   - v0.9에서 ApiClient 기반으로 리팩토링 (코드 라인 수 ~50% 감소 예상)
   - 기존 도구 이름, 파라미터, 설명 등은 변경 없음 (호환성 유지)

**섹션 6.5.4 신설: `[v0.9] Resource Handler 통합 패턴 (SMGI-01)`**

1. **toResourceResult() 공통 변환 함수 설계:**
   - 입력: `ApiResult<T>`
   - 출력: `ReadResourceResult` (MCP SDK 타입)
   - 3가지 분기:
     (a) `expired` → 안내 텍스트 "Session expired. Please create a new session..."
     (b) `networkError` → 안내 텍스트 "WAIaaS daemon is not responding..."
     (c) `ok` → JSON.stringify(data)
     (d) `!ok` (API 에러) → error JSON 텍스트
   - Resource는 isError 개념 없음 (contents 배열로 반환), 만료 시 안내 텍스트가 resource 내용 자체가 됨

2. **3개 resource handler 리팩토링 패턴:**
   - wallet-balance: `apiClient.get('/v1/wallet/balance')` → toResourceResult
   - wallet-address: `apiClient.get('/v1/wallet/address')` → toResourceResult
   - system-status: `apiClient.get('/v1/system/status')` → toResourceResult
   - 대표 예시 의사 코드 (wallet-balance)

3. **Open Question 해결 기록:**
   - Research Open Question 1 (getState 추가) → SMGI-D01로 결정
   - Research Open Question 3 (Resource handler 만료 처리) → 동일 ApiClient + toResourceResult 패턴
   - Research Open Question 4 (previous_token_hash) → EXT-04 이연 확정

문서 헤더에 `v0.9 SessionManager MCP 통합 설계: 2026-02-09 (Phase 38-01: ApiClient + tool/resource handler 통합)` 추가.
  </action>
  <verify>
38-sdk-mcp-interface.md에서 다음을 확인:
1. `grep -c "toToolResult" .planning/deliverables/38-sdk-mcp-interface.md` -- 공통 변환 함수 존재
2. `grep -c "toResourceResult" .planning/deliverables/38-sdk-mcp-interface.md` -- resource 변환 함수 존재
3. `grep -c "registerSendToken\|registerGetBalance\|registerGetAddress" .planning/deliverables/38-sdk-mcp-interface.md` -- factory 패턴 존재
4. `grep -c "createMcpServer" .planning/deliverables/38-sdk-mcp-interface.md` -- 서버 생성 함수 존재
5. `grep -c "6.5.3" .planning/deliverables/38-sdk-mcp-interface.md` -- 섹션 존재
6. `grep -c "6.5.4" .planning/deliverables/38-sdk-mcp-interface.md` -- 섹션 존재
  </verify>
  <done>
섹션 6.5.3, 6.5.4가 38-sdk-mcp-interface.md에 존재하고, toToolResult() 4가지 분기(expired/networkError/error/ok), 6개 tool handler 리팩토링 전후 비교 테이블, registerXxx factory 패턴, createMcpServer() DI 설계, toResourceResult() 3가지 분기, 3개 resource handler 통합 패턴이 모두 정의되어 있다.
  </done>
</task>

</tasks>

<verification>
Phase 38 Plan 01 전체 검증:
1. `grep -c "6.5" .planning/deliverables/38-sdk-mcp-interface.md` -- 6.5 섹션 계열이 6개 이상 존재 (6.5, 6.5.1, 6.5.2, 6.5.3, 6.5.4)
2. `grep "SMGI-01" .planning/deliverables/38-sdk-mcp-interface.md` -- SMGI-01 요구사항 참조 존재
3. ApiResult, ApiClient, toToolResult, toResourceResult, getState 모두 설계 문서에 포함
4. 기존 섹션 6.4.x (Phase 37 내용) 손상 없음
</verification>

<success_criteria>
- ApiClient 래퍼 클래스의 전체 인터페이스 (7개 메서드)가 설계 문서에 의사 코드 수준으로 정의되어 있다
- ApiResult discriminated union 4종 분기가 명확히 정의되어 있다
- 6개 tool handler + 3개 resource handler의 리팩토링 패턴이 정의되어 있다
- toToolResult/toResourceResult 공통 변환 함수의 에러 분기(특히 isError 회피)가 정의되어 있다
- SessionManager.getState() 추가가 설계 문서에 반영되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/38-sessionmanager-mcp-integration/38-01-SUMMARY.md`
</output>
