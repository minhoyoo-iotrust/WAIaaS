---
phase: 38-sessionmanager-mcp-integration
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - .planning/deliverables/38-sdk-mcp-interface.md
  - objectives/v0.9-session-management-automation.md
autonomous: true

must_haves:
  truths:
    - "갱신 중 tool 호출의 동시성 처리(구 토큰 사용 → 401 시 50ms 대기 → 재시도)가 시퀀스 다이어그램으로 정의되어 있다"
    - "프로세스 생명주기(start 실패 → degraded mode, SIGTERM → dispose, 재시작 → 파일 복원)가 설계 문서에 정의되어 있다"
    - "에러 복구 루프(만료 상태에서 60초 주기 파일 확인, 외부 토큰 감지 시 active 전환)가 SessionManager에 설계되어 있다"
    - "세션 만료 시 isError 미설정 안내 메시지 반환과 Claude Desktop 연결 해제 방지 전략이 문서화되어 있다"
    - "v0.9 objectives에 SMGI-01~04 설계 완료와 Phase 38 결정사항이 반영되어 있다"
  artifacts:
    - path: ".planning/deliverables/38-sdk-mcp-interface.md"
      provides: "섹션 6.5.5~6.5.7 동시성 + 생명주기 + 에러 처리 설계"
      contains: "recoveryLoop"
    - path: "objectives/v0.9-session-management-automation.md"
      provides: "SMGI-01~04 설계 확정 태그 + Phase 38 결정사항"
      contains: "Phase 38"
  key_links:
    - from: "에러 복구 루프"
      to: "SessionManager.startRecoveryLoop()"
      via: "만료 상태 → 60초 파일 확인 → active 전환"
      pattern: "startRecoveryLoop"
    - from: "갱신 중 tool 호출"
      to: "ApiClient.handle401()"
      via: "50ms 대기 → getToken() 재호출 → 재시도"
      pattern: "handle401"
    - from: "프로세스 생명주기"
      to: "index.ts main()"
      via: "start → connect → SIGTERM → dispose"
      pattern: "graceful shutdown"
---

<objective>
38-sdk-mcp-interface.md에 토큰 로테이션 동시성 처리, MCP 프로세스 생명주기, Claude Desktop 에러 처리 전략을 정의하고, v0.9 objectives에 Phase 38 완료를 반영한다.

Purpose: SMGI-02(동시성), SMGI-03(프로세스 생명주기), SMGI-04(에러 처리) 요구사항을 충족하여, 구현 단계에서 MCP Server의 세션 관리가 설계 없이 진행되는 위험을 제거한다.
Output: 38-sdk-mcp-interface.md 섹션 6.5.5~6.5.7 신설 + objectives 업데이트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/deliverables/38-sdk-mcp-interface.md
@.planning/phases/38-sessionmanager-mcp-integration/38-RESEARCH.md
@.planning/phases/38-sessionmanager-mcp-integration/38-01-SUMMARY.md
@.planning/phases/37-sessionmanager-core-design/37-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 동시성 + 프로세스 생명주기 + 에러 복구 루프 설계</name>
  <files>.planning/deliverables/38-sdk-mcp-interface.md</files>
  <action>
38-sdk-mcp-interface.md의 섹션 6.5.4 뒤에 다음 섹션을 추가한다.

**섹션 6.5.5 신설: `[v0.9] 토큰 로테이션 동시성 처리 (SMGI-02)`**

1. **갱신 중 tool 호출 시나리오 시퀀스 다이어그램:**
   ```
   시간 →
   T0: renew() 시작 (isRenewing=true)
   T1: tool handler 호출 → apiClient.request()
        → getState()='active' → getToken()=구 토큰
        → doFetch(구 토큰) → 성공 (데몬이 아직 구 토큰 수용)
   T2: renew() API 응답 수신 → 데몬 DB에서 token_hash 교체
   T3: renew() writeMcpToken(새 토큰) → this.token = 새 토큰 (isRenewing=false)
   T4: tool handler 호출 → getToken()=새 토큰 → doFetch(새 토큰) → 성공
   ```

2. **T1~T2 사이 경쟁 시나리오 (401 발생 케이스):**
   ```
   T0: renew() 시작
   T1: tool handler 호출 → getToken()=구 토큰
   T2: renew() 데몬 응답 수신 → DB에서 token_hash 교체됨
   T3: tool handler의 doFetch(구 토큰) 도착 → 401 (DB에는 새 hash)
   T4: handle401() → 50ms 대기
   T5: renew() writeMcpToken → this.token = 새 토큰
   T6: handle401() getToken()=새 토큰 (≠ 구 토큰) → doFetch(새 토큰) → 성공
   ```

3. **50ms 대기 근거:**
   - Node.js 단일 스레드에서 갱신 API 응답 처리(writeMcpToken + 메모리 교체)는 보통 1-10ms
   - 50ms는 파일 I/O + 이벤트 루프 지연을 포함한 안전 마진
   - 50ms 이내에 갱신이 완료되면 getToken() 재호출에서 새 토큰 획득
   - 50ms 이후에도 동일 토큰이면 handleUnauthorized() 진행 (파일 재로드 시도)

4. **동시성 보장 테이블:**
   | 시나리오 | getToken() 반환 | 401 발생? | 복구 방법 |
   |---------|----------------|----------|----------|
   | 갱신 미진행 | 현재 토큰 | No | - |
   | 갱신 중 (데몬 미교체) | 구 토큰 | No | - |
   | 갱신 중 (데몬 교체됨, MCP 미교체) | 구 토큰 | Yes | handle401 50ms→재시도 |
   | 갱신 완료 | 새 토큰 | No | - |
   | 외부 갱신 (CLI/Telegram) | 구 토큰 | Yes | handleUnauthorized→파일 reload |

5. **설계 결정 SMGI-D02:** `Mutex/Lock 미사용. Node.js 단일 스레드에서 getToken()의 동기 반환 + 401 재시도가 충분하다. 갱신 중 tool 호출을 차단하면 사용자 체감 지연 발생.`
   참조: Research Anti-Patterns "갱신 중 Mutex로 tool 호출 차단"

**섹션 6.5.6 신설: `[v0.9] MCP 프로세스 생명주기 (SMGI-03)`**

1. **index.ts 엔트리포인트 생명주기 5단계:**

   | 단계 | 동작 | 실패 시 |
   |------|------|---------|
   | 1. SessionManager 생성 | new SessionManager(options) | 예외 없음 (생성자는 상태 초기화만) |
   | 2. SessionManager 시작 | await sessionManager.start() | catch → console.error, degraded mode 진입 |
   | 3. ApiClient 생성 | new ApiClient(sessionManager, baseUrl) | 예외 없음 |
   | 4. MCP Server 생성 + 연결 | createMcpServer(apiClient) + server.connect(transport) | throw → process.exit(1) |
   | 5. SIGTERM/SIGINT 핸들링 | sessionManager.dispose() → process.exit(0) | dispose는 안전 (timer 정리, 예외 무시) |

2. **Degraded mode 정의:**
   - SessionManager.start() 실패 = 토큰 없음 또는 만료된 토큰
   - state = 'expired' 또는 'error'
   - MCP Server는 정상 기동 (Claude Desktop과 stdio 연결 유지)
   - 모든 tool/resource 호출 시 ApiClient.request()가 getState() 확인 → expired 반환
   - toToolResult/toResourceResult가 안내 메시지 반환 (isError 미설정)
   - **에러 복구 루프** 활성화 (아래 정의)

3. **에러 복구 루프 설계 (SMGI-D03):**
   - **소속:** SessionManager 내부 메서드 `startRecoveryLoop()` / `stopRecoveryLoop()`
   - **트리거:** state가 'expired' 또는 'error'로 전환될 때 자동 시작
   - **중단:** state가 'active'로 전환될 때 자동 중단
   - **동작:** 60초 간격으로 readMcpToken() 호출, 새 토큰 발견 시:
     (1) decodeJwt로 디코딩 + 범위 검증
     (2) exp > now이면 토큰 교체 + state='active' + scheduleRenewal()
     (3) exp <= now이면 무시 (여전히 만료)
   - **타이머:** safeSetTimeout(recoveryCheck, 60_000) 체이닝 (setInterval 미사용, C-01 일관성)
   - **로그:** `[waiaas-mcp:session] Recovery: checking token file...` / `Recovery: found fresh token, resuming active mode`
   - **설계 결정 SMGI-D03:** `에러 복구 루프는 SessionManager 소속. ApiClient가 아닌 SessionManager가 세션 상태 관리 책임을 가지며, 토큰 파일 감시 역할을 한다. fs.watch 대신 주기적 polling으로 플랫폼 안정성 확보 (SM-12 일관).`

4. **Claude Desktop 재시작 시나리오:**
   - Claude Desktop 재시작 → MCP Server 프로세스 종료 + 새 프로세스 시작
   - 새 프로세스의 SessionManager.start():
     (1) readMcpToken()으로 파일에서 토큰 로드 (SM-04)
     (2) 이전 갱신에서 writeMcpToken으로 저장된 최신 토큰 존재 → 정상 시작
     (3) 파일 없으면 → env var fallback → 만료 가능성 → degraded mode + recovery loop
   - **핵심:** 이전 프로세스의 갱신 결과가 파일에 영속화되어 있으므로 (SM-10 파일-우선 쓰기), 재시작 시 최신 토큰 복원 가능

5. **갱신 도중 프로세스 kill 시나리오:**
   - renew() 7-step 중 Step 5(writeMcpToken) 전에 kill → 파일에 구 토큰, 메모리 소멸
   - renew() 7-step 중 Step 5 후, Step 6(메모리 교체) 전에 kill → 파일에 새 토큰, 메모리 소멸
   - 두 경우 모두 재시작 시 파일에서 로드 → 파일이 최신이면 새 토큰, 아니면 구 토큰
   - **보장:** SM-10(파일-우선 쓰기) 덕분에 파일은 항상 "적어도 마지막 성공 갱신" 상태
   - SIGTERM 수신 시 dispose()에서 renew() inflight 확인하지 않음 (isRenewing이 true여도 timer 정리 + exit). 갱신 API 응답이 도착하지 않으면 파일에 구 토큰 유지 (안전).

6. **TypeScript 의사 코드** -- index.ts main() 함수 (Research Example 4 기반):
   - SessionManager 생성 + try/catch start
   - ApiClient 생성
   - createMcpServer + StdioServerTransport 연결
   - SIGTERM/SIGINT → shutdown 함수
   - main().catch → Fatal 로그 + exit(1)

**참조:** Research Pattern 3, Pitfall 3(만료 환경변수), Pitfall 5(start 실패). SM-04, SM-10, SM-12.
  </action>
  <verify>
38-sdk-mcp-interface.md에서 다음을 확인:
1. `grep -c "6.5.5" .planning/deliverables/38-sdk-mcp-interface.md` -- 동시성 섹션 존재
2. `grep -c "6.5.6" .planning/deliverables/38-sdk-mcp-interface.md` -- 생명주기 섹션 존재
3. `grep -c "startRecoveryLoop\|recoveryLoop" .planning/deliverables/38-sdk-mcp-interface.md` -- 복구 루프 정의 존재
4. `grep -c "degraded" .planning/deliverables/38-sdk-mcp-interface.md` -- degraded mode 정의 존재
5. `grep -c "SMGI-D02\|SMGI-D03" .planning/deliverables/38-sdk-mcp-interface.md` -- 설계 결정 존재
6. `grep -c "SIGTERM" .planning/deliverables/38-sdk-mcp-interface.md` -- SIGTERM 처리 존재
  </verify>
  <done>
섹션 6.5.5, 6.5.6이 38-sdk-mcp-interface.md에 존재하고, 갱신 중 tool 호출 시퀀스 다이어그램, 50ms 대기 근거, 동시성 보장 테이블, 프로세스 5단계 생명주기, degraded mode 정의, 에러 복구 루프(startRecoveryLoop 60초 polling), Claude Desktop 재시작/프로세스 kill 시나리오, SIGTERM graceful shutdown이 모두 정의되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Claude Desktop 에러 처리 + objectives 반영</name>
  <files>
    .planning/deliverables/38-sdk-mcp-interface.md
    objectives/v0.9-session-management-automation.md
  </files>
  <action>
**Part A: 38-sdk-mcp-interface.md 섹션 6.5.7 신설**

**섹션 6.5.7 신설: `[v0.9] Claude Desktop 에러 처리 전략 (SMGI-04)`**

1. **isError 사용 원칙 테이블:**
   | 상황 | isError 설정 | 근거 |
   |------|------------|------|
   | API 에러 (400 Bad Request, 403 Forbidden 등) | true | 도구 실행 에러 (MCP 스펙 정상 사용) |
   | 세션 만료 (expired) | 미설정 | H-04: Claude Desktop 반복 에러 연결 해제 방지 |
   | 네트워크 에러 (daemon unavailable) | 미설정 | 일시적 문제, 연결 해제 방지 |
   | 정책 거부 (DELAY tier pending) | true | 정상적 도구 실행 에러 (사용자 행동 필요) |
   | Kill Switch 활성 (503) | 미설정 | 일시적 상태, 연결 해제 방지 |

2. **세션 만료 안내 메시지 형식:**
   ```json
   {
     "status": "session_expired",
     "message": "Session has expired. The owner has been notified. Please try again in a few minutes after a new session is created.",
     "hint": "Run 'waiaas mcp refresh-token' or use Telegram /newsession to create a new session.",
     "retryable": true
   }
   ```
   - `retryable: true`는 LLM이 나중에 재시도 가능함을 암시
   - `hint`는 사용자에게 복구 방법 안내 (CLI 또는 Telegram)

3. **데몬 미가동 안내 메시지 형식:**
   ```json
   {
     "status": "daemon_unavailable",
     "message": "WAIaaS daemon is not responding. Please check if the daemon is running with 'waiaas status'.",
     "retryable": true
   }
   ```

4. **Kill Switch 활성 안내 메시지 형식:**
   ```json
   {
     "status": "kill_switch_active",
     "message": "Emergency kill switch is active. All transaction operations are suspended.",
     "retryable": true
   }
   ```
   - 503 응답을 ApiClient.parseResponse()에서 감지하여 특별 처리
   - isError 미설정 (Kill Switch는 Owner가 해제할 때까지 지속, 반복 에러 방지)

5. **반복 에러 연결 해제 방지 종합 전략:**
   (a) isError를 일시적/복구 가능 에러에 사용하지 않음 (위 테이블)
   (b) 안내 메시지에 retryable: true 포함으로 LLM이 사용자에게 상황 설명
   (c) 에러 복구 루프(섹션 6.5.6)로 외부 토큰 감지 시 자동 복구
   (d) stdout 오염 방지: SessionManager/ApiClient 모든 로그 console.error 통일

6. **stdout 오염 방지 규칙:**
   - MCP stdio transport: stdout = JSON-RPC only, stderr = 로그
   - 금지: console.log, process.stdout.write (로그 용도)
   - 허용: console.error, process.stderr.write (로그 용도)
   - 로그 접두사 규약:
     - SessionManager: `[waiaas-mcp:session]`
     - ApiClient: `[waiaas-mcp:api-client]`
     - index.ts: `[waiaas-mcp]`
   - 설계 결정 SMGI-D04: `console.log 사용 금지. 모든 내부 로그를 console.error로 통일. stdio transport에서 stdout 오염은 JSON-RPC 파싱 실패 → 즉시 연결 해제를 유발한다.`

7. **Phase 38 설계 결정 요약 테이블:**
   | ID | 결정 | 근거 |
   |----|------|------|
   | SMGI-D01 | getState() 4번째 public 메서드 추가 | ApiClient의 세션 상태 사전 확인 필요 |
   | SMGI-D02 | Mutex/Lock 미사용, 50ms 대기 + 401 재시도 | Node.js 단일 스레드, 차단 지연 방지 |
   | SMGI-D03 | 에러 복구 루프 SessionManager 소속, 60초 polling | fs.watch 대신 안정적 polling, SM-12 일관 |
   | SMGI-D04 | console.log 금지, console.error 통일 | stdio stdout 오염 → JSON-RPC 파싱 실패 방지 |

문서 헤더에 `Phase 38-02: 동시성 + 생명주기 + 에러 처리` 추가.
문서 푸터(v0.9 참조 문서 섹션)에 Phase 38 참조 추가.

**Part B: objectives/v0.9-session-management-automation.md 업데이트**

1. SMGI-01~04 관련 섹션에 `[설계 확정 -- Phase 38]` 태그 추가
2. 영향받는 설계 문서 테이블의 SDK-MCP 행에 `[설계 완료: Phase 37-01 + 37-02 + 38-01 + 38-02]` 업데이트
3. Phase 38 설계 결과 섹션 신설: SMGI-D01~D04 핵심 설계 결정 4건
4. 문서 푸터에 Phase 38 업데이트 이력 추가
  </action>
  <verify>
38-sdk-mcp-interface.md에서:
1. `grep -c "6.5.7" .planning/deliverables/38-sdk-mcp-interface.md` -- 에러 처리 섹션 존재
2. `grep -c "isError" .planning/deliverables/38-sdk-mcp-interface.md` -- isError 원칙 존재
3. `grep -c "SMGI-D04" .planning/deliverables/38-sdk-mcp-interface.md` -- 설계 결정 존재
4. `grep -c "console.error" .planning/deliverables/38-sdk-mcp-interface.md` -- stdout 규칙 존재
5. `grep -c "kill_switch_active" .planning/deliverables/38-sdk-mcp-interface.md` -- Kill Switch 처리 존재

objectives에서:
6. `grep -c "Phase 38" objectives/v0.9-session-management-automation.md` -- Phase 38 반영
7. `grep -c "SMGI-D0" objectives/v0.9-session-management-automation.md` -- 설계 결정 반영
  </verify>
  <done>
섹션 6.5.7이 38-sdk-mcp-interface.md에 존재하고, isError 사용 원칙 5종 테이블, 세션 만료/데몬 미가동/Kill Switch 안내 메시지 JSON 형식, 반복 에러 연결 해제 방지 4가지 전략, stdout 오염 방지 규칙, SMGI-D01~D04 결정 요약 테이블이 정의되어 있다. objectives 문서에 Phase 38 설계 결과(SMGI-D01~D04)와 [설계 확정] 태그가 반영되어 있다.
  </done>
</task>

</tasks>

<verification>
Phase 38 Plan 02 전체 검증:
1. 섹션 6.5.5 (동시성) + 6.5.6 (생명주기) + 6.5.7 (에러 처리)가 38-sdk-mcp-interface.md에 존재
2. SMGI-02, SMGI-03, SMGI-04 요구사항 참조가 각 섹션에 포함
3. 에러 복구 루프(startRecoveryLoop)가 SessionManager 소속으로 설계
4. isError 회피 원칙이 expired/networkError/killSwitch에 적용
5. objectives에 Phase 38 설계 완료 반영
6. 기존 섹션 6.4.x, 6.5.1~6.5.4 (Plan 38-01 내용) 손상 없음
</verification>

<success_criteria>
- 갱신 중 tool 호출 동시성 시퀀스 다이어그램과 50ms 대기 근거가 설계 문서에 정의되어 있다
- 프로세스 5단계 생명주기와 degraded mode가 정의되어 있다
- 에러 복구 루프(60초 파일 polling)가 SessionManager 내부 메서드로 설계되어 있다
- Claude Desktop 재시작/프로세스 kill 시나리오의 토큰 복원 보장이 정의되어 있다
- isError 사용 원칙 5종과 3가지 안내 메시지 JSON 형식이 정의되어 있다
- stdout 오염 방지 규칙(console.log 금지)이 명시되어 있다
- objectives에 Phase 38 설계 결정(SMGI-D01~D04)이 반영되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/38-sessionmanager-mcp-integration/38-02-SUMMARY.md`
</output>
