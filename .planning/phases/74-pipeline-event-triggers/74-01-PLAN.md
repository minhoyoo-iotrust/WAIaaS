---
phase: 74-pipeline-event-triggers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/pipeline/pipeline.ts
  - packages/daemon/src/pipeline/index.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/pipeline-notification.test.ts
autonomous: true

must_haves:
  truths:
    - "stage1Validate 완료 후 TX_REQUESTED notify가 fire-and-forget으로 호출된다"
    - "stage3Policy에서 POLICY_DENIED 시 POLICY_VIOLATION notify가 호출된다"
    - "stage5Execute 완료 후 TX_SUBMITTED notify가 호출된다"
    - "stage5Execute 실패 시 TX_FAILED notify가 호출된다"
    - "stage6Confirm 성공 시 TX_CONFIRMED notify가 호출된다"
    - "stage6Confirm 실패 시 TX_FAILED notify가 호출된다"
    - "notify 호출이 파이프라인 실행을 차단하지 않는다 (void fire-and-forget)"
  artifacts:
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "각 stage에서 NotificationService.notify() fire-and-forget 호출"
      contains: "notify"
    - path: "packages/daemon/src/__tests__/pipeline-notification.test.ts"
      provides: "파이프라인 stage 알림 트리거 테스트"
  key_links:
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "PipelineContext.notificationService?.notify()"
      pattern: "notificationService.*notify"
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/api/server.ts"
      via: "TransactionRouteDeps.notificationService passes to PipelineContext"
      pattern: "notificationService"
---

<objective>
파이프라인 스테이지(1/3/5/6)에서 주요 이벤트 발생 시 NotificationService.notify()를 fire-and-forget으로 호출하여 TX_REQUESTED, POLICY_VIOLATION, TX_SUBMITTED, TX_FAILED, TX_CONFIRMED 알림이 실제로 발송되도록 연결한다.

Purpose: 파이프라인에서 발생하는 트랜잭션 이벤트를 알림 시스템에 연결하여 사용자가 실시간으로 거래 상태 변화를 통보받을 수 있도록 한다.
Output: 파이프라인 stages에 notify() 호출이 추가되고, PipelineContext를 통해 NotificationService가 전달되며, 테스트로 검증된다.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/73-notification-log-infra/73-01-SUMMARY.md
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/pipeline/pipeline.ts
@packages/daemon/src/pipeline/index.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/notifications/notification-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: PipelineContext에 NotificationService 추가 + 각 stage에 fire-and-forget notify() 연결</name>
  <files>
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/pipeline/pipeline.ts
    packages/daemon/src/pipeline/index.ts
    packages/daemon/src/api/routes/transactions.ts
    packages/daemon/src/api/server.ts
  </files>
  <action>
1. **PipelineContext 확장** (`stages.ts`):
   - `PipelineContext` interface에 `notificationService?: NotificationService` 필드 추가 (optional, import type로 가져오기)
   - `import type { NotificationService } from '../notifications/notification-service.js';` 추가

2. **stage1Validate 수정** (`stages.ts`):
   - DB INSERT 후, 함수 끝에 fire-and-forget으로 TX_REQUESTED 알림 발송:
   ```ts
   void ctx.notificationService?.notify('TX_REQUESTED', ctx.agentId, {
     amount: ctx.request.amount,
     to: ctx.request.to,
   }, { txId: ctx.txId });
   ```
   - `void` prefix로 Promise를 fire-and-forget 처리 (파이프라인 차단 금지 결정 준수)

3. **stage3Policy 수정** (`stages.ts`):
   - `evaluation.allowed === false` 블록에서 WAIaaSError throw 직전에:
   ```ts
   void ctx.notificationService?.notify('POLICY_VIOLATION', ctx.agentId, {
     reason: evaluation.reason ?? 'Policy denied',
     amount: ctx.request.amount,
     to: ctx.request.to,
   }, { txId: ctx.txId });
   ```

4. **stage5Execute 수정** (`stages.ts`):
   - submitTransaction 성공 후 DB UPDATE 직후에 TX_SUBMITTED 알림:
   ```ts
   void ctx.notificationService?.notify('TX_SUBMITTED', ctx.agentId, {
     txHash: ctx.submitResult.txHash,
     amount: ctx.request.amount,
     to: ctx.request.to,
   }, { txId: ctx.txId });
   ```
   - simulateTransaction 실패 시 (SIMULATION_FAILED throw 직전):
   ```ts
   void ctx.notificationService?.notify('TX_FAILED', ctx.agentId, {
     reason: simResult.error ?? 'Simulation failed',
     amount: ctx.request.amount,
   }, { txId: ctx.txId });
   ```

5. **stage6Confirm 수정** (`stages.ts`):
   - 성공 시 (CONFIRMED DB UPDATE 직후):
   ```ts
   void ctx.notificationService?.notify('TX_CONFIRMED', ctx.agentId, {
     txHash: ctx.submitResult!.txHash,
     amount: ctx.request.amount,
     to: ctx.request.to,
   }, { txId: ctx.txId });
   ```
   - 실패 시 (FAILED DB UPDATE 직후, throw 직전):
   ```ts
   void ctx.notificationService?.notify('TX_FAILED', ctx.agentId, {
     reason: errorMessage,
     amount: ctx.request.amount,
   }, { txId: ctx.txId });
   ```

6. **TransactionRouteDeps 확장** (`transactions.ts`):
   - `TransactionRouteDeps` interface에 `notificationService?: NotificationService` 추가
   - import type 추가: `import type { NotificationService } from '../../notifications/notification-service.js';`
   - POST /transactions/send 핸들러에서 `PipelineContext` 생성 시 `notificationService: deps.notificationService`를 포함

7. **createApp() 수정** (`server.ts`):
   - transaction routes 등록 시 `notificationService: deps.notificationService`를 TransactionRouteDeps에 전달

8. **TransactionPipeline 수정** (`pipeline.ts`):
   - `PipelineDeps` interface에 `notificationService?: NotificationService` 추가 (import type)
   - `executeSend`에서 PipelineContext 생성 시 `notificationService: this.deps.notificationService` 포함
   - NOTE: TransactionPipeline은 현재 route handler에서 직접 사용되지 않지만 (route handler가 stages를 직접 호출), 향후 호환성을 위해 추가

기존 테스트 영향: PipelineContext에 optional 필드가 추가되므로 기존 테스트에서 notificationService를 전달하지 않아도 정상 동작 (optional chaining `?.notify()` 사용)
  </action>
  <verify>
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build --filter=@waiaas/daemon` 빌드 성공
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --project daemon --reporter=verbose 2>&1 | tail -20` 기존 테스트 통과
  </verify>
  <done>
  - PipelineContext에 optional notificationService 필드가 존재
  - stage1/3/5/6에서 notify()가 fire-and-forget으로 호출됨
  - TransactionRouteDeps와 createApp()에서 notificationService가 전달됨
  - 기존 테스트 모두 통과 (optional이므로 미전달 시 no-op)
  </done>
</task>

<task type="auto">
  <name>Task 2: 파이프라인 알림 트리거 단위 테스트</name>
  <files>
    packages/daemon/src/__tests__/pipeline-notification.test.ts
  </files>
  <action>
새 테스트 파일 `pipeline-notification.test.ts` 생성. 각 stage에서 올바른 이벤트 타입으로 notify()가 호출되는지 검증한다.

**테스트 구조:**
```ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
```

1. **Mock NotificationService** 생성:
   - `{ notify: vi.fn().mockResolvedValue(undefined) }` 형태의 mock 객체
   - PipelineContext에 `notificationService`로 주입

2. **테스트용 DB + mock adapter 셋업:**
   - 기존 pipeline.test.ts 패턴을 참조하여 in-memory SQLite + Drizzle DB 셋업
   - mock adapter: `buildTransaction`, `simulateTransaction`, `signTransaction`, `submitTransaction`, `waitForConfirmation` 모두 mock
   - mock keyStore: `decryptPrivateKey` -> Uint8Array, `releaseKey` -> void
   - mock policyEngine: `evaluate` -> `{ allowed: true, tier: 'INSTANT' }`

3. **테스트 케이스 (7개):**

   a. `stage1Validate: TX_REQUESTED 알림 발송` — stage1 호출 후 notificationService.notify가 'TX_REQUESTED'로 호출됨 확인

   b. `stage3Policy: POLICY_VIOLATION 알림 발송 (정책 거부)` — policyEngine.evaluate가 `{ allowed: false, reason: 'limit exceeded' }` 반환 시, notify가 'POLICY_VIOLATION'으로 호출됨 확인 (WAIaaSError도 throw됨)

   c. `stage5Execute: TX_SUBMITTED 알림 발송 (성공)` — 모든 mock 성공 시, notify가 'TX_SUBMITTED'으로 호출됨 확인

   d. `stage5Execute: TX_FAILED 알림 발송 (시뮬레이션 실패)` — simulateTransaction이 `{ success: false, error: 'sim fail' }` 반환 시, notify가 'TX_FAILED'로 호출됨 확인

   e. `stage6Confirm: TX_CONFIRMED 알림 발송 (성공)` — waitForConfirmation 성공 시 notify가 'TX_CONFIRMED'으로 호출됨 확인

   f. `stage6Confirm: TX_FAILED 알림 발송 (확인 실패)` — waitForConfirmation throw 시 notify가 'TX_FAILED'로 호출됨 확인

   g. `notify 미설정 시 stage가 정상 동작` — notificationService를 undefined로 설정하고 stage1-6 전체 실행 시 에러 없이 정상 완료됨 확인 (optional chaining 안전성)

4. **fire-and-forget 검증:**
   - notify mock이 reject해도 stage가 정상 완료되는 추가 테스트 (notify가 throw해도 파이프라인 차단 안 됨을 검증):
   ```ts
   notifyMock.mockRejectedValueOnce(new Error('channel down'));
   await expect(stage1Validate(ctx)).resolves.not.toThrow();
   ```
   단, void fire-and-forget이므로 이 테스트에서는 unhandled rejection이 발생하지 않음을 확인.
   NOTE: `void promise`는 rejection을 무시하지 않음. 만약 notify 내부에서 try/catch를 안 하면 unhandled rejection이 될 수 있음. 하지만 NotificationService.notify()는 이미 내부에서 모든 에러를 catch하므로 (sendWithFallback/broadcast의 구조), 실제로는 reject하지 않음. 테스트에서는 mock을 사용하므로 이 점을 고려하여, reject 시에도 void로 인해 stage 자체는 영향 없음을 확인.

기존 pipeline.test.ts, pipeline-integration.test.ts 패턴을 참조하여 DB setup/teardown 구조를 맞춘다.
  </action>
  <verify>
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/daemon/src/__tests__/pipeline-notification.test.ts --reporter=verbose` 모든 테스트 통과
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --project daemon --reporter=verbose 2>&1 | tail -20` 기존 + 신규 테스트 통과
  </verify>
  <done>
  - 7+ 테스트 케이스가 pipeline-notification.test.ts에 존재
  - TX_REQUESTED, POLICY_VIOLATION, TX_SUBMITTED, TX_FAILED, TX_CONFIRMED 각 이벤트에 대한 notify() 호출이 검증됨
  - notificationService 미설정 시 정상 동작이 검증됨
  - 전체 daemon 테스트 스위트 통과
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build` — 전체 모노레포 빌드 성공
2. `npx vitest run --project daemon` — 기존 + 신규 테스트 모두 통과
3. `grep -r 'void ctx.notificationService' packages/daemon/src/pipeline/stages.ts` — 5개 이상 fire-and-forget 호출 확인
4. pipeline-notification.test.ts 통과
</verification>

<success_criteria>
- 파이프라인 stage1에서 TX_REQUESTED 알림이 fire-and-forget으로 발송된다 (TRIG-01)
- 파이프라인 stage3에서 정책 위반 시 POLICY_VIOLATION 알림이 발송된다 (TRIG-05)
- 파이프라인 stage5에서 TX_SUBMITTED/TX_FAILED 알림이 발송된다 (TRIG-02, TRIG-04)
- 파이프라인 stage6에서 TX_CONFIRMED/TX_FAILED 알림이 발송된다 (TRIG-03, TRIG-04)
- 알림 발송이 파이프라인 실행을 차단하지 않는다
- 기존 863 테스트가 깨지지 않는다
</success_criteria>

<output>
After completion, create `.planning/phases/74-pipeline-event-triggers/74-01-SUMMARY.md`
</output>
