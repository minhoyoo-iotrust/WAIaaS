---
phase: 74-pipeline-event-triggers
plan: 02
type: execute
wave: 2
depends_on: ["74-01"]
files_modified:
  - packages/daemon/src/api/routes/sessions.ts
  - packages/daemon/src/api/routes/agents.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/route-notification.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /sessions 성공 시 SESSION_CREATED notify가 호출된다"
    - "세션 만료 처리(background worker) 시 SESSION_EXPIRED notify가 호출된다"
    - "PUT /agents/:id/owner 성공 시 OWNER_SET notify가 호출된다"
    - "알림 발송이 라우트 응답을 차단하지 않는다 (fire-and-forget)"
  artifacts:
    - path: "packages/daemon/src/api/routes/sessions.ts"
      provides: "POST /sessions에서 SESSION_CREATED notify 호출"
      contains: "notify.*SESSION_CREATED"
    - path: "packages/daemon/src/api/routes/agents.ts"
      provides: "PUT /agents/:id/owner에서 OWNER_SET notify 호출"
      contains: "notify.*OWNER_SET"
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "session-cleanup worker에서 SESSION_EXPIRED notify 호출"
      contains: "notify.*SESSION_EXPIRED"
    - path: "packages/daemon/src/__tests__/route-notification.test.ts"
      provides: "라우트 핸들러 알림 트리거 테스트"
  key_links:
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "SessionRouteDeps.notificationService?.notify()"
      pattern: "notificationService.*notify"
    - from: "packages/daemon/src/api/routes/agents.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "AgentRouteDeps.notificationService?.notify()"
      pattern: "notificationService.*notify"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "this.notificationService?.notify() in session-cleanup worker"
      pattern: "notificationService.*notify.*SESSION_EXPIRED"
---

<objective>
라우트 핸들러(세션 생성, Owner 등록)와 백그라운드 워커(세션 만료)에서 주요 이벤트 발생 시 NotificationService.notify()를 fire-and-forget으로 호출하여 SESSION_CREATED, SESSION_EXPIRED, OWNER_SET 알림이 실제로 발송되도록 연결한다.

Purpose: 파이프라인 외부의 주요 이벤트(세션 생성/만료, Owner 등록)도 알림으로 전달하여 사용자가 데몬의 모든 중요 상태 변화를 통보받을 수 있도록 한다.
Output: sessions.ts, agents.ts 라우트에 notify() 호출이 추가되고, daemon.ts의 session-cleanup worker에 SESSION_EXPIRED 알림이 추가되며, 테스트로 검증된다.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-pipeline-event-triggers/74-01-SUMMARY.md
@packages/daemon/src/api/routes/sessions.ts
@packages/daemon/src/api/routes/agents.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/notifications/notification-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: 라우트 핸들러 + 백그라운드 워커에 notify() 연결</name>
  <files>
    packages/daemon/src/api/routes/sessions.ts
    packages/daemon/src/api/routes/agents.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/lifecycle/daemon.ts
  </files>
  <action>
1. **SessionRouteDeps 확장** (`sessions.ts`):
   - `SessionRouteDeps` interface에 `notificationService?: NotificationService` 추가
   - `import type { NotificationService } from '../../notifications/notification-service.js';` 추가
   - POST /sessions 핸들러에서, 성공 응답(c.json 201) 직전에 fire-and-forget:
   ```ts
   void deps.notificationService?.notify('SESSION_CREATED', parsed.agentId, {
     sessionId,
   });
   ```
   - 위치: `deps.db.insert(sessions).values(...)` 및 `c.json(...)` 사이. 정확히는 insert 후, return c.json 직전에 배치.

2. **AgentRouteDeps 확장** (`agents.ts`):
   - `AgentRouteDeps` interface에 `notificationService?: NotificationService` 추가
   - `import type { NotificationService } from '../../notifications/notification-service.js';` 추가
   - PUT /agents/:id/owner 핸들러에서, `ownerLifecycle.setOwner()` 호출 성공 후, return c.json 직전에:
   ```ts
   void deps.notificationService?.notify('OWNER_SET', agentId, {
     ownerAddress,
   });
   ```

3. **createApp() 수정** (`server.ts`):
   - session routes 등록 시 `notificationService: deps.notificationService`를 SessionRouteDeps에 전달
   - agent routes 등록 시 `notificationService: deps.notificationService`를 AgentRouteDeps에 전달

4. **session-cleanup worker 수정** (`daemon.ts`):
   - 현재 session-cleanup worker는 `this.sqlite.exec("DELETE FROM sessions WHERE expires_at < unixepoch() AND revoked_at IS NULL")` 로 만료 세션을 삭제만 함
   - 수정: 삭제 전에 만료된 세션 목록을 먼저 조회하여 각각에 대해 SESSION_EXPIRED 알림을 fire-and-forget으로 발송
   ```ts
   this.workers.register('session-cleanup', {
     interval: 60_000,
     handler: () => {
       if (this.sqlite && !this._isShuttingDown) {
         // Notify expired sessions before deletion (fire-and-forget)
         if (this.notificationService && this._db) {
           try {
             const { sessions } = require('../infrastructure/database/schema.js');
             // Use raw SQL to find expiring sessions
             const expired = this.sqlite.prepare(
               "SELECT id, agent_id FROM sessions WHERE expires_at < unixepoch() AND revoked_at IS NULL"
             ).all() as Array<{ id: string; agent_id: string }>;
             for (const session of expired) {
               void this.notificationService.notify('SESSION_EXPIRED', session.agent_id, {
                 sessionId: session.id,
               });
             }
           } catch {
             // Fire-and-forget: never block cleanup
           }
         }
         this.sqlite.exec(
           "DELETE FROM sessions WHERE expires_at < unixepoch() AND revoked_at IS NULL",
         );
       }
     },
   });
   ```
   - NOTE: raw SQL을 사용하는 이유는 better-sqlite3 prepare/all이 동기이고, 기존 패턴과 일치하기 때문. Drizzle select보다 경량.
   - NOTE: require() 대신 이미 daemon.ts 상단에서 schema를 import하지 않으므로, raw SQL prepare()를 사용. 컬럼명은 snake_case (DB 컬럼명).

5. **기존 테스트 영향 없음 확인:**
   - SessionRouteDeps, AgentRouteDeps에 optional 필드만 추가되므로 기존 테스트는 notificationService를 전달하지 않아도 동작함
   - daemon.ts의 session-cleanup은 notificationService가 null이면 기존 로직만 실행됨
  </action>
  <verify>
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build --filter=@waiaas/daemon` 빌드 성공
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --project daemon --reporter=verbose 2>&1 | tail -20` 기존 테스트 통과
  </verify>
  <done>
  - SessionRouteDeps에 optional notificationService 필드가 존재
  - AgentRouteDeps에 optional notificationService 필드가 존재
  - POST /sessions에서 SESSION_CREATED notify 호출
  - PUT /agents/:id/owner에서 OWNER_SET notify 호출
  - session-cleanup worker에서 SESSION_EXPIRED notify 호출 (삭제 전 조회)
  - createApp()에서 notificationService가 session/agent route deps에 전달됨
  - 기존 테스트 모두 통과
  </done>
</task>

<task type="auto">
  <name>Task 2: 라우트 핸들러 알림 트리거 테스트 + 전체 통합 검증</name>
  <files>
    packages/daemon/src/__tests__/route-notification.test.ts
  </files>
  <action>
새 테스트 파일 `route-notification.test.ts` 생성. 라우트 핸들러와 백그라운드 워커에서 올바른 이벤트 타입으로 notify()가 호출되는지 검증한다.

**테스트 구조:**
기존 api-sessions.test.ts, api-agents.test.ts 패턴을 참조하여 createApp() + fetch() 기반 통합 테스트를 구성한다.

1. **셋업:**
   - in-memory SQLite + Drizzle DB + pushSchema
   - JwtSecretManager (real) for session creation
   - masterPasswordHash (Argon2id hash)
   - mock NotificationService: `{ notify: vi.fn().mockResolvedValue(undefined), addChannel: vi.fn(), getChannelNames: vi.fn().mockReturnValue([]) }` 형태의 mock 객체
   - createApp()에 mock notificationService 전달

2. **테스트 케이스 (5개):**

   a. `POST /sessions 성공 시 SESSION_CREATED notify 호출`:
     - agent 생성 (DB insert) -> POST /v1/sessions { agentId } -> 201
     - notifyMock이 'SESSION_CREATED', agentId, { sessionId: expect.any(String) }로 호출되었는지 확인

   b. `PUT /agents/:id/owner 성공 시 OWNER_SET notify 호출`:
     - agent 생성 (DB insert) -> PUT /v1/agents/:id/owner { owner_address: "..." } -> 200
     - notifyMock이 'OWNER_SET', agentId, { ownerAddress: "..." }로 호출되었는지 확인

   c. `notificationService 미설정 시 POST /sessions 정상 동작`:
     - createApp()에서 notificationService를 undefined로 전달
     - POST /v1/sessions -> 201 정상 응답 (notify 호출 없어도 에러 없음)

   d. `notificationService 미설정 시 PUT /agents/:id/owner 정상 동작`:
     - notificationService 없이 PUT /v1/agents/:id/owner -> 200 정상 응답

   e. `SESSION_EXPIRED notify는 세션 만료 시 호출된다` (단위 테스트):
     - daemon.ts의 session-cleanup worker를 직접 테스트하기 어려우므로, 대안:
     - in-memory DB에 만료된 세션(expires_at < now)을 INSERT
     - raw SQL로 만료 세션 조회 후 notify 호출하는 로직을 추출하여 테스트
     - 또는: daemon.ts 테스트가 아닌 경우, 세션 만료 알림 로직을 별도 헬퍼로 추출하여 테스트할 수 있으나, 범위를 최소화하여:
       - sqlite.prepare()로 만료 세션 조회 → notificationService.notify('SESSION_EXPIRED') 호출 패턴을 검증하는 단위 테스트 작성
       - 테스트에서 직접 만료된 세션을 DB에 INSERT하고, 조회 + notify 패턴이 동작하는지 확인

3. **전체 daemon 테스트 스위트 실행:**
   - 기존 모든 테스트 + 74-01의 pipeline-notification.test.ts + 74-02의 route-notification.test.ts 전체 통과 확인

기존 api-sessions.test.ts의 셋업 패턴(masterAuth 처리, agent 생성, JWT 발급)을 참조. X-Master-Password 헤더 필요.
  </action>
  <verify>
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run packages/daemon/src/__tests__/route-notification.test.ts --reporter=verbose` 모든 테스트 통과
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --project daemon --reporter=verbose 2>&1 | tail -20` 전체 테스트 통과
  - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build` 전체 빌드 성공
  </verify>
  <done>
  - 5+ 테스트 케이스가 route-notification.test.ts에 존재
  - SESSION_CREATED, SESSION_EXPIRED, OWNER_SET 각 이벤트에 대한 notify() 호출이 검증됨
  - notificationService 미설정 시 정상 동작이 검증됨
  - 전체 daemon 테스트 스위트 통과 (기존 + 74-01 + 74-02)
  - TRIG-06 (SESSION_CREATED), TRIG-07 (SESSION_EXPIRED), TRIG-08 (OWNER_SET) 충족
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build` — 전체 모노레포 빌드 성공
2. `npx vitest run --project daemon` — 기존 + 74-01 + 74-02 테스트 모두 통과
3. `grep -r 'notificationService.*notify' packages/daemon/src/api/routes/sessions.ts` — SESSION_CREATED 호출 확인
4. `grep -r 'notificationService.*notify' packages/daemon/src/api/routes/agents.ts` — OWNER_SET 호출 확인
5. `grep -r 'SESSION_EXPIRED' packages/daemon/src/lifecycle/daemon.ts` — worker에서 SESSION_EXPIRED 호출 확인
</verification>

<success_criteria>
- POST /v1/sessions 성공 시 SESSION_CREATED 알림이 발송된다 (TRIG-06)
- 세션 만료 처리 시 SESSION_EXPIRED 알림이 발송된다 (TRIG-07)
- PUT /v1/agents/:id/owner 성공 시 OWNER_SET 알림이 발송된다 (TRIG-08)
- 알림 발송이 라우트 응답을 차단하지 않는다 (fire-and-forget)
- 기존 863 테스트가 깨지지 않는다
</success_criteria>

<output>
After completion, create `.planning/phases/74-pipeline-event-triggers/74-02-SUMMARY.md`
</output>
