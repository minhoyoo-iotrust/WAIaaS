---
phase: 131-ssrf-guard-x402-handler-payment-signing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/x402/ssrf-guard.ts
  - packages/daemon/src/__tests__/ssrf-guard.test.ts
autonomous: true

must_haves:
  truths:
    - "사설 IP(10.x, 172.16-31.x, 192.168.x, 127.x)/localhost/링크 로컬(169.254.x)/loopback(::1) 주소가 모두 차단된다"
    - "IPv4-mapped IPv6(::ffff:127.0.0.1), 옥탈(0177.0.0.1), 16진수(0x7f000001), 10진수 IP 등 우회 벡터가 차단된다"
    - "리다이렉트 매 hop에서 대상 IP가 재검증되고 최대 3회로 제한된다"
    - "HTTPS만 허용되고 HTTP URL은 거부된다"
    - "URL 정규화(hostname lowercase, trailing dot 제거, userinfo@ 거부, 포트 443 전용)가 동작한다"
  artifacts:
    - path: "packages/daemon/src/services/x402/ssrf-guard.ts"
      provides: "SSRF 가드 모듈 (validateUrlSafety, safeFetchWithRedirects, assertPublicIP)"
      exports: ["validateUrlSafety", "safeFetchWithRedirects"]
    - path: "packages/daemon/src/__tests__/ssrf-guard.test.ts"
      provides: "SSRF 가드 테스트 (사설 IP, 우회 벡터, 리다이렉트, 프로토콜, URL 정규화)"
  key_links:
    - from: "packages/daemon/src/services/x402/ssrf-guard.ts"
      to: "node:dns/promises"
      via: "dns.lookup({all:true}) DNS 사전 해석"
      pattern: "lookup.*all.*true"
    - from: "packages/daemon/src/services/x402/ssrf-guard.ts"
      to: "@waiaas/core WAIaaSError"
      via: "X402_SSRF_BLOCKED 에러 throw"
      pattern: "WAIaaSError.*X402_SSRF_BLOCKED"
---

<objective>
SSRF 가드 모듈을 TDD로 구현하여 x402 핸들러가 외부 URL로 HTTP 요청 시 사설 IP/우회 벡터/비안전 프로토콜을 차단하는 보안 계층을 제공한다.

Purpose: x402 핸들러는 에이전트가 제공한 외부 URL로 HTTP 프록시를 수행하므로, SSRF가 가장 큰 공격 표면이다. DNS 사전 해석 + 사설 IP 차단 + 리다이렉트 재검증으로 다층 방어를 구현한다.
Output: ssrf-guard.ts (검증 모듈) + ssrf-guard.test.ts (포괄적 바이패스 벡터 테스트)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-RESEARCH.md

# Phase 130 types (needed for WAIaaSError import)
@packages/core/src/errors/error-codes.ts (X402_SSRF_BLOCKED 에러 코드 정의 확인)
@packages/core/src/errors/base-error.ts (WAIaaSError 사용법)
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSRF 가드 테스트 작성 (RED)</name>
  <files>packages/daemon/src/__tests__/ssrf-guard.test.ts</files>
  <action>
SSRF 가드의 모든 방어 계층을 검증하는 테스트를 먼저 작성한다. `packages/daemon/src/__tests__/ssrf-guard.test.ts`에 작성.

node:dns/promises의 `lookup`을 vi.mock으로 모킹하여 DNS 해석 결과를 제어한다. global fetch도 vi.fn()으로 모킹한다.

**테스트 그룹 및 케이스:**

1. **URL 정규화 (normalizeUrl)**
   - trailing dot 제거: `https://example.com./path` -> hostname `example.com`
   - hostname lowercase: `https://EXAMPLE.COM/` -> `example.com`
   - userinfo@ 거부: `https://user:pass@example.com/` -> X402_SSRF_BLOCKED
   - 포트 검증: `https://example.com:8443/` -> X402_SSRF_BLOCKED (443 아닌 포트)
   - 빈 포트(기본 443) 허용: `https://example.com/path` -> 통과

2. **프로토콜 검증 (HTTPS 강제)**
   - HTTP 거부: `http://example.com/` -> X402_SSRF_BLOCKED
   - HTTPS 허용: `https://example.com/` -> 통과

3. **사설 IPv4 차단 (X4SEC-01)**
   - `10.0.0.1` (10.0.0.0/8)
   - `172.16.0.1` (172.16.0.0/12)
   - `172.31.255.255` (172.16.0.0/12 상한)
   - `192.168.1.1` (192.168.0.0/16)
   - `127.0.0.1` (loopback)
   - `127.255.255.255` (loopback 상한)
   - `169.254.1.1` (link-local)
   - `0.0.0.0` (this network)
   - `100.64.0.1` (CGNAT)
   - `224.0.0.1` (multicast)
   - `240.0.0.1` (reserved)
   - `255.255.255.255` (broadcast)
   - 각각 DNS lookup 모킹 결과가 해당 IP를 반환하면 X402_SSRF_BLOCKED

4. **사설 IPv6 차단 (X4SEC-01)**
   - `::1` (loopback)
   - `::` (unspecified)
   - `fe80::1` (link-local)
   - `fc00::1` (unique local)
   - `fd00::1` (unique local)
   - `ff02::1` (multicast)

5. **우회 벡터 차단 (X4SEC-02)**
   - IPv4-mapped IPv6 dotted: `::ffff:127.0.0.1` -> 차단
   - IPv4-mapped IPv6 dotted private: `::ffff:10.0.0.1` -> 차단
   - IPv4-mapped IPv6 hex: `::ffff:7f00:0001` -> 차단
   - 16진수 hostname (직접 IP가 아닌 경우 DNS에서 해석): DNS 해석 결과가 사설이면 차단
   - 10진수 IP hostname (2130706433 = 127.0.0.1): DNS 해석 결과가 사설이면 차단

6. **공용 IP 허용**
   - DNS가 `8.8.8.8` 반환 시 통과
   - DNS가 `2001:4860:4860::8888` 반환 시 통과
   - 다중 IP 반환 시 모두 공용이면 통과

7. **다중 IP에서 일부 사설 시 차단**
   - DNS가 `[8.8.8.8, 10.0.0.1]` 반환 -> 차단 (하나라도 사설이면)

8. **리다이렉트 재검증 (X4SEC-03) - safeFetchWithRedirects**
   - 정상 리다이렉트 (공용 IP -> 공용 IP): 3xx + Location 따라감
   - 리다이렉트 대상이 사설 IP: 차단
   - 리다이렉트 대상이 HTTP: 차단
   - 최대 3회 초과 리다이렉트: X402_SSRF_BLOCKED
   - 비-리다이렉트 응답(200, 402, 500): 그대로 반환

각 테스트는 `expect(() => validateUrlSafety(url)).rejects.toThrow(WAIaaSError)` 패턴으로, 에러 코드가 `X402_SSRF_BLOCKED`인지 검증한다.

**모킹 패턴:**
```typescript
vi.mock('node:dns/promises', () => ({
  lookup: vi.fn(),
}));
import { lookup } from 'node:dns/promises';
const mockLookup = vi.mocked(lookup);
```

테스트 실행 시 모든 테스트가 FAIL해야 한다 (구현체 없으므로).
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/ssrf-guard.test.ts` 실행 시 모든 테스트가 FAIL (RED 단계).
단, import 에러가 아닌 assertion 에러여야 한다 -- 빈 stub 파일이라도 존재해야 하므로, `packages/daemon/src/services/x402/ssrf-guard.ts`에 export 스텁을 먼저 만든다.
  </verify>
  <done>
SSRF 가드 테스트가 20개 이상 작성되고, 사설 IP/우회 벡터/리다이렉트/프로토콜/URL 정규화를 포괄하며, 모두 FAIL 상태이다.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSRF 가드 구현 (GREEN + REFACTOR)</name>
  <files>packages/daemon/src/services/x402/ssrf-guard.ts</files>
  <action>
모든 RED 테스트를 통과시키는 SSRF 가드를 구현한다. `packages/daemon/src/services/x402/ssrf-guard.ts`에 작성.

**구현 순서:**

1. **normalizeUrl(urlString: string): URL**
   - `new URL(urlString)`으로 파싱
   - trailing dot 제거: `hostname.endsWith('.') -> hostname.slice(0, -1)`
   - 소문자는 URL constructor가 자동 처리

2. **validateUrlSafety(urlString: string): Promise<URL>**
   - `normalizeUrl()`로 정규화
   - 프로토콜 검증: `url.protocol !== 'https:'` -> X402_SSRF_BLOCKED
   - userinfo 거부: `url.username || url.password` -> X402_SSRF_BLOCKED
   - 포트 검증: `url.port && url.port !== '443'` -> X402_SSRF_BLOCKED
   - hostname이 IP인 경우 (`isIP(hostname)` > 0): `assertPublicIP(hostname)` 직접 호출
   - hostname이 도메인인 경우: `dns.lookup(hostname, { all: true })` -> 모든 address에 `assertPublicIP()`

3. **assertPublicIP(ip: string): void**
   - `normalizeIPv6Mapped(ip)` 호출로 IPv4-mapped IPv6 정규화
   - `isPrivateIP(normalized)` 검사 -> true면 X402_SSRF_BLOCKED

4. **normalizeIPv6Mapped(ip: string): string**
   - `::ffff:A.B.C.D` 패턴 -> IPv4 부분 추출
   - `::ffff:HHHH:HHHH` 패턴 -> 16진수를 IPv4로 변환
   - 그 외 -> 그대로 반환

5. **isPrivateIP(ip: string): boolean**
   - IPv4 판별: `isPrivateIPv4(ip)`
   - IPv6 판별: `isPrivateIPv6(ip)`
   - 연구 파일의 `isPrivateIPv4` / `isPrivateIPv6` 함수를 그대로 구현
   - RFC 5735/6890 전체 범위: 0.x, 10.x, 100.64-127.x (CGNAT), 127.x, 169.254.x, 172.16-31.x, 192.0.0.x, 192.0.2.x, 192.168.x, 198.18-19.x, 198.51.100.x, 203.0.113.x, 224-239.x (multicast), 240+.x (reserved)
   - IPv6: ::1, ::, fe80:/10, fc00:/7 (fc/fd), ff00:/8

6. **safeFetchWithRedirects(url: URL, method: string, headers?: Record<string, string>, body?: string, timeout?: number): Promise<Response>**
   - `redirect: 'manual'`로 fetch
   - 3xx 응답 시 Location 헤더 추출 -> `validateUrlSafety(new URL(location, currentUrl).toString())` 재검증
   - 최대 3회 리다이렉트 (4번째에서 X402_SSRF_BLOCKED)
   - 리다이렉트 후 method를 GET으로 변경, 원본 headers/body 제거
   - `AbortController` + `setTimeout` 으로 타임아웃 관리 (기본 30초)
   - 비-리다이렉트(< 300 or >= 400): 그대로 반환

**Import:**
```typescript
import { lookup } from 'node:dns/promises';
import { isIP } from 'node:net';
import { WAIaaSError } from '@waiaas/core';
```

**에러 생성 패턴:**
```typescript
throw new WAIaaSError('X402_SSRF_BLOCKED', { message: '...' });
```
WAIaaSError 생성자 시그니처를 확인하여 올바른 패턴으로 사용한다. 기존 코드(`sign-only.ts`, `stages.ts`)의 WAIaaSError 사용법을 참조.
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/ssrf-guard.test.ts` 실행 시 모든 테스트가 PASS (GREEN 단계).
  </verify>
  <done>
SSRF 가드가 모든 테스트를 통과하고, validateUrlSafety + safeFetchWithRedirects가 export되어 x402-handler에서 import 가능하다.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/daemon/src/__tests__/ssrf-guard.test.ts` -- 모든 테스트 통과
2. `npx vitest run packages/daemon/src/__tests__/` -- 기존 테스트 미파괴
3. `npx tsc --noEmit -p packages/daemon/tsconfig.json` -- TypeScript 컴파일 에러 없음
</verification>

<success_criteria>
- SSRF 가드 모듈이 20개 이상 테스트와 함께 동작한다
- 모든 RFC 5735/6890 사설 IP 범위와 우회 벡터(IPv4-mapped IPv6, 옥탈, 헥스)가 차단된다
- HTTPS만 허용되고, 리다이렉트 매 hop에서 IP가 재검증된다
- URL 정규화(trailing dot, userinfo, 포트)가 올바르게 동작한다
- WAIaaSError('X402_SSRF_BLOCKED')로 일관된 에러가 반환된다
</success_criteria>

<output>
After completion, create `.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-01-SUMMARY.md`
</output>
