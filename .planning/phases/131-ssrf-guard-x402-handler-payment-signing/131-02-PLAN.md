---
phase: 131-ssrf-guard-x402-handler-payment-signing
plan: 02
type: tdd
wave: 2
depends_on: ["131-01", "131-03"]
files_modified:
  - packages/daemon/src/services/x402/x402-handler.ts
  - packages/daemon/src/__tests__/x402-handler.test.ts
autonomous: true

must_haves:
  truths:
    - "HTTP 402 응답의 PAYMENT-REQUIRED 헤더에서 PaymentRequirements가 파싱되고 Zod으로 검증된다"
    - "비-402 응답(200/4xx/5xx)은 그대로 패스스루된다"
    - "accepts 배열에서 WAIaaS가 지원하는 (scheme, network) 쌍이 자동 선택되고 최저가가 우선된다"
    - "지원 불가 scheme/network 시 X402_UNSUPPORTED_SCHEME 에러가 반환된다"
    - "결제 서명 후 재요청 시 PAYMENT-SIGNATURE 헤더가 포함되고 다시 402이면 X402_PAYMENT_REJECTED로 종료된다"
    - "5xx 서버 에러, 지원 불가 scheme, 타임아웃이 각각 구분된 에러로 처리된다"
  artifacts:
    - path: "packages/daemon/src/services/x402/x402-handler.ts"
      provides: "x402 핸들러 모듈 (handleX402Fetch, parse402Response, selectPaymentRequirement)"
      exports: ["handleX402Fetch", "parse402Response", "selectPaymentRequirement"]
    - path: "packages/daemon/src/__tests__/x402-handler.test.ts"
      provides: "x402 핸들러 테스트 (402 파싱, scheme 선택, 패스스루, 재시도, 에러 처리)"
  key_links:
    - from: "packages/daemon/src/services/x402/x402-handler.ts"
      to: "packages/daemon/src/services/x402/ssrf-guard.ts"
      via: "validateUrlSafety + safeFetchWithRedirects 호출"
      pattern: "import.*ssrf-guard"
    - from: "packages/daemon/src/services/x402/x402-handler.ts"
      to: "packages/daemon/src/services/x402/payment-signer.ts"
      via: "signPayment 호출로 결제 서명 생성"
      pattern: "import.*payment-signer"
    - from: "packages/daemon/src/services/x402/x402-handler.ts"
      to: "@x402/core/http"
      via: "encodePaymentSignatureHeader/decodePaymentRequiredHeader"
      pattern: "encodePaymentSignatureHeader|decodePaymentRequiredHeader"
    - from: "packages/daemon/src/services/x402/x402-handler.ts"
      to: "@waiaas/core"
      via: "X402FetchRequest/Response 스키마 + resolveX402Network + WAIaaSError"
      pattern: "X402FetchRequest|resolveX402Network|WAIaaSError"
---

<objective>
x402 핸들러를 TDD로 구현하여 402 응답 파싱, (scheme, network) 자동 선택, 결제 서명 후 재요청의 전체 흐름을 오케스트레이션한다.

Purpose: x402 핸들러는 SSRF 가드(Plan 01)와 결제 서명(Plan 03)을 조합하여 에이전트 요청 -> SSRF 검증 -> 외부 HTTP 요청 -> 402 파싱 -> 결제 서명 -> 재요청의 독립 파이프라인을 제공한다. 기존 6-stage 파이프라인을 확장하지 않는다.
Output: x402-handler.ts (오케스트레이션) + x402-handler.test.ts (전체 흐름 테스트)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-RESEARCH.md

# Phase 130 types
@packages/core/src/interfaces/x402.types.ts (X402FetchRequest/Response, PaymentRequirements, resolveX402Network)
@packages/core/src/errors/error-codes.ts (X402 에러 코드 8개)

# Plan 01/03 SUMMARYs (Wave 2 의존)
@.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-01-SUMMARY.md
@.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: x402 핸들러 테스트 작성 (RED)</name>
  <files>packages/daemon/src/__tests__/x402-handler.test.ts</files>
  <action>
x402 핸들러의 전체 흐름을 검증하는 테스트를 먼저 작성한다. `packages/daemon/src/__tests__/x402-handler.test.ts`에 작성.

ssrf-guard와 payment-signer를 vi.mock으로 모킹한다. @x402/core/http 함수도 모킹 대상이다.

**모킹 전략:**
```typescript
vi.mock('../services/x402/ssrf-guard.js', () => ({
  validateUrlSafety: vi.fn(),
  safeFetchWithRedirects: vi.fn(),
}));
vi.mock('../services/x402/payment-signer.js', () => ({
  signPayment: vi.fn(),
}));
```

`safeFetchWithRedirects`가 반환하는 Response 객체는 `new Response(body, { status, headers })` 패턴으로 생성한다.

**테스트 그룹:**

1. **비-402 응답 패스스루 (X4HAND-03)**
   - 200 OK 응답: body, status, headers가 그대로 X402FetchResponse로 반환
   - 404 Not Found: status 404, body 그대로 반환
   - 500 Internal Server Error: status 500, body 그대로 반환
   - safeFetchWithRedirects가 1번만 호출됨 (결제 서명 안 함)

2. **402 응답 파싱 (X4HAND-01 - parse402Response)**
   - PAYMENT-REQUIRED 헤더에서 PaymentRequirements 추출: `decodePaymentRequiredHeader(headerValue)` -> `PaymentRequiredV2Schema.parse()` 검증
   - PAYMENT-REQUIRED 헤더 없으면 JSON body에서 파싱 시도
   - 유효하지 않은 PaymentRequirements -> Zod 검증 실패 에러

3. **(scheme, network) 자동 선택 (X4HAND-02 - selectPaymentRequirement)**
   - accepts에서 scheme='exact' + 지원 네트워크(eip155:84532) 선택
   - 여러 지원 가능 항목 중 최저 amount 선택
   - accepts에 지원 가능한 항목 없음 -> X402_UNSUPPORTED_SCHEME
   - scheme이 'exact'가 아닌 항목은 필터링됨

4. **결제 서명 + 재요청 (X4HAND-04)**
   - 첫 요청 402 -> signPayment 호출 -> PAYMENT-SIGNATURE 헤더로 재요청
   - 재요청 200 OK -> body 반환 + payment 정보 포함
   - encodePaymentSignatureHeader로 PaymentPayload가 인코딩됨

5. **재시도 제한 (X4HAND-05)**
   - 결제 서명 재요청 후 다시 402 -> X402_PAYMENT_REJECTED 에러 (1회만 재시도)
   - safeFetchWithRedirects가 정확히 2번 호출됨 (원본 + 재요청)

6. **에러 처리 (X4HAND-06)**
   - safeFetchWithRedirects가 네트워크 에러 throw -> 적절한 에러 전파
   - 타임아웃 (AbortError) -> 구분된 에러
   - signPayment 실패 -> 에러 전파

7. **SSRF 가드 연동**
   - validateUrlSafety가 호출됨 (URL 검증)
   - validateUrlSafety가 X402_SSRF_BLOCKED throw -> 그대로 전파

**X402HandlerDeps 모킹:**
```typescript
const mockDeps = {
  paymentSigner: { sign: vi.fn() },
  keyStore: mockKeyStore,
  walletId: 'test-wallet',
  walletAddress: '0x1234...',
  masterPassword: 'test-password',
  supportedNetworks: new Set(['eip155:84532', 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1']),
};
```

RED 단계: 구현체가 없으므로 모든 테스트 FAIL.
스텁 파일 `packages/daemon/src/services/x402/x402-handler.ts`에 빈 export를 만들어 import 에러를 방지한다.
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/x402-handler.test.ts` 실행 시 모든 테스트가 FAIL (RED 단계).
import 에러가 아닌 assertion 에러여야 한다.
  </verify>
  <done>
x402 핸들러 테스트가 15개 이상 작성되고, 402 파싱/scheme 선택/패스스루/재시도/에러 처리를 포괄하며, 모두 FAIL 상태이다.
  </done>
</task>

<task type="auto">
  <name>Task 2: x402 핸들러 구현 (GREEN + REFACTOR)</name>
  <files>packages/daemon/src/services/x402/x402-handler.ts</files>
  <action>
모든 RED 테스트를 통과시키는 x402 핸들러를 구현한다. `packages/daemon/src/services/x402/x402-handler.ts`에 작성.

**구현 순서:**

1. **X402HandlerDeps 인터페이스**
   ```typescript
   export interface X402HandlerDeps {
     keyStore: { decryptPrivateKey(walletId: string, masterPassword: string): Promise<Uint8Array>; releaseKey(key: Uint8Array): void };
     walletId: string;
     walletAddress: string;
     masterPassword: string;
     supportedNetworks: Set<string>;  // CAIP-2 식별자 set
   }
   ```

2. **handleX402Fetch(request: X402FetchRequest, deps: X402HandlerDeps): Promise<X402FetchResponse>**
   - 1단계: `validateUrlSafety(request.url)` -- SSRF 가드
   - 2단계: `safeFetchWithRedirects(url, request.method, request.headers, request.body)` -- 첫 번째 외부 요청
   - 3단계: 비-402 응답 -> `buildPassthroughResponse(response)` 즉시 반환
   - 4단계: `parse402Response(response)` -- PaymentRequired 파싱
   - 5단계: `selectPaymentRequirement(paymentRequired.accepts, deps.supportedNetworks)` -- (scheme, network) 선택
   - 6단계: `signPayment(selected, deps.keyStore, deps.walletId, deps.walletAddress, deps.masterPassword)` -- 결제 서명
   - 7단계: `encodePaymentSignatureHeader(paymentPayload)` -- 헤더 인코딩
   - 8단계: `safeFetchWithRedirects(url, request.method, { ...request.headers, 'PAYMENT-SIGNATURE': encoded }, request.body)` -- 재요청
   - 9단계: 재요청 결과 처리
     - 402 -> `throw new WAIaaSError('X402_PAYMENT_REJECTED')`
     - 비-ok -> `throw new WAIaaSError('X402_SERVER_ERROR')`
     - ok -> `buildPaymentResponse(response, selected)` 반환

3. **parse402Response(response: Response): Promise<PaymentRequired>**
   - PAYMENT-REQUIRED 헤더 존재 시: `decodePaymentRequiredHeader(headerValue)` -> `PaymentRequiredV2Schema.parse(decoded)`
   - 헤더 없으면: `response.json()` -> `PaymentRequiredV2Schema.parse(body)`
   - @x402/core/http의 decodePaymentRequiredHeader와 @x402/core/schemas의 PaymentRequiredV2Schema 사용

4. **selectPaymentRequirement(accepts: PaymentRequirements[], supportedNetworks: Set<string>): PaymentRequirements**
   - scheme === 'exact'만 필터
   - `resolveX402Network(req.network)` 성공 + `supportedNetworks.has(req.network)` 통과하는 항목만
   - 지원 항목 없으면 X402_UNSUPPORTED_SCHEME
   - 최저 amount 선택: `reduce((min, req) => BigInt(req.amount) < BigInt(min.amount) ? req : min)`

5. **buildPassthroughResponse(response: Response): Promise<X402FetchResponse>**
   - `{ status: response.status, headers: Object.fromEntries(response.headers), body: await response.text() }`

6. **buildPaymentResponse(response: Response, requirement: PaymentRequirements): Promise<X402FetchResponse>**
   - passthrough + `payment: { amount: requirement.amount, asset: requirement.asset, network: requirement.network, payTo: requirement.payTo, txId: '' }`

**Import:**
```typescript
import { validateUrlSafety, safeFetchWithRedirects } from './ssrf-guard.js';
import { signPayment } from './payment-signer.js';
import { encodePaymentSignatureHeader, decodePaymentRequiredHeader } from '@x402/core/http';
import { PaymentRequiredV2Schema } from '@x402/core/schemas';
import type { PaymentRequired, PaymentRequirements } from '@x402/core/types';
import { resolveX402Network, type X402FetchRequest, type X402FetchResponse } from '@waiaas/core';
import { WAIaaSError } from '@waiaas/core';
```

**주의사항:**
- `@x402/core/http`의 정확한 export를 확인한다. 연구 파일에서 `encodePaymentSignatureHeader`, `decodePaymentRequiredHeader` 함수명을 확인. 없으면 자체 base64 인코딩/디코딩을 구현한다.
- 기존 6-stage 파이프라인(stages.ts)을 수정하지 않는다 -- 독립 파이프라인.
- resource.url은 signPayment 반환값의 resource.url을 request.url로 설정한다.
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/x402-handler.test.ts` 실행 시 모든 테스트가 PASS (GREEN 단계).
  </verify>
  <done>
x402 핸들러가 모든 테스트를 통과하고, handleX402Fetch가 export되어 REST API 라우터(Phase 132)에서 import 가능하다. SSRF 가드/결제 서명/402 파싱/재시도가 올바르게 오케스트레이션된다.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/daemon/src/__tests__/x402-handler.test.ts` -- 모든 테스트 통과
2. `npx vitest run packages/daemon/src/__tests__/ssrf-guard.test.ts packages/daemon/src/__tests__/payment-signer.test.ts` -- 기존 Plan 01/03 테스트 유지
3. `npx vitest run packages/daemon/src/__tests__/` -- 전체 daemon 테스트 미파괴
4. `npx tsc --noEmit -p packages/daemon/tsconfig.json` -- TypeScript 컴파일 에러 없음
</verification>

<success_criteria>
- 402 응답의 PAYMENT-REQUIRED 헤더에서 PaymentRequirements가 파싱되고 Zod으로 검증된다
- 비-402 응답이 그대로 패스스루된다
- accepts에서 지원 가능한 최저가 (scheme, network) 쌍이 자동 선택된다
- PAYMENT-SIGNATURE 헤더로 재요청이 이루어지고, 재요청 후 402이면 1회만 재시도 후 X402_PAYMENT_REJECTED
- SSRF 가드와 결제 서명이 올바르게 조합된 독립 파이프라인이 동작한다
</success_criteria>

<output>
After completion, create `.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-02-SUMMARY.md`
</output>
