---
phase: 131-ssrf-guard-x402-handler-payment-signing
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/x402/payment-signer.ts
  - packages/daemon/src/__tests__/payment-signer.test.ts
autonomous: true

must_haves:
  truths:
    - "EVM EIP-3009 transferWithAuthorization EIP-712 서명이 viem signTypedData로 생성된다"
    - "Solana SPL TransferChecked 부분 서명이 @solana/kit signBytes로 생성되고 feePayer가 noopSigner로 처리된다"
    - "키스토어 복호화 후 서명이 완료되면 finally 블록에서 sodium_memzero로 키가 해제된다"
    - "EIP-3009 validBefore가 now+5분으로 설정되고 nonce가 crypto.randomBytes(32)로 생성된다"
    - "PaymentPayload 구조가 @x402/core의 PaymentPayloadV2Schema와 호환된다"
  artifacts:
    - path: "packages/daemon/src/services/x402/payment-signer.ts"
      provides: "결제 서명 생성 모듈 (EVM EIP-3009 + Solana TransferChecked + 키 관리)"
      exports: ["signPayment", "signEip3009", "signSolanaTransferChecked"]
    - path: "packages/daemon/src/__tests__/payment-signer.test.ts"
      provides: "결제 서명 테스트 (EIP-712 구조, Solana 부분 서명, 키 관리 finally)"
  key_links:
    - from: "packages/daemon/src/services/x402/payment-signer.ts"
      to: "viem/accounts privateKeyToAccount"
      via: "account.signTypedData() EIP-3009 서명"
      pattern: "signTypedData"
    - from: "packages/daemon/src/services/x402/payment-signer.ts"
      to: "@solana/kit signBytes"
      via: "Solana 부분 서명 생성"
      pattern: "signBytes"
    - from: "packages/daemon/src/services/x402/payment-signer.ts"
      to: "packages/daemon/src/infrastructure/keystore/keystore.ts"
      via: "decryptPrivateKey -> sign -> releaseKey (finally)"
      pattern: "decryptPrivateKey.*finally.*releaseKey"
---

<objective>
체인별 결제 서명 생성 모듈을 TDD로 구현하여 x402 핸들러가 EVM(EIP-3009)과 Solana(TransferChecked) 결제 서명을 안전하게 생성할 수 있도록 한다.

Purpose: x402 프로토콜에서 클라이언트(WAIaaS)는 결제 서명을 생성하여 리소스 서버에 제출해야 한다. EVM은 EIP-3009 transferWithAuthorization(오프체인 서명), Solana는 SPL TransferChecked 부분 서명(feePayer는 facilitator) 방식이다. 키 관리는 기존 sign-only 파이프라인과 동일한 decrypt->sign->finally release 패턴을 따른다.
Output: payment-signer.ts (체인별 서명 전략) + payment-signer.test.ts (서명 구조 검증 + 키 관리 테스트)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-RESEARCH.md

# Phase 130 types
@packages/core/src/interfaces/x402.types.ts (PaymentRequirements, parseCaip2, resolveX402Network)

# Existing signing patterns
@packages/daemon/src/pipeline/sign-only.ts (Step 9: decrypt->sign->finally release 패턴)
@packages/daemon/src/infrastructure/keystore/keystore.ts (decryptPrivateKey, releaseKey)

# Chain adapter patterns
@packages/adapters/evm/src/adapter.ts (privateKeyToAccount, signTypedData 패턴)
@packages/adapters/solana/src/adapter.ts (signBytes, createKeyPairFromBytes, compileTransaction 패턴)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 결제 서명 테스트 작성 (RED)</name>
  <files>packages/daemon/src/__tests__/payment-signer.test.ts</files>
  <action>
결제 서명 모듈의 모든 기능을 검증하는 테스트를 먼저 작성한다. `packages/daemon/src/__tests__/payment-signer.test.ts`에 작성.

keyStore는 모킹한다. viem의 privateKeyToAccount와 @solana/kit의 signBytes는 실제로 호출하여 서명 구조를 검증한다 (순수 함수이므로 모킹 불필요).

**테스트 그룹:**

1. **EVM EIP-3009 서명 (signEip3009)**
   - Base Sepolia (eip155:84532) PaymentRequirements로 서명 생성
   - 반환된 payload에 `x402Version: 2`, `accepted` (원본 requirements), `payload.signature` (0x 65-byte hex), `payload.authorization` 객체가 포함된다
   - `payload.authorization.from`이 privateKey에서 파생된 주소와 일치한다
   - `payload.authorization.to`가 requirements.payTo와 일치한다
   - `payload.authorization.value`가 requirements.amount와 일치한다
   - `payload.authorization.validAfter`가 '0'이다
   - `payload.authorization.validBefore`가 현재 시간 + 5분 (오차 +-10초)이다
   - `payload.authorization.nonce`가 0x + 64자 hex (32 bytes)이다
   - signTypedData의 domain이 올바른 USDC 도메인(name, version, chainId, verifyingContract)인지 검증 (viem의 recoverTypedDataAddress로 서명 검증 가능)

2. **Solana TransferChecked 부분 서명 (signSolanaTransferChecked)**
   - 모킹: RPC의 getLatestBlockhash를 vi.fn()으로 모킹하여 고정 blockhash 반환
   - 반환된 payload에 `x402Version: 2`, `accepted`, `payload.transaction` (base64 string)이 포함된다
   - `payload.transaction`이 유효한 base64이다 (Buffer.from(tx, 'base64') 성공)
   - feePayer가 requirements.extra.feePayer 주소이다

3. **키 관리 패턴 (signPayment - 통합)**
   - keyStore.decryptPrivateKey가 호출된다
   - 서명 성공 시 keyStore.releaseKey가 호출된다
   - 서명 중 에러 발생 시에도 keyStore.releaseKey가 호출된다 (finally 블록 검증)
   - keyStore mock: `decryptPrivateKey` -> 고정 테스트 키 반환, `releaseKey` -> vi.fn()

4. **체인 전략 선택 (signPayment)**
   - EVM 네트워크 (eip155:...) -> signEip3009 호출
   - Solana 네트워크 (solana:...) -> signSolanaTransferChecked 호출
   - 미지원 네트워크 -> X402_UNSUPPORTED_SCHEME 에러

5. **USDC Domain 상수 테이블**
   - Base (eip155:8453): name='USD Coin', version='2', chainId=8453
   - Base Sepolia (eip155:84532): name='USD Coin', version='2', chainId=84532
   - 미지원 네트워크: X402_UNSUPPORTED_SCHEME 에러

**테스트 키 (고정):**
- EVM: `crypto.randomBytes(32)` 또는 고정 hex 키 (테스트 전용)
- Solana: `crypto.randomBytes(64)` 또는 고정 byte 배열 (테스트 전용)

**모킹 패턴:**
```typescript
const mockKeyStore = {
  decryptPrivateKey: vi.fn(),
  releaseKey: vi.fn(),
};
```

RED 단계: 구현체가 없으므로 모든 테스트 FAIL.
스텁 파일 `packages/daemon/src/services/x402/payment-signer.ts`에 빈 export를 만들어 import 에러를 방지한다.
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/payment-signer.test.ts` 실행 시 모든 테스트가 FAIL (RED 단계).
import 에러가 아닌 assertion 에러여야 한다.
  </verify>
  <done>
결제 서명 테스트가 15개 이상 작성되고, EIP-3009 서명 구조, Solana 부분 서명, 키 관리 패턴, 체인 전략 선택을 포괄하며, 모두 FAIL 상태이다.
  </done>
</task>

<task type="auto">
  <name>Task 2: 결제 서명 구현 (GREEN + REFACTOR)</name>
  <files>packages/daemon/src/services/x402/payment-signer.ts</files>
  <action>
모든 RED 테스트를 통과시키는 결제 서명 모듈을 구현한다. `packages/daemon/src/services/x402/payment-signer.ts`에 작성.

**구현 순서:**

1. **USDC_DOMAINS 상수 테이블**
   - 연구 파일의 상수 테이블을 그대로 사용 (Base, Base Sepolia, Ethereum, Ethereum Sepolia, Polygon, Arbitrum, Optimism)
   - 타입: `Record<string, { name: string; version: string; chainId: number; verifyingContract: string }>`

2. **signPayment(requirements, keyStore, walletId, walletAddress, masterPassword, rpc?) -> PaymentPayload**
   - 키 관리 패턴 (sign-only.ts Step 9와 동일):
     ```typescript
     let privateKey: Uint8Array | null = null;
     try {
       privateKey = await keyStore.decryptPrivateKey(walletId, masterPassword);
       const { namespace } = parseCaip2(requirements.network);
       if (namespace === 'eip155') {
         return await signEip3009(requirements, privateKey, walletAddress);
       } else if (namespace === 'solana') {
         return await signSolanaTransferChecked(requirements, privateKey, walletAddress, rpc!);
       } else {
         throw new WAIaaSError('X402_UNSUPPORTED_SCHEME');
       }
     } finally {
       if (privateKey) keyStore.releaseKey(privateKey);
     }
     ```

3. **signEip3009(requirements, privateKey, walletAddress) -> Record<string, unknown>**
   - `parseCaip2(requirements.network)` -> chainId
   - USDC_DOMAINS에서 domain 조회 (없으면 X402_UNSUPPORTED_SCHEME)
   - `crypto.randomBytes(32)` -> nonce (0x hex)
   - `validBefore = BigInt(Math.floor(Date.now() / 1000) + 300)` (5분)
   - `privateKeyToAccount(privateKeyHex)` -> account
   - `account.signTypedData(...)` -- EIP-712 TransferWithAuthorization 타입
   - PaymentPayload 구성:
     ```typescript
     {
       x402Version: 2,
       resource: { url: '' },  // handler가 채움
       accepted: requirements,
       payload: {
         signature,
         authorization: { from, to, value, validAfter: '0', validBefore: string, nonce },
       },
     }
     ```

4. **signSolanaTransferChecked(requirements, privateKey, walletAddress, rpc) -> Record<string, unknown>**
   - `requirements.extra?.feePayer`에서 facilitator 주소 추출
   - `createNoopSigner(feePayerAddress)` -- feePayer 서명 슬롯만
   - `createKeyPairFromBytes(privateKey)` 또는 `createKeyPairFromPrivateKeyBytes(privateKey.slice(0, 32))` -- 키 길이에 따라 선택
   - `rpc.getLatestBlockhash().send()` -- blockhash 획득
   - `findAssociatedTokenPda(...)` -- source/destination ATA 계산
   - `getTransferCheckedInstruction(...)` -- SPL TransferChecked instruction
   - `pipe(createTransactionMessage({version: 0}), setFeePayer, setBlockhash, appendInstruction)` -- 트랜잭션 빌드
   - `compileTransaction(txMessage)` -> `signBytes(keyPair.privateKey, compiled.messageBytes)` -- 부분 서명
   - `getTransactionEncoder().encode(...)` -> base64 직렬화
   - PaymentPayload 구성: `{ x402Version: 2, resource: { url: '' }, accepted: requirements, payload: { transaction: base64 } }`

**Import:**
```typescript
import { privateKeyToAccount } from 'viem/accounts';
import { randomBytes } from 'node:crypto';
import type { Hex } from 'viem';
import { parseCaip2 } from '@waiaas/core';
import { WAIaaSError } from '@waiaas/core';
```

**주의사항:**
- IChainAdapter를 경유하지 않는다 -- EIP-3009는 트랜잭션이 아닌 EIP-712 typed data 서명이므로
- privateKey를 Hex로 변환: `\`0x${Buffer.from(privateKey).toString('hex')}\`` as Hex
- keyStore 인터페이스: `{ decryptPrivateKey(walletId, masterPassword): Promise<Uint8Array>; releaseKey(key: Uint8Array): void }`
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/payment-signer.test.ts` 실행 시 모든 테스트가 PASS (GREEN 단계).
  </verify>
  <done>
결제 서명 모듈이 모든 테스트를 통과하고, signPayment/signEip3009/signSolanaTransferChecked가 export되어 x402-handler에서 import 가능하다. 키 관리가 finally 블록으로 안전하게 처리된다.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run packages/daemon/src/__tests__/payment-signer.test.ts` -- 모든 테스트 통과
2. `npx vitest run packages/daemon/src/__tests__/` -- 기존 테스트 미파괴
3. `npx tsc --noEmit -p packages/daemon/tsconfig.json` -- TypeScript 컴파일 에러 없음
</verification>

<success_criteria>
- EVM EIP-3009 서명이 올바른 EIP-712 구조(domain, types, message)로 생성된다
- Solana TransferChecked 부분 서명이 base64 직렬화된 트랜잭션으로 생성된다
- 키스토어 복호화/해제가 finally 블록으로 안전하게 처리된다
- validBefore가 now+5분, nonce가 32바이트 랜덤으로 설정된다
- 체인 전략 선택이 CAIP-2 namespace로 정확히 분기된다
</success_criteria>

<output>
After completion, create `.planning/phases/131-ssrf-guard-x402-handler-payment-signing/131-03-SUMMARY.md`
</output>
