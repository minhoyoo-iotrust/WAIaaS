---
phase: 34-자금-회수-보안-분기-설계
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/36-killswitch-autostop-evm.md
  - .planning/deliverables/53-session-renewal-protocol.md
  - .planning/deliverables/35-notification-architecture.md
autonomous: true

must_haves:
  truths:
    - "Kill Switch 복구 대기 시간이 Owner 유무에 따라 분기된다 (Owner 없음: 24h, Owner 있음: 30min)"
    - "Owner 없는 에이전트의 복구는 masterAuth + 24h 강제 대기이다"
    - "Owner 있는 에이전트의 복구는 ownerAuth + masterAuth + 30min 대기이다"
    - "Owner 없는 에이전트의 세션 갱신이 거부 윈도우 없이 즉시 확정된다"
    - "Owner 있는(LOCKED) 에이전트의 세션 갱신 알림에 [거부하기] 버튼이 3채널 명세되어 있다"
  artifacts:
    - path: ".planning/deliverables/36-killswitch-autostop-evm.md"
      provides: "Kill Switch 복구 Owner 분기 설계"
      contains: "recovery_eligible_at"
    - path: ".planning/deliverables/53-session-renewal-protocol.md"
      provides: "세션 갱신 Owner 분기 설계"
      contains: "rejectButton"
    - path: ".planning/deliverables/35-notification-architecture.md"
      provides: "[거부하기] 버튼 채널별 명세"
      contains: "SESSION_RENEWED"
  key_links:
    - from: "36-killswitch-autostop-evm.md 복구 분기"
      to: "agents.owner_address IS NOT NULL 쿼리"
      via: "시스템 내 Owner 등록 에이전트 존재 여부로 판단"
    - from: "53-session-renewal-protocol.md 갱신 분기"
      to: "resolveOwnerState()"
      via: "갱신 대상 에이전트의 OwnerState 산출"
    - from: "35-notification-architecture.md [거부하기] 버튼"
      to: "DELETE /v1/sessions/:id"
      via: "기존 세션 폐기 API 재활용 (53 §6.1)"
---

<objective>
Kill Switch 복구 대기 시간의 Owner 유무별 분기를 36-killswitch-autostop-evm.md에 설계하고, 세션 갱신의 Owner 유무별 분기(즉시 확정 vs [거부하기] 버튼)를 53-session-renewal-protocol.md와 35-notification-architecture.md에 반영한다.

Purpose: Phase 34 Success Criteria 5를 충족하여, Kill Switch 복구와 세션 갱신의 Owner 유무별 동작 분기가 구현 가능 수준으로 명세된다.
Output: 36에 복구 분기, 53에 갱신 분기, 35에 [거부하기] 버튼 채널별 명세.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# v0.8 objectives (Kill Switch §6, 세션 갱신 §7, 알림 §8)
@objectives/v0.8-optional-owner-progressive-security.md

# Phase 31 resolveOwnerState() 함수 확정
@.planning/phases/31-데이터-모델-타입-기반-설계/31-02-SUMMARY.md

# Phase 33 알림 버튼 채널별 패턴 (Telegram url, Discord Embed, ntfy.sh view)
@.planning/phases/33-정책-다운그레이드-알림-설계/33-02-SUMMARY.md

# Target files
@.planning/deliverables/36-killswitch-autostop-evm.md
@.planning/deliverables/53-session-renewal-protocol.md
@.planning/deliverables/35-notification-architecture.md

# Reference: OwnerState 산출 + resolveOwnerState()
@.planning/deliverables/33-time-lock-approval-mechanism.md

# Research
@.planning/phases/34-자금-회수-보안-분기-설계/34-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kill Switch 복구 Owner 유무 분기를 36-killswitch-autostop-evm.md에 반영</name>
  <files>.planning/deliverables/36-killswitch-autostop-evm.md</files>
  <action>
36-killswitch-autostop-evm.md에서 Kill Switch 복구 관련 섹션(§4 복구 절차 또는 POST /v1/admin/recover 관련)을 [v0.8] 태그로 보완한다.

**추가할 내용:**

1. **Owner 유무별 복구 대기 시간 분기 테이블:**

   | 시나리오 | 인증 | 대기 시간 | 근거 |
   |---------|------|----------|------|
   | Owner 있음 (시스템 내 1개라도) | ownerAuth + masterAuth | 30분 (1,800초) | Owner 서명이 이중 인증 역할 |
   | Owner 없음 (모든 에이전트 미등록) | masterAuth만 | 24시간 (86,400초) | 이중 인증 부재를 시간으로 보상 |

2. **Owner 유무 판단 기준:**
   - Kill Switch는 **시스템 전체** 동작이므로 에이전트별 분기 부적절
   - 판단 쿼리: `SELECT 1 FROM agents WHERE owner_address IS NOT NULL LIMIT 1`
   - 한 명이라도 Owner가 있으면 "Owner 있음" 시나리오 적용
   - 근거: Owner가 있는 에이전트의 자금 보호가 최우선. ownerAuth 이중 인증을 강제하되 대기 시간을 짧게 (30분)

3. **대기 시간 구현 패턴 (2단계 복구):**
   ```
   Step 1: POST /v1/admin/recover (최초 요청)
   - masterAuth 검증
   - Owner 있음: ownerAuth 검증 추가
   - system_state에 recovery_eligible_at = now + waitSeconds 기록
   - system_state에 recovery_wait_seconds = (1800 또는 86400) 기록
   - Kill Switch 상태: ACTIVATED → RECOVERING
   - 응답: 202 Accepted + { recoveryEligibleAt, waitSeconds }

   Step 2: POST /v1/admin/recover (대기 후 요청)
   - Kill Switch 상태 === RECOVERING 확인
   - now >= recovery_eligible_at 확인
   - 미경과 시: 409 Conflict + RECOVERY_WAIT_REQUIRED + { remainingSeconds }
   - 경과 시: 실제 복구 수행 (RECOVERING → NORMAL)
   - 응답: 200 OK + { status: 'NORMAL' }
   ```

4. **RecoverRequest 스키마 변경:**
   - 현재: masterPassword(필수) + ownerAuth 헤더(필수)
   - v0.8: masterPassword(필수) + ownerAuth 헤더(**Owner 있을 때만 필수**)
   - Owner 유무에 따른 인증 분기:
     ```typescript
     const hasOwner = db.prepare(
       'SELECT 1 FROM agents WHERE owner_address IS NOT NULL LIMIT 1'
     ).get() !== undefined

     if (hasOwner && !ownerSignature) {
       throw unauthorized('OWNER_AUTH_REQUIRED',
         '시스템에 Owner가 등록된 에이전트가 있으므로 ownerAuth 필요')
     }
     ```

5. **system_state 키 추가:**
   - `recovery_eligible_at`: 복구 가능 시각 (Unix epoch 초)
   - `recovery_wait_seconds`: 적용된 대기 시간 (1800 또는 86400)
   - 기존 kill_switch_status: NORMAL → ACTIVATED → **RECOVERING** → NORMAL
   - RECOVERING 상태 추가 설명: 복구 요청 접수됨, 대기 시간 경과 대기 중

6. **config.toml 설정 가능 여부:**
   - 기본값: `kill_switch_recovery_wait_owner = 1800`, `kill_switch_recovery_wait_no_owner = 86400`
   - config.toml [security] 섹션에서 재정의 가능 (운영 유연성)
   - 환경변수: WAIAAS_SECURITY_KILL_SWITCH_RECOVERY_WAIT_OWNER, WAIAAS_SECURITY_KILL_SWITCH_RECOVERY_WAIT_NO_OWNER

7. **에러 코드 추가:**
   | 에러 코드 | HTTP | 조건 |
   |-----------|------|------|
   | KILL_SWITCH_NOT_ACTIVE | 409 | 상태가 NORMAL일 때 복구 요청 |
   | OWNER_AUTH_REQUIRED | 401 | Owner 있는데 ownerAuth 미제공 |
   | RECOVERY_WAIT_REQUIRED | 409 | RECOVERING 상태에서 대기 미경과 |
   | RECOVERY_ALREADY_STARTED | 409 | 이미 RECOVERING 상태에서 새 Step 1 요청 |

**반드시 지켜야 할 것:**
- Kill Switch 3-state(NORMAL/ACTIVATED/RECOVERING) 기존 설계와 일관 유지
- RECOVERING은 기존 36 문서에 이미 존재할 수 있음 -- 확인 후 보완
- [v0.8] 태그로 Owner 유무 분기 추가분 표시
- 에이전트별 분기가 아닌 시스템별 분기 근거 명시

**하지 말 것:**
- 에이전트별 복구 시간 분기 (시스템 전체 동작이므로 부적절)
- sleep/대기를 HTTP 요청 내에서 처리 (2단계 패턴 사용 -- Pitfall 5)
- Kill Switch 발동 로직 변경 (발동은 masterAuth로 동일 -- 복구만 분기)
  </action>
  <verify>
36-killswitch-autostop-evm.md에서 다음을 확인:
1. Owner 유무별 복구 대기 시간 분기 테이블(30min vs 24h)이 존재한다
2. "recovery_eligible_at" 또는 "2단계 복구" 패턴이 명세되어 있다
3. "RECOVERING" 상태가 명세되어 있다
4. RecoverRequest 스키마에 ownerAuth 선택적 분기가 명세되어 있다
5. "RECOVERY_WAIT_REQUIRED" 에러 코드가 존재한다
6. Owner 유무 판단 쿼리(agents WHERE owner_address IS NOT NULL)가 명세되어 있다
  </verify>
  <done>
36-killswitch-autostop-evm.md에 Kill Switch 복구 Owner 유무 분기(30min vs 24h), 2단계 복구 패턴(ACTIVATED→RECOVERING→NORMAL), RecoverRequest ownerAuth 선택적 분기, system_state 키(recovery_eligible_at, recovery_wait_seconds), config.toml 설정, 에러 코드가 [v0.8] 태그로 추가되어 있다.
SECURITY-01(Owner 없음 24h), SECURITY-02(Owner 있음 30min) 충족.
  </done>
</task>

<task type="auto">
  <name>Task 2: 세션 갱신 Owner 분기 + [거부하기] 버튼을 53-session-renewal-protocol.md와 35-notification-architecture.md에 반영</name>
  <files>
    .planning/deliverables/53-session-renewal-protocol.md
    .planning/deliverables/35-notification-architecture.md
  </files>
  <action>
53-session-renewal-protocol.md에 세션 갱신의 Owner 유무별 분기를 추가하고, 35-notification-architecture.md에 SESSION_RENEWED 알림의 [거부하기] 버튼 채널별 명세를 추가한다.

**Part A: 53-session-renewal-protocol.md 보완**

1. **세션 갱신 후 Owner 분기 테이블 (§ 적절한 위치에 추가):**

   | OwnerState | 갱신 동작 | 알림 내용 | 거부 윈도우 |
   |-----------|---------|---------|-----------|
   | NONE (Owner 없음) | 즉시 확정 | "세션 갱신됨 (3/30)" 정보성 | 없음 |
   | GRACE (Owner 유예) | 즉시 확정 | "세션 갱신됨 (3/30)" 정보성 | 없음 |
   | LOCKED (Owner 잠금) | 갱신 후 알림 | "세션 갱신됨 (3/30)" + [거부하기] | 활성 (기본 1시간) |

2. **갱신 처리 후 알림 분기 의사 코드:**
   ```typescript
   // renewSession() 내부, 갱신 성공 후
   const agent = db.prepare('SELECT * FROM agents WHERE id = ?').get(session.agent_id)
   const ownerState = resolveOwnerState({
     ownerAddress: agent.owner_address,
     ownerVerified: !!agent.owner_verified,
   })

   const notificationContext = {
     sessionId, agentName: agent.name,
     renewalCount, maxRenewals,
     remainingAbsoluteLife,
   }

   if (ownerState === 'LOCKED') {
     // Owner 잠금: [거부하기] 버튼 포함 알림 + 거부 윈도우 안내
     notificationService.notify({
       type: 'SESSION_RENEWED',
       severity: 'INFO',
       context: {
         ...notificationContext,
         rejectButton: true,
         rejectWindowExpiry: now + rejectWindowSeconds,
         rejectUrl: `/v1/dashboard/sessions/${sessionId}/reject?nonce=${generateNonce()}`,
       },
     })
   } else {
     // NONE 또는 GRACE: 정보성 알림만 (거부자 없음 = 즉시 확정)
     notificationService.notify({
       type: 'SESSION_RENEWED',
       severity: 'INFO',
       context: { ...notificationContext, rejectButton: false },
     })
   }
   ```

3. **거부 메커니즘 변경 없음 확인:**
   - 기존 DELETE /v1/sessions/:id 재활용 (53 §6.1 확정)
   - 거부하기 = 세션 폐기 (완전 삭제)
   - Owner가 직접 DELETE API를 호출하거나, [거부하기] 버튼 URL 경유

4. **SESSION_RENEWED context에 rejectButton 플래그 추가:**
   - `rejectButton: boolean` -- 채널 어댑터가 [거부하기] 버튼 렌더링 여부 결정
   - `rejectWindowExpiry?: number` -- 거부 윈도우 만료 시각 (LOCKED일 때만)
   - `rejectUrl?: string` -- 거부하기 URL (LOCKED일 때만)

5. **거부 윈도우 의미 명확화:**
   - 거부 윈도우(기본 1시간)는 **알림 문구에 표시되는 안내**일 뿐
   - Owner는 세션이 유효한 한 언제든 DELETE로 폐기 가능 (거부 윈도우 경과 후에도)
   - [거부하기] URL은 세션이 존재하는 한 계속 유효 (nonce는 세션에 바인딩)
   - 34-RESEARCH Open Question 3에 대한 결정: URL은 세션 유효 기간 내 항상 동작

**Part B: 35-notification-architecture.md 보완**

1. **SESSION_RENEWED 이벤트 Owner 분기 템플릿 추가:**

   **Owner 없음/GRACE (정보성):**
   ```
   Telegram:
   ℹ️ 세션 갱신됨
   에이전트: {agentName}
   갱신 횟수: {renewalCount}/{maxRenewals}
   남은 수명: {remainingAbsoluteLife}

   Discord (Embed):
   [color: #3498db] 세션 갱신됨
   에이전트: {agentName}
   갱신: {renewalCount}/{maxRenewals}

   ntfy.sh:
   Title: 세션 갱신됨
   Body: {agentName} ({renewalCount}/{maxRenewals})
   Tags: session
   ```

   **Owner LOCKED ([거부하기] 포함):**
   ```
   Telegram:
   ℹ️ 세션 갱신됨
   에이전트: {agentName}
   갱신 횟수: {renewalCount}/{maxRenewals}
   남은 수명: {remainingAbsoluteLife}
   거부 가능 시한: {rejectWindowExpiry}
   [거부하기]  ← InlineKeyboardButton url 기반

   Discord (Embed):
   [color: #3498db] 세션 갱신됨
   에이전트: {agentName}
   갱신: {renewalCount}/{maxRenewals}
   거부 가능 시한: {rejectWindowExpiry}
   [거부하기]({rejectUrl})  ← Embed markdown 링크

   ntfy.sh:
   Title: 세션 갱신됨
   Body: {agentName} ({renewalCount}/{maxRenewals})
   Tags: session
   Actions: view, 거부하기, {rejectUrl}
   ```

2. **[거부하기] 버튼 채널별 구현 (33-02에서 확정된 패턴 재사용):**
   - **Telegram:** InlineKeyboardButton url 기반 -- 33-02 승인/거부 버튼과 동일 패턴
     - URL: `http://127.0.0.1:3100/v1/dashboard/sessions/{sessionId}/reject?nonce={nonce}`
     - 클릭 시 브라우저에서 대시보드 페이지 열림 → masterAuth(implicit)로 DELETE 실행
   - **Discord:** Embed markdown 링크 `[거부하기]({rejectUrl})` -- Webhook Button 미지원 (33-02 결정)
   - **ntfy.sh:** Actions view 타입 `view, 거부하기, {rejectUrl}` -- http 타입 불가 (33-02 결정)

3. **[거부하기] URL 보안 (33-02 보안 고려사항과 동일):**
   | 보안 항목 | 대책 |
   |---------|------|
   | 외부 노출 | localhost(127.0.0.1:3100)로 한정 |
   | URL 재사용 | nonce 1회용 토큰으로 방지 |
   | 인증 | masterAuth(implicit) -- 데몬 접근 = 인증 완료 |
   | ownerAuth 불필요 이유 | 세션 폐기는 보안 강화 방향 (다운그레이드 아님) |

4. **NotificationEventType 업데이트:**
   - SESSION_RENEWED 이벤트는 이미 존재 (기존 15개 이벤트 중 하나)
   - context 스키마에 rejectButton, rejectWindowExpiry, rejectUrl 추가
   - 채널 어댑터는 rejectButton === true일 때만 [거부하기] 버튼 렌더링

**반드시 지켜야 할 것:**
- 53 문서에서 기존 세션 갱신 프로토콜 구조를 유지하면서 Owner 분기 추가
- 35 문서에서 33-02 확정 패턴(Telegram url, Discord Embed 링크, ntfy.sh view)과 동일 구현
- [v0.8] 태그로 Phase 34에서 추가된 내용 표시
- 거부 메커니즘은 기존 DELETE /v1/sessions/:id 재활용 (새 엔드포인트 추가 없음)

**하지 말 것:**
- 새로운 거부 전용 API 엔드포인트 생성 (기존 DELETE 재활용)
- NONE/GRACE에서 [거부하기] 버튼 표시 (거부자 없으므로)
- 거부 윈도우를 하드 차단으로 구현 (안내 문구일 뿐, Owner는 언제든 DELETE 가능)
- Telegram callback_data 사용 (ownerAuth 불필요하지만 일관성을 위해 url 기반 유지)
  </action>
  <verify>
53-session-renewal-protocol.md에서:
1. OwnerState별 갱신 분기 테이블(NONE/GRACE/LOCKED)이 존재한다
2. "rejectButton" 플래그가 SESSION_RENEWED context에 추가되어 있다
3. LOCKED에서만 [거부하기] 활성화, NONE/GRACE에서 즉시 확정 명시

35-notification-architecture.md에서:
4. SESSION_RENEWED Owner 분기 템플릿이 3채널(Telegram/Discord/ntfy.sh) 명세되어 있다
5. [거부하기] 버튼이 Telegram(url), Discord(Embed 링크), ntfy.sh(view)로 명세되어 있다
6. [거부하기] URL 보안 테이블이 존재한다
  </verify>
  <done>
53-session-renewal-protocol.md에 세션 갱신 Owner 분기(NONE/GRACE 즉시 확정, LOCKED [거부하기] 활성), rejectButton 플래그, 거부 윈도우 의미 명확화가 [v0.8] 태그로 추가되어 있다.
35-notification-architecture.md에 SESSION_RENEWED Owner 분기 템플릿 3채널, [거부하기] 버튼 채널별 명세, URL 보안이 [v0.8] 태그로 추가되어 있다.
SECURITY-03(Owner 없음 즉시 확정), SECURITY-04(Owner 있음 [거부하기]), NOTIF-03([거부하기] 버튼) 충족.
  </done>
</task>

</tasks>

<verification>
Phase 34 Success Criteria 5 충족 확인:
5. [SC-5] Kill Switch 복구 대기 시간(Owner 없음: 24h / Owner 있음: 30min)과 세션 갱신 거부 윈도우 분기가 명세되어 있다

요구사항 매핑 확인:
- SECURITY-01: Owner 없는 에이전트 Kill Switch 복구 masterAuth + 24h (Task 1)
- SECURITY-02: Owner 있는 에이전트 Kill Switch 복구 ownerAuth + masterAuth + 30min (Task 1)
- SECURITY-03: Owner 없는 에이전트 세션 갱신 즉시 확정 (Task 2)
- SECURITY-04: Owner 있는 에이전트 세션 갱신 [거부하기] 버튼 (Task 2)
- NOTIF-03: [거부하기] 버튼 채널별 명세 (Task 2)
</verification>

<success_criteria>
- 36-killswitch-autostop-evm.md에 Owner 유무별 복구 분기(24h vs 30min) + 2단계 패턴 + RECOVERING 상태가 추가되어 있다
- 53-session-renewal-protocol.md에 OwnerState별 갱신 분기(즉시 확정 vs [거부하기]) + rejectButton 플래그가 추가되어 있다
- 35-notification-architecture.md에 SESSION_RENEWED [거부하기] 버튼 3채널 명세가 추가되어 있다
- 모든 [v0.8] 태그가 적용되어 변경 추적이 가능하다
- SECURITY-01~04 + NOTIF-03 총 5개 요구사항 충족
</success_criteria>

<output>
After completion, create `.planning/phases/34-자금-회수-보안-분기-설계/34-02-SUMMARY.md`
</output>
