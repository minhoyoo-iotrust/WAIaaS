---
phase: 53-session-management
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/core/src/schemas/session.schema.ts
  - packages/daemon/src/api/routes/sessions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/api-sessions.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/sessions with masterAuth creates a session and returns JWT token"
    - "GET /v1/sessions with masterAuth returns list of active sessions for an agent"
    - "DELETE /v1/sessions/:id with masterAuth revokes a session immediately"
    - "A revoked session's token is rejected by sessionAuth middleware"
    - "Session creation stores token_hash, expiresAt, absoluteExpiresAt in DB"
  artifacts:
    - path: "packages/daemon/src/api/routes/sessions.ts"
      provides: "Session CRUD route handlers (POST, GET, DELETE)"
      exports: ["sessionRoutes"]
    - path: "packages/daemon/src/__tests__/api-sessions.test.ts"
      provides: "Session API test suite"
      min_lines: 120
    - path: "packages/core/src/schemas/session.schema.ts"
      provides: "CreateSessionRequestSchema Zod validator"
      exports: ["CreateSessionRequestSchema", "CreateSessionRequest"]
  key_links:
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      via: "jwtSecretManager.signToken() for JWT issuance"
      pattern: "jwtSecretManager\\.signToken"
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle insert/select/update on sessions table"
      pattern: "db\\.insert\\(sessions\\)|db\\.select\\(\\)\\.from\\(sessions\\)"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/api/routes/sessions.ts"
      via: "app.route('/v1', sessionRoutes(deps))"
      pattern: "sessionRoutes"
---

<objective>
Implement session CRUD API: POST /v1/sessions (create + JWT issuance), GET /v1/sessions (list active), DELETE /v1/sessions/:id (revoke).

Purpose: Agents need sessions to authenticate API calls. This plan enables the full session lifecycle (create, inspect, revoke) which is the foundation for session-based access control.

Output: Working session routes with TDD tests, integrated into server.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-auth-foundation/52-01-SUMMARY.md
@.planning/phases/52-auth-foundation/52-02-SUMMARY.md
@packages/daemon/src/api/server.ts
@packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/api/routes/agents.ts
@packages/daemon/src/api/middleware/session-auth.ts
@packages/daemon/src/__tests__/session-auth.test.ts
@packages/core/src/schemas/session.schema.ts
@packages/core/src/schemas/index.ts
@packages/daemon/src/infrastructure/config/loader.ts
@packages/core/src/errors/error-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CreateSessionRequestSchema + session routes with tests</name>
  <files>
    packages/core/src/schemas/session.schema.ts
    packages/core/src/schemas/index.ts
    packages/daemon/src/api/routes/sessions.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/__tests__/api-sessions.test.ts
  </files>
  <action>
**1. Add CreateSessionRequestSchema to core (session.schema.ts):**

```typescript
export const CreateSessionRequestSchema = z.object({
  agentId: z.string().uuid(),
  ttl: z.number().int().min(300).max(604800).optional(), // defaults to config security.session_ttl (86400)
  constraints: z.record(z.unknown()).nullable().optional(),
});
export type CreateSessionRequest = z.infer<typeof CreateSessionRequestSchema>;
```

Export from `packages/core/src/schemas/index.ts`:
```typescript
export { SessionSchema, type Session, CreateSessionRequestSchema, type CreateSessionRequest } from './session.schema.js';
```

**2. Create session routes (packages/daemon/src/api/routes/sessions.ts):**

SessionRouteDeps interface:
```typescript
export interface SessionRouteDeps {
  db: BetterSQLite3Database<typeof schema>;
  jwtSecretManager: JwtSecretManager;
  config: DaemonConfig;
}
```

**POST /sessions** (masterAuth protected, registered at server level):
- Parse body with CreateSessionRequestSchema
- Verify agent exists in DB (agents table, eq(agents.id, parsed.agentId)), throw AGENT_NOT_FOUND if not
- Check active session count for this agent: count sessions WHERE agent_id = agentId AND revoked_at IS NULL AND expires_at > now. If count >= config.security.max_sessions_per_agent (default 5), throw SESSION_LIMIT_EXCEEDED
- Generate session ID via generateId()
- Compute TTL: use parsed.ttl ?? config.security.session_ttl (default 86400 seconds)
- Compute expiresAt = now + ttl (seconds), absoluteExpiresAt = now + 30 * 86400 (30 days absolute lifetime)
- Create JwtPayload { sub: sessionId, agt: agentId, iat: nowSec, exp: nowSec + ttl }
- Sign token via jwtSecretManager.signToken(payload)
- Compute tokenHash = createHash('sha256').update(token).digest('hex') (from node:crypto)
- Insert into sessions table: { id, agentId, tokenHash, expiresAt: new Date(expiresAt*1000), absoluteExpiresAt: new Date(absoluteExpiresAt*1000), createdAt: new Date(nowSec*1000), renewalCount: 0, maxRenewals: 30, constraints: parsed.constraints ? JSON.stringify(parsed.constraints) : null }
- Return 201 with { id: sessionId, token, expiresAt: expiresAt (epoch seconds), agentId }

**GET /sessions** (masterAuth protected):
- Read query param agentId: c.req.query('agentId')
- If no agentId query param, throw 400 (use WAIaaSError AGENT_NOT_FOUND with message "agentId query parameter required")
- Select all sessions WHERE agent_id = agentId AND revoked_at IS NULL, ordered by createdAt desc
- For each session, compute runtime status: if expiresAt < now -> 'EXPIRED', else 'ACTIVE'
- Return 200 with array of { id, agentId, status, renewalCount, maxRenewals, expiresAt (epoch sec), absoluteExpiresAt (epoch sec), createdAt (epoch sec), lastRenewedAt (epoch sec or null) }

**DELETE /sessions/:id** (masterAuth protected):
- Get session ID from c.req.param('id')
- Look up session by id, throw SESSION_NOT_FOUND if missing
- If already revoked (revokedAt !== null), return 200 with { id, status: 'REVOKED', message: 'Session already revoked' }
- Update session: set revokedAt = new Date(nowSec * 1000)
- Return 200 with { id, status: 'REVOKED' }

**3. Register session routes in server.ts:**

Import sessionRoutes from './routes/sessions.js'.

In createApp(), after the masterAuth registration and before agent routes, add:
```typescript
// Register session routes when deps are available (masterAuth + JWT)
if (deps.db && deps.jwtSecretManager && deps.config) {
  app.route(
    '/v1',
    sessionRoutes({
      db: deps.db,
      jwtSecretManager: deps.jwtSecretManager,
      config: deps.config,
    }),
  );
}
```

Session routes are at /v1/sessions, protected by masterAuth at server level. Add to the existing masterAuth block:
```typescript
app.use('/v1/sessions', createMasterAuth({ masterPasswordHash: deps.masterPasswordHash }));
app.use('/v1/sessions/*', createMasterAuth({ masterPasswordHash: deps.masterPasswordHash }));
```

**4. Write TDD tests (packages/daemon/src/__tests__/api-sessions.test.ts):**

Follow the session-auth.test.ts pattern: in-memory SQLite, JwtSecretManager, Hono app.request().

Setup:
- createDatabase(':memory:'), pushSchema, new JwtSecretManager(db), initialize()
- Use createApp() with full deps (including masterPasswordHash from Argon2id hash of test password)
- For masterAuth, compute hash beforehand with argon2id (same pattern as master-auth.test.ts)
- Helper: masterAuthHeader() returns { 'X-Master-Password': TEST_PASSWORD }

Test cases (RED then GREEN):

1. **POST /v1/sessions returns 201 with JWT token** - send { agentId, ttl: 3600 }, verify response has id, token (starts with wai_sess_), expiresAt, agentId
2. **POST /v1/sessions returns 404 when agent not found** - send { agentId: nonexistent UUID }
3. **POST /v1/sessions returns 403 SESSION_LIMIT_EXCEEDED** - create 5 sessions for same agent, attempt 6th
4. **POST /v1/sessions returns 401 without masterAuth** - no X-Master-Password header
5. **GET /v1/sessions?agentId=X returns active sessions** - create 2 sessions, verify list has 2 items with correct fields
6. **GET /v1/sessions?agentId=X excludes revoked sessions** - create session, revoke it, verify list empty
7. **DELETE /v1/sessions/:id revokes session** - create session, delete it, verify status REVOKED
8. **DELETE /v1/sessions/:id returns SESSION_NOT_FOUND for unknown id** - attempt delete on nonexistent session
9. **Revoked session token rejected by sessionAuth** - create session, delete it, then attempt to use the returned token on a sessionAuth-protected route -> expect 401 SESSION_REVOKED
10. **Session stores correct tokenHash and timestamps** - create session, query DB directly, verify tokenHash = sha256(token), expiresAt and absoluteExpiresAt are correct

For test helpers, seed a test agent first:
```typescript
function seedAgent(agentId: string) {
  const ts = Math.floor(Date.now() / 1000);
  sqlite.prepare(
    `INSERT INTO agents (id, name, chain, network, public_key, status, owner_verified, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
  ).run(agentId, 'Test Agent', 'solana', 'mainnet', `pk-${agentId}`, 'ACTIVE', 0, ts, ts);
}
```

For Argon2id test hash, use the createRequire pattern from master-auth.ts to import argon2id from sodium-native (or use the same approach as master-auth.test.ts -- check that file for the hash generation pattern).
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test` -- all tests pass including new session tests.
Verify POST creates session, GET lists sessions, DELETE revokes, and revoked token is rejected.
  </verify>
  <done>
POST /v1/sessions creates session + returns JWT (201), GET /v1/sessions lists active sessions, DELETE /v1/sessions/:id revokes session, revoked tokens rejected by sessionAuth, session limit enforced, 10+ tests passing.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` -- all daemon tests pass (existing + new session tests)
2. `pnpm build` -- TypeScript compilation succeeds with no errors
3. Session creation returns valid wai_sess_ JWT token that is accepted by sessionAuth middleware
4. Session revocation via DELETE causes sessionAuth to reject the token with SESSION_REVOKED
5. GET /v1/sessions returns correct session status (ACTIVE/EXPIRED) based on expiresAt vs now
</verification>

<success_criteria>
- POST /v1/sessions creates a session and returns a valid JWT token (201)
- GET /v1/sessions?agentId=X returns list of active sessions with status, renewalCount, timestamps
- DELETE /v1/sessions/:id sets revokedAt, subsequent token use returns 401 SESSION_REVOKED
- Session limit (max_sessions_per_agent config) is enforced
- All 10+ new tests pass alongside existing 204+ tests with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/53-session-management/53-01-SUMMARY.md`
</output>
