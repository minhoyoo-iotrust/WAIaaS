---
phase: 53-session-management
plan: 02
type: tdd
wave: 2
depends_on: ["53-01"]
files_modified:
  - packages/daemon/src/api/routes/sessions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/api-session-renewal.test.ts
autonomous: true

must_haves:
  truths:
    - "PUT /v1/sessions/:id/renew with sessionAuth issues new token and invalidates old token"
    - "Renewal is rejected when renewalCount >= maxRenewals (30)"
    - "Renewal is rejected when absoluteExpiresAt is exceeded (30 days)"
    - "Renewal is rejected when less than 50% of current TTL has elapsed"
    - "Renewal uses token_hash CAS to prevent race conditions"
    - "Old token stops working immediately after renewal"
  artifacts:
    - path: "packages/daemon/src/api/routes/sessions.ts"
      provides: "PUT /v1/sessions/:id/renew handler with 5 safety checks"
      contains: "renewalCount"
    - path: "packages/daemon/src/__tests__/api-session-renewal.test.ts"
      provides: "Session renewal test suite with 5 safety checks"
      min_lines: 150
  key_links:
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts"
      via: "signToken for new JWT, verifyToken for old token validation"
      pattern: "jwtSecretManager\\.signToken"
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle update sessions with CAS on token_hash"
      pattern: "eq\\(sessions\\.tokenHash"
---

<objective>
Implement session renewal (PUT /v1/sessions/:id/renew) with 5 safety checks: maxRenewals limit, absolute lifetime, 50% TTL elapsed, token_hash CAS, and token rotation.

Purpose: Session renewal enables long-lived agent operations while maintaining security boundaries. The 5 safety checks prevent infinite renewal, stale sessions, and race conditions.

Output: Working renewal endpoint with comprehensive TDD tests covering all 5 safety checks.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-auth-foundation/52-01-SUMMARY.md
@.planning/phases/53-session-management/53-01-SUMMARY.md
@packages/daemon/src/api/routes/sessions.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/api/middleware/session-auth.ts
@packages/core/src/errors/error-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PUT /v1/sessions/:id/renew with 5 safety checks + tests</name>
  <files>
    packages/daemon/src/api/routes/sessions.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/__tests__/api-session-renewal.test.ts
  </files>
  <action>
**1. Add PUT /sessions/:id/renew handler to sessions.ts:**

This endpoint is sessionAuth-protected (not masterAuth). The caller must be the session owner -- the JWT identifies the session.

Register sessionAuth on the renew path in server.ts:
```typescript
// Session renewal uses sessionAuth (the session's own token)
if (deps.jwtSecretManager && deps.db) {
  const sessionAuth = createSessionAuth({ jwtSecretManager: deps.jwtSecretManager, db: deps.db });
  app.use('/v1/sessions/*/renew', sessionAuth);
}
```

Note: existing masterAuth is on `/v1/sessions` and `/v1/sessions/*`. The renew path needs sessionAuth instead. To handle this, the `renew` endpoint should NOT be covered by masterAuth. Adjust server.ts auth registration:
- masterAuth on `/v1/sessions` (POST/GET at root -- matches POST /v1/sessions and GET /v1/sessions)
- masterAuth on DELETE pattern -- keep masterAuth on `/v1/sessions/*` but skip the renew sub-path. Since Hono middleware stacks, use a more targeted approach:
  - Register masterAuth on `/v1/sessions` (covers POST and GET at root level)
  - Register masterAuth on `/v1/sessions/:id` via a custom middleware that checks method+path for DELETE only
  - OR simpler: register masterAuth broadly on `/v1/sessions*` and then in the renew handler, since sessionAuth runs FIRST on the more specific path `/v1/sessions/*/renew`, the sessionAuth will execute. The masterAuth will also execute but the renew handler can ignore it.

  **Simplest correct approach:**
  - Keep masterAuth on `/v1/sessions` (covers POST /sessions and GET /sessions)
  - For DELETE /sessions/:id, masterAuth on `/v1/sessions/*` works
  - For renew, override with sessionAuth on `/v1/sessions/*/renew`
  - Since both would match /sessions/:id/renew, use the route handler to determine: Actually Hono applies middleware in registration order. If sessionAuth is registered BEFORE masterAuth for the renew path, it will execute first.

  **Best approach for clarity:** Don't register masterAuth on `/v1/sessions/*` (it would conflict with renew). Instead:
  - masterAuth on `/v1/sessions` (POST create, GET list)
  - sessionAuth on `/v1/sessions/*/renew` (PUT renew)
  - For DELETE, add masterAuth in the delete route handler itself, OR register masterAuth specifically for DELETE via a path that won't match renew.

  **Final decision:** Since Hono's `app.use` applies to all methods on the path, do this:
  - Remove `app.use('/v1/sessions/*', masterAuth)` if it would conflict
  - Keep `app.use('/v1/sessions', masterAuth)` for POST/GET on /v1/sessions
  - The DELETE handler in sessions.ts should check masterAuth itself by accepting masterAuth as a dep. But that changes the pattern.

  **Cleanest approach (consistent with existing pattern):** Update SessionRouteDeps to include masterPasswordHash. In the delete handler, verify X-Master-Password manually (or accept that DELETE is also at the sessions sub-router level). Actually, looking at the existing pattern, the simplest is:

  In server.ts:
  ```typescript
  // masterAuth for session management (create, list, delete)
  app.use('/v1/sessions', createMasterAuth({ ... }));
  // sessionAuth for session renewal (uses own token)
  app.use('/v1/sessions/*/renew', sessionAuth);
  ```

  For DELETE /v1/sessions/:id, since `/v1/sessions` masterAuth covers it (Hono path matching: `/v1/sessions` matches `/v1/sessions/XYZ` for sub-routers when the sub-router defines route `/:id`). Wait -- actually the sub-router at `/v1` means routes are `/sessions`, `/sessions/:id`, `/sessions/:id/renew`. The `app.use('/v1/sessions', masterAuth)` only matches requests to exactly `/v1/sessions`, not `/v1/sessions/123`. We need both:

  ```typescript
  // masterAuth for sessions CRUD (create/list at root, delete at :id)
  if (deps.masterPasswordHash !== undefined) {
    const masterAuth = createMasterAuth({ masterPasswordHash: deps.masterPasswordHash });
    app.use('/v1/sessions', masterAuth);
    app.use('/v1/sessions/:id', masterAuth);
  }
  // sessionAuth for renewal (PUT /v1/sessions/:id/renew)
  if (deps.jwtSecretManager && deps.db) {
    const sessionAuth = createSessionAuth({ jwtSecretManager: deps.jwtSecretManager, db: deps.db });
    app.use('/v1/sessions/:id/renew', sessionAuth);
  }
  ```

  Since `/v1/sessions/:id` and `/v1/sessions/:id/renew` are different paths, masterAuth won't apply to `/renew` and sessionAuth won't apply to DELETE. This is clean separation.

**PUT /sessions/:id/renew handler logic:**

1. Get sessionId from c.req.param('id')
2. Get calling session's ID from c.get('sessionId' as never) -- set by sessionAuth
3. **Verify caller owns the session:** if param id !== context sessionId, throw SESSION_NOT_FOUND (prevent renewing other sessions)
4. Get current token from Authorization header: c.req.header('Authorization')?.slice('Bearer '.length)
5. Compute currentTokenHash = createHash('sha256').update(currentToken).digest('hex')

**5 Safety Checks (in order):**

6. **Check 1 - Session exists and not revoked:**
   Look up session from DB. Throw SESSION_NOT_FOUND if missing. Throw SESSION_REVOKED if revokedAt !== null.

7. **Check 2 - token_hash CAS (Compare-And-Swap):**
   If session.tokenHash !== currentTokenHash, throw SESSION_RENEWAL_MISMATCH. This prevents race conditions where two renew requests run concurrently.

8. **Check 3 - maxRenewals limit:**
   If session.renewalCount >= session.maxRenewals, throw RENEWAL_LIMIT_REACHED.

9. **Check 4 - Absolute lifetime:**
   If nowSec >= absoluteExpiresAtSec (session.absoluteExpiresAt epoch), throw SESSION_ABSOLUTE_LIFETIME_EXCEEDED.

10. **Check 5 - 50% TTL elapsed:**
    Compute the original TTL from the JWT: currentTtl = jwtPayload.exp - jwtPayload.iat (from the verified token).
    Compute elapsed = nowSec - jwtPayload.iat.
    If elapsed < currentTtl * 0.5, throw RENEWAL_TOO_EARLY.

**Issue new token:**

11. Compute newTtl = same as current token's TTL (jwtPayload.exp - jwtPayload.iat). Clamp: newExpiresAt = min(nowSec + newTtl, absoluteExpiresAtSec).
12. Create new JwtPayload { sub: sessionId, agt: session.agentId, iat: nowSec, exp: newExpiresAt }
13. Sign new token via jwtSecretManager.signToken(newPayload)
14. Compute newTokenHash = createHash('sha256').update(newToken).digest('hex')
15. Update session in DB atomically:
    ```typescript
    const result = db.update(sessions)
      .set({
        tokenHash: newTokenHash,
        expiresAt: new Date(newExpiresAt * 1000),
        renewalCount: session.renewalCount + 1,
        lastRenewedAt: new Date(nowSec * 1000),
      })
      .where(
        and(
          eq(sessions.id, sessionId),
          eq(sessions.tokenHash, currentTokenHash) // CAS guard
        )
      )
      .run();
    ```
    If result.changes === 0, throw SESSION_RENEWAL_MISMATCH (CAS failed, concurrent renewal won).

16. Return 200 with { id: sessionId, token: newToken, expiresAt: newExpiresAt, renewalCount: session.renewalCount + 1 }

Import `and` from drizzle-orm for the compound WHERE clause.

**2. Write TDD tests (packages/daemon/src/__tests__/api-session-renewal.test.ts):**

Setup: Same pattern as api-sessions.test.ts -- in-memory SQLite, full createApp with masterPasswordHash + jwtSecretManager + config deps.

Helper functions:
- seedAgent(id) -- insert agent
- createSessionViaApi(agentId) -- POST /v1/sessions with masterAuth header, returns { id, token, expiresAt }
- renewSessionViaApi(sessionId, token) -- PUT /v1/sessions/:id/renew with Bearer token

Test cases:

1. **Successful renewal returns new token** - create session, wait (use vi.useFakeTimers and advance > 50% of TTL), renew, verify new token, old token no longer works
2. **Old token rejected after renewal** - create session, renew, attempt to use old token on a protected route -> 401 (INVALID_TOKEN or SESSION_REVOKED)
3. **Renewal rejected: maxRenewals exceeded** - create session, manually set renewalCount = 30 in DB, attempt renew -> 403 RENEWAL_LIMIT_REACHED
4. **Renewal rejected: absolute lifetime exceeded** - create session, manually set absoluteExpiresAt to past in DB, attempt renew -> 403 SESSION_ABSOLUTE_LIFETIME_EXCEEDED
5. **Renewal rejected: too early (< 50% TTL elapsed)** - create session with 1-hour TTL, immediately try renew (0 seconds elapsed) -> 403 RENEWAL_TOO_EARLY
6. **Renewal rejected: revoked session** - create session, revoke it (DELETE), attempt renew with old token -> 401 SESSION_REVOKED (caught by sessionAuth middleware)
7. **Renewal rejected: token_hash CAS mismatch** - create session, manually change tokenHash in DB to a different value, attempt renew -> 403 SESSION_RENEWAL_MISMATCH
8. **Renewal rejected: wrong session ID** - create two sessions, try to renew session B using session A's token -> SESSION_NOT_FOUND (param id != context sessionId)
9. **renewalCount increments on each renewal** - create session, renew twice (advancing time between), verify renewalCount = 2 and lastRenewedAt updated
10. **New token expiresAt clamped by absoluteExpiresAt** - create session where absoluteExpiresAt is only 1800 seconds away, renew with 3600 TTL -> new expiresAt should equal absoluteExpiresAt

For time manipulation, use vi.useFakeTimers() to control Date.now():
```typescript
vi.useFakeTimers();
vi.setSystemTime(baseTime);
// Create session (TTL 3600)
// Advance past 50%
vi.setSystemTime(baseTime + 1801 * 1000);
// Renew should succeed
```

Note: jose uses Date.now() for JWT expiration checks, so vi.useFakeTimers works for both app logic and JWT verification.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm test` -- all tests pass including renewal tests.
Verify all 5 safety checks are enforced, token rotation works, and CAS prevents race conditions.
  </verify>
  <done>
PUT /v1/sessions/:id/renew issues new token, invalidates old token, enforces 5 safety checks (maxRenewals, absolute lifetime, 50% TTL, token_hash CAS, revocation check), 10+ tests passing. Renewal count increments correctly, expiresAt clamped by absoluteExpiresAt.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` -- all daemon tests pass (existing + session CRUD + renewal tests)
2. `pnpm build` -- TypeScript compilation succeeds
3. Old token stops working after renewal (SESSION_RENEWAL_MISMATCH or sessionAuth rejection)
4. All 5 safety checks correctly reject invalid renewal attempts with appropriate error codes
5. CAS on token_hash prevents concurrent renewal race conditions
6. Session renewal count increments and lastRenewedAt updates
</verification>

<success_criteria>
- PUT /v1/sessions/:id/renew issues new JWT, updates tokenHash in DB, increments renewalCount
- Old token immediately rejected after renewal (token_hash changed in DB)
- Safety check 1: renewalCount >= 30 -> RENEWAL_LIMIT_REACHED (403)
- Safety check 2: absoluteExpiresAt exceeded -> SESSION_ABSOLUTE_LIFETIME_EXCEEDED (403)
- Safety check 3: < 50% TTL elapsed -> RENEWAL_TOO_EARLY (403)
- Safety check 4: token_hash CAS mismatch -> SESSION_RENEWAL_MISMATCH (403)
- Safety check 5: session revoked -> SESSION_REVOKED (401, caught by sessionAuth)
- 10+ new tests pass alongside all existing tests with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/53-session-management/53-02-SUMMARY.md`
</output>
