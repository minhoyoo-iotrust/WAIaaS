---
phase: 136-cumulative-spending-engine
plan: 02
type: execute
wave: 2
depends_on: ["136-01"]
files_modified:
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/workflow/approval-workflow.ts
  - packages/core/src/enums/notification.ts
  - packages/core/src/interfaces/IPolicyEngine.ts
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/__tests__/notification-channels.test.ts
  - packages/daemon/src/__tests__/cumulative-spending.test.ts
autonomous: true

must_haves:
  truths:
    - "daily_limit_usd 설정 상태에서 24시간 내 누적 USD가 한도를 초과하면 APPROVAL로 격상된다"
    - "monthly_limit_usd 설정 상태에서 30일 내 누적 USD가 한도를 초과하면 APPROVAL로 격상된다"
    - "PENDING/QUEUED/SIGNED 상태 트랜잭션의 reserved_amount_usd가 누적 합산에 포함된다"
    - "누적 지출이 한도의 80%에 도달하면 CUMULATIVE_LIMIT_WARNING 알림이 발송된다"
    - "APPROVAL 격상 시 TX_APPROVAL_REQUIRED 이벤트에 reason 필드가 포함된다"
    - "건별 tier와 누적 tier 중 더 보수적인 tier가 최종 결과로 반환된다"
  artifacts:
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateAndReserve 내 누적 USD 집계 쿼리 + APPROVAL 격상 로직"
      contains: "daily_limit_usd"
    - path: "packages/core/src/enums/notification.ts"
      provides: "CUMULATIVE_LIMIT_WARNING 이벤트 타입"
      contains: "CUMULATIVE_LIMIT_WARNING"
    - path: "packages/core/src/interfaces/IPolicyEngine.ts"
      provides: "PolicyEvaluation에 reason 필드 활용 (approvalReason)"
      contains: "approvalReason"
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "Stage 3 누적 알림 발송 + TX_APPROVAL_REQUIRED reason 확장"
      contains: "CUMULATIVE_LIMIT_WARNING"
    - path: "packages/daemon/src/__tests__/cumulative-spending.test.ts"
      provides: "누적 한도 단위 테스트"
      contains: "evaluateAndReserve"
  key_links:
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "SUM(amount_usd) + SUM(reserved_amount_usd) 누적 집계 쿼리"
      pattern: "SUM.*amount_usd"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/core/src/enums/notification.ts"
      via: "CUMULATIVE_LIMIT_WARNING 알림 발송"
      pattern: "CUMULATIVE_LIMIT_WARNING"
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "packages/core/src/interfaces/IPolicyEngine.ts"
      via: "PolicyEvaluation.approvalReason 필드로 격상 사유 전달"
      pattern: "approvalReason"
---

<objective>
evaluateAndReserve의 BEGIN IMMEDIATE 트랜잭션 내에서 24시간/30일 롤링 윈도우 누적 USD 집계를 수행하고, 한도 초과 시 APPROVAL로 격상하며, 80% 경고 알림과 TX_APPROVAL_REQUIRED reason 필드를 구현한다.

Purpose: 분할 전송으로 건별 한도를 우회하는 시나리오를 차단하여 Owner의 자금 통제권을 강화한다. PENDING/QUEUED/SIGNED 상태의 reserved_amount_usd도 합산하여 동시 요청에 의한 이중 지출을 방지한다.
Output: 누적 집계 로직, APPROVAL 격상, CUMULATIVE_LIMIT_WARNING 알림, reason 필드 확장, 단위 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/136-cumulative-spending-engine/136-01-SUMMARY.md
@objectives/v1.5.3-usd-policy-enhancement.md
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/workflow/approval-workflow.ts
@packages/core/src/enums/notification.ts
@packages/core/src/interfaces/IPolicyEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: PolicyEvaluation 확장 + CUMULATIVE_LIMIT_WARNING 이벤트 + approval-workflow reserved_amount_usd 클리어</name>
  <files>
    packages/core/src/interfaces/IPolicyEngine.ts
    packages/core/src/enums/notification.ts
    packages/daemon/src/__tests__/notification-channels.test.ts
    packages/daemon/src/workflow/approval-workflow.ts
  </files>
  <action>
1. **IPolicyEngine.ts -- PolicyEvaluation에 approvalReason 필드 추가:**
   - PolicyEvaluation 인터페이스에 optional 필드를 추가한다:
     ```ts
     /** Reason for APPROVAL escalation (per_tx / cumulative_daily / cumulative_monthly). */
     approvalReason?: 'per_tx' | 'cumulative_daily' | 'cumulative_monthly';
     ```
   - 이 필드는 tier === 'APPROVAL'일 때만 설정된다. evaluateAndReserve에서 누적 한도 초과로 APPROVAL이 된 경우 해당 사유를 기록한다.

2. **notification.ts -- CUMULATIVE_LIMIT_WARNING 이벤트 추가:**
   - NOTIFICATION_EVENT_TYPES 배열의 'DAILY_SUMMARY' 다음에 'CUMULATIVE_LIMIT_WARNING'을 추가한다.
   - 총 22개 이벤트가 된다.

3. **notification-channels.test.ts -- 이벤트 수 업데이트:**
   - `expect(NOTIFICATION_EVENT_TYPES).toHaveLength(21)` -> `toHaveLength(22)`
   - 'CUMULATIVE_LIMIT_WARNING'이 포함되어 있는지 확인하는 assertion 추가.

4. **approval-workflow.ts -- reserved_amount_usd NULL 클리어 추가:**
   - approve() 메서드의 `UPDATE transactions SET status = ?, reserved_amount = NULL WHERE id = ?` 쿼리에 `reserved_amount_usd = NULL` 추가:
     ```ts
     'UPDATE transactions SET status = ?, reserved_amount = NULL, reserved_amount_usd = NULL WHERE id = ?'
     ```
   - reject() 메서드의 동일 UPDATE에도 `reserved_amount_usd = NULL` 추가.
   - processExpiredApprovals() 메서드의 동일 UPDATE에도 `reserved_amount_usd = NULL` 추가.
   - 총 3곳 수정. 이렇게 해야 APPROVAL/CANCEL/EXPIRE된 트랜잭션이 누적 집계에서 제외된다.
  </action>
  <verify>
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build --filter=@waiaas/core` 성공
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/notification-channels.test.ts` 통과
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/approval-workflow.test.ts` 기존 테스트 통과
  </verify>
  <done>
    - PolicyEvaluation.approvalReason 필드가 추가되어 APPROVAL 격상 사유를 전달할 수 있다
    - CUMULATIVE_LIMIT_WARNING 이벤트가 NotificationEventType에 등록되었다
    - approval-workflow의 approve/reject/expire에서 reserved_amount_usd도 NULL로 클리어된다
  </done>
</task>

<task type="auto">
  <name>Task 2: evaluateAndReserve 누적 집계 + APPROVAL 격상 + Stage 3 알림</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/__tests__/cumulative-spending.test.ts
  </files>
  <action>
1. **database-policy-engine.ts -- evaluateAndReserve 누적 집계 로직:**

   evaluateAndReserve()의 BEGIN IMMEDIATE 트랜잭션 내부에서, 기존 SPENDING_LIMIT 평가 블록(Step 5, 라인 544-577) 이후에 누적 평가 로직을 추가한다.

   기존 Step 5 블록이 반환하는 `spendingResult`를 바로 return하지 않고, 누적 평가를 추가로 수행한다:

   ```ts
   // Step 5 기존 코드 유지 (네이티브 + 건별 USD 평가)
   // ...spendingResult 계산...

   // Step 6: 누적 USD 한도 평가 (daily/monthly)
   if (usdAmount !== undefined && usdAmount > 0) {
     const rules: SpendingLimitRules = JSON.parse(spendingPolicy.rules);
     const hasCumulativeLimits = rules.daily_limit_usd !== undefined || rules.monthly_limit_usd !== undefined;

     if (hasCumulativeLimits) {
       const now = Math.floor(Date.now() / 1000);
       let cumulativeTier: PolicyTier = 'INSTANT';
       let cumulativeReason: 'cumulative_daily' | 'cumulative_monthly' | undefined;

       // 6a: Daily (24h rolling window)
       if (rules.daily_limit_usd !== undefined) {
         const windowStart = now - 86400; // 24 * 60 * 60
         const spent = this.getCumulativeUsdSpent(sqlite, walletId, windowStart);
         const totalWithCurrent = spent + usdAmount;

         if (totalWithCurrent > rules.daily_limit_usd) {
           cumulativeTier = 'APPROVAL';
           cumulativeReason = 'cumulative_daily';
         }
       }

       // 6b: Monthly (30-day rolling window)
       if (rules.monthly_limit_usd !== undefined && cumulativeReason === undefined) {
         const windowStart = now - 2592000; // 30 * 24 * 60 * 60
         const spent = this.getCumulativeUsdSpent(sqlite, walletId, windowStart);
         const totalWithCurrent = spent + usdAmount;

         if (totalWithCurrent > rules.monthly_limit_usd) {
           cumulativeTier = 'APPROVAL';
           cumulativeReason = 'cumulative_monthly';
         }
       }

       // Step 7: 최종 tier = max(건별 tier, 누적 tier)
       const perTxTier = spendingResult?.tier ?? ('INSTANT' as PolicyTier);
       const finalTier = maxTier(perTxTier, cumulativeTier);

       // approvalReason 결정
       let approvalReason: 'per_tx' | 'cumulative_daily' | 'cumulative_monthly' | undefined;
       if (finalTier === 'APPROVAL') {
         if (cumulativeReason) {
           approvalReason = cumulativeReason;
         } else {
           approvalReason = 'per_tx';
         }
       }

       // USD amounts 기록 (Plan 01에서 구현한 로직 위치에 통합)
       sqlite
         .prepare('UPDATE transactions SET reserved_amount = ?, amount_usd = ?, reserved_amount_usd = ? WHERE id = ?')
         .run(transaction.amount, usdAmount, usdAmount, txId);

       return {
         allowed: true,
         tier: finalTier,
         ...(spendingResult?.delaySeconds !== undefined && finalTier === 'DELAY' ? { delaySeconds: spendingResult.delaySeconds } : {}),
         ...(approvalReason ? { approvalReason } : {}),
       };
     }
   }

   // 누적 한도 미설정 시 기존 경로: USD 기록 + 건별 결과 반환
   // (Plan 01에서 구현한 usdAmount 기록 로직)
   ```

   **중요**: 기존 Step 5의 `UPDATE transactions SET reserved_amount` 부분을 Step 6 누적 평가 경로에서도 처리해야 한다. 누적 평가 경로에서는 amount_usd/reserved_amount_usd도 함께 기록하므로 기존 UPDATE를 대체한다. 누적 한도가 없는 경로에서는 Plan 01에서 구현한 기존 UPDATE가 동작한다.

2. **database-policy-engine.ts -- getCumulativeUsdSpent 헬퍼 메서드:**
   - private 메서드로 추가한다. objective 문서의 SQL 패턴을 따른다:
   ```ts
   /**
    * Get cumulative USD spent by wallet within a time window.
    * Includes both confirmed amounts (amount_usd) and pending reservations (reserved_amount_usd).
    */
   private getCumulativeUsdSpent(sqlite: Database, walletId: string, windowStart: number): number {
     // 1. 확정된 트랜잭션 (CONFIRMED/SIGNED) amount_usd
     const confirmedRow = sqlite
       .prepare(
         `SELECT COALESCE(SUM(amount_usd), 0) AS total
          FROM transactions
          WHERE wallet_id = ? AND status IN ('CONFIRMED', 'SIGNED')
          AND created_at >= ? AND amount_usd IS NOT NULL`,
       )
       .get(walletId, windowStart) as { total: number };

     // 2. 대기 중 트랜잭션 (PENDING/QUEUED/SIGNED) reserved_amount_usd
     // SIGNED은 확정(1)과 대기(2) 모두에 포함 -- 중복 방지를 위해 reserved_amount_usd만 사용
     // (SIGNED 상태는 amount_usd에 확정 기록, reserved_amount_usd에 예약 기록이 모두 존재)
     // 따라서: CONFIRMED의 amount_usd + PENDING/QUEUED의 reserved_amount_usd로 집계
     const pendingRow = sqlite
       .prepare(
         `SELECT COALESCE(SUM(reserved_amount_usd), 0) AS total
          FROM transactions
          WHERE wallet_id = ? AND status IN ('PENDING', 'QUEUED')
          AND reserved_amount_usd IS NOT NULL`,
       )
       .get(walletId) as { total: number };

     // SIGNED 상태: confirm되었지만 아직 체인 전파 중. amount_usd로 집계 (confirmed와 동일 취급).
     // 단, SIGNED가 첫 번째 쿼리에 이미 포함되므로 별도 쿼리 불필요.

     return confirmedRow.total + pendingRow.total;
   }
   ```

   **주의**: SIGNED 상태의 중복 카운팅 방지. SIGNED는 첫 번째 쿼리(CONFIRMED/SIGNED의 amount_usd)에 포함되므로 두 번째 쿼리(PENDING/QUEUED의 reserved_amount_usd)에서 제외한다. 이중 지출 방지가 목적이므로, PENDING/QUEUED의 reserved_amount_usd를 별도로 합산한다.

3. **database-policy-engine.ts -- evaluateSpendingLimit에서 approvalReason 반환:**
   - 기존 evaluateSpendingLimit()에서 `return { allowed: true, tier: finalTier, ... }`의 tier가 APPROVAL인 경우, `approvalReason: 'per_tx'`를 추가한다:
     ```ts
     return {
       allowed: true,
       tier: finalTier,
       ...(delaySeconds !== undefined ? { delaySeconds } : {}),
       ...(finalTier === 'APPROVAL' ? { approvalReason: 'per_tx' as const } : {}),
     };
     ```

4. **stages.ts -- Stage 3에서 누적 경고 알림 + TX_APPROVAL_REQUIRED reason 확장:**

   stage3Policy() 함수에서 evaluation 결과 처리 부분(라인 329 이후)을 확장한다:

   a) APPROVAL 격상 시 TX_APPROVAL_REQUIRED 알림에 reason 필드 추가:
      - stage4Wait()에서 APPROVAL 처리할 때 notification을 발송하지 않는 것으로 보인다. 현재 코드에서 TX_APPROVAL_REQUIRED 알림이 어디서도 발송되지 않으므로, stage4Wait의 APPROVAL 분기 직전(ctx.tier 설정 후, stage4Wait 호출 전)에 알림을 추가한다.
      - 위치: stage3Policy() 끝부분, `ctx.tier = tier` 설정 후에서 tier === 'APPROVAL'이고 !downgraded인 경우:
        ```ts
        // APPROVAL tier 알림 발송 (reason 포함)
        if (tier === 'APPROVAL' && !downgraded) {
          const reason = evaluation.approvalReason ?? 'per_tx';
          void ctx.notificationService?.notify('TX_APPROVAL_REQUIRED', ctx.walletId, {
            amount: getRequestAmount(ctx.request),
            to: getRequestTo(ctx.request),
            reason,
          }, { txId: ctx.txId });
        }
        ```

   b) 누적 80% 경고 알림:
      - evaluateAndReserve에서 누적 비율 정보를 반환하면 stage3Policy에서 알림을 발송하는 구조가 깔끔하지만, evaluateAndReserve는 동기 함수이므로 알림(fire-and-forget async)을 직접 호출할 수 없다.
      - 대신 PolicyEvaluation에 `cumulativeWarning` optional 필드를 추가한다:
        ```ts
        // IPolicyEngine.ts에 추가
        /** Cumulative spending warning: ratio (0-1) of limit used, if >= 0.8. */
        cumulativeWarning?: { type: 'daily' | 'monthly'; ratio: number; spent: number; limit: number };
        ```
      - evaluateAndReserve에서 누적 집계 시, 한도 미초과이지만 80% 이상인 경우 이 필드를 설정한다.
      - stage3Policy에서 evaluation.cumulativeWarning이 있으면 CUMULATIVE_LIMIT_WARNING 알림을 발송한다:
        ```ts
        if (evaluation.cumulativeWarning) {
          const w = evaluation.cumulativeWarning;
          void ctx.notificationService?.notify('CUMULATIVE_LIMIT_WARNING', ctx.walletId, {
            type: w.type,
            spent: String(w.spent.toFixed(2)),
            limit: String(w.limit.toFixed(2)),
            ratio: String(Math.round(w.ratio * 100)),
          }, { txId: ctx.txId });
        }
        ```

5. **cumulative-spending.test.ts -- 누적 한도 단위 테스트 (새 파일):**
   - 기존 policy-engine.test.ts 패턴을 참조하여 새 테스트 파일을 생성한다.
   - 테스트 케이스:
     a) daily_limit_usd 설정, 누적 미초과 -> 건별 tier 유지
     b) daily_limit_usd 설정, 누적 초과 -> APPROVAL 격상 + approvalReason === 'cumulative_daily'
     c) monthly_limit_usd 설정, 누적 초과 -> APPROVAL 격상 + approvalReason === 'cumulative_monthly'
     d) PENDING 트랜잭션의 reserved_amount_usd가 누적에 포함됨 (이중 지출 방지)
     e) CANCELLED/EXPIRED 트랜잭션은 누적에 미포함 (reserved_amount_usd === NULL)
     f) 건별 DELAY + 누적 APPROVAL -> 최종 APPROVAL (max tier)
     g) daily 80% 도달 -> cumulativeWarning 필드 설정 (한도 미초과)
     h) usdAmount undefined (오라클 장애) -> 누적 평가 스킵, 건별만 수행
   - 테스트 환경: in-memory SQLite(createDatabase), 직접 INSERT로 과거 트랜잭션 생성, evaluateAndReserve 호출.
  </action>
  <verify>
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build` 전체 빌드 성공
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/cumulative-spending.test.ts` 모든 테스트 통과
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/policy-engine.test.ts` 기존 테스트 통과
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/approval-workflow.test.ts` 기존 테스트 통과
    - `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx vitest run --reporter=verbose packages/daemon/src/__tests__/notification-channels.test.ts` 통과
  </verify>
  <done>
    - daily_limit_usd/monthly_limit_usd 초과 시 APPROVAL로 격상되고 approvalReason이 설정된다
    - PENDING/QUEUED의 reserved_amount_usd가 누적 합산에 포함되어 이중 지출이 방지된다
    - 80% 경고 시 CUMULATIVE_LIMIT_WARNING 알림이 발송된다
    - TX_APPROVAL_REQUIRED 알림에 reason 필드가 포함된다
    - 8개 이상의 단위 테스트가 통과한다
    - 기존 테스트에 regression이 없다
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build` -- 전체 빌드 성공
2. `npx vitest run packages/daemon/src/__tests__/cumulative-spending.test.ts` -- 누적 한도 테스트 전체 통과
3. `npx vitest run packages/daemon/src/__tests__/policy-engine.test.ts` -- 기존 정책 엔진 regression 없음
4. `npx vitest run packages/daemon/src/__tests__/approval-workflow.test.ts` -- 승인 워크플로 regression 없음
5. `npx vitest run packages/daemon/src/__tests__/notification-channels.test.ts` -- 알림 이벤트 22개 확인
6. 누적 한도 초과 시 evaluateAndReserve가 tier: 'APPROVAL', approvalReason: 'cumulative_daily' 또는 'cumulative_monthly' 반환 확인
7. reserved_amount_usd가 approve/reject/expire 시 NULL로 클리어되어 누적에서 제외됨 확인
</verification>

<success_criteria>
- CUMUL-04: evaluateAndReserve에서 24시간/30일 롤링 윈도우 내 누적 USD 지출을 집계하여 한도 초과 시 APPROVAL로 격상
- CUMUL-05: PENDING/QUEUED/SIGNED 상태의 reserved_amount_usd가 누적 합산에 포함되어 이중 지출 방지
- CUMUL-06: 누적 지출이 한도의 80%에 도달하면 CUMULATIVE_LIMIT_WARNING 알림 발송
- CUMUL-07: TX_APPROVAL_REQUIRED 이벤트에 reason 필드(per_tx/cumulative_daily/cumulative_monthly) 포함
- 모든 기존 테스트 + 새 테스트 통과
</success_criteria>

<output>
After completion, create `.planning/phases/136-cumulative-spending-engine/136-02-SUMMARY.md`
</output>
