---
phase: 178-adapter-solana-branch-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/adapters/solana/src/__tests__/solana-batch-branches.test.ts
  - packages/adapters/solana/src/__tests__/solana-sign-external-branches.test.ts
autonomous: true
requirements:
  - SOL-01
  - SOL-02

must_haves:
  truths:
    - "convertBatchInstruction TRANSFER branch produces a single getTransferSolInstruction"
    - "convertBatchInstruction TOKEN_TRANSFER branch with mint not found throws TOKEN_ACCOUNT_NOT_FOUND"
    - "convertBatchInstruction TOKEN_TRANSFER branch with invalid mint owner throws INVALID_INSTRUCTION"
    - "convertBatchInstruction TOKEN_TRANSFER branch with Token-2022 mint uses TOKEN_2022_PROGRAM_ID"
    - "convertBatchInstruction CONTRACT_CALL branch validates missing programId, instructionData, accounts"
    - "convertBatchInstruction CONTRACT_CALL branch accepts both Uint8Array and base64 string instructionData"
    - "convertBatchInstruction CONTRACT_CALL branch maps all 4 AccountRole combinations"
    - "convertBatchInstruction APPROVE branch with mint not found throws TOKEN_ACCOUNT_NOT_FOUND"
    - "convertBatchInstruction APPROVE branch with Token-2022 uses TOKEN_2022_PROGRAM_ID"
    - "buildBatch outer catch re-throws ChainError without wrapping"
    - "buildBatch outer catch wraps generic Error as WAIaaSError CHAIN_ERROR"
    - "signExternalTransaction with corrupted bytes (valid base64 but invalid tx) throws INVALID_RAW_TRANSACTION"
    - "signExternalTransaction with 32-byte private key (secp256k1 length) creates key pair correctly"
    - "signExternalTransaction outer catch wraps non-ChainError as INVALID_RAW_TRANSACTION"
  artifacts:
    - path: "packages/adapters/solana/src/__tests__/solana-batch-branches.test.ts"
      provides: "Branch-focused tests for convertBatchInstruction 4-type dispatch + error paths"
    - path: "packages/adapters/solana/src/__tests__/solana-sign-external-branches.test.ts"
      provides: "Branch-focused tests for signExternalTransaction edge cases"
  key_links:
    - from: "packages/adapters/solana/src/__tests__/solana-batch-branches.test.ts"
      to: "packages/adapters/solana/src/adapter.ts"
      via: "convertBatchInstruction private method exercised through buildBatch"
      pattern: "adapter\\.buildBatch"
    - from: "packages/adapters/solana/src/__tests__/solana-sign-external-branches.test.ts"
      to: "packages/adapters/solana/src/adapter.ts"
      via: "signExternalTransaction public method"
      pattern: "adapter\\.signExternalTransaction"
---

<objective>
Add branch-coverage tests for convertBatchInstruction() 4-type dispatch and signExternalTransaction() edge cases to close ~20 uncovered branches in adapter.ts.

Purpose: SOL-01 requires all 4 instruction type branches in convertBatchInstruction to have both happy-path and error-path tests. SOL-02 requires signExternalTransaction's base64 decode failure, key length detection, and signer mismatch branches to be tested. These are the highest-impact uncovered branches in the adapter.

Output: Two new test files covering batch instruction dispatch branches and sign-external edge cases.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/adapters/solana/src/adapter.ts
@packages/adapters/solana/src/__tests__/solana-batch.test.ts
@packages/adapters/solana/src/__tests__/solana-sign-only.test.ts
@packages/adapters/solana/src/__tests__/solana-contract-call.test.ts
@packages/adapters/solana/src/__tests__/solana-approve.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: convertBatchInstruction branch-coverage tests</name>
  <files>packages/adapters/solana/src/__tests__/solana-batch-branches.test.ts</files>
  <action>
Create a new test file `solana-batch-branches.test.ts` that specifically targets uncovered branches in `convertBatchInstruction()` and the `buildBatch()` error handling. Use the same vi.hoisted + vi.mock pattern from the existing `solana-batch.test.ts`.

The file must cover these SPECIFIC uncovered branches:

**TOKEN_TRANSFER branch error paths in convertBatchInstruction:**
1. Mint not found (`mintAccountInfo.value` is null) -- throws `ChainError('TOKEN_ACCOUNT_NOT_FOUND')`
2. Invalid mint owner (not SPL_TOKEN or TOKEN_2022) -- throws `ChainError('INVALID_INSTRUCTION', 'Invalid token mint: owner is not a token program')`
3. Token-2022 mint owner -- uses TOKEN_2022_PROGRAM_ID for PDA + transferChecked
4. Destination ATA exists (needCreateAta = false) -- returns only transferChecked instruction (length 1)

**CONTRACT_CALL branch error paths in convertBatchInstruction:**
5. Missing programId -- throws `ChainError('INVALID_INSTRUCTION', 'Missing programId...')`
6. Missing instructionData -- throws `ChainError('INVALID_INSTRUCTION', 'Missing instructionData...')`
7. Missing/empty accounts -- throws `ChainError('INVALID_INSTRUCTION', 'Missing accounts...')`
8. instructionData as base64 string (not Uint8Array) -- converts via Buffer.from(string, 'base64')
9. All 4 AccountRole mappings in batch context: WRITABLE_SIGNER, READONLY_SIGNER, WRITABLE, READONLY

**APPROVE branch error paths in convertBatchInstruction:**
10. Mint not found for approve -- throws `ChainError('TOKEN_ACCOUNT_NOT_FOUND')`
11. Invalid mint owner for approve -- throws `ChainError('INVALID_INSTRUCTION')`
12. Token-2022 approve -- uses TOKEN_2022_PROGRAM_ID

**Unknown type fallthrough:**
13. Force an unknown instruction type by passing an object that doesn't match any classifier pattern -- triggers the final `throw new ChainError('INVALID_INSTRUCTION', 'Unknown instruction type')` at the bottom of convertBatchInstruction

**buildBatch outer catch re-throw paths:**
14. When convertBatchInstruction throws a ChainError, buildBatch re-throws it (instanceof ChainError check)
15. When a generic Error occurs in the pipeline, it wraps in WAIaaSError

Test structure: Use `describe('SolanaAdapter - buildBatch branch coverage', () => { ... })` with sub-describe blocks for each instruction type. Mock setup should follow the exact same pattern as `solana-batch.test.ts` (vi.hoisted for mockRpc + token mocks, vi.mock for @solana/kit and @solana-program/token).

For the "unknown type" test (#13): create a batch with 2 instructions where the second instruction is `{ from: TEST_FROM, to: TEST_TO, amount: 1n }` but also add a `spender` field AND a `programId` field simultaneously -- this won't match because `classifyInstruction` checks `spender` first (APPROVE) but the actual instruction has no `token` field, so `convertBatchInstruction` will try APPROVE path which requires `token` and will fail. A simpler approach: mock `classifyInstruction` to return an unexpected string, or -- since it's private -- construct an instruction that classifyInstruction returns APPROVE but the data doesn't match. Actually, the easiest approach: the unknown type throw is already guarded by classifyInstruction always returning one of the 4 known types, so this branch is dead code. Skip this test and document why.

For the generic Error catch test (#15): mock `getLatestBlockhash` to reject with a non-Error non-ChainError value (e.g., a string), so the outer catch triggers the WAIaaSError wrap path.
  </action>
  <verify>
Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/adapter-solana test -- --run src/__tests__/solana-batch-branches.test.ts`
All tests must pass with 0 failures.
  </verify>
  <done>
At least 12 new test cases pass, covering TOKEN_TRANSFER error paths (mint not found, invalid owner, Token-2022, ATA exists), CONTRACT_CALL error paths (missing programId/instructionData/accounts, base64 data, 4 roles), APPROVE error paths (mint not found, invalid owner, Token-2022), and buildBatch outer catch re-throw paths.
  </done>
</task>

<task type="auto">
  <name>Task 2: signExternalTransaction branch-coverage tests</name>
  <files>packages/adapters/solana/src/__tests__/solana-sign-external-branches.test.ts</files>
  <action>
Create a new test file `solana-sign-external-branches.test.ts` that targets uncovered branches in `signExternalTransaction()`. This file does NOT need vi.mock for RPC because signExternalTransaction is an offline operation (same as `solana-sign-only.test.ts`).

The file must cover these SPECIFIC uncovered branches:

**Base64 decode failure branch (inner try/catch at Step 1, lines 1249-1255):**
1. The existing test in `solana-sign-only.test.ts` tests `'invalid-base64!!!'` which may succeed at `Buffer.from(rawTx, 'base64')` but fail at `txDecoder.decode()`. Create a test where the base64 itself is malformed in a way that `Buffer.from()` returns garbage bytes -- note: Buffer.from with 'base64' encoding is lenient and won't throw for most inputs. The real trigger is when `txDecoder.decode(txBytes)` fails (Step 2). Verify the existing tests already cover Step 2 decode failure. If Step 1 base64 decode try/catch is never actually triggered because Buffer.from is lenient, document this finding. The branch may be uncovered because it requires a true base64 parse failure which Node.js Buffer.from doesn't produce.

**32-byte private key branch (line 1270-1271):**
2. Test signExternalTransaction with a 32-byte private key (not 64-byte). Build a valid unsigned transaction using a keypair, then extract just the 32-byte private seed from the 64-byte key, and call signExternalTransaction with it. Verify it produces a valid signed transaction. This exercises the `createKeyPairFromPrivateKeyBytes` branch.

**Non-ChainError in outer catch (lines 1300-1304):**
3. Create a scenario where a non-ChainError error propagates to the outer catch. This is tricky with a real implementation. One approach: pass a rawTx that is valid base64 and valid wire-format transaction structure, but causes `signBytes` or `getAddressFromPublicKey` to throw a generic Error (not ChainError). Mock approach: since this file doesn't use vi.mock for @solana/kit, instead use a specially crafted private key that causes `createKeyPairFromBytes` to throw (e.g., all-zero 64 bytes may be rejected by the Ed25519 implementation). Test that the outer catch wraps it as `ChainError('INVALID_RAW_TRANSACTION')`.

**Transaction decode failure branch (Step 2, lines 1258-1265):**
4. Provide valid base64 that decodes to bytes but is not a valid Solana transaction. This should trigger the inner decode try/catch. Use `Buffer.from([0, 0, 0, 0, 0, 0]).toString('base64')` as rawTx. Verify it throws `ChainError('INVALID_RAW_TRANSACTION')` with message containing 'Failed to decode'.

Test structure: Use real Ed25519 keypairs (same as `solana-sign-only.test.ts` pattern with `buildTestKeypair()`). Use `beforeAll` to generate keypairs and build fixture transactions.
  </action>
  <verify>
Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/adapter-solana test -- --run src/__tests__/solana-sign-external-branches.test.ts`
All tests must pass with 0 failures.
  </verify>
  <done>
At least 3 new test cases pass, covering the 32-byte key path, transaction decode failure, and outer catch wrapping. The base64 decode failure branch is either covered or documented as a dead code branch due to Buffer.from leniency.
  </done>
</task>

</tasks>

<verification>
1. Run all adapter-solana tests: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/adapter-solana test -- --run`
2. All existing + new tests pass with 0 failures
3. Run coverage: `pnpm --filter @waiaas/adapter-solana test -- --run --coverage` and verify branch count improved
</verification>

<success_criteria>
- 15+ new test cases across 2 files pass
- All existing tests continue to pass (no regressions)
- Branch coverage in adapter.ts increases measurably
- convertBatchInstruction 4-type dispatch fully exercised with error paths
- signExternalTransaction key-length branching exercised
</success_criteria>

<output>
After completion, create `.planning/phases/178-adapter-solana-branch-coverage/178-01-SUMMARY.md`
</output>
