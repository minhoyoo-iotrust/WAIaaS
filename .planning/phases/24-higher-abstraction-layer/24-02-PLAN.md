---
phase: 24-higher-abstraction-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/62-action-provider-architecture.md
  - docs/63-swap-action-spec.md
autonomous: true

must_haves:
  truths:
    - "IActionProvider 인터페이스가 metadata/actions/resolve() 3개 구성으로 정의되어 있고, resolve()가 ContractCallRequest를 반환하여 기존 파이프라인 정책 평가를 거치는 resolve-then-execute 패턴이 명세되어 있다"
    - "ActionDefinition Zod 스키마가 name/description/chain/inputSchema/riskLevel/defaultTier로 정의되어 있고, MCP Tool로의 자동 변환(server.tool() 매핑)이 설계되어 있다"
    - "~/.waiaas/actions/ 디렉토리 기반 ESM 플러그인 로드 메커니즘이 설계되어 있고, validate-then-trust 보안 경계(IActionProvider 인터페이스 준수 + resolve() 반환값 Zod 검증)가 명세되어 있다"
    - "ActionProviderRegistry가 register/getProvider/getAllActions/loadPlugins를 지원하고, mcpExpose 플래그로 MCP Tool 노출 범위를 제어한다"
    - "Jupiter Swap Action Provider가 Quote API -> /swap-instructions -> ContractCallRequest 변환 전체 흐름으로 설계되어 있고, 슬리피지 보호(기본 50bps, 최대 500bps), priceImpact 1% 상한, Jito MEV 보호가 포함되어 있다"
    - "악성 플러그인 방어, 슬리피지 조작 시나리오, resolve() 반환값 검증 등 보안/테스트 시나리오가 정의되어 있다"
  artifacts:
    - path: "docs/62-action-provider-architecture.md"
      provides: "CHAIN-EXT-07 Action Provider 아키텍처 (IActionProvider, resolve-then-execute, MCP 변환, 플러그인)"
      contains: "IActionProvider"
    - path: "docs/63-swap-action-spec.md"
      provides: "CHAIN-EXT-08 Swap Action 상세 설계 (Jupiter 연동, 슬리피지, MEV 보호)"
      contains: "JupiterSwapActionProvider"
  key_links:
    - from: "docs/62-action-provider-architecture.md"
      to: "docs/58-contract-call-spec.md"
      via: "resolve() 반환 타입이 ContractCallRequest -- 기존 파이프라인 Stage 1-6 진입"
      pattern: "ContractCallRequest"
    - from: "docs/62-action-provider-architecture.md"
      to: "docs/38-sdk-mcp-interface.md"
      via: "ActionDefinition -> server.tool(name, description, zodSchema, handler) 자동 변환"
      pattern: "server\\.tool"
    - from: "docs/63-swap-action-spec.md"
      to: "docs/62-action-provider-architecture.md"
      via: "JupiterSwapActionProvider implements IActionProvider"
      pattern: "IActionProvider"
---

<objective>
IActionProvider 인터페이스와 resolve-then-execute 패턴을 정의하고, ActionDefinition에서 MCP Tool로의 자동 변환 메커니즘과 플러그인 로드 메커니즘을 설계한 뒤, 첫 번째 구현체인 Jupiter Swap Action Provider를 Quote API -> ContractCallRequest 변환까지 상세 설계한다.

Purpose: DeFi 프로토콜 지식을 IChainAdapter에서 분리하여, 모든 DeFi 작업이 기존 정책 엔진(CONTRACT_WHITELIST, SPENDING_LIMIT 등)을 거치도록 보장한다. 에이전트가 "Jupiter에서 USDC를 SOL로 스왑"같은 고수준 의도를 표현하면, Action Provider가 이를 ContractCallRequest로 변환하여 기존 6단계 파이프라인에 주입한다.
Output: docs/62-action-provider-architecture.md (CHAIN-EXT-07), docs/63-swap-action-spec.md (CHAIN-EXT-08)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/24-higher-abstraction-layer/24-RESEARCH.md

# Phase 23 핵심 산출물 (ContractCallRequest 참조)
@docs/58-contract-call-spec.md

# MCP 기존 설계 (server.tool() 패턴 참조)
@docs/38-sdk-mcp-interface.md

# 파이프라인 + 정책 엔진 (resolve 결과가 거치는 경로)
@docs/32-transaction-pipeline-api.md
@docs/33-time-lock-approval-mechanism.md

# 어댑터 인터페이스 (IChainAdapter 저수준 유지 원칙)
@docs/27-chain-adapter-interface.md

# 데이터 디렉토리 구조 (~/.waiaas/ 참조)
@docs/24-monorepo-data-directory.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: IActionProvider 아키텍처 + MCP 변환 + 플러그인 로드 설계</name>
  <files>docs/62-action-provider-architecture.md</files>
  <action>
docs/62-action-provider-architecture.md 파일을 생성한다. 한글로 작성하며, 기존 Phase 22-23 설계 문서(58, 59, 60)의 포맷과 동일한 구조를 따른다.

**문서 헤더:**
- 문서 ID: CHAIN-EXT-07
- Phase: 24 (상위 추상화 레이어 설계)
- 참조: 58 (ContractCallRequest), 38 (MCP 인터페이스), 32 (파이프라인), 33 (정책 엔진), 27 (어댑터 인터페이스), 24 (모노레포/데이터 디렉토리), 24-RESEARCH.md
- 요구사항 매핑: ACTION-01, ACTION-02, ACTION-03, ACTION-05

**섹션 1: 개요**
- 목적: DeFi 프로토콜 지식을 IChainAdapter에서 분리하는 Action Provider 레이어
- 핵심 설계 원칙: (1) IChainAdapter에 DeFi 지식 추가 금지, (2) resolve()는 반드시 ContractCallRequest를 반환 (정책 우회 금지), (3) 모든 Action은 기존 6단계 파이프라인을 거침, (4) MCP Tool 과다 등록 방지(mcpExpose 제어)

**섹션 2: IActionProvider 인터페이스 (ACTION-01)**
- ActionProviderMetadata: name(snake_case), description, version, chains[], mcpExpose, requiredApis[]
- ActionDefinition: name, description, chain, inputSchema(Zod), riskLevel, defaultTier
- IActionProvider: metadata, actions[], resolve(actionName, params, context) -> ContractCallRequest
- ActionContext: walletAddress, chain, agentId
- 에러 타입: ActionNotFoundError, ActionValidationError, ActionResolveError
- resolve() 반환값 Zod 검증: ContractCallRequestSchema.parse()로 반환값 강제 검증. 직렬화된 트랜잭션(Base64 문자열), 서명된 트랜잭션 등 비정상 반환 차단
- 24-RESEARCH.md의 인터페이스 코드를 설계 스펙 수준으로 정제하여 포함

**섹션 3: resolve-then-execute 패턴 상세 (ACTION-01)**
- 전체 흐름: 에이전트/MCP -> ActionProvider.resolve() -> ContractCallRequest -> 파이프라인 Stage 1-6
- Stage 1: type='CONTRACT_CALL' 검증 (Action이 생성한 ContractCallRequest)
- Stage 2: 세션 allowedContracts에 Action의 대상 프로그램/컨트랙트 포함 필요
- Stage 3: CONTRACT_WHITELIST (Action 대상 프로그램 화이트리스트), SPENDING_LIMIT(USD 기준, 24-01 참조)
- Stage 4: 보안 티어 분류 (defaultTier 참조)
- Stage 5-6: buildContractCall() -> 서명 -> 제출 -> 확정
- 시퀀스 다이어그램 (텍스트 기반)
- Action 요청과 일반 CONTRACT_CALL 요청의 차이점: Action은 resolve()가 자동으로 ContractCallRequest를 생성하므로 에이전트가 calldata/programId를 알 필요 없음

**섹션 4: ActionProviderRegistry (ACTION-01)**
- register(provider): IActionProvider 인터페이스 검증 후 등록
- getProvider(name): 이름으로 프로바이더 조회
- getAllActions(): 등록된 모든 ActionDefinition 반환
- getAction(actionName): 특정 액션의 ActionDefinition + 소속 프로바이더 반환
- loadPlugins(dir): 섹션 6의 플러그인 로드 호출
- 중복 이름 방지: 동일 name 등록 시 ActionNameConflictError
- 내장 프로바이더 vs 플러그인 프로바이더 구분 (built-in은 항상 로드)

**섹션 5: ActionDefinition -> MCP Tool 자동 변환 (ACTION-02)**
- 변환 매핑:
  - ActionDefinition.name -> server.tool() name
  - ActionDefinition.description + riskLevel -> server.tool() description (riskLevel을 설명에 부가)
  - ActionDefinition.inputSchema (Zod) -> server.tool() inputSchema (MCP SDK가 Zod -> JSON Schema 자동 변환)
  - handler: resolve() -> transactionService.submit() -> MCP 응답 포맷
- mcpExpose 필터링: metadata.mcpExpose=true인 프로바이더의 actions만 MCP Tool로 등록
- MCP Tool 등록 상한: 기존 6개(38-sdk-mcp) + Action 최대 10개 = 16개 상한
- 상한 초과 시: 경고 로그 + riskLevel='low'인 Action부터 MCP 미노출
- 변환 시점: 데몬 시작 시 ActionProviderRegistry.getAllActions()에서 mcpExpose=true인 것들을 server.tool()로 등록
- 기존 38-sdk-mcp-interface.md의 6개 Tool과 병존하는 구조

**섹션 6: 플러그인 로드 메커니즘 (ACTION-03)**
- 디렉토리 구조: ~/.waiaas/actions/{plugin-name}/index.js + package.json
- 로드 순서: (1) 내장 프로바이더 등록 -> (2) ~/.waiaas/actions/ 스캔 -> (3) 각 플러그인 ESM dynamic import -> (4) 인터페이스 검증 -> (5) 보안 검증 -> (6) 등록
- ESM dynamic import: import(pathToFileURL(pluginPath).href), export default 패턴
- 인터페이스 검증 (validate-then-trust):
  - metadata 필드 존재 확인 (name, description, version, chains, mcpExpose)
  - actions 배열 존재 + 각 ActionDefinition 필수 필드 확인
  - resolve 함수 존재 확인
  - 실제 resolve() 호출은 하지 않음 (구조 검증만)
- 보안 검증:
  - chains 범위 검증: 프로바이더가 선언한 chain만 허용
  - resolve() 반환값 런타임 Zod 검증: ContractCallRequestSchema.parse() 강제
  - 플러그인에서 네트워크 접근은 허용하되, 직접 트랜잭션 서명/제출은 불가 (키스토어 접근 없음)
- 플러그인 로드 실패 시: 해당 플러그인만 skip + 경고 로그, 다른 플러그인 및 시스템 정상 동작
- config.toml에 enabled_actions 설정: 허용된 플러그인 이름 목록 (미설정 시 모든 플러그인 로드)
- 향후 확장: vm.Module 기반 샌드박스 (현재 v0.6은 validate-then-trust)

**섹션 7: 에러 처리 + 에러 코드**
- ACTION_NOT_FOUND, ACTION_VALIDATION_FAILED, ACTION_RESOLVE_FAILED
- ACTION_RETURN_INVALID (resolve() 반환값 검증 실패)
- ACTION_PLUGIN_LOAD_FAILED, ACTION_NAME_CONFLICT
- MCP_TOOL_LIMIT_EXCEEDED (경고)
- 에러 코드와 기존 에러 체계(37-rest-api)와의 관계

**섹션 8: REST API 확장**
- POST /v1/actions/:actionName/resolve -- resolve()만 호출하여 ContractCallRequest 반환 (dry-run)
- POST /v1/actions/:actionName/execute -- resolve() + 파이프라인 주입 (full flow)
- GET /v1/actions -- 등록된 Action 목록 반환
- GET /v1/actions/:actionName -- 특정 Action 상세 (inputSchema 포함)
- 인증: 기존 sessionAuth 미들웨어 적용

**섹션 9: 테스트 레벨 / Mock / 보안 시나리오 (ACTION-05)**
- 단위 테스트: MockActionProvider(고정 ContractCallRequest 반환), Registry 등록/조회, MCP 변환
- 통합 테스트: resolve() -> 파이프라인 주입 전체 흐름, 플러그인 로드/실패
- 보안 시나리오 (최소 10개):
  - 악성 플러그인: resolve()가 직렬화된 트랜잭션(Base64) 반환 -> Zod 검증으로 차단
  - 악성 플러그인: resolve()에서 직접 RPC 제출 -> 키스토어 접근 불가로 서명 불가
  - 이름 충돌: 내장 프로바이더와 동일 이름의 플러그인 -> ActionNameConflictError
  - MCP Tool 폭증: 16개 상한 초과 시 동작
  - 플러그인 로드 중 오류 (syntaxError, missing export) -> skip + 경고
  - resolve() 무한 대기 -> AbortSignal.timeout(30000) 적용
  - 체인 범위 위반: Solana 전용 프로바이더가 EVM ContractCallRequest 반환 -> 체인 불일치 차단
  - 입력 검증 우회: inputSchema 미준수 params -> Zod 검증으로 차단
  - resolve() 결과에 과도한 accounts (DoS) -> accounts 배열 최대 개수 제한
  - 허용되지 않은 플러그인 (config.toml enabled_actions 미포함) -> skip

**섹션 10: Phase 25 수정 가이드**
- 수정 필요 문서: 38 (MCP Tool에 Action 추가), 37 (REST API에 /v1/actions 추가), 27 (IChainAdapter 변경 없음 명시), 24 (config.toml에 actions 섹션 추가)

**부록 A: ActionDefinition -> MCP Tool 변환 예시 (코드 수준)**
**부록 B: 플러그인 package.json 및 index.js 템플릿**

분량: ~1500-2000줄 목표.
  </action>
  <verify>
1. docs/62-action-provider-architecture.md 파일이 존재하고 1200줄 이상이다
2. ACTION-01, ACTION-02, ACTION-03, ACTION-05 4개 요구사항이 모두 섹션에 매핑되어 있다
3. IActionProvider 인터페이스에 metadata/actions/resolve() 3개 구성이 정의되어 있다
4. resolve()가 ContractCallRequest를 반환하는 패턴이 명시되어 있다
5. ActionDefinition -> server.tool() 매핑이 name/description/inputSchema 수준으로 설계되어 있다
6. ~/.waiaas/actions/ 디렉토리 기반 플러그인 로드가 설계되어 있다
7. validate-then-trust 보안 경계가 명세되어 있다
8. mcpExpose 플래그와 MCP Tool 16개 상한이 명시되어 있다
9. 보안 시나리오가 10개 이상 정의되어 있다
10. REST API 확장 (/v1/actions 엔드포인트)이 설계되어 있다
  </verify>
  <done>
IActionProvider 인터페이스와 resolve-then-execute 패턴이 정의되어 있고, ActionDefinition -> MCP Tool 자동 변환과 ~/.waiaas/actions/ 플러그인 로드가 설계되어 있으며, 보안 시나리오 10개 이상이 포함되어 있다
  </done>
</task>

<task type="auto">
  <name>Task 2: Jupiter Swap Action Provider 상세 설계</name>
  <files>docs/63-swap-action-spec.md</files>
  <action>
docs/63-swap-action-spec.md 파일을 생성한다. 한글로 작성하며, 기존 설계 문서 포맷을 따른다. 이 문서는 62-action-provider-architecture.md에서 정의한 IActionProvider의 첫 번째 구현체를 상세 설계한다.

**문서 헤더:**
- 문서 ID: CHAIN-EXT-08
- Phase: 24 (상위 추상화 레이어 설계)
- 참조: 62 (Action Provider 아키텍처), 58 (ContractCallRequest), 31 (Solana 어댑터), 32 (파이프라인), 24-RESEARCH.md
- 요구사항 매핑: ACTION-04 (Jupiter Swap 상세), ACTION-05 (테스트 시나리오 -- Swap 관련)

**섹션 1: 개요**
- 목적: IActionProvider의 첫 번째 구현체로서 Jupiter DEX 집계기를 통한 Solana 토큰 스왑 설계
- Jupiter 선정 이유: Solana 최대 DEX 집계기, 150+ 소스 최적 라우팅, Jito MEV 보호 내장
- 향후 확장: 0x Swap API (EVM), Raydium (Solana 직접) 등은 동일 IActionProvider 패턴으로

**섹션 2: JupiterSwapActionProvider 구현체 (ACTION-04)**
- metadata: name='jupiter_swap', chains=['solana'], mcpExpose=true, requiredApis=['Jupiter Quote API']
- actions: 1개 ActionDefinition (jupiter_swap)
- inputSchema Zod:
  - inputMint: z.string() (Base58 mint address)
  - outputMint: z.string() (Base58 mint address)
  - amount: z.string() (smallest unit, lamports/토큰 최소단위)
  - slippageBps: z.number().int().min(1).max(500).default(50) (기본 0.5%, 최대 5%)
- riskLevel: 'high', defaultTier: 'APPROVAL'

**섹션 3: resolve() 상세 흐름 (ACTION-04)**
- Step 1: 입력 검증 (inputSchema.parse)
- Step 2: Jupiter Quote API 호출
  - URL: GET https://api.jup.ag/swap/v1/quote
  - 파라미터: inputMint, outputMint, amount, slippageBps, restrictIntermediateTokens=true
  - 타임아웃: 10초 (AbortSignal.timeout(10000))
  - 에러 처리: 네트워크 실패, 400 응답(유동성 부족), 429(rate limit)
- Step 3: Quote 응답 검증
  - outAmount 존재 확인
  - priceImpactPct 검증: > 1.0% 시 ActionResolveError('Price impact too high')
  - routePlan 경로 수 확인 (정보 로깅용)
- Step 4: Jupiter Swap Instructions API 호출
  - URL: POST https://api.jup.ag/swap/v1/swap-instructions
  - Body: { quoteResponse, userPublicKey, prioritizationFeeLamports: { jitoTipLamports: 1000 } }
  - 타임아웃: 15초
  - /swap 엔드포인트는 사용하지 않음 (직렬화된 전체 트랜잭션 반환 -> ContractCallRequest 변환 불가)
- Step 5: instruction 데이터 -> ContractCallRequest 변환
  - swapInstruction.data -> instructionData (Base64)
  - swapInstruction.accounts -> accounts 배열 ({ address, isSigner, isWritable })
  - swapInstruction.programId -> programId + to
  - from: context.walletAddress
  - computeBudgetInstructions 처리: setupInstructions에 포함된 compute budget 명시
- Step 6: 반환값 Zod 검증 (ContractCallRequestSchema.parse)
- Fallback 경로: /swap-instructions 실패 시, POST /swap의 swapTransaction을 VersionedTransaction.deserialize()로 instruction 추출 (최후 수단, 24-RESEARCH.md Open Question 1)

**섹션 4: 슬리피지 보호 (ACTION-04)**
- 기본 slippageBps = 50 (0.5%) -- Jupiter 기본값
- 최대 slippageBps = 500 (5%) -- inputSchema에서 강제
- dynamicSlippage 옵션: Jupiter가 시장 상황에 따라 자동 조정 (향후 확장)
- priceImpactPct 상한: 1.0% (하드코딩, 설정 가능하게 하지 않음 -- 에이전트 보호)
- 슬리피지 경고 로깅: slippageBps > 100 (1%) 시 WARN 로그

**섹션 5: MEV 보호 (ACTION-04)**
- Jito 통합: jitoTipLamports 파라미터로 Jito 블록 엔진에 직접 트랜잭션 전송
- 기본 Jito 팁: 1000 lamports (약 $0.00015 @ SOL $150)
- Jito 팁 상한: 100000 lamports (약 $0.015) -- 과도한 팁 방지
- Jito 미사용 시: 일반 mempool로 제출 (MEV 노출 가능성 경고)
- dynamicComputeUnitLimit: true (Jupiter가 시뮬레이션 기반 CU 최적화)
- prioritizationFeeLamports: jitoTipLamports와 병행 가능

**섹션 6: 보안 가이드라인 (ACTION-04)**
- Jupiter 프로그램 주소 화이트리스트: JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 (v6)
- CONTRACT_WHITELIST에 Jupiter 프로그램 등록 필수 (미등록 시 파이프라인 Stage 3에서 거부)
- 에이전트 세션에 allowedContracts에 Jupiter 주소 포함 필요
- 스왑 실행 후 잔액 변화 감사 로그 기록 (inputMint 감소, outputMint 증가 기대)
- 연속 스왑 감지: 동일 에이전트 5분 내 3회 이상 스왑 시 경고 (자동 봇 패턴 의심)

**섹션 7: 에러 처리**
- JUPITER_QUOTE_FAILED: Quote API 호출 실패
- JUPITER_SWAP_INSTRUCTIONS_FAILED: Swap Instructions API 호출 실패
- JUPITER_PRICE_IMPACT_TOO_HIGH: priceImpactPct > 1.0%
- JUPITER_INSUFFICIENT_LIQUIDITY: Quote 결과에서 outAmount=0 또는 route 없음
- JUPITER_TIMEOUT: API 응답 타임아웃
- 에러 코드와 기존 에러 체계(37-rest-api, 58-contract-call)와의 관계

**섹션 8: 향후 확장 (0x Swap EVM)**
- 0x Swap API v2 개요: GET /swap/allowance-holder/quote (Permit2/AllowanceHolder)
- EVM 스왑의 차이점: approve 선행 필요 (ERC-20 -> 0x AllowanceHolder), gas 추정, 서명 방식 차이
- UniswapSwapActionProvider로 동일 IActionProvider 패턴 적용 가능
- 이 섹션은 참고용이며 v0.6 범위에 구현 설계는 포함하지 않음

**섹션 9: 테스트 레벨 / Mock / 보안 시나리오 (ACTION-05 Swap 관련)**
- 단위 테스트: MockJupiterAPI (nock/msw), 고정 quote 반환, instruction 변환 검증
- 통합 테스트: resolve() -> ContractCallRequest -> 파이프라인 주입 전체 흐름 (MockHTTP + MockPipeline)
- 보안 시나리오 (최소 8개):
  - 슬리피지 조작: slippageBps=500 입력 시 최대 허용(5%) 동작
  - priceImpact 초과: 1.1% quote에서 ActionResolveError 발생
  - Jupiter API 장애: 타임아웃 후 JUPITER_TIMEOUT 에러
  - 유동성 부족: route 없는 토큰 쌍에서 JUPITER_INSUFFICIENT_LIQUIDITY
  - 변조된 instruction: resolve() 결과에 예상치 못한 programId -> 파이프라인 CONTRACT_WHITELIST에서 차단
  - Jito 팁 과다: jitoTipLamports > 100000 시 차단
  - /swap-instructions 실패 -> fallback (VersionedTransaction.deserialize) 동작 확인
  - 연속 스왑 감지: 3회/5분 경고 동작

**부록 A: Jupiter Quote API 응답 스키마 (주요 필드)**
**부록 B: Jupiter Swap Instructions API 응답 스키마**
**부록 C: ContractCallRequest 변환 매핑 상세**

분량: ~1000-1500줄 목표.
  </action>
  <verify>
1. docs/63-swap-action-spec.md 파일이 존재하고 800줄 이상이다
2. ACTION-04 요구사항이 커버되어 있다 (Jupiter Quote -> /swap-instructions -> ContractCallRequest 전체 흐름)
3. ACTION-05의 Swap 관련 테스트 시나리오가 8개 이상이다
4. 슬리피지 보호: 기본 50bps, 최대 500bps, priceImpact 1% 상한이 명세되어 있다
5. MEV 보호: Jito 통합이 설계되어 있다
6. /swap-instructions 엔드포인트 사용이 명시되어 있고, /swap 미사용 이유가 설명되어 있다
7. ContractCallRequest 변환 매핑이 instructionData/accounts/programId 수준으로 상세하다
8. Jupiter 프로그램 주소 화이트리스트가 명시되어 있다
  </verify>
  <done>
Jupiter Swap Action Provider가 Quote API -> /swap-instructions -> ContractCallRequest 변환까지 상세 설계되어 있고, 슬리피지 보호(50bps 기본/500bps 상한/priceImpact 1%), MEV 보호(Jito 통합), 보안 시나리오 8개 이상이 포함되어 있다
  </done>
</task>

</tasks>

<verification>
1. docs/62-action-provider-architecture.md가 CHAIN-EXT-07 문서 ID를 포함하고, ACTION-01/02/03/05를 커버한다
2. docs/63-swap-action-spec.md가 CHAIN-EXT-08 문서 ID를 포함하고, ACTION-04/05를 커버한다
3. IActionProvider.resolve()가 ContractCallRequest를 반환하는 패턴이 양 문서에서 일관된다
4. ActionDefinition -> MCP Tool 변환이 기존 38-sdk-mcp-interface.md의 server.tool() 패턴과 일치한다
5. 플러그인 로드가 24-monorepo-data-directory.md의 ~/.waiaas/ 구조와 일치한다
6. Jupiter Swap의 ContractCallRequest가 58-contract-call-spec.md의 Solana ContractCallRequest 구조와 일치한다
</verification>

<success_criteria>
- IActionProvider 인터페이스와 ActionDefinition Zod 스키마가 정의되어 있고, resolve()가 ContractCallRequest를 반환하여 기존 파이프라인 정책 평가를 거치는 패턴이 명세되어 있다
- ActionDefinition에서 MCP Tool로의 자동 변환과 ~/.waiaas/actions/ 디렉토리 기반 플러그인 로드 메커니즘이 설계되어 있다
- Jupiter Swap Action Provider가 quote API 호출부터 ContractCallRequest 변환, 슬리피지 보호, MEV 보호까지 상세 설계되어 있다
- 악성 플러그인 방어, 슬리피지 조작 등 보안/테스트 시나리오가 충분히 정의되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/24-higher-abstraction-layer/24-02-SUMMARY.md`
</output>
