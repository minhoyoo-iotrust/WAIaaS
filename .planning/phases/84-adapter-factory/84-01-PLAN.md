---
phase: 84-adapter-factory
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/infrastructure/adapter-pool.ts
  - packages/daemon/src/__tests__/adapter-pool.test.ts
autonomous: true

must_haves:
  truths:
    - "AdapterPool.resolve('solana', 'devnet', rpcUrl) returns a SolanaAdapter connected to that rpcUrl"
    - "AdapterPool.resolve('ethereum', 'ethereum-sepolia', rpcUrl) returns an EvmAdapter connected to that rpcUrl"
    - "Calling resolve twice with same chain:network returns the exact same adapter instance (referential equality)"
    - "AdapterPool.disconnectAll() calls disconnect on every cached adapter"
  artifacts:
    - path: "packages/daemon/src/infrastructure/adapter-pool.ts"
      provides: "AdapterPool class with resolve() and disconnectAll()"
      exports: ["AdapterPool"]
    - path: "packages/daemon/src/__tests__/adapter-pool.test.ts"
      provides: "Unit tests for AdapterPool"
      contains: "AdapterPool"
  key_links:
    - from: "packages/daemon/src/infrastructure/adapter-pool.ts"
      to: "@waiaas/adapter-solana"
      via: "dynamic import in resolve()"
      pattern: "import.*@waiaas/adapter-solana"
    - from: "packages/daemon/src/infrastructure/adapter-pool.ts"
      to: "@waiaas/adapter-evm"
      via: "dynamic import in resolve()"
      pattern: "import.*@waiaas/adapter-evm"
---

<objective>
Implement and test the AdapterPool class that provides lazy-initialized, cached IChainAdapter instances keyed by chain:network.

Purpose: The daemon needs to support both Solana and EVM agents simultaneously. Instead of a single hardcoded SolanaAdapter, AdapterPool resolves the correct adapter type based on agent chain/network, reuses instances for the same network, and cleanly disconnects all on shutdown.

Output: `packages/daemon/src/infrastructure/adapter-pool.ts` with full test coverage.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/daemon/src/lifecycle/daemon.ts (current single-adapter pattern)
@packages/adapters/evm/src/adapter.ts (EvmAdapter constructor: network, chain?, nativeSymbol?, nativeName?)
@packages/adapters/evm/src/evm-chain-map.ts (EVM_CHAIN_MAP: Record<EvmNetworkType, EvmChainEntry>)
@packages/adapters/solana/src/adapter.ts (SolanaAdapter constructor: network)
@packages/core/src/enums/chain.ts (ChainType, NetworkType, EvmNetworkType, SOLANA_NETWORK_TYPES, EVM_NETWORK_TYPES)
</context>

<tasks>

<task type="auto">
  <name>Task 1: AdapterPool class + unit tests (TDD)</name>
  <files>
    packages/daemon/src/infrastructure/adapter-pool.ts
    packages/daemon/src/__tests__/adapter-pool.test.ts
  </files>
  <action>
**RED phase -- write tests first:**

Create `packages/daemon/src/__tests__/adapter-pool.test.ts` testing:

1. `resolve('solana', 'devnet', 'https://api.devnet.solana.com')` creates and returns a SolanaAdapter
2. `resolve('ethereum', 'ethereum-sepolia', 'https://sepolia.drpc.org')` creates and returns an EvmAdapter with correct nativeSymbol/nativeName from EVM_CHAIN_MAP
3. Two calls to `resolve()` with the same chain:network return the same instance (=== referential equality)
4. Two calls with different networks return different instances
5. `disconnectAll()` calls disconnect() on all cached adapters
6. After `disconnectAll()`, the internal cache is cleared and next resolve creates a fresh adapter
7. Resolve with unknown chain throws an error

Mock `@waiaas/adapter-solana` and `@waiaas/adapter-evm` modules using `vi.mock()`:
- SolanaAdapter mock: constructor(network), connect(rpcUrl) -> Promise<void>, disconnect() -> Promise<void>, isConnected() -> true
- EvmAdapter mock: constructor(network, chain, nativeSymbol, nativeName), connect(rpcUrl) -> Promise<void>, disconnect() -> Promise<void>, isConnected() -> true

**GREEN phase -- implement AdapterPool:**

Create `packages/daemon/src/infrastructure/adapter-pool.ts`:

```typescript
import type { IChainAdapter, ChainType, NetworkType, EvmNetworkType } from '@waiaas/core';
import { EVM_NETWORK_TYPES } from '@waiaas/core';

export class AdapterPool {
  private readonly _pool = new Map<string, IChainAdapter>();

  /**
   * Build cache key from chain:network.
   */
  private cacheKey(chain: ChainType, network: NetworkType): string {
    return `${chain}:${network}`;
  }

  /**
   * Resolve (lazy-create + cache) an adapter for the given chain:network.
   * - Solana: SolanaAdapter(network) -> connect(rpcUrl)
   * - Ethereum: EvmAdapter(network, viemChain, nativeSymbol, nativeName) -> connect(rpcUrl)
   * Same chain:network returns the cached instance.
   */
  async resolve(chain: ChainType, network: NetworkType, rpcUrl: string): Promise<IChainAdapter> {
    const key = this.cacheKey(chain, network);
    const existing = this._pool.get(key);
    if (existing) return existing;

    let adapter: IChainAdapter;

    if (chain === 'solana') {
      const { SolanaAdapter } = await import('@waiaas/adapter-solana');
      adapter = new SolanaAdapter(network);
    } else if (chain === 'ethereum') {
      const { EvmAdapter, EVM_CHAIN_MAP } = await import('@waiaas/adapter-evm');
      const entry = EVM_CHAIN_MAP[network as EvmNetworkType];
      if (!entry) {
        throw new Error(`No EVM chain config for network '${network}'`);
      }
      adapter = new EvmAdapter(network, entry.viemChain, entry.nativeSymbol, entry.nativeName);
    } else {
      throw new Error(`Unsupported chain: ${chain}`);
    }

    await adapter.connect(rpcUrl);
    this._pool.set(key, adapter);
    return adapter;
  }

  /**
   * Disconnect all cached adapters and clear the pool.
   */
  async disconnectAll(): Promise<void> {
    const promises: Promise<void>[] = [];
    for (const adapter of this._pool.values()) {
      promises.push(adapter.disconnect().catch((err) => {
        console.warn('AdapterPool disconnect warning:', err);
      }));
    }
    await Promise.all(promises);
    this._pool.clear();
  }

  /** Number of cached adapters. */
  get size(): number {
    return this._pool.size;
  }
}
```

Key design decisions:
- Dynamic import for both adapter packages (same pattern as current daemon.ts)
- EVM_CHAIN_MAP lookup provides viemChain + nativeSymbol + nativeName automatically
- disconnectAll() is concurrent (Promise.all) with catch per adapter (fail-soft)
- Pool clears after disconnectAll so subsequent resolves create fresh adapters
- `@waiaas/adapter-evm` must be added as dependency to daemon/package.json (Plan 02 handles this)
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/daemon test -- adapter-pool` -- all tests pass.
  </verify>
  <done>
AdapterPool class exists with resolve() and disconnectAll(). Tests cover: Solana resolution, EVM resolution with correct nativeSymbol/nativeName from EVM_CHAIN_MAP, instance caching (referential equality), disconnectAll clears pool, unknown chain throws.
  </done>
</task>

</tasks>

<verification>
1. `packages/daemon/src/infrastructure/adapter-pool.ts` exports AdapterPool class
2. `AdapterPool.resolve()` returns IChainAdapter for both 'solana' and 'ethereum' chains
3. Same chain:network pair returns cached instance
4. `disconnectAll()` disconnects all and clears cache
5. All tests pass: `pnpm --filter @waiaas/daemon test -- adapter-pool`
</verification>

<success_criteria>
- AdapterPool class implemented with lazy init + caching
- Tests cover both chain types, caching, and disconnectAll
- TDD RED->GREEN->REFACTOR cycle completed
</success_criteria>

<output>
After completion, create `.planning/phases/84-adapter-factory/84-01-SUMMARY.md`
</output>
