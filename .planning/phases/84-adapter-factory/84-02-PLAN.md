---
phase: 84-adapter-factory
plan: 02
type: execute
wave: 2
depends_on: ["84-01"]
files_modified:
  - packages/daemon/package.json
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/api/routes/wallet.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/__tests__/api-agents.test.ts
  - packages/daemon/src/__tests__/api-transactions.test.ts
  - packages/daemon/src/__tests__/api-new-endpoints.test.ts
  - packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts
  - packages/daemon/src/__tests__/pipeline-stage1-stage3.test.ts
autonomous: true

must_haves:
  truths:
    - "Daemon startup creates AdapterPool instead of single SolanaAdapter"
    - "Wallet routes resolve adapter from pool using agent's chain:network from DB"
    - "Transaction routes resolve adapter from pool using agent's chain:network from DB"
    - "Pipeline stages 5-6 use the adapter provided via PipelineContext (unchanged interface)"
    - "Daemon shutdown calls adapterPool.disconnectAll() instead of single adapter.disconnect()"
    - "All existing tests pass (regression-free)"
  artifacts:
    - path: "packages/daemon/package.json"
      provides: "@waiaas/adapter-evm dependency added"
      contains: "@waiaas/adapter-evm"
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "AdapterPool initialization and shutdown"
      contains: "AdapterPool"
    - path: "packages/daemon/src/api/server.ts"
      provides: "CreateAppDeps accepts adapterPool instead of single adapter"
      contains: "adapterPool"
    - path: "packages/daemon/src/api/routes/wallet.ts"
      provides: "Wallet routes resolve adapter per-agent from pool"
      contains: "adapterPool"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "Transaction routes resolve adapter per-agent from pool"
      contains: "adapterPool"
  key_links:
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/infrastructure/adapter-pool.ts"
      via: "import and instantiate AdapterPool"
      pattern: "new AdapterPool"
    - from: "packages/daemon/src/api/routes/wallet.ts"
      to: "packages/daemon/src/infrastructure/adapter-pool.ts"
      via: "deps.adapterPool.resolve(agent.chain, agent.network, rpcUrl)"
      pattern: "adapterPool.resolve"
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/infrastructure/adapter-pool.ts"
      via: "deps.adapterPool.resolve(agent.chain, agent.network, rpcUrl)"
      pattern: "adapterPool.resolve"
---

<objective>
Wire AdapterPool into the daemon lifecycle, API server, and all route handlers so the daemon supports multi-chain adapter resolution per agent instead of a single hardcoded SolanaAdapter.

Purpose: Complete the transition from single-adapter to pool-based pattern, enabling Solana and EVM agents to coexist in the same daemon instance. This is the infrastructure that Phase 85+ builds upon for EVM transactions.

Output: Updated daemon.ts, server.ts, wallet.ts, transactions.ts, stages.ts, and all affected test files.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/84-adapter-factory/84-01-SUMMARY.md (AdapterPool class)
@packages/daemon/src/lifecycle/daemon.ts (single adapter Step 4 + shutdown)
@packages/daemon/src/api/server.ts (CreateAppDeps with adapter: IChainAdapter | null)
@packages/daemon/src/api/routes/wallet.ts (WalletRouteDeps with adapter: IChainAdapter | null)
@packages/daemon/src/api/routes/transactions.ts (TransactionRouteDeps with adapter: IChainAdapter)
@packages/daemon/src/pipeline/stages.ts (PipelineContext with adapter: IChainAdapter)
@packages/daemon/src/infrastructure/config/loader.ts (DaemonConfig with rpc section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add @waiaas/adapter-evm dependency + update daemon.ts and server.ts</name>
  <files>
    packages/daemon/package.json
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/api/server.ts
  </files>
  <action>
**1. Add @waiaas/adapter-evm to daemon/package.json:**

Add `"@waiaas/adapter-evm": "workspace:*"` to dependencies.

**2. Update daemon.ts:**

Replace the single `adapter: IChainAdapter | null` field with `adapterPool: AdapterPool | null`:

- Import `AdapterPool` from `../infrastructure/adapter-pool.js`
- Remove `private adapter: IChainAdapter | null = null;`
- Add `private adapterPool: AdapterPool | null = null;`

**Step 4 changes:**
Replace the current Step 4 (SolanaAdapter init) with AdapterPool creation. The pool uses lazy init, so Step 4 just creates the AdapterPool instance -- no connect() calls here. The actual adapter connections happen on-demand when routes call `resolve()`.

```typescript
// Step 4: Adapter pool initialization (10s, fail-soft)
try {
  await withTimeout(
    (async () => {
      const { AdapterPool } = await import('../infrastructure/adapter-pool.js');
      this.adapterPool = new AdapterPool();
      console.log('Step 4: AdapterPool created (lazy init)');
    })(),
    10_000,
    'STEP4_ADAPTER',
  );
} catch (err) {
  console.warn('Step 4 (fail-soft): AdapterPool init warning:', err);
  this.adapterPool = null;
}
```

**Step 5 (createApp) changes:**
Pass `adapterPool` and `config` to createApp instead of single `adapter`:

```typescript
const app = createApp({
  // ... existing deps ...
  adapterPool: this.adapterPool,
  config: this._config!,
  // Remove: adapter: this.adapter,
});
```

**Shutdown changes:**
Replace single adapter disconnect with pool disconnectAll:

```typescript
// Disconnect all chain adapters
if (this.adapterPool) {
  try {
    await this.adapterPool.disconnectAll();
    console.log('Adapter pool disconnected');
  } catch (err) {
    console.warn('Adapter pool disconnect warning:', err);
  }
  this.adapterPool = null;
}
```

**executeFromStage5 changes:**
This method currently uses `this.adapter` directly. Update it to resolve from pool using the agent's chain/network:

```typescript
private async executeFromStage5(txId: string, agentId: string): Promise<void> {
  try {
    if (!this._db || !this.adapterPool || !this.keyStore || !this._config) {
      console.warn(`executeFromStage5(${txId}): missing deps, skipping`);
      return;
    }
    // ... look up agent ...

    // Resolve adapter from pool using agent chain:network
    const rpcUrl = this.resolveRpcUrl(agent.chain, agent.network);
    const adapter = await this.adapterPool.resolve(
      agent.chain as ChainType,
      agent.network as NetworkType,
      rpcUrl,
    );

    // ... construct PipelineContext with resolved adapter ...
  }
}
```

**Add helper method resolveRpcUrl:**

```typescript
/**
 * Resolve RPC URL from config for a given chain:network.
 * Maps network to config key: 'devnet' -> rpc.solana_devnet,
 * 'ethereum-sepolia' -> rpc.evm_ethereum_sepolia, etc.
 */
private resolveRpcUrl(chain: string, network: string): string {
  if (!this._config) throw new Error('Config not loaded');

  if (chain === 'solana') {
    const key = `solana_${network}` as keyof typeof this._config.rpc;
    return (this._config.rpc[key] as string) || '';
  } else if (chain === 'ethereum') {
    const key = `evm_${network.replace(/-/g, '_')}` as keyof typeof this._config.rpc;
    return (this._config.rpc[key] as string) || '';
  }
  return '';
}
```

**3. Update server.ts CreateAppDeps:**

- Remove `adapter?: IChainAdapter | null;`
- Add `adapterPool?: AdapterPool | null;`
- Import AdapterPool type

Update createApp function:
- Wallet routes: pass `adapterPool` + `config` instead of single adapter
- Transaction routes: pass `adapterPool` + `config` instead of single adapter
- The condition for registering transaction routes changes: check `deps.adapterPool` instead of `deps.adapter`

```typescript
// Wallet routes
if (deps.db) {
  app.route(
    '/v1',
    walletRoutes({
      db: deps.db,
      adapterPool: deps.adapterPool ?? null,
      config: deps.config ?? null,
    }),
  );
}

// Transaction routes -- now require adapterPool instead of single adapter
if (
  deps.db &&
  deps.keyStore &&
  deps.masterPassword !== undefined &&
  deps.adapterPool &&
  deps.policyEngine &&
  deps.config
) {
  app.route(
    '/v1',
    transactionRoutes({
      db: deps.db,
      adapterPool: deps.adapterPool,
      config: deps.config,
      keyStore: deps.keyStore,
      policyEngine: deps.policyEngine,
      masterPassword: deps.masterPassword,
      // ... rest unchanged ...
    }),
  );
}
```
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/daemon run typecheck` -- no type errors.
  </verify>
  <done>
daemon.ts uses AdapterPool instead of single SolanaAdapter. server.ts passes adapterPool to routes. @waiaas/adapter-evm added as workspace dependency. resolveRpcUrl helper maps chain:network to config key.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update route handlers + pipeline context + fix tests</name>
  <files>
    packages/daemon/src/api/routes/wallet.ts
    packages/daemon/src/api/routes/transactions.ts
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/__tests__/api-agents.test.ts
    packages/daemon/src/__tests__/api-transactions.test.ts
    packages/daemon/src/__tests__/api-new-endpoints.test.ts
    packages/daemon/src/__tests__/pipeline-stage5-execute.test.ts
    packages/daemon/src/__tests__/pipeline-stage1-stage3.test.ts
  </files>
  <action>
**1. Update wallet.ts:**

Change WalletRouteDeps:
```typescript
import type { AdapterPool } from '../../infrastructure/adapter-pool.js';
import type { DaemonConfig } from '../../infrastructure/config/loader.js';

export interface WalletRouteDeps {
  db: BetterSQLite3Database<typeof schema>;
  adapterPool: AdapterPool | null;
  config: DaemonConfig | null;
}
```

In the balance and assets handlers, resolve adapter per-agent:
```typescript
// Replace: if (!deps.adapter) throw
// With:
if (!deps.adapterPool || !deps.config) {
  throw new WAIaaSError('CHAIN_ERROR', {
    message: 'Chain adapter not available',
  });
}

// Resolve RPC URL from config
const rpcUrl = resolveRpcUrl(deps.config, agent.chain, agent.network);
const adapter = await deps.adapterPool.resolve(
  agent.chain as ChainType,
  agent.network as NetworkType,
  rpcUrl,
);
```

Add local helper function `resolveRpcUrl(config, chain, network)` -- same logic as daemon.ts but static:
```typescript
function resolveRpcUrl(config: DaemonConfig, chain: string, network: string): string {
  if (chain === 'solana') {
    const key = `solana_${network}` as keyof typeof config.rpc;
    return (config.rpc[key] as string) || '';
  } else if (chain === 'ethereum') {
    const key = `evm_${network.replace(/-/g, '_')}` as keyof typeof config.rpc;
    return (config.rpc[key] as string) || '';
  }
  return '';
}
```

Actually -- to avoid duplication, extract `resolveRpcUrl` as a shared utility exported from `adapter-pool.ts` (or a new `rpc-url.ts` file). Use the same function in daemon.ts, wallet.ts, and transactions.ts. Put it in `adapter-pool.ts` since it's closely related:

```typescript
// In adapter-pool.ts:
export function resolveRpcUrl(rpcConfig: Record<string, string>, chain: string, network: string): string {
  if (chain === 'solana') {
    const key = `solana_${network}`;
    return rpcConfig[key] || '';
  } else if (chain === 'ethereum') {
    const key = `evm_${network.replace(/-/g, '_')}`;
    return rpcConfig[key] || '';
  }
  return '';
}
```

Callers pass `config.rpc as unknown as Record<string, string>`.

**2. Update transactions.ts:**

Change TransactionRouteDeps:
```typescript
import type { AdapterPool } from '../../infrastructure/adapter-pool.js';

export interface TransactionRouteDeps {
  db: BetterSQLite3Database<typeof schema>;
  adapterPool: AdapterPool;    // Required (not nullable -- routes only register if pool exists)
  keyStore: LocalKeyStore;
  policyEngine: IPolicyEngine;
  masterPassword: string;
  config: DaemonConfig;         // Now full DaemonConfig (not just policy_defaults)
  // ... existing optional deps unchanged ...
}
```

In the POST /transactions/send handler, resolve adapter per-agent before building PipelineContext:
```typescript
// After looking up agent from DB:
const rpcUrl = resolveRpcUrl(deps.config.rpc as unknown as Record<string, string>, agent.chain, agent.network);
const adapter = await deps.adapterPool.resolve(
  agent.chain as ChainType,
  agent.network as NetworkType,
  rpcUrl,
);

// Build PipelineContext with resolved adapter:
const ctx: PipelineContext = {
  // ...
  adapter,  // Now per-agent resolved adapter
  // ...
  config: {
    policy_defaults_delay_seconds: deps.config.security.policy_defaults_delay_seconds,
    policy_defaults_approval_timeout: deps.config.security.policy_defaults_approval_timeout,
  },
};
```

**3. PipelineContext in stages.ts:**

PipelineContext.adapter remains `IChainAdapter` (not AdapterPool). The route handler resolves the correct adapter and passes it in. No changes to stages.ts needed -- stages already use `ctx.adapter` which is an IChainAdapter. This is intentional: stages don't know about the pool, they get a resolved adapter.

**4. Fix existing test files:**

The key test files affected are those that create a `createApp()` with mock adapter. They need to switch from `adapter: mockAdapter` to `adapterPool: mockAdapterPool`.

Create a **minimal mock AdapterPool** for tests:
```typescript
// In test setup:
const mockAdapter = { /* existing mock IChainAdapter */ };
const mockAdapterPool = {
  resolve: vi.fn().mockResolvedValue(mockAdapter),
  disconnectAll: vi.fn().mockResolvedValue(undefined),
  size: 0,
};
```

Then pass `adapterPool: mockAdapterPool` instead of `adapter: mockAdapter` to createApp.

Update these test files:
- `api-agents.test.ts` -- if it passes adapter to createApp
- `api-transactions.test.ts` -- uses adapter in createApp deps
- `api-new-endpoints.test.ts` -- uses adapter in createApp deps
- `pipeline-stage5-execute.test.ts` -- PipelineContext.adapter unchanged, just verify still works
- `pipeline-stage1-stage3.test.ts` -- PipelineContext unchanged
- Other test files that reference `adapter` in createApp: check each one

For wallet route tests (api-new-endpoints.test.ts likely), update the deps to match new WalletRouteDeps interface.

For transaction route tests, update the deps to match new TransactionRouteDeps interface -- pass `adapterPool` and full `config` instead of single `adapter` and partial config.

**Important: preserve backward compat for pipeline tests.** PipelineContext.adapter is still a single IChainAdapter, so pipeline test files (stage5, stage1-stage3) should NOT need changes unless they call createApp. If they test stages directly with mock context, they stay the same.

Run the full daemon test suite to identify any additional test files that need updating and fix them all.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/daemon test` -- all tests pass (or match pre-existing known failures only: lifecycle.test.ts flaky, e2e-errors.test.ts 404/401).
  </verify>
  <done>
All route handlers resolve adapter per-agent from AdapterPool using agent.chain:network from DB. Transaction and wallet routes use adapterPool.resolve(). PipelineContext.adapter remains IChainAdapter (resolved before pipeline entry). All existing tests updated and passing. resolveRpcUrl shared utility maps chain:network to config.rpc key.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/daemon run typecheck` passes
2. `pnpm --filter @waiaas/daemon test` passes (all except pre-existing known failures)
3. daemon.ts Step 4 creates AdapterPool (not SolanaAdapter)
4. daemon.ts shutdown calls adapterPool.disconnectAll()
5. wallet.ts resolves adapter per-agent from pool
6. transactions.ts resolves adapter per-agent from pool
7. PipelineContext.adapter is still IChainAdapter (stages unchanged)
8. @waiaas/adapter-evm is in daemon/package.json dependencies
</verification>

<success_criteria>
- Daemon startup creates AdapterPool instead of single SolanaAdapter
- All routes resolve correct adapter type based on agent's chain:network
- Same chain:network reuses cached adapter (pool semantics)
- Shutdown disconnects all adapters in pool
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/84-adapter-factory/84-02-SUMMARY.md`
</output>
