---
phase: 50-api-solana-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["50-01"]
files_modified:
  - packages/daemon/src/api/routes/agents.ts
  - packages/daemon/src/api/routes/wallet.ts
  - packages/daemon/src/api/routes/index.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/index.ts
  - packages/daemon/src/__tests__/api-agents.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/agents creates an agent with Solana key pair and returns 201"
    - "GET /v1/wallet/address returns the agent's base58 Solana public key"
    - "GET /v1/wallet/balance returns SOL balance in lamports from RPC"
    - "Non-existent agent ID returns 404 WAIaaSError JSON"
    - "DaemonLifecycle Step 4 initializes SolanaAdapter and Step 5 starts Hono HTTP server"
  artifacts:
    - path: "packages/daemon/src/api/routes/agents.ts"
      provides: "POST /v1/agents route handler"
      exports: ["agentRoutes"]
    - path: "packages/daemon/src/api/routes/wallet.ts"
      provides: "GET /v1/wallet/address and GET /v1/wallet/balance route handlers"
      exports: ["walletRoutes"]
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "DaemonLifecycle Step 4 (adapter init) and Step 5 (HTTP server start) filled in"
  key_links:
    - from: "packages/daemon/src/api/routes/agents.ts"
      to: "packages/daemon/src/infrastructure/keystore/keystore.ts"
      via: "keyStore.generateKeyPair() during agent creation"
      pattern: "generateKeyPair"
    - from: "packages/daemon/src/api/routes/wallet.ts"
      to: "IChainAdapter.getBalance()"
      via: "adapter.getBalance(agent.publicKey)"
      pattern: "getBalance"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "@hono/node-server"
      via: "serve() in Step 5"
      pattern: "serve"
---

<objective>
Implement agent creation and wallet query API routes, and wire the HTTP server + SolanaAdapter into DaemonLifecycle Steps 4-5.

Purpose: Enables the core agent workflow: create an agent (generates Solana key pair) and query its wallet address/balance via REST API.
Output: Agent/wallet route handlers, DaemonLifecycle integration, tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-api-solana-pipeline/50-01-SUMMARY.md

Key references:
- packages/daemon/src/api/server.ts — createApp() from Plan 50-01
- packages/daemon/src/lifecycle/daemon.ts — Step 4/5 stubs to fill
- packages/daemon/src/infrastructure/database/schema.ts — agents table
- packages/daemon/src/infrastructure/keystore/keystore.ts — LocalKeyStore.generateKeyPair()
- packages/core/src/schemas/agent.schema.ts — CreateAgentRequestSchema
- packages/core/src/interfaces/IChainAdapter.ts — getBalance()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agent/wallet routes + DaemonLifecycle Step 4/5 integration</name>
  <files>
    packages/daemon/src/api/routes/agents.ts
    packages/daemon/src/api/routes/wallet.ts
    packages/daemon/src/api/routes/index.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/index.ts
  </files>
  <action>
1. Create `packages/daemon/src/api/routes/agents.ts`:

   **POST /v1/agents** handler:
   - Parse body with CreateAgentRequestSchema from @waiaas/core (name, chain='solana', network='devnet')
   - Validate Zod; on error, throw WAIaaSError or return 400
   - Generate agent ID with generateId()
   - Determine RPC URL from config: for network 'devnet' -> config.rpc.solana_devnet, etc.
   - Call keyStore.generateKeyPair(agentId, chain, masterPassword) to create Solana Ed25519 key pair
   - INSERT into agents table: { id, name, chain, network, publicKey, status: 'ACTIVE', createdAt: now, updatedAt: now }
   - Return 201 with JSON: { id, name, chain, network, publicKey, status, createdAt }

   Route handler needs access to: db (Drizzle), keyStore, masterPassword, config.
   Use a dependency injection pattern: the route factory function accepts deps and returns a Hono router.
   ```typescript
   export function agentRoutes(deps: AgentRouteDeps): Hono { ... }
   ```
   Where AgentRouteDeps = { db, keyStore, masterPassword, config }

2. Create `packages/daemon/src/api/routes/wallet.ts`:

   **GET /v1/wallet/address** handler:
   - Requires query param or header `X-Agent-Id` (v1.1 simplified: agent ID passed in header since no sessionAuth yet)
   - Look up agent by ID in DB
   - If not found: throw WAIaaSError('AGENT_NOT_FOUND') -> 404
   - Return 200 with JSON: { agentId, chain, network, address: agent.publicKey }

   **GET /v1/wallet/balance** handler:
   - Requires `X-Agent-Id` header
   - Look up agent by ID
   - If not found: throw WAIaaSError('AGENT_NOT_FOUND') -> 404
   - Call adapter.getBalance(agent.publicKey)
   - Return 200 with JSON: { agentId, chain, network, address: agent.publicKey, balance: balanceInfo.balance.toString(), decimals: 9, symbol: 'SOL' }
   - Note: balance is returned as string (bigint -> string for JSON)

   Route factory:
   ```typescript
   export function walletRoutes(deps: WalletRouteDeps): Hono { ... }
   ```
   Where WalletRouteDeps = { db, adapter (IChainAdapter) }

3. Create `packages/daemon/src/api/routes/index.ts`:
   - Barrel export: agentRoutes, walletRoutes

4. Update `packages/daemon/src/api/server.ts`:
   - Extend createApp() deps to include: { db, keyStore, masterPassword, config, adapter }
   - Register agent routes: app.route('/v1', agentRoutes(deps))
   - Register wallet routes: app.route('/v1', walletRoutes(deps))
   - All deps are optional so server can still be created with just middleware for testing

5. Update `packages/daemon/src/lifecycle/daemon.ts` to fill Step 4 + Step 5:

   **Step 4: Adapter initialization (10s timeout, fail-soft)**
   ```typescript
   // Replace stub with:
   const { SolanaAdapter } = await import('@waiaas/adapter-solana');
   this.adapter = new SolanaAdapter('solana', this._config!.??? /* network */);

   // Determine RPC URL from config
   const rpcUrl = this._config!.rpc.solana_devnet; // v1.1: devnet only
   await this.adapter.connect(rpcUrl);
   console.log('Step 4: SolanaAdapter connected to', rpcUrl);
   ```
   - Use dynamic import for @waiaas/adapter-solana to avoid hard dependency
   - Store adapter as private field: `private adapter: IChainAdapter | null = null;`
   - fail-soft: if adapter connect fails, log warning but continue (daemon runs without chain adapter)

   **Step 5: HTTP server start (5s timeout, fail-fast)**
   ```typescript
   // Replace stub with:
   const { createApp } = await import('../api/index.js');
   const { serve } = await import('@hono/node-server');

   const app = createApp({
     db: this.db, // Drizzle instance
     keyStore: this.keyStore,
     masterPassword: masterPassword, // need to pass through
     config: this._config,
     adapter: this.adapter,
   });

   this.httpServer = serve({
     fetch: app.fetch,
     hostname: this._config!.daemon.hostname,
     port: this._config!.daemon.port,
   });

   console.log(`Step 5: HTTP server listening on ${this._config!.daemon.hostname}:${this._config!.daemon.port}`);
   ```
   - Store the server reference for shutdown
   - Add `private httpServer: any = null;` field
   - Also need to store db (Drizzle instance, not just sqlite) for route access

   **Shutdown Steps 2-4: HTTP server close**
   ```typescript
   // Replace stubs with:
   if (this.httpServer) {
     this.httpServer.close();
     console.log('Step 2-4: HTTP server closed');
   }
   ```

   NOTE: DaemonLifecycle.start() currently receives `masterPassword` but doesn't store it. It will need to be stored (or passed through to createApp) for the keystore operations in route handlers. Store as `private masterPassword: string = ''` and set in _startInternal.

   Also need to store the Drizzle db instance (not just sqlite). Currently only sqlite (raw) is stored. Modify:
   - `const { sqlite, db } = createDatabase(dbPath);` and store both
   - `private db: ReturnType<typeof createDatabase>['db'] | null = null;`

6. Update `packages/daemon/src/index.ts`:
   - Export createApp, agentRoutes, walletRoutes from api module

IMPORTANT: v1.1 has NO sessionAuth or masterAuth middleware on routes. Agent identification is via X-Agent-Id header. This is the simplest possible auth model for the first working prototype.
  </action>
  <verify>
    - `pnpm build --filter=@waiaas/daemon` succeeds
    - `pnpm typecheck --filter=@waiaas/daemon` succeeds
    - DaemonLifecycle Step 4/5 stubs replaced with real implementation
    - DaemonLifecycle stores both sqlite (Database) and db (Drizzle instance)
  </verify>
  <done>
    - POST /v1/agents handler creates agent + Solana key pair + DB row
    - GET /v1/wallet/address returns agent's base58 public key
    - GET /v1/wallet/balance calls SolanaAdapter.getBalance() and returns lamports
    - DaemonLifecycle Step 4 connects SolanaAdapter, Step 5 starts Hono server
    - DaemonLifecycle.db field provides Drizzle instance to route handlers
    - Shutdown closes HTTP server
  </done>
</task>

<task type="auto">
  <name>Task 2: Agent and wallet API route tests</name>
  <files>
    packages/daemon/src/__tests__/api-agents.test.ts
  </files>
  <action>
1. Create test file using in-memory SQLite + mock adapter + Hono app.request().

2. Test setup:
   - Create in-memory database with createDatabase(':memory:') and pushSchema()
   - Create mock keyStore with generateKeyPair that returns { publicKey: 'mockPublicKey...', encryptedPrivateKey: new Uint8Array() }
   - Create mock adapter with getBalance that returns { address: '...', balance: 1000000000n, decimals: 9, symbol: 'SOL' }
   - Create app with createApp({ db, keyStore, masterPassword: 'test', config: mockConfig, adapter: mockAdapter })

3. Test categories:

**POST /v1/agents (5 tests):**
- Valid request returns 201 with agent JSON (id, name, chain, network, publicKey)
- Created agent has status 'ACTIVE'
- Missing name field returns 400 (Zod validation error)
- Agent ID is UUID format
- Agent is persisted in DB (SELECT after POST confirms existence)

**GET /v1/wallet/address (3 tests):**
- Valid agent ID returns 200 with address JSON
- Non-existent agent ID returns 404 with AGENT_NOT_FOUND error code
- Missing X-Agent-Id header returns 400

**GET /v1/wallet/balance (3 tests):**
- Valid agent returns 200 with balance as string
- Balance includes correct decimals (9) and symbol ('SOL')
- Non-existent agent returns 404

**Integration flow (2 tests):**
- Create agent -> get address -> verify publicKey matches
- Create agent -> get balance -> verify response shape

Target: 13 tests minimum.
  </action>
  <verify>
    - `pnpm test --filter=@waiaas/daemon` passes all tests
    - Agent creation, address, balance endpoints all verified
  </verify>
  <done>
    - Agent CRUD and wallet query routes tested with in-memory DB
    - Error handling verified (404 for missing agent, 400 for bad input)
    - Integration flow tested (create -> query)
  </done>
</task>

</tasks>

<verification>
- `pnpm build --filter=@waiaas/daemon` succeeds
- `pnpm test --filter=@waiaas/daemon` passes all tests (existing + ~13 new)
- POST /v1/agents creates agent with Solana key pair
- GET /v1/wallet/address returns correct public key
- GET /v1/wallet/balance returns lamports balance
- DaemonLifecycle Step 4/5 no longer stubs
</verification>

<success_criteria>
Agent creation and wallet query endpoints are working, DaemonLifecycle is fully integrated with SolanaAdapter and Hono server, ready for transaction pipeline in Plan 50-04.
</success_criteria>

<output>
After completion, create `.planning/phases/50-api-solana-pipeline/50-03-SUMMARY.md`
</output>
