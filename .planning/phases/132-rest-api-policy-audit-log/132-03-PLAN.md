---
phase: 132-rest-api-policy-audit-log
plan: 03
type: execute
wave: 2
depends_on: ["132-01", "132-02"]
files_modified:
  - packages/daemon/src/api/routes/x402.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/__tests__/x402-route.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/x402/fetch 엔드포인트가 sessionAuth로 보호된다"
    - "x402.enabled=false일 때 X402_DISABLED 에러를 반환한다"
    - "X402_ALLOWED_DOMAINS 정책이 없으면 X402_DOMAIN_NOT_ALLOWED로 거부한다"
    - "허용 도메인의 402 응답에서 SPENDING_LIMIT evaluateAndReserve가 호출된다"
    - "SPENDING_LIMIT DELAY 티어에서 delaySeconds > request_timeout이면 X402_DELAY_TIMEOUT으로 거부한다"
    - "SPENDING_LIMIT APPROVAL 티어에서 즉시 X402_APPROVAL_REQUIRED로 거부한다"
    - "결제 성공 시 transactions 테이블에 type=X402_PAYMENT, status=CONFIRMED로 기록된다"
    - "결제 실패 시 transactions 테이블에 status=FAILED로 기록되고 reserved_amount가 해제된다"
    - "TX_REQUESTED/TX_CONFIRMED/TX_FAILED 알림이 발송된다"
    - "Kill Switch 활성 시 x402 결제가 차단된다"
  artifacts:
    - path: "packages/daemon/src/api/routes/x402.ts"
      provides: "POST /v1/x402/fetch 라우트 + 오케스트레이션"
      exports: ["x402Routes"]
    - path: "packages/daemon/src/api/server.ts"
      provides: "x402 라우트 등록 + sessionAuth 경로"
      contains: "x402Routes"
    - path: "packages/daemon/src/__tests__/x402-route.test.ts"
      provides: "x402 라우트 통합 테스트"
      min_lines: 150
  key_links:
    - from: "packages/daemon/src/api/routes/x402.ts"
      to: "packages/daemon/src/services/x402/x402-domain-policy.ts"
      via: "evaluateX402Domain import"
      pattern: "evaluateX402Domain"
    - from: "packages/daemon/src/api/routes/x402.ts"
      to: "packages/daemon/src/services/x402/x402-usd-resolver.ts"
      via: "resolveX402UsdAmount import"
      pattern: "resolveX402UsdAmount"
    - from: "packages/daemon/src/api/routes/x402.ts"
      to: "packages/daemon/src/services/x402/x402-handler.ts"
      via: "handleX402Fetch or parse402Response + selectPaymentRequirement + signPayment"
      pattern: "handleX402Fetch|parse402Response|selectPaymentRequirement"
    - from: "packages/daemon/src/api/routes/x402.ts"
      to: "packages/daemon/src/pipeline/database-policy-engine.ts"
      via: "evaluateAndReserve + releaseReservation"
      pattern: "evaluateAndReserve|releaseReservation"
    - from: "packages/daemon/src/api/routes/x402.ts"
      to: "packages/daemon/src/notifications/notification-service.ts"
      via: "notify TX_REQUESTED/TX_CONFIRMED/TX_FAILED"
      pattern: "notify.*TX_REQUESTED|TX_CONFIRMED|TX_FAILED"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/api/routes/x402.ts"
      via: "x402Routes import + app.route registration"
      pattern: "x402Routes"
---

<objective>
POST /v1/x402/fetch REST API 엔드포인트를 구현하고, 정책 평가 -> 트랜잭션 기록 -> 알림 발송의 전체 오케스트레이션을 완성한다.

Purpose: AI 에이전트가 x402 유료 API를 자동 결제하며 사용할 수 있는 핵심 엔드포인트. X4POL-03/05/06/07/08, X4API-01/02/04 요구사항을 한 번에 충족한다.
Output: x402.ts 라우트, server.ts 등록, 통합 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/132-rest-api-policy-audit-log/132-RESEARCH.md
@.planning/phases/132-rest-api-policy-audit-log/132-01-SUMMARY.md
@.planning/phases/132-rest-api-policy-audit-log/132-02-SUMMARY.md
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/services/x402/x402-handler.ts
@packages/daemon/src/services/x402/payment-signer.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/daemon/src/notifications/notification-service.ts
@packages/daemon/src/infrastructure/config/loader.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /v1/x402/fetch 라우트 + 오케스트레이션 구현</name>
  <files>packages/daemon/src/api/routes/x402.ts</files>
  <action>
    POST /v1/x402/fetch 라우트를 OpenAPIHono createRoute 패턴으로 구현한다. 기존 transactionRoutes 패턴을 따른다.

    1. X402RouteDeps 인터페이스 정의:
       ```typescript
       export interface X402RouteDeps {
         db: BetterSQLite3Database<typeof schema>;
         sqlite: SQLiteDatabase;
         keyStore: LocalKeyStore;
         policyEngine: IPolicyEngine;
         masterPassword: string;
         config: DaemonConfig;
         notificationService?: NotificationService;
         priceOracle?: IPriceOracle;
         adapterPool: AdapterPool | null;
         settingsService?: SettingsService;
       }
       ```

    2. OpenAPI 라우트 정의 (createRoute):
       - method: 'post', path: '/x402/fetch', tags: ['x402']
       - request body: X402FetchRequestSchema (url, method, headers, body)
       - 200 응답: X402FetchResponseSchema (status, headers, body, payment?)
       - 에러 응답: buildErrorResponses로 X402_DISABLED, X402_DOMAIN_NOT_ALLOWED, X402_SSRF_BLOCKED, X402_UNSUPPORTED_SCHEME, X402_PAYMENT_REJECTED, X402_DELAY_TIMEOUT, X402_APPROVAL_REQUIRED, X402_SERVER_ERROR, WALLET_NOT_FOUND, POLICY_DENIED 등록

    3. 핸들러 오케스트레이션 흐름 (Research Pattern 2 참조):

       Phase A -- 결제 전 검증:
       a. config.x402?.enabled 확인. false면 WAIaaSError('X402_DISABLED') throw
       b. sessionAuth에서 walletId, sessionId 추출 (c.get('walletId'), c.get('sessionId'))
       c. 요청 바디 파싱 (c.req.valid('json'))
       d. new URL(body.url).hostname으로 도메인 추출
       e. 월렛 조회 (wallets 테이블). 없으면 WAIaaSError('WALLET_NOT_FOUND')
       f. 월렛의 chain, network, address 추출
       g. policies 로드 -> resolveOverrides는 불가능 (private 메서드). 대신 DB에서 직접 X402_ALLOWED_DOMAINS 정책을 조회한다:
          - policies 테이블에서 (walletId 또는 global) + (network 또는 null) + type='X402_ALLOWED_DOMAINS' + enabled=true 조회
          - 4-level override 적용: wallet+network > wallet+null > global+network > global+null 우선순위로 단일 정책 선택
          - evaluateX402Domain(selectedPolicies, targetDomain) 호출
          - 거부 시 WAIaaSError('X402_DOMAIN_NOT_ALLOWED') throw + POLICY_VIOLATION 알림
       h. SSRF 가드 + 초기 HTTP 요청 (handleX402Fetch의 step 1-3에 해당하는 부분을 라우트에서 직접 수행하거나, handleX402Fetch에 onPaymentRequired 콜백을 주입)

       ** 핵심 설계 결정 -- handleX402Fetch 사용 방식 **:
       Research Open Question 1 참조. handleX402Fetch는 모놀리식이지만 parse402Response, selectPaymentRequirement가 export되어 있다.
       두 가지 접근 중 하나를 선택:

       Option A (권장 -- 라우트에서 직접 오케스트레이션):
       1. validateUrlSafety(body.url) -- SSRF 가드
       2. safeFetchWithRedirects(url, method, headers, bodyStr) -- 초기 요청
       3. 비-402 -> buildPassthroughResponse로 즉시 반환 (DB 기록 없음)
       4. 402 -> parse402Response(response)
       5. selectPaymentRequirement(accepts, supportedNetworks)
       6. [여기서 정책 평가: amount 확인 후 SPENDING_LIMIT]
       7. signPayment(selected, keyStore, walletId, walletAddress, masterPassword)
       8. 재요청 (safeFetchWithRedirects with PAYMENT-SIGNATURE header)
       9. 결과 처리

       Option B (handleX402Fetch에 콜백 주입):
       handleX402Fetch를 수정하여 onPaymentRequired 콜백을 받는다. 콜백에서 정책 평가를 수행하고 throw로 중단.
       -> handleX402Fetch 수정이 필요하므로 Phase 131 결과물 변경. 가능하면 Option A를 사용.

       Phase B -- 402 감지 후 (결제 전):
       i. parse402Response(response)로 PaymentRequirements 추출
       j. selectPaymentRequirement(accepts, supportedNetworks)로 최적 옵션 선택
       k. 선택된 requirement에서 amount, payTo, asset, network 추출
       l. transactions INSERT (type=X402_PAYMENT, status=PENDING, metadata에 target_url/payment_amount/network/asset/scheme 저장)
       m. TX_REQUESTED 알림 (fire-and-forget: void notificationService?.notify(...))
       n. resolveX402UsdAmount(amount, asset, caip2Network, priceOracle) 호출
       o. evaluateAndReserve 호출:
          - TransactionParam: { type: 'TRANSFER', amount: selected.amount, toAddress: selected.payTo, chain, network }
          - type='TRANSFER'로 전달 (Research Pitfall 3: X402_PAYMENT으로 하면 type-specific 정책 트리거 가능)
          - usdAmount 전달
       p. 평가 결과 처리:
          - allowed=false -> 트랜잭션 CANCELLED, releaseReservation, WAIaaSError('POLICY_DENIED')
          - tier='APPROVAL' -> 트랜잭션 CANCELLED (error='X402_APPROVAL_REQUIRED'), releaseReservation, WAIaaSError('X402_APPROVAL_REQUIRED') (X4POL-06)
          - tier='DELAY' ->
            - delaySeconds = evaluation.delaySeconds ?? config.security.policy_defaults_delay_seconds
            - requestTimeout = config.x402?.request_timeout ?? 30
            - delaySeconds > requestTimeout -> 트랜잭션 CANCELLED (error='X402_DELAY_TIMEOUT'), releaseReservation, WAIaaSError('X402_DELAY_TIMEOUT') (X4POL-05)
            - delaySeconds <= requestTimeout -> await sleep(delaySeconds * 1000), 이후 계속
          - tier='INSTANT' 또는 tier='NOTIFY' -> 바로 계속
       q. tier 업데이트 (DB transactions SET tier)

       Phase C -- 결제 서명 + 재요청:
       r. signPayment(selected, keyStore, walletId, walletAddress, masterPassword, rpc?) 호출
          - rpc 파라미터: Solana의 경우 RPC URL 필요. resolveRpcUrl(config, chain, network)로 획득 (기존 adapter-pool.ts의 resolveRpcUrl export 확인)
       s. PAYMENT-SIGNATURE 헤더 생성 (base64 encode -- x402-handler.ts의 encodePaymentSignatureHeader 패턴 재사용하거나 직접 구현)
       t. safeFetchWithRedirects(url, method, retryHeaders, bodyStr) 재요청
       u. 결과 처리:
          - 402 재수신 -> 트랜잭션 FAILED, releaseReservation, TX_FAILED 알림, WAIaaSError('X402_PAYMENT_REJECTED')
          - 비-ok -> 트랜잭션 FAILED, releaseReservation, TX_FAILED 알림, WAIaaSError('X402_SERVER_ERROR')
          - ok -> 트랜잭션 CONFIRMED (executedAt 설정), TX_CONFIRMED 알림, 응답 반환

       try-catch로 전체 흐름 감싸기:
       - catch 블록에서: txId가 생성된 상태면 트랜잭션 FAILED + releaseReservation + TX_FAILED 알림
       - Research Pitfall 5 참조: reserved_amount 해제 누락 방지

    4. x402Routes(deps) 팩토리 함수:
       - const app = new OpenAPIHono() 생성
       - defaultHook: openApiValidationHook (기존 패턴)
       - createRoute로 POST /x402/fetch 등록
       - return app

    5. supportedNetworks 구성:
       - CAIP2_TO_NETWORK의 키들을 Set으로 변환
       - 또는 월렛의 chain에 따라 EVM/Solana 네트워크만 필터링
       - adapterPool에서 사용 가능한 네트워크 확인

    6. sleep 유틸리티: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    비-402 응답 (패스스루) 처리:
    - 트랜잭션 기록 없음. 정책 평가 없음. 그대로 반환.
    - 기존 handleX402Fetch의 buildPassthroughResponse 패턴 참조.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit -p packages/daemon/tsconfig.json
    ```
  </verify>
  <done>
    x402.ts가 컴파일되고, POST /v1/x402/fetch의 전체 오케스트레이션 흐름(도메인 검증 -> 초기 HTTP -> 402 파싱 -> SPENDING_LIMIT 평가 -> DELAY/APPROVAL 분기 -> 결제 서명 -> 재요청 -> DB 기록 -> 알림)이 구현되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: server.ts에 x402 라우트 등록 + sessionAuth 경로 매핑</name>
  <files>packages/daemon/src/api/server.ts</files>
  <action>
    server.ts의 createApp 함수에 x402 라우트를 등록한다.

    1. import 추가:
       ```typescript
       import { x402Routes } from './routes/x402.js';
       ```

    2. sessionAuth 경로 추가 (기존 sessionAuth 블록 내, /v1/actions/* 아래):
       ```typescript
       app.use('/v1/x402/*', sessionAuth);
       ```

    3. x402 라우트 등록 (기존 action routes 등록 블록 아래):
       ```typescript
       // Register x402 routes when pipeline deps + config are available
       if (
         deps.db &&
         deps.sqlite &&
         deps.keyStore &&
         deps.masterPassword !== undefined &&
         deps.policyEngine &&
         deps.config
       ) {
         app.route('/v1', x402Routes({
           db: deps.db,
           sqlite: deps.sqlite,
           keyStore: deps.keyStore,
           policyEngine: deps.policyEngine,
           masterPassword: deps.masterPassword,
           config: deps.config,
           notificationService: deps.notificationService,
           priceOracle: deps.priceOracle,
           adapterPool: deps.adapterPool ?? null,
           settingsService: deps.settingsService,
         }));
       }
       ```

    4. Kill Switch 보호: 기존 killSwitchGuard가 '/v1/admin/*' 제외 전체에 적용되므로 x402도 자동 차단됨. 추가 작업 불필요. (X4POL-08 충족)

    주의: sessionAuth 경로는 반드시 라우트 등록 전에 등록해야 한다 (기존 패턴 준수).
  </action>
  <verify>
    ```bash
    npx tsc --noEmit -p packages/daemon/tsconfig.json
    ```
  </verify>
  <done>
    server.ts에서 x402Routes가 등록되고, /v1/x402/* 경로에 sessionAuth가 적용된다. Kill Switch 활성 시 x402 결제가 차단된다.
  </done>
</task>

<task type="auto">
  <name>Task 3: x402 라우트 통합 테스트</name>
  <files>packages/daemon/src/__tests__/x402-route.test.ts</files>
  <action>
    POST /v1/x402/fetch 엔드포인트의 통합 테스트를 작성한다. 기존 daemon 테스트 패턴(createApp에 mock deps 주입, app.request로 HTTP 호출)을 따른다.

    테스트 그룹:

    1. **인증 (sessionAuth)**
       - Authorization 헤더 없이 POST /v1/x402/fetch -> 401
       - 유효한 세션 토큰으로 POST -> 정상 처리

    2. **x402 비활성화 (X4API-03)**
       - config.x402.enabled=false -> 422 X402_DISABLED 에러

    3. **도메인 정책 (X4POL-01, X4POL-02)**
       - X402_ALLOWED_DOMAINS 정책 없음 -> X402_DOMAIN_NOT_ALLOWED 에러
       - 정책에 "api.example.com" 등록, 요청 url="https://api.example.com/data" -> 도메인 허용
       - 정책에 "*.example.com" 등록, 요청 url="https://sub.example.com/data" -> 도메인 허용
       - 정책에 "*.example.com" 등록, 요청 url="https://evil.com/data" -> X402_DOMAIN_NOT_ALLOWED

    4. **비-402 패스스루**
       - 외부 서버가 200 반환 -> 그대로 패스스루, DB 기록 없음, payment=undefined

    5. **SPENDING_LIMIT 통합 (X4POL-03, X4POL-07)**
       - 402 응답 + SPENDING_LIMIT INSTANT -> 결제 진행, transactions CONFIRMED
       - 402 응답 + SPENDING_LIMIT NOTIFY -> 결제 진행, tier=NOTIFY
       - evaluateAndReserve가 txId로 reserved_amount를 설정하는지 확인

    6. **DELAY 타임아웃 (X4POL-05)**
       - DELAY 티어 + delaySeconds=5, request_timeout=30 -> 5초 대기 후 결제 계속 (테스트에서 sleep을 vi.mock하여 즉시 resolve)
       - DELAY 티어 + delaySeconds=60, request_timeout=30 -> X402_DELAY_TIMEOUT 즉시 거부

    7. **APPROVAL 즉시 거부 (X4POL-06)**
       - APPROVAL 티어 -> X402_APPROVAL_REQUIRED 즉시 거부, transactions CANCELLED

    8. **트랜잭션 기록 (X4API-02)**
       - 결제 성공 -> transactions 테이블에 type=X402_PAYMENT, status=CONFIRMED, metadata에 target_url 포함
       - 결제 실패 -> transactions 테이블에 status=FAILED

    9. **알림 트리거 (X4API-04)**
       - 결제 시작 -> TX_REQUESTED 알림 호출
       - 결제 성공 -> TX_CONFIRMED 알림 호출
       - 결제 실패 -> TX_FAILED 알림 호출

    10. **예약 해제 (Pitfall 5)**
        - 결제 실패 시 releaseReservation(txId) 호출 확인
        - APPROVAL/DELAY_TIMEOUT 거부 시 releaseReservation 호출 확인

    테스트 설정:
    - vi.mock으로 ssrf-guard (validateUrlSafety, safeFetchWithRedirects) 모킹
    - vi.mock으로 payment-signer (signPayment) 모킹
    - 인메모리 SQLite DB + 스키마 마이그레이션 (기존 테스트 패턴)
    - JWT 세션 토큰 생성 (기존 테스트 유틸)
    - NotificationService mock (notify 호출 확인)

    주의:
    - handleX402Fetch를 모킹하지 않고 하위 함수(parse402Response, selectPaymentRequirement)를 모킹한다 (Option A 사용 시). 또는 ssrf-guard와 payment-signer만 모킹하고 x402-handler를 통째로 실행한다.
    - 테스트에서 실제 외부 HTTP 요청이 발생하지 않도록 safeFetchWithRedirects를 모킹한다.
  </action>
  <verify>
    ```bash
    # x402 라우트 테스트 실행
    npx vitest run packages/daemon/src/__tests__/x402-route.test.ts

    # 전체 daemon 테스트 회귀 확인
    npx vitest run --project daemon
    ```
  </verify>
  <done>
    x402 라우트 통합 테스트가 모든 시나리오를 커버하고, 기존 daemon 테스트와 함께 전체 통과한다. 12개 요구사항(X4POL-01~08, X4API-01~04)이 테스트로 검증된다.
  </done>
</task>

</tasks>

<verification>
```bash
# Phase 132 전체 검증
npx vitest run packages/daemon/src/__tests__/x402-domain-policy.test.ts
npx vitest run packages/daemon/src/__tests__/x402-usd-resolver.test.ts
npx vitest run packages/daemon/src/__tests__/x402-route.test.ts
npx tsc --noEmit -p packages/daemon/tsconfig.json
npx vitest run --project daemon
```
</verification>

<success_criteria>
- POST /v1/x402/fetch가 sessionAuth로 보호되고 정상 동작한다
- X402_ALLOWED_DOMAINS 정책이 기본 거부로 동작한다
- SPENDING_LIMIT 4-tier가 evaluateAndReserve로 평가되고 TOCTOU가 방지된다
- DELAY는 request_timeout 내 대기, 초과 시 X402_DELAY_TIMEOUT 거부
- APPROVAL은 즉시 X402_APPROVAL_REQUIRED 거부
- x402 결제가 transactions 테이블에 type=X402_PAYMENT으로 기록된다
- TX_REQUESTED/TX_CONFIRMED/TX_FAILED 알림이 연동된다
- Kill Switch 활성 시 x402 결제가 차단된다
- 결제 실패 시 reserved_amount가 해제된다
- 전체 daemon 테스트 통과 (회귀 없음)
</success_criteria>

<output>
After completion, create `.planning/phases/132-rest-api-policy-audit-log/132-03-SUMMARY.md`
</output>
