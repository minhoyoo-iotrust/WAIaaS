---
phase: 120-db-migration-stability
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/infrastructure/database/migrate.ts
  - packages/daemon/src/__tests__/migration-chain.test.ts
autonomous: true

must_haves:
  truths:
    - "v5 스키마 DB에서 pushSchema() 호출 시 에러 없이 마이그레이션이 완료된다"
    - "v1 스키마 DB에서 pushSchema() 호출 시 v2-v9 전체 마이그레이션 체인이 성공한다"
    - "fresh DB에서 pushSchema() 호출 시 기존 동작(테이블+인덱스+버전 기록)이 유지된다"
    - "마이그레이션 후 모든 인덱스가 sqlite_master에 존재한다"
    - "v7 마이그레이션이 devnet->testnet, ethereum-sepolia->testnet, ethereum-mainnet->mainnet 변환을 수행한다"
    - "v6 마이그레이션이 transactions.network를 wallets.network에서 올바르게 백필한다"
    - "v3 마이그레이션이 AGENT_CREATED->WALLET_CREATED 이벤트 변환을 수행한다"
    - "모든 테이블 재생성 마이그레이션 후 FK 참조 무결성이 보존된다"
  artifacts:
    - path: "packages/daemon/src/infrastructure/database/migrate.ts"
      provides: "pushSchema 순서 수정 — 인덱스 생성이 마이그레이션 완료 후 실행"
      contains: "runMigrations(sqlite)"
    - path: "packages/daemon/src/__tests__/migration-chain.test.ts"
      provides: "마이그레이션 체인 테스트 + 데이터 변환 검증"
      min_lines: 200
  key_links:
    - from: "packages/daemon/src/infrastructure/database/migrate.ts"
      to: "pushSchema function"
      via: "인덱스 생성을 runMigrations() 호출 이후로 이동"
      pattern: "runMigrations.*indexes"
    - from: "packages/daemon/src/__tests__/migration-chain.test.ts"
      to: "packages/daemon/src/infrastructure/database/migrate.ts"
      via: "pushSchema + runMigrations import"
      pattern: "import.*pushSchema.*migrate"
---

<objective>
pushSchema()의 인덱스 생성 순서를 수정하고, 마이그레이션 체인 전체 경로 테스트 + 데이터 변환 정확성 테스트를 추가한다.

Purpose: 기존 DB(v1~v5)를 가진 환경에서 v1.4.6+ 코드로 데몬 시작 시 "no such column: environment" 에러로 차단되는 HIGH 버그(MIGR-01)를 수정하고, 향후 같은 종류의 회귀를 방지하는 테스트를 구축한다.

Output: 수정된 pushSchema() + 마이그레이션 체인 테스트 파일
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/daemon/src/infrastructure/database/migrate.ts
@packages/daemon/src/__tests__/migration-runner.test.ts
@packages/daemon/src/__tests__/migration-v6-v8.test.ts
@objectives/issues/v1.4.8-031-pushschema-index-before-migration.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: pushSchema 실행 순서 수정 + 마이그레이션 체인 테스트</name>
  <files>
    packages/daemon/src/infrastructure/database/migrate.ts
    packages/daemon/src/__tests__/migration-chain.test.ts
  </files>
  <action>
**1. pushSchema() 실행 순서 변경 (`migrate.ts`)**

현재 `pushSchema()` 함수의 실행 순서가 잘못되어 있다. 인덱스 생성이 마이그레이션 실행 전에 일어나므로, 기존 DB에서 최신 스키마 기준 인덱스(예: `wallets(chain, environment)`)를 생성하려 할 때 컬럼이 아직 없어 실패한다.

**수정할 순서 (3단계):**

```
Step 1: CREATE TABLE IF NOT EXISTS (테이블만 생성, 인덱스 없음)
        + schema_version 기록 (fresh DB면 전체 버전 기록)
Step 2: runMigrations() — 기존 DB의 스키마를 최신으로 업그레이드
Step 3: CREATE INDEX IF NOT EXISTS — 모든 컬럼이 확보된 후 안전하게 인덱스 생성
```

구체적으로 `pushSchema()` 함수를 다음과 같이 수정:

```typescript
export function pushSchema(sqlite: Database): void {
  const tables = getCreateTableStatements();
  const indexes = getCreateIndexStatements();

  // Step 1: 테이블 생성 + 버전 기록 (인덱스 없음)
  sqlite.exec('BEGIN');
  try {
    for (const stmt of tables) {
      sqlite.exec(stmt);
    }

    // Record schema version 1 if not already recorded
    const existing = sqlite
      .prepare('SELECT version FROM schema_version WHERE version = 1')
      .get() as { version: number } | undefined;
    if (!existing) {
      // Fresh DB: record all versions up to LATEST_SCHEMA_VERSION
      const ts = Math.floor(Date.now() / 1000);
      sqlite
        .prepare('INSERT INTO schema_version (version, applied_at, description) VALUES (?, ?, ?)')
        .run(1, ts, 'Initial schema (11 tables)');

      for (const migration of MIGRATIONS) {
        sqlite
          .prepare('INSERT OR IGNORE INTO schema_version (version, applied_at, description) VALUES (?, ?, ?)')
          .run(migration.version, ts, `${migration.description} (via pushSchema)`);
      }
    }

    sqlite.exec('COMMIT');
  } catch (err) {
    sqlite.exec('ROLLBACK');
    throw err;
  }

  // Step 2: 마이그레이션 (기존 DB의 컬럼 추가/변환)
  runMigrations(sqlite);

  // Step 3: 인덱스 생성 (모든 컬럼이 확보된 후)
  sqlite.exec('BEGIN');
  try {
    for (const stmt of indexes) {
      sqlite.exec(stmt);
    }
    sqlite.exec('COMMIT');
  } catch (err) {
    sqlite.exec('ROLLBACK');
    throw err;
  }
}
```

**핵심 변경점:**
- 인덱스 생성 루프를 Step 1 트랜잭션에서 제거
- runMigrations() 호출 후 별도 트랜잭션으로 인덱스 생성

**2. 마이그레이션 체인 테스트 파일 생성 (`migration-chain.test.ts`)**

새 테스트 파일 `packages/daemon/src/__tests__/migration-chain.test.ts`을 생성한다. 이 파일은 이슈 031에 정의된 T-1 ~ T-11 테스트를 구현한다.

**테스트 구조:**

```
describe('pushSchema on existing databases')
  ├── T-1: v5 DB에서 pushSchema 성공
  ├── T-3: v1 DB(agents)에서 pushSchema 성공 (전체 마이그레이션 체인)
  ├── T-4: fresh DB에서 pushSchema 성공 (기존 동작 유지)
  └── T-5: 인덱스 완전성 검증

describe('migration chain schema equivalence')
  └── T-2/T-6: v1/v5 마이그레이션 후 스키마가 fresh DB와 동일

describe('data transformation: v7 network to environment')
  ├── T-7a: devnet -> testnet
  ├── T-7b: ethereum-sepolia -> testnet
  ├── T-7c: ethereum-mainnet -> mainnet
  ├── T-7d: polygon-amoy -> testnet
  ├── T-7e: base-mainnet -> mainnet
  └── T-7f: default_network 보존

describe('data transformation: v6 transactions.network backfill')
  ├── T-8a: Solana 트랜잭션 백필
  ├── T-8b: EVM 트랜잭션 백필
  └── T-8c: 다수 트랜잭션 백필 (월렛 1개 + 트랜잭션 5건)

describe('data transformation: v3 agents to wallets')
  ├── T-9a: AGENT_CREATED -> WALLET_CREATED 이벤트 변환
  ├── T-9b: agent_id -> wallet_id FK 보존
  └── T-9c: AGENT_SUSPENDED -> WALLET_SUSPENDED notification_logs 변환

describe('FK integrity preservation')
  ├── T-10a: v5 마이그레이션 후 PRAGMA foreign_key_check 통과
  └── T-10b: v1 마이그레이션 후 PRAGMA foreign_key_check 통과

describe('edge cases')
  ├── T-11a: NULL owner_address 보존
  ├── T-11b: 빈 테이블 마이그레이션 (에러 없음)
  └── T-11c: suspended 월렛 데이터 보존
```

**스키마 스냅샷 헬퍼 함수:**

두 개의 헬퍼 함수가 필요하다:

1. `createV1SchemaDatabase()` — v1 스키마(agents 테이블, Solana-only CHECK, agent_id FK) 생성. 이미 `migration-runner.test.ts`의 `createV1Database()` 패턴을 참조하되, notification_logs와 audit_log 등 v1에 존재했던 모든 테이블을 포함해야 한다. schema_version에 version=1만 기록.

2. `createV5SchemaDatabase()` — v5 스키마(wallets 테이블, wallet_id FK, token_registry, settings, wallets.network). 이미 `migration-v6-v8.test.ts`의 `createV5Database()` 패턴을 참조. schema_version에 version 1-5 기록.

**인덱스 완전성 검증 (T-5) 구현:**

`getCreateIndexStatements()`가 반환하는 인덱스 이름 목록을 파싱하여 `sqlite_master`에서 실제 인덱스가 존재하는지 확인한다. 인덱스 이름은 SQL 문에서 `IF NOT EXISTS` 뒤의 이름을 추출한다.

```typescript
function getAllExpectedIndexNames(): string[] {
  // getCreateIndexStatements()의 각 문에서 인덱스 이름 추출
  // 'CREATE INDEX IF NOT EXISTS idx_xxx ON ...' -> 'idx_xxx'
  // 'CREATE UNIQUE INDEX IF NOT EXISTS idx_xxx ON ...' -> 'idx_xxx'
  return getCreateIndexStatements().map((stmt) => {
    const match = stmt.match(/(?:CREATE\s+(?:UNIQUE\s+)?INDEX\s+IF\s+NOT\s+EXISTS\s+)(\w+)/i);
    if (!match) throw new Error(`Cannot parse index name from: ${stmt}`);
    return match[1]!;
  });
}
```

참고: `getCreateIndexStatements`는 현재 모듈 내부 함수이므로, 테스트에서 직접 접근할 수 없다. 대신 sqlite_master에서 실제 인덱스 목록을 가져와 기대하는 인덱스 이름 배열과 비교한다. 기대하는 인덱스 이름은 테스트 파일에 하드코딩한다 (31개 인덱스).

**스키마 동등성 비교 (T-2/T-6):**

`migration-v6-v8.test.ts`의 기존 패턴을 확장한다. 모든 11개 테이블의 컬럼 이름을 비교한다.

```typescript
function getTableColumns(db: DatabaseType, table: string): string[] {
  return (db.prepare(`PRAGMA table_info('${table}')`).all() as Array<{ name: string }>)
    .map((c) => c.name)
    .sort();
}

function getTableIndexes(db: DatabaseType, table: string): string[] {
  return (db.prepare(`PRAGMA index_list('${table}')`).all() as Array<{ name: string }>)
    .map((i) => i.name)
    .filter((n) => !n.startsWith('sqlite_'))
    .sort();
}
```

**데이터 삽입 헬퍼:**

각 스냅샷 DB에 샘플 데이터를 삽입하는 헬퍼 함수를 작성한다. v1 DB에는 agents/agent_id, v5 DB에는 wallets/wallet_id를 사용한다.

TDD 주의: 이 플랜은 type: tdd이다. 먼저 migration-chain.test.ts 테스트를 작성하여 FAIL을 확인한 후 (v5에서 pushSchema 호출 시 "no such column: environment" 에러), migrate.ts를 수정하여 PASS를 확인한다.

**RED 단계:**
1. migration-chain.test.ts 작성 (최소한 T-1: v5 DB에서 pushSchema 성공 테스트)
2. 테스트 실행 → FAIL 확인 ("no such column: environment")
3. 커밋: `test(120-01): add failing migration chain tests`

**GREEN 단계:**
1. migrate.ts의 pushSchema() 순서 수정
2. 테스트 실행 → PASS 확인
3. 커밋: `fix(120-01): reorder pushSchema to run indexes after migrations`

**REFACTOR 단계:**
1. 나머지 테스트 (T-2~T-11) 추가
2. 전체 테스트 실행 → PASS 확인
3. 커밋: `test(120-01): add comprehensive migration chain and data transformation tests`
  </action>
  <verify>
1. `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/daemon test -- --run migration-chain` — 모든 마이그레이션 체인 테스트 통과
2. `pnpm --filter @waiaas/daemon test -- --run migration-runner` — 기존 마이그레이션 러너 테스트 회귀 없음
3. `pnpm --filter @waiaas/daemon test -- --run migration-v6-v8` — 기존 v6-v8 테스트 회귀 없음
4. `pnpm --filter @waiaas/daemon test -- --run database` — 기존 DB 테스트 회귀 없음
  </verify>
  <done>
1. pushSchema()가 테이블 생성 → 마이그레이션 → 인덱스 생성 순서로 실행된다
2. v5 스키마 DB에서 pushSchema() 호출 시 에러 없이 완료된다 (MIGR-01 해소)
3. v1 스키마 DB에서 pushSchema() 호출 시 v2→v9 전체 체인이 성공한다 (MIGR-02)
4. v7 environment 매핑, v6 network 백필, v3 이름 변환이 테스트로 검증된다 (MIGR-03)
5. 기존 migration-runner, migration-v6-v8, database 테스트에 회귀가 없다
6. 마이그레이션 후 31개 인덱스가 모두 sqlite_master에 존재한다
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/daemon test -- --run migration-chain` — 신규 테스트 전체 통과
2. `pnpm --filter @waiaas/daemon test -- --run migration-runner` — 기존 테스트 회귀 없음
3. `pnpm --filter @waiaas/daemon test -- --run migration-v6-v8` — 기존 테스트 회귀 없음
4. `pnpm --filter @waiaas/daemon test -- --run database` — 기존 테스트 회귀 없음
5. migrate.ts에서 pushSchema 함수의 인덱스 생성이 runMigrations() 호출 이후에 위치하는지 코드 확인
</verification>

<success_criteria>
- MIGR-01: pushSchema가 테이블→마이그레이션→인덱스 순서로 실행
- MIGR-02: v1, v5 시작점에서 최신 버전까지 마이그레이션 체인 테스트 통과
- MIGR-03: environment 매핑, network 백필, 이름 변환 데이터 변환 테스트 통과
- 기존 마이그레이션/DB 테스트에 회귀 없음
</success_criteria>

<output>
After completion, create `.planning/phases/120-db-migration-stability/120-01-SUMMARY.md`
</output>
