---
phase: 62-python-sdk
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python-sdk/pyproject.toml
  - python-sdk/waiaas/__init__.py
  - python-sdk/waiaas/client.py
  - python-sdk/waiaas/models.py
  - python-sdk/waiaas/errors.py
  - python-sdk/waiaas/retry.py
  - python-sdk/tests/test_client.py
  - python-sdk/tests/test_models.py
  - python-sdk/tests/test_retry.py
  - python-sdk/tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "WAIaaSClient initializes with base_url and session_token, then calls get_balance/get_address/get_assets returning typed Pydantic models"
    - "WAIaaSClient.send_token() sends TRANSFER request and returns transaction ID and status"
    - "WAIaaSClient.get_transaction()/list_transactions() retrieve transaction history with cursor pagination"
    - "WAIaaSClient.renew_session() calls PUT /v1/sessions/{id}/renew and returns renewed token + expiry"
    - "Pydantic v2 models validate response data and raise ValidationError on invalid input"
    - "429/5xx responses trigger exponential backoff retry (1s, 2s, 4s, max 3 attempts) before raising"
    - "WAIaaSError includes code, message, status_code, retryable, hint attributes from API error responses"
  artifacts:
    - path: "python-sdk/pyproject.toml"
      provides: "Package metadata, dependencies, build config"
      contains: "httpx"
    - path: "python-sdk/waiaas/client.py"
      provides: "WAIaaSClient async HTTP client"
      exports: ["WAIaaSClient"]
    - path: "python-sdk/waiaas/models.py"
      provides: "Pydantic v2 request/response models"
      exports: ["WalletBalance", "WalletAddress", "WalletAssets", "TransactionResponse", "TransactionDetail", "TransactionList", "SessionRenewResponse"]
    - path: "python-sdk/waiaas/errors.py"
      provides: "WAIaaSError exception class"
      exports: ["WAIaaSError"]
    - path: "python-sdk/waiaas/retry.py"
      provides: "Exponential backoff retry logic"
      exports: ["RetryPolicy", "with_retry"]
    - path: "python-sdk/tests/test_client.py"
      provides: "Client integration tests with MockTransport"
    - path: "python-sdk/tests/test_models.py"
      provides: "Pydantic model validation tests"
    - path: "python-sdk/tests/test_retry.py"
      provides: "Retry logic tests"
  key_links:
    - from: "python-sdk/waiaas/client.py"
      to: "python-sdk/waiaas/models.py"
      via: "returns typed Pydantic models from API responses"
      pattern: "WalletBalance|TransactionDetail"
    - from: "python-sdk/waiaas/client.py"
      to: "python-sdk/waiaas/retry.py"
      via: "wraps HTTP requests with retry logic"
      pattern: "RetryPolicy|with_retry"
    - from: "python-sdk/waiaas/client.py"
      to: "python-sdk/waiaas/errors.py"
      via: "raises WAIaaSError on non-2xx responses"
      pattern: "WAIaaSError"
    - from: "python-sdk/waiaas/client.py"
      to: "REST API /v1/*"
      via: "async httpx calls to daemon endpoints"
      pattern: "/v1/wallet|/v1/transactions|/v1/sessions"
---

<objective>
Create the waiaas Python SDK package with WAIaaSClient (async httpx), Pydantic v2 request/response models, WAIaaSError exception, exponential backoff retry, and comprehensive pytest tests using httpx MockTransport.

Purpose: Enable Python-based AI agent frameworks to interact with WAIaaS daemon using the same interface as the TypeScript SDK, with type-safe models and automatic retry on transient errors.

Output: Complete python-sdk/ directory with pyproject.toml, waiaas package (client, models, errors, retry), and tests (30+ test cases).
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@objectives/v1.3-sdk-mcp-notifications.md (Python SDK section, lines 84-107)
@packages/daemon/src/api/routes/openapi-schemas.ts (response schemas -- source of truth for Pydantic models)
@packages/daemon/src/api/routes/wallet.ts (wallet API endpoints)
@packages/daemon/src/api/routes/transactions.ts (transaction API endpoints)
@packages/daemon/src/api/routes/sessions.ts (session renewal endpoint)
@packages/daemon/src/api/error-hints.ts (error hint map)
@packages/core/src/errors/base-error.ts (WAIaaSError shape)
@packages/core/src/errors/error-codes.ts (68 error codes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package scaffold + Pydantic models + errors + retry</name>
  <files>
    python-sdk/pyproject.toml
    python-sdk/waiaas/__init__.py
    python-sdk/waiaas/models.py
    python-sdk/waiaas/errors.py
    python-sdk/waiaas/retry.py
    python-sdk/waiaas/py.typed
    python-sdk/tests/__init__.py
    python-sdk/tests/conftest.py
    python-sdk/tests/test_models.py
    python-sdk/tests/test_retry.py
  </files>
  <action>
**1a. pyproject.toml -- package scaffold with hatch build:**

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "waiaas"
version = "0.1.0"
description = "Python SDK for WAIaaS (Wallet-as-a-Service for AI Agents)"
readme = "README.md"
license = "MIT"
requires-python = ">=3.10"
dependencies = [
    "httpx>=0.27",
    "pydantic>=2.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0",
    "pytest-asyncio>=0.24",
    "anyio>=4.0",
]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.hatch.build.targets.wheel]
packages = ["waiaas"]
```

**1b. waiaas/__init__.py -- public API:**

```python
"""WAIaaS Python SDK -- AI Agent Wallet-as-a-Service client."""

from waiaas.client import WAIaaSClient
from waiaas.errors import WAIaaSError
from waiaas.models import (
    WalletAddress,
    WalletBalance,
    WalletAssets,
    AssetInfo,
    TransactionResponse,
    TransactionDetail,
    TransactionList,
    PendingTransactionList,
    SessionRenewResponse,
    SendTokenRequest,
)

__version__ = "0.1.0"

__all__ = [
    "WAIaaSClient",
    "WAIaaSError",
    "WalletAddress",
    "WalletBalance",
    "WalletAssets",
    "AssetInfo",
    "TransactionResponse",
    "TransactionDetail",
    "TransactionList",
    "PendingTransactionList",
    "SessionRenewResponse",
    "SendTokenRequest",
]
```

**1c. waiaas/models.py -- Pydantic v2 models matching OpenAPI schemas:**

Map directly from the Zod schemas in openapi-schemas.ts:

```python
"""Pydantic v2 models for WAIaaS API request/response data."""

from __future__ import annotations
from pydantic import BaseModel, Field
from typing import Optional


# ---------------------------------------------------------------------------
# Wallet models
# ---------------------------------------------------------------------------

class WalletAddress(BaseModel):
    agent_id: str = Field(alias="agentId")
    chain: str
    network: str
    address: str

    model_config = {"populate_by_name": True}


class WalletBalance(BaseModel):
    agent_id: str = Field(alias="agentId")
    chain: str
    network: str
    address: str
    balance: str
    decimals: int
    symbol: str

    model_config = {"populate_by_name": True}


class AssetInfo(BaseModel):
    mint: str
    symbol: str
    name: str
    balance: str
    decimals: int
    is_native: bool = Field(alias="isNative")
    usd_value: Optional[float] = Field(default=None, alias="usdValue")

    model_config = {"populate_by_name": True}


class WalletAssets(BaseModel):
    agent_id: str = Field(alias="agentId")
    chain: str
    network: str
    assets: list[AssetInfo]

    model_config = {"populate_by_name": True}


# ---------------------------------------------------------------------------
# Transaction models
# ---------------------------------------------------------------------------

class SendTokenRequest(BaseModel):
    """Request body for POST /v1/transactions/send."""
    to: str
    amount: str
    memo: Optional[str] = None


class TransactionResponse(BaseModel):
    """Response from POST /v1/transactions/send (201)."""
    id: str
    status: str


class TransactionDetail(BaseModel):
    """Response from GET /v1/transactions/:id."""
    id: str
    agent_id: str = Field(alias="agentId")
    type: str
    status: str
    tier: Optional[str] = None
    chain: str
    to_address: Optional[str] = Field(default=None, alias="toAddress")
    amount: Optional[str] = None
    tx_hash: Optional[str] = Field(default=None, alias="txHash")
    error: Optional[str] = None
    created_at: Optional[int] = Field(default=None, alias="createdAt")

    model_config = {"populate_by_name": True}


class TransactionList(BaseModel):
    """Response from GET /v1/transactions."""
    items: list[TransactionDetail]
    cursor: Optional[str] = None
    has_more: bool = Field(alias="hasMore")

    model_config = {"populate_by_name": True}


class PendingTransactionList(BaseModel):
    """Response from GET /v1/transactions/pending."""
    items: list[TransactionDetail]


# ---------------------------------------------------------------------------
# Session models
# ---------------------------------------------------------------------------

class SessionRenewResponse(BaseModel):
    """Response from PUT /v1/sessions/:id/renew."""
    id: str
    token: str
    expires_at: int = Field(alias="expiresAt")
    renewal_count: int = Field(alias="renewalCount")

    model_config = {"populate_by_name": True}
```

All model fields use `alias` for JSON camelCase deserialization from the API while exposing snake_case Python attributes. `populate_by_name = True` allows both camelCase (API JSON) and snake_case (Python code) population.

**1d. waiaas/errors.py -- WAIaaSError exception:**

```python
"""WAIaaS error types matching the daemon's error response format."""

from __future__ import annotations
from typing import Any, Optional


class WAIaaSError(Exception):
    """Error from WAIaaS API or client-side validation."""

    def __init__(
        self,
        code: str,
        message: str,
        status_code: int = 0,
        retryable: bool = False,
        details: Optional[dict[str, Any]] = None,
        request_id: Optional[str] = None,
        hint: Optional[str] = None,
    ) -> None:
        super().__init__(message)
        self.code = code
        self.message = message
        self.status_code = status_code
        self.retryable = retryable
        self.details = details
        self.request_id = request_id
        self.hint = hint

    @classmethod
    def from_response(cls, status_code: int, body: dict[str, Any]) -> "WAIaaSError":
        """Create WAIaaSError from API error response JSON."""
        return cls(
            code=body.get("code", "UNKNOWN_ERROR"),
            message=body.get("message", "Unknown error"),
            status_code=status_code,
            retryable=body.get("retryable", False),
            details=body.get("details"),
            request_id=body.get("requestId"),
            hint=body.get("hint"),
        )

    def __repr__(self) -> str:
        return f"WAIaaSError(code={self.code!r}, message={self.message!r}, status_code={self.status_code})"
```

**1e. waiaas/retry.py -- exponential backoff retry:**

```python
"""Exponential backoff retry for transient HTTP errors."""

from __future__ import annotations
import asyncio
from dataclasses import dataclass, field
from typing import TypeVar, Callable, Awaitable

T = TypeVar("T")


@dataclass
class RetryPolicy:
    """Configuration for exponential backoff retry."""
    max_retries: int = 3
    base_delay: float = 1.0  # seconds
    max_delay: float = 10.0  # seconds
    retryable_status_codes: set[int] = field(
        default_factory=lambda: {429, 500, 502, 503, 504}
    )

    def get_delay(self, attempt: int) -> float:
        """Calculate delay for the given attempt (0-indexed)."""
        delay = self.base_delay * (2 ** attempt)
        return min(delay, self.max_delay)

    def is_retryable_status(self, status_code: int) -> bool:
        """Check if the given HTTP status code is retryable."""
        return status_code in self.retryable_status_codes


async def with_retry(
    fn: Callable[[], Awaitable[T]],
    policy: RetryPolicy,
) -> T:
    """Execute an async function with exponential backoff retry.

    Retries on exceptions that have a `status_code` attribute matching
    the policy's retryable status codes. The `retryable` attribute on
    the error is also checked -- if False, no retry is attempted.

    Args:
        fn: Async function to execute.
        policy: Retry policy configuration.

    Returns:
        The result of the function call.

    Raises:
        The last exception if all retries are exhausted.
    """
    last_error: Exception | None = None
    for attempt in range(policy.max_retries + 1):
        try:
            return await fn()
        except Exception as e:
            last_error = e
            status_code = getattr(e, "status_code", 0)
            retryable = getattr(e, "retryable", True)

            # Don't retry if not retryable or not a retryable status code
            if not retryable or not policy.is_retryable_status(status_code):
                raise

            # Don't retry if we've exhausted attempts
            if attempt >= policy.max_retries:
                raise

            delay = policy.get_delay(attempt)
            await asyncio.sleep(delay)

    # Should not reach here, but satisfy type checker
    assert last_error is not None
    raise last_error
```

**1f. waiaas/py.typed -- PEP 561 marker file:**

Create an empty `py.typed` marker file so type checkers recognize this as a typed package.

**1g. tests/__init__.py -- empty:**

Empty file.

**1h. tests/conftest.py -- shared fixtures:**

```python
"""Shared pytest fixtures for WAIaaS SDK tests."""

import json
import pytest
import httpx

# Standard response fixtures
AGENT_ID = "01234567-89ab-cdef-0123-456789abcdef"
SESSION_ID = "fedcba98-7654-3210-fedc-ba9876543210"
TX_ID = "aabbccdd-eeff-0011-2233-445566778899"


def make_response(status_code: int, body: dict) -> httpx.Response:
    """Create an httpx.Response from status and body dict."""
    return httpx.Response(
        status_code=status_code,
        json=body,
    )


def mock_transport(handler):
    """Create httpx.MockTransport from a request handler function."""
    return httpx.MockTransport(handler)
```

**1i. tests/test_models.py -- Pydantic model validation (10+ tests):**

Tests covering:
1. WalletBalance from camelCase JSON
2. WalletAddress from camelCase JSON
3. WalletAssets with nested AssetInfo
4. TransactionDetail with null optional fields
5. TransactionList with cursor pagination
6. PendingTransactionList
7. SessionRenewResponse from camelCase JSON
8. SendTokenRequest serialization
9. Invalid data -> ValidationError (missing required field)
10. Invalid data -> ValidationError (wrong type)
11. AssetInfo with optional usd_value

**1j. tests/test_retry.py -- retry logic tests (8+ tests):**

Tests covering:
1. Succeeds on first attempt -> no retry
2. 429 error -> retries and succeeds on second attempt
3. 500 error -> retries with exponential backoff
4. Non-retryable status code (400) -> no retry, raises immediately
5. Non-retryable error (retryable=False) -> no retry
6. Exhausts max_retries -> raises last error
7. Delay calculation (1s, 2s, 4s)
8. Max delay cap

Use `unittest.mock.patch("waiaas.retry.asyncio.sleep")` to mock sleep and verify delay timing without actually waiting. Verify mock_sleep was called with correct increasing delays.

  </action>
  <verify>
Install dev dependencies and run model + retry tests:
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS/python-sdk && pip install -e ".[dev]" && pytest tests/test_models.py tests/test_retry.py -v
```
All tests pass. Verify package structure:
```bash
python -c "from waiaas import WAIaaSClient, WAIaaSError, WalletBalance; print('imports OK')"
```
  </verify>
  <done>
python-sdk/ directory created with pyproject.toml (hatch build, httpx>=0.27, pydantic>=2.0), waiaas package (__init__.py, models.py, errors.py, retry.py, py.typed), and tests for models (10+ tests) and retry (8+ tests). All Pydantic models match the daemon's OpenAPI response schemas with camelCase alias support. WAIaaSError has code/message/status_code/retryable/hint/details attributes. RetryPolicy supports configurable max_retries, base_delay, and retryable status codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: WAIaaSClient implementation + client integration tests</name>
  <files>
    python-sdk/waiaas/client.py
    python-sdk/tests/test_client.py
  </files>
  <action>
**2a. waiaas/client.py -- WAIaaSClient (async httpx):**

```python
"""WAIaaS async HTTP client for AI agent wallet operations."""

from __future__ import annotations
import httpx
from typing import Any, Optional

from waiaas.models import (
    WalletAddress,
    WalletBalance,
    WalletAssets,
    TransactionResponse,
    TransactionDetail,
    TransactionList,
    PendingTransactionList,
    SessionRenewResponse,
    SendTokenRequest,
)
from waiaas.errors import WAIaaSError
from waiaas.retry import RetryPolicy, with_retry


class WAIaaSClient:
    """Async client for WAIaaS daemon REST API.

    Usage:
        async with WAIaaSClient("http://localhost:3000", "wai_sess_xxx") as client:
            balance = await client.get_balance()
            print(balance.balance, balance.symbol)
    """

    def __init__(
        self,
        base_url: str,
        session_token: str,
        *,
        retry_policy: Optional[RetryPolicy] = None,
        timeout: float = 30.0,
        http_client: Optional[httpx.AsyncClient] = None,
    ) -> None:
        self._base_url = base_url.rstrip("/")
        self._session_token = session_token
        self._retry_policy = retry_policy or RetryPolicy()
        self._timeout = timeout
        self._owns_client = http_client is None
        self._client = http_client or httpx.AsyncClient(
            base_url=self._base_url,
            timeout=timeout,
            headers=self._build_headers(),
        )

    def _build_headers(self) -> dict[str, str]:
        return {
            "Authorization": f"Bearer {self._session_token}",
            "Content-Type": "application/json",
        }

    @property
    def session_token(self) -> str:
        return self._session_token

    def set_session_token(self, token: str) -> None:
        """Update the session token for subsequent requests."""
        self._session_token = token
        self._client.headers["Authorization"] = f"Bearer {token}"

    async def __aenter__(self) -> "WAIaaSClient":
        return self

    async def __aexit__(self, *args: Any) -> None:
        await self.close()

    async def close(self) -> None:
        """Close the underlying HTTP client."""
        if self._owns_client:
            await self._client.aclose()

    # -----------------------------------------------------------------
    # Internal HTTP helpers
    # -----------------------------------------------------------------

    async def _request(
        self,
        method: str,
        path: str,
        *,
        json_body: Optional[dict[str, Any]] = None,
        params: Optional[dict[str, Any]] = None,
    ) -> httpx.Response:
        """Make an HTTP request with retry logic."""

        async def _do_request() -> httpx.Response:
            response = await self._client.request(
                method,
                path,
                json=json_body,
                params=params,
            )
            if response.status_code >= 400:
                try:
                    body = response.json()
                except Exception:
                    body = {"code": "UNKNOWN_ERROR", "message": response.text}
                raise WAIaaSError.from_response(response.status_code, body)
            return response

        return await with_retry(_do_request, self._retry_policy)

    # -----------------------------------------------------------------
    # Wallet API
    # -----------------------------------------------------------------

    async def get_address(self) -> WalletAddress:
        """GET /v1/wallet/address -- Get agent wallet address."""
        resp = await self._request("GET", "/v1/wallet/address")
        return WalletAddress.model_validate(resp.json())

    async def get_balance(self) -> WalletBalance:
        """GET /v1/wallet/balance -- Get agent wallet balance."""
        resp = await self._request("GET", "/v1/wallet/balance")
        return WalletBalance.model_validate(resp.json())

    async def get_assets(self) -> WalletAssets:
        """GET /v1/wallet/assets -- Get all assets held by agent wallet."""
        resp = await self._request("GET", "/v1/wallet/assets")
        return WalletAssets.model_validate(resp.json())

    # -----------------------------------------------------------------
    # Transaction API
    # -----------------------------------------------------------------

    async def send_token(
        self,
        to: str,
        amount: str,
        *,
        memo: Optional[str] = None,
    ) -> TransactionResponse:
        """POST /v1/transactions/send -- Send native token transfer.

        Args:
            to: Recipient address.
            amount: Amount in base units (lamports for SOL).
            memo: Optional memo string.

        Returns:
            TransactionResponse with id and status.
        """
        request = SendTokenRequest(to=to, amount=amount, memo=memo)
        body = request.model_dump(exclude_none=True)
        resp = await self._request("POST", "/v1/transactions/send", json_body=body)
        return TransactionResponse.model_validate(resp.json())

    async def get_transaction(self, tx_id: str) -> TransactionDetail:
        """GET /v1/transactions/:id -- Get transaction details."""
        resp = await self._request("GET", f"/v1/transactions/{tx_id}")
        return TransactionDetail.model_validate(resp.json())

    async def list_transactions(
        self,
        *,
        limit: int = 20,
        cursor: Optional[str] = None,
    ) -> TransactionList:
        """GET /v1/transactions -- List transactions with cursor pagination.

        Args:
            limit: Number of transactions per page (1-100, default 20).
            cursor: Cursor for pagination (UUID of last item).

        Returns:
            TransactionList with items, cursor, and has_more.
        """
        params: dict[str, Any] = {"limit": limit}
        if cursor:
            params["cursor"] = cursor
        resp = await self._request("GET", "/v1/transactions", params=params)
        return TransactionList.model_validate(resp.json())

    async def list_pending_transactions(self) -> PendingTransactionList:
        """GET /v1/transactions/pending -- List pending transactions."""
        resp = await self._request("GET", "/v1/transactions/pending")
        return PendingTransactionList.model_validate(resp.json())

    # -----------------------------------------------------------------
    # Session API
    # -----------------------------------------------------------------

    async def renew_session(self, session_id: str) -> SessionRenewResponse:
        """PUT /v1/sessions/:id/renew -- Renew session token.

        After renewal, the client automatically updates its session token.

        Args:
            session_id: Session ID to renew.

        Returns:
            SessionRenewResponse with new token, expiry, and renewal count.
        """
        resp = await self._request("PUT", f"/v1/sessions/{session_id}/renew")
        result = SessionRenewResponse.model_validate(resp.json())
        # Auto-update session token
        self.set_session_token(result.token)
        return result
```

Key design decisions:
- Async context manager for clean resource management
- httpx.AsyncClient with configurable base_url, timeout, headers
- `set_session_token()` for manual token updates
- `renew_session()` auto-updates the token after successful renewal
- All methods return typed Pydantic models
- `_request()` wraps all HTTP calls with retry policy
- Error responses are parsed into WAIaaSError via `from_response()`
- Optional `http_client` parameter allows injecting mock transport in tests
- `SendTokenRequest` Pydantic model validates send_token args before request

**2b. tests/test_client.py -- comprehensive client tests using MockTransport (20+ tests):**

Structure the tests with httpx.MockTransport. For each test, create a handler function that returns canned responses:

```python
def make_handler(responses: dict[tuple[str, str], tuple[int, dict]]):
    """Create a mock handler from a route -> response mapping."""
    def handler(request: httpx.Request) -> httpx.Response:
        key = (request.method, request.url.path)
        if key in responses:
            status, body = responses[key]
            return httpx.Response(status, json=body)
        return httpx.Response(404, json={"code": "NOT_FOUND", "message": "Not found"})
    return handler
```

Test categories:

1. **Wallet methods (4 tests):**
   - get_balance() returns WalletBalance with correct fields
   - get_address() returns WalletAddress with correct fields
   - get_assets() returns WalletAssets with nested AssetInfo list
   - get_assets() with empty assets list

2. **Transaction methods (5 tests):**
   - send_token() sends POST with correct body, returns TransactionResponse
   - send_token() with memo includes memo in body
   - get_transaction() returns TransactionDetail
   - list_transactions() passes limit and cursor params
   - list_pending_transactions() returns PendingTransactionList

3. **Session methods (3 tests):**
   - renew_session() returns SessionRenewResponse
   - renew_session() auto-updates client session token
   - set_session_token() updates Authorization header

4. **Error handling (4 tests):**
   - 401 response -> raises WAIaaSError with code/message/hint
   - 404 response -> raises WAIaaSError with retryable=False
   - Error includes request_id from response
   - Non-JSON error response -> raises WAIaaSError with UNKNOWN_ERROR code

5. **Retry integration (3 tests):**
   - 429 response -> retries and succeeds on next call
   - 500 response -> retries with backoff, succeeds on third attempt
   - Non-retryable 400 error -> no retry, raises immediately

6. **Context manager (2 tests):**
   - async with creates and closes client properly
   - close() is idempotent

For retry tests, use a stateful handler that returns different responses on successive calls:

```python
call_count = 0
def handler(request):
    nonlocal call_count
    call_count += 1
    if call_count < 3:
        return httpx.Response(429, json={"code": "RATE_LIMIT_EXCEEDED", "message": "Too many requests", "retryable": True})
    return httpx.Response(200, json={...})
```

Mock `asyncio.sleep` to avoid actual delays in retry tests:
```python
from unittest.mock import patch, AsyncMock
@patch("waiaas.retry.asyncio.sleep", new_callable=AsyncMock)
async def test_retry_on_429(mock_sleep):
    ...
```

All test clients should be created with a MockTransport injected:
```python
transport = httpx.MockTransport(handler)
http_client = httpx.AsyncClient(transport=transport, base_url="http://test")
client = WAIaaSClient("http://test", "token", http_client=http_client)
```
  </action>
  <verify>
Run all Python SDK tests:
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS/python-sdk && pytest tests/ -v --tb=short
```
All tests pass (30+ tests total across test_models, test_retry, test_client).

Verify the full import chain works:
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS/python-sdk && python -c "
from waiaas import WAIaaSClient, WAIaaSError, WalletBalance, WalletAddress, WalletAssets
from waiaas import TransactionResponse, TransactionDetail, TransactionList
from waiaas import SessionRenewResponse, SendTokenRequest
from waiaas.retry import RetryPolicy
print('All imports successful')
"
```
  </verify>
  <done>
WAIaaSClient fully implemented with: get_balance(), get_address(), get_assets(), send_token(), get_transaction(), list_transactions(), list_pending_transactions(), renew_session(). All methods return typed Pydantic models. Error responses raise WAIaaSError with code/message/status_code/retryable/hint. 429/5xx triggers exponential backoff retry. renew_session() auto-updates session token. 30+ tests pass covering wallet/transaction/session methods, error handling, retry logic, and context manager lifecycle.
  </done>
</task>

</tasks>

<verification>
1. `cd python-sdk && pip install -e ".[dev]"` -- installs without errors
2. `cd python-sdk && pytest tests/ -v` -- 30+ tests pass
3. `python -c "from waiaas import WAIaaSClient, WAIaaSError"` -- imports succeed
4. Pydantic models correctly parse camelCase JSON from daemon API (alias support)
5. WAIaaSError.from_response() correctly maps code/message/status_code/retryable/hint
6. RetryPolicy respects max_retries, base_delay, retryable_status_codes
7. WAIaaSClient.renew_session() auto-updates session token after successful renewal
8. send_token() validates request body via Pydantic before sending
9. 429/500/502/503/504 responses trigger retry; 4xx (non-429) does not retry
10. Existing Node.js test suite (`npx vitest run` from project root) still passes (no regressions)
</verification>

<success_criteria>
- WAIaaSClient initializes with base_url + session_token and calls all 8 API methods
- get_balance/get_address/get_assets return typed Pydantic models with correct field mapping
- send_token() sends TRANSFER request body and returns TransactionResponse
- get_transaction/list_transactions/list_pending_transactions return typed models
- renew_session() returns renewed token and auto-updates client
- Pydantic v2 models validate response data; invalid data raises ValidationError
- WAIaaSError has code, message, status_code, retryable, hint, details attributes
- 429/5xx responses trigger exponential backoff (1s, 2s, 4s, max 3 retries)
- Non-retryable errors raise immediately without retry
- 30+ pytest tests pass covering all methods, errors, retry, and model validation
</success_criteria>

<output>
After completion, create `.planning/phases/62-python-sdk/62-01-SUMMARY.md`
</output>
