---
phase: 51-cli-e2e-integration
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - packages/cli/src/__tests__/e2e-lifecycle.test.ts
  - packages/cli/src/__tests__/e2e-agent-wallet.test.ts
  - packages/cli/src/__tests__/e2e-transaction.test.ts
  - packages/cli/src/__tests__/e2e-errors.test.ts
  - packages/cli/src/__tests__/helpers/daemon-harness.ts
  - packages/cli/vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "E2E lifecycle: init creates directory, start boots daemon, status shows running, stop shuts down cleanly"
    - "E2E agent: POST /v1/agents creates agent, GET /v1/wallet/address returns base58 key, GET /v1/wallet/balance returns balance"
    - "E2E transaction: POST /v1/transactions/send returns 201 with txId, GET /v1/transactions/:id shows status progression"
    - "E2E errors: bad config causes start failure, non-existent agent returns 404, duplicate start returns error"
    - "All 12 E2E test scenarios pass automatically"
  artifacts:
    - path: "packages/cli/src/__tests__/e2e-lifecycle.test.ts"
      provides: "4 lifecycle E2E tests (E-01 to E-04)"
      contains: "describe.*Lifecycle"
    - path: "packages/cli/src/__tests__/e2e-agent-wallet.test.ts"
      provides: "3 agent management E2E tests (E-05 to E-07)"
      contains: "describe.*Agent"
    - path: "packages/cli/src/__tests__/e2e-transaction.test.ts"
      provides: "2 transaction E2E tests (E-08 to E-09)"
      contains: "describe.*Transaction"
    - path: "packages/cli/src/__tests__/e2e-errors.test.ts"
      provides: "3 error handling E2E tests (E-10 to E-12)"
      contains: "describe.*Error"
    - path: "packages/cli/src/__tests__/helpers/daemon-harness.ts"
      provides: "Shared test harness for spawning and managing daemon process"
      contains: "startTestDaemon"
  key_links:
    - from: "packages/cli/src/__tests__/helpers/daemon-harness.ts"
      to: "packages/daemon/src/index.ts"
      via: "import startDaemon or spawn daemon subprocess"
      pattern: "startDaemon|spawn"
    - from: "packages/cli/src/__tests__/e2e-agent-wallet.test.ts"
      to: "packages/daemon/src/api/routes/agents.ts"
      via: "HTTP fetch to POST /v1/agents"
      pattern: "fetch.*v1/agents"
    - from: "packages/cli/src/__tests__/e2e-transaction.test.ts"
      to: "packages/daemon/src/api/routes/transactions.ts"
      via: "HTTP fetch to POST /v1/transactions/send"
      pattern: "fetch.*v1/transactions"
---

<objective>
Implement 12 E2E test scenarios that validate the complete WAIaaS user journey: daemon lifecycle (4), agent management (3), SOL transaction (2), and error handling (3). These tests programmatically start the daemon, interact via HTTP, and verify end-to-end behavior.

Purpose: Prove that all layers (CLI init, daemon lifecycle, API server, SolanaAdapter, pipeline) work together as an integrated system. This is the final validation gate for v1.1.
Output: 12 passing E2E tests in 4 test files + shared daemon harness.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-cli-e2e-integration/51-01-SUMMARY.md
@.planning/phases/50-api-solana-pipeline/50-03-SUMMARY.md
@.planning/phases/50-api-solana-pipeline/50-04-SUMMARY.md

# Key source files
@packages/daemon/src/index.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/routes/agents.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/infrastructure/config/loader.ts
@packages/cli/src/commands/init.ts
@packages/cli/src/commands/start.ts
@objectives/v1.1-core-infrastructure.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Daemon test harness + lifecycle and error E2E tests (7 tests)</name>
  <files>
    packages/cli/src/__tests__/helpers/daemon-harness.ts
    packages/cli/src/__tests__/e2e-lifecycle.test.ts
    packages/cli/src/__tests__/e2e-errors.test.ts
    packages/cli/vitest.config.ts
  </files>
  <action>
    **IMPORTANT:** E2E tests start a real daemon process (in-process, not subprocess) with a real SQLite DB but mock chain adapter. They test the full vertical slice: CLI init -> daemon start -> HTTP API -> database -> shutdown.

    **packages/cli/vitest.config.ts** -- update config:
    ```typescript
    import { defineConfig } from 'vitest/config';

    export default defineConfig({
      test: {
        globals: true,
        passWithNoTests: true,
        testTimeout: 30_000,  // E2E tests need longer timeout
        hookTimeout: 30_000,
        pool: 'forks',  // Isolate tests using forks (sodium-native mprotect compatibility)
      },
    });
    ```

    **packages/cli/src/__tests__/helpers/daemon-harness.ts** -- shared E2E harness:

    Create a `TestDaemonHarness` class:
    ```typescript
    export interface TestDaemonHarness {
      dataDir: string;
      port: number;
      baseUrl: string;
      daemon: DaemonLifecycle;
      cleanup: () => Promise<void>;
    }
    ```

    Functions:
    - `initTestDataDir(): string` -- creates a temp directory (`os.tmpdir() + '/waiaas-e2e-' + randomUUID()`), creates subdirs (data/, keystore/, logs/), writes minimal config.toml with a random available port (find free port: create server on port 0, get assigned port, close server). Returns path.
    - `startTestDaemon(dataDir: string, masterPassword?: string): Promise<TestDaemonHarness>` -- imports `startDaemon` from `@waiaas/daemon`, calls `startDaemon(dataDir, masterPassword ?? 'test-password-12345')`. After start, reads config to get port. Returns harness with daemon instance, port, baseUrl. **Mock SolanaAdapter:** Before starting, set `WAIAAS_RPC_SOLANA_DEVNET` env to empty string or a mock URL to ensure adapter init is fail-soft (adapter=null). Actually, since Step 4 is fail-soft, the daemon will continue even if adapter connection fails -- but we need the adapter for transaction tests. For lifecycle/error tests, let adapter be null (fail-soft).
    - `stopTestDaemon(harness: TestDaemonHarness): Promise<void>` -- calls `harness.daemon.shutdown('TEST')`, removes temp directory recursively.
    - `fetchApi(harness: TestDaemonHarness, path: string, opts?: RequestInit): Promise<Response>` -- `fetch(harness.baseUrl + path, opts)` convenience wrapper.
    - `waitForHealth(harness: TestDaemonHarness, timeoutMs?: number): Promise<void>` -- polls GET /health every 200ms until 200 or timeout.

    **packages/cli/src/__tests__/e2e-lifecycle.test.ts** -- 4 tests (E-01 to E-04):

    ```
    describe('E2E Lifecycle', () => {
      // Shared dataDir per suite
      let dataDir: string;
      let harness: TestDaemonHarness | null = null;

      afterEach(async () => {
        if (harness) await stopTestDaemon(harness);
        harness = null;
        // cleanup dataDir
      });

      test('E-01: init creates data directory, config.toml, and keystore/', async () => {
        // Create temp dir but don't init
        dataDir = path.join(os.tmpdir(), 'waiaas-e2e-' + randomUUID());
        // Call initCommand(dataDir)
        await initCommand(dataDir);
        // Assert: dataDir exists, config.toml exists, keystore/ exists, data/ exists
        expect(existsSync(path.join(dataDir, 'config.toml'))).toBe(true);
        expect(existsSync(path.join(dataDir, 'keystore'))).toBe(true);
        expect(existsSync(path.join(dataDir, 'data'))).toBe(true);
        // Cleanup
        rmSync(dataDir, { recursive: true, force: true });
      });

      test('E-02: start boots daemon, health check returns 200', async () => {
        dataDir = initTestDataDir();
        harness = await startTestDaemon(dataDir);
        await waitForHealth(harness);
        const res = await fetchApi(harness, '/health');
        expect(res.status).toBe(200);
        const body = await res.json();
        expect(body).toHaveProperty('status', 'ok');
      });

      test('E-03: stop shuts down daemon, PID file removed', async () => {
        dataDir = initTestDataDir();
        harness = await startTestDaemon(dataDir);
        await waitForHealth(harness);
        // Verify PID file exists before stop
        expect(existsSync(path.join(dataDir, 'daemon.pid'))).toBe(true);
        await harness.daemon.shutdown('TEST');
        // Verify PID file removed after shutdown
        expect(existsSync(path.join(dataDir, 'daemon.pid'))).toBe(false);
        harness = null; // already stopped
      });

      test('E-04: status shows running (programmatic check)', async () => {
        dataDir = initTestDataDir();
        harness = await startTestDaemon(dataDir);
        await waitForHealth(harness);
        // Verify PID file exists with correct PID
        const pidContent = readFileSync(path.join(dataDir, 'daemon.pid'), 'utf-8');
        expect(parseInt(pidContent)).toBe(process.pid);
        // Health check confirms running
        const res = await fetchApi(harness, '/health');
        expect(res.status).toBe(200);
      });
    });
    ```

    **packages/cli/src/__tests__/e2e-errors.test.ts** -- 3 tests (E-10 to E-12):

    ```
    describe('E2E Error Handling', () => {
      test('E-10: invalid config.toml causes daemon start failure', async () => {
        const dataDir = initTestDataDir();
        // Write invalid config (unknown section)
        writeFileSync(path.join(dataDir, 'config.toml'), '[invalid_section]\nfoo = "bar"');
        await expect(startTestDaemon(dataDir)).rejects.toThrow();
        rmSync(dataDir, { recursive: true, force: true });
      });

      test('E-11: non-existent agent returns 404', async () => {
        const dataDir = initTestDataDir();
        const harness = await startTestDaemon(dataDir);
        await waitForHealth(harness);
        const res = await fetchApi(harness, '/v1/wallet/balance', {
          headers: { 'X-Agent-Id': 'non-existent-agent-id' },
        });
        expect(res.status).toBe(404);
        const body = await res.json();
        expect(body).toHaveProperty('code');
        await stopTestDaemon(harness);
      });

      test('E-12: duplicate daemon start fails with lock error', async () => {
        const dataDir = initTestDataDir();
        const harness = await startTestDaemon(dataDir);
        await waitForHealth(harness);
        // Try to start a second daemon on the same dataDir
        await expect(startTestDaemon(dataDir)).rejects.toThrow(/already running|ELOCKED|SYSTEM_LOCKED/);
        await stopTestDaemon(harness);
      });
    });
    ```

    Run `pnpm test --filter=@waiaas/cli` to verify 7 tests pass.
  </action>
  <verify>
    - `pnpm test --filter=@waiaas/cli` passes all lifecycle and error E2E tests
    - Tests properly clean up temp directories and daemon processes
    - No port conflicts between test runs
  </verify>
  <done>
    7 E2E tests pass: 4 lifecycle (E-01 to E-04) + 3 error handling (E-10 to E-12). Daemon harness enables reliable test daemon spawning with automatic cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Agent/wallet and transaction E2E tests (5 tests)</name>
  <files>
    packages/cli/src/__tests__/e2e-agent-wallet.test.ts
    packages/cli/src/__tests__/e2e-transaction.test.ts
    packages/cli/src/__tests__/helpers/daemon-harness.ts
  </files>
  <action>
    **CRITICAL CONSIDERATION:** Agent and transaction tests require the SolanaAdapter. Since E2E tests run in CI without a real Solana validator, these tests must work with a mocked adapter. Two strategies:

    **Strategy: In-process daemon with mock adapter injection.**
    Extend the daemon harness to support injecting a mock IChainAdapter. Modify `startTestDaemon` to accept an optional `mockAdapter` parameter. When provided, instead of calling the full `startDaemon()`, manually construct DaemonLifecycle steps 1-3, inject the mock adapter for step 4, then complete steps 5-6. Alternatively, since step 4 is fail-soft, start daemon normally (adapter=null), but for agent tests that don't need chain operations, this is fine. For balance/transaction tests, we need a mock.

    **Refined approach:** Use a `MockChainAdapter` implementing IChainAdapter:
    ```typescript
    class MockChainAdapter implements IChainAdapter {
      chainType = 'solana' as const;
      connected = true;
      async connect() {}
      async disconnect() {}
      isConnected() { return true; }
      async getHealth() { return { connected: true, latency: 10, blockHeight: 1000n }; }
      async getBalance(address: string) { return 1_000_000_000n; } // 1 SOL
      async buildTransaction(params: any) { return new Uint8Array(200); }
      async simulateTransaction(tx: Uint8Array) { return { success: true }; }
      async signTransaction(tx: Uint8Array, privateKey: Uint8Array) { return new Uint8Array(200); }
      async submitTransaction(signedTx: Uint8Array) { return 'mock-tx-signature-abc123'; }
      async waitForConfirmation(signature: string) { return { confirmed: true, slot: 12345 }; }
    }
    ```

    Add `startTestDaemonWithMockAdapter(dataDir: string, password?: string): Promise<TestDaemonHarness>` to the harness that:
    1. Creates a DaemonLifecycle instance
    2. Manually runs steps 1-3 (config, DB, keystore) by calling `daemon.start(dataDir, password)` -- but before step 4, override adapter. Actually, DaemonLifecycle doesn't expose adapter injection.

    **Simpler approach:** Modify the harness to start the daemon normally (adapter will be null since no real RPC), and for agent creation tests, just test POST /v1/agents (which doesn't need chain adapter). For balance tests, check that it returns an appropriate error when adapter is null. For transaction tests, also check the error response when adapter is null.

    **REVISED STRATEGY:** Given the existing codebase constraints:
    - Agent creation (E-05): Works without adapter (DB + keystore only)
    - Address lookup (E-06): Works without adapter (DB lookup only)
    - Balance (E-07): Requires adapter -- test that it handles adapter=null gracefully (returns error or 0)
    - Transaction send (E-08): Requires adapter -- test with adapter=null, expect pipeline to fail at stage 5 and record FAILED status
    - Transaction poll (E-09): Test the polling mechanism with a transaction that went to FAILED status

    If the `createApp` conditional route registration means transaction routes aren't registered when adapter is null, then transaction tests need a mock. In that case, extend `startTestDaemon` in the harness to pass a `createApp` call with a mock adapter injected.

    **Implementation:**

    Update `daemon-harness.ts` to add `startTestDaemonWithAdapter`:
    - Import DaemonLifecycle, createDatabase, pushSchema, LocalKeyStore, loadConfig, createApp from @waiaas/daemon
    - Manually perform startup:
      1. loadConfig(dataDir) -> config
      2. createDatabase(dbPath) -> { sqlite, db }
      3. new LocalKeyStore(keystoreDir)
      4. adapter = new MockChainAdapter()
      5. createApp({ db, keyStore, masterPassword, config, adapter, policyEngine: new DefaultPolicyEngine() })
      6. serve({ fetch: app.fetch, hostname, port }) -> httpServer
    - Return harness with cleanup that closes httpServer, sqlite, etc.
    - This is effectively what DaemonLifecycle.start() does, but with mock adapter

    **packages/cli/src/__tests__/e2e-agent-wallet.test.ts** -- 3 tests (E-05 to E-07):

    ```
    describe('E2E Agent Management', () => {
      let harness: TestDaemonHarness;

      beforeAll(async () => {
        const dataDir = initTestDataDir();
        harness = await startTestDaemonWithAdapter(dataDir);
        await waitForHealth(harness);
      });

      afterAll(async () => {
        await stopTestDaemon(harness);
      });

      test('E-05: POST /v1/agents creates agent with Solana address', async () => {
        const res = await fetchApi(harness, '/v1/agents', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: 'test-agent', chain: 'solana', network: 'devnet' }),
        });
        expect(res.status).toBe(201);
        const body = await res.json();
        expect(body).toHaveProperty('id');
        expect(body).toHaveProperty('publicKey');
        expect(body.chain).toBe('solana');
        // Store agentId for subsequent tests
        harness._agentId = body.id;
      });

      test('E-06: GET /v1/wallet/address returns base58 public key', async () => {
        const res = await fetchApi(harness, '/v1/wallet/address', {
          headers: { 'X-Agent-Id': harness._agentId },
        });
        expect(res.status).toBe(200);
        const body = await res.json();
        expect(body).toHaveProperty('address');
        // base58: alphanumeric string, 32-44 chars
        expect(body.address).toMatch(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/);
      });

      test('E-07: GET /v1/wallet/balance returns SOL balance', async () => {
        const res = await fetchApi(harness, '/v1/wallet/balance', {
          headers: { 'X-Agent-Id': harness._agentId },
        });
        expect(res.status).toBe(200);
        const body = await res.json();
        expect(body).toHaveProperty('balance');
        // MockChainAdapter returns 1_000_000_000 (1 SOL in lamports)
        expect(body.balance).toBe('1000000000');
      });
    });
    ```

    **packages/cli/src/__tests__/e2e-transaction.test.ts** -- 2 tests (E-08 to E-09):

    ```
    describe('E2E Transaction', () => {
      let harness: TestDaemonHarness;
      let agentId: string;

      beforeAll(async () => {
        const dataDir = initTestDataDir();
        harness = await startTestDaemonWithAdapter(dataDir);
        await waitForHealth(harness);
        // Create agent first
        const agentRes = await fetchApi(harness, '/v1/agents', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: 'tx-test-agent', chain: 'solana', network: 'devnet' }),
        });
        const agentBody = await agentRes.json();
        agentId = agentBody.id;
      });

      afterAll(async () => {
        await stopTestDaemon(harness);
      });

      test('E-08: POST /v1/transactions/send returns 201 with transaction ID', async () => {
        const res = await fetchApi(harness, '/v1/transactions/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Agent-Id': agentId,
          },
          body: JSON.stringify({
            to: '11111111111111111111111111111112',  // System program address as dummy recipient
            amount: '100000',  // 0.0001 SOL in lamports
          }),
        });
        expect(res.status).toBe(201);
        const body = await res.json();
        expect(body).toHaveProperty('id');
        expect(body).toHaveProperty('status');
        harness._txId = body.id;
      });

      test('E-09: GET /v1/transactions/:id shows status progression (poll to terminal)', async () => {
        // Poll for the transaction to reach a terminal state
        // With MockChainAdapter, it should reach CONFIRMED
        let status = '';
        let attempts = 0;
        const maxAttempts = 30; // 30 * 500ms = 15s max

        while (attempts < maxAttempts) {
          const res = await fetchApi(harness, `/v1/transactions/${harness._txId}`);
          expect(res.status).toBe(200);
          const body = await res.json();
          status = body.status;

          if (status === 'CONFIRMED' || status === 'FAILED' || status === 'CANCELLED') {
            break;
          }

          await new Promise(r => setTimeout(r, 500));
          attempts++;
        }

        // With MockChainAdapter, pipeline should complete successfully
        expect(status).toBe('CONFIRMED');
      });
    });
    ```

    **Note on MockChainAdapter compatibility:** The mock adapter needs to return types compatible with what the pipeline stages expect. Review the pipeline stages.ts to ensure:
    - `buildTransaction` return type matches what stage5Execute passes to simulateTransaction
    - `signTransaction` returns Uint8Array compatible with submitTransaction
    - `waitForConfirmation` returns an object with `confirmed: true`

    If the pipeline stages use specific type shapes, adapt the MockChainAdapter accordingly. Check the actual stage functions in `packages/daemon/src/pipeline/stages.ts` and `packages/daemon/src/api/routes/transactions.ts` for expected parameter/return types.

    The MockChainAdapter.signTransaction needs the private key parameter. Since the pipeline calls `keyStore.decryptPrivateKey()` which returns a sodium guarded buffer, the mock signTransaction should accept Uint8Array and return a Uint8Array. The actual SolanaAdapter.signTransaction uses @solana/kit `createKeyPairFromBytes` -- the mock just returns a dummy signed tx.

    Run `pnpm test --filter=@waiaas/cli` to verify all 12 E2E tests pass.
  </action>
  <verify>
    - `pnpm test --filter=@waiaas/cli` passes all 12 E2E tests
    - `pnpm test` from root passes (all packages)
    - Agent creation produces valid Solana address
    - Transaction flow reaches CONFIRMED status via mock adapter
    - No test pollution between suites (each suite has its own dataDir and port)
  </verify>
  <done>
    5 E2E tests pass: 3 agent/wallet (E-05 to E-07) + 2 transaction (E-08 to E-09). Combined with Task 1's 7 tests, all 12 E2E scenarios from v1.1 objective pass. Total test count: 167 (existing) + ~17 (CLI unit) + 12 (E2E) = ~196.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds across all packages
2. `pnpm test` passes all tests (existing 167 + CLI unit + E2E = ~196 total)
3. `pnpm lint` passes
4. All 12 E2E scenarios verified:
   - E-01: init creates dirs ✓
   - E-02: start boots daemon with health 200 ✓
   - E-03: stop removes PID file ✓
   - E-04: status shows running PID ✓
   - E-05: agent creation returns 201 ✓
   - E-06: address returns base58 ✓
   - E-07: balance returns SOL ✓
   - E-08: transaction send returns 201 ✓
   - E-09: transaction poll reaches CONFIRMED ✓
   - E-10: bad config rejects daemon start ✓
   - E-11: non-existent agent returns 404 ✓
   - E-12: duplicate daemon fails with lock error ✓
</verification>

<success_criteria>
- 12 E2E tests pass automatically without manual intervention
- MockChainAdapter enables full transaction pipeline testing without real Solana RPC
- Each test suite has isolated dataDir and port (no conflicts)
- Test harness properly cleans up daemon processes and temp directories
- Phase 51 success criteria #3 and #4 from ROADMAP.md verified
</success_criteria>

<output>
After completion, create `.planning/phases/51-cli-e2e-integration/51-02-SUMMARY.md`
</output>
