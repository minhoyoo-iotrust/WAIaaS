---
phase: 37-sessionmanager-core-design
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ".planning/deliverables/38-sdk-mcp-interface.md"
  - "objectives/v0.9-session-management-automation.md"
autonomous: true

must_haves:
  truths:
    - "SessionManager 클래스의 getToken/start/dispose 3개 public 메서드와 내부 상태(token, sessionId, expiresAt, expiresIn, renewalCount, maxRenewals, timer, isRenewing, state)가 설계 문서에 정의되어 있다"
    - "토큰 로드 우선순위(파일 > 환경변수)와 jose decodeJwt 기반 JWT payload 디코딩(sid, aid, exp, iat 추출) 절차가 설계 문서에 정의되어 있다"
    - "SessionManagerOptions 인터페이스(baseUrl, dataDir, envToken)와 SessionState 타입('active'|'expired'|'error')이 정의되어 있다"
    - "방어적 JWT 파싱(필수 claim 존재 확인 + exp 범위 검증)이 C-03 pitfall 대응으로 명시되어 있다"
  artifacts:
    - path: ".planning/deliverables/38-sdk-mcp-interface.md"
      provides: "SessionManager 클래스 인터페이스 + 토큰 로드 전략 설계 섹션"
      contains: "SessionManager"
    - path: "objectives/v0.9-session-management-automation.md"
      provides: "SMGR-01, SMGR-03 설계 완료 상태 반영"
      contains: "Phase 37-01"
  key_links:
    - from: "SessionManager.loadToken()"
      to: "@waiaas/core readMcpToken()"
      via: "Phase 36-01에서 확정된 공유 유틸리티 호출"
      pattern: "readMcpToken"
    - from: "SessionManager.loadToken()"
      to: "jose decodeJwt()"
      via: "JWT payload base64url 무검증 디코딩"
      pattern: "decodeJwt"
---

<objective>
38-sdk-mcp-interface.md에 SessionManager 클래스 인터페이스(3개 public 메서드, 9개 내부 상태, SessionManagerOptions, SessionState)와 토큰 로드 전략(파일 > env var 우선순위, jose decodeJwt 디코딩, 방어적 파싱)을 설계 문서 수준으로 정의한다.

Purpose: Phase 37의 첫 번째 플랜으로, SessionManager의 "무엇"(인터페이스)과 "어떻게 시작하는가"(토큰 로드)를 확정하여 Plan 37-02(갱신/실패/reload)의 기반을 제공한다.
Output: 38-sdk-mcp-interface.md에 SessionManager 설계 섹션 추가, v0.9 objectives에 SMGR-01/SMGR-03 완료 반영.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 36 결과 (토큰 파일 인프라 의존)
@.planning/phases/36-토큰-파일-인프라-알림-이벤트/36-01-SUMMARY.md

# SessionManager 관련 설계 원본
@objectives/v0.9-session-management-automation.md
@.planning/phases/37-sessionmanager-core-design/37-RESEARCH.md

# 기존 설계 문서 (수정 대상)
@.planning/deliverables/38-sdk-mcp-interface.md
# 참조 설계 문서
@.planning/deliverables/30-session-token-protocol.md
@.planning/deliverables/53-session-renewal-protocol.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 38-sdk-mcp-interface.md에 SessionManager 인터페이스 + 토큰 로드 설계 섹션 추가</name>
  <files>.planning/deliverables/38-sdk-mcp-interface.md</files>
  <action>
38-sdk-mcp-interface.md의 MCP Server 섹션(현재 `v0.3 확장 계획: MCP Server 내장 토큰 갱신 메커니즘` placeholder가 있는 위치)에 `[v0.9] SessionManager 핵심 설계` 섹션을 추가한다. 기존 placeholder 텍스트를 대체하되, 기존 내용을 삭제하지 않고 확장한다.

추가할 내용 (한글 설계 문서):

**1. SessionManager 클래스 인터페이스 (SMGR-01)**

1-1. 파일 위치: `packages/mcp/src/session-manager.ts`
1-2. SessionManagerOptions 인터페이스:
  - `baseUrl?: string` — 데몬 베이스 URL (기본값: `http://127.0.0.1:3100`)
  - `dataDir?: string` — 데이터 디렉토리 (기본값: `~/.waiaas`)
  - `envToken?: string` — 환경변수 토큰 (WAIAAS_SESSION_TOKEN, 테스트 주입용)

1-3. SessionState 타입: `'active' | 'expired' | 'error'`

1-4. 내부 상태 9개:
  - `token: string` — 현재 유효 JWT (wai_sess_ 접두어 포함)
  - `sessionId: string` — JWT claims의 sid
  - `expiresAt: number` — epoch ms (서버 응답 기준, 드리프트 보정용)
  - `expiresIn: number` — original TTL ms (갱신 스케줄 계산용)
  - `renewalCount: number` — 현재 갱신 횟수 (초기값 0, 첫 갱신 응답에서 업데이트)
  - `maxRenewals: number` — 최대 갱신 횟수 (초기값 Infinity, 첫 갱신 응답에서 업데이트)
  - `timer: NodeJS.Timeout | null` — 갱신 타이머 핸들
  - `isRenewing: boolean` — 갱신 진행 중 플래그 (중복 갱신 방지)
  - `state: SessionState` — 현재 세션 상태

1-5. Public 메서드 3개:
  - `getToken(): string` — 현재 유효 토큰 반환. 모든 tool handler가 이 메서드 사용. 갱신 중에도 현재(구) 토큰 반환, 갱신 완료 후 다음 호출부터 새 토큰.
  - `async start(): Promise<void>` — loadToken() + scheduleRenewal() 호출. 프로세스 시작 시 1회 호출. 데몬 미기동 시 graceful degradation (로컬 JWT exp 기준 동작).
  - `dispose(): void` — clearTimeout(timer) + timer = null. SIGTERM 시 호출. inflight 갱신이 있으면 renewPromise 완료 대기(최대 5초).

1-6. 내부 메서드 5개 (Plan 37-02에서 상세 설계):
  - `private loadToken(): void` — 토큰 로드 + JWT 디코딩 + 내부 상태 설정
  - `private scheduleRenewal(): void` — 갱신 타이머 설정
  - `private async renew(): Promise<void>` — PUT /renew 호출 + 파일 쓰기 + 메모리 교체
  - `private handleRenewalError(error: RenewalError): void` — 5종 에러 분기
  - `async handleUnauthorized(): Promise<boolean>` — lazy 401 reload

1-7. 상수:
  - `RENEWAL_RATIO = 0.6` — TTL의 60% 경과 시점에 갱신
  - `MAX_TIMEOUT_MS = 2_147_483_647` — setTimeout 32-bit 상한 (2^31 - 1)
  - `TOKEN_PREFIX = 'wai_sess_'` — 토큰 접두어

1-8. TypeScript 의사 코드 (설계 문서 수준):
  - constructor, getToken, start, dispose의 구체적 구현 의사 코드 포함
  - MCP SDK(@modelcontextprotocol/sdk)와 완전 독립 — Composition 패턴

**2. 토큰 로드 전략 (SMGR-03)**

2-1. loadToken() 메서드 설계:
  - Step 1: `readMcpToken(this.tokenFilePath)` 호출 (Phase 36-01 확정 유틸리티)
  - Step 2: 파일 없으면 `process.env.WAIAAS_SESSION_TOKEN ?? null` fallback
  - Step 3: 둘 다 없으면 `Error('[waiaas-mcp] No session token found')` throw
  - Step 4: `wai_sess_` 접두어 제거 후 `jose decodeJwt(jwt)` 호출
  - Step 5: 필수 claim 추출 — `sid` (string), `exp` (number, epoch seconds), `iat` (number, epoch seconds)
  - Step 6: 방어적 범위 검증 (C-03 대응) — exp가 과거 10년~미래 1년 범위 내인지 확인
  - Step 7: 만료 확인 — `exp <= Math.floor(Date.now() / 1000)` 이면 state = 'expired' + throw
  - Step 8: 내부 상태 설정 — token, sessionId, expiresAt(exp*1000), expiresIn((exp-iat)*1000), state='active'

2-2. TypeScript 의사 코드 포함 (37-RESEARCH.md Pattern 2 참조)

2-3. 에러 케이스 3종:
  - 토큰 미존재: `Error('[waiaas-mcp] No session token found')`
  - JWT 파싱 실패: `Error('[waiaas-mcp] Invalid JWT: missing sid/exp/iat')`
  - 토큰 만료: `Error('[waiaas-mcp] Token expired: {iso8601}')` + state='expired'

2-4. 로그 출력 (console.error 기반):
  - 파일 로드 성공: `[waiaas-mcp] Token loaded from file (expires: {iso8601})`
  - 환경변수 fallback: `[waiaas-mcp] Token loaded from WAIAAS_SESSION_TOKEN env var`
  - 만료 경고: `[waiaas-mcp] Token expired at {iso8601}. Waiting for external refresh.`

[v0.9] 태그를 모든 추가 항목에 표기한다.
  </action>
  <verify>
38-sdk-mcp-interface.md에서 다음을 확인:
1. `SessionManager` 클래스 정의 섹션이 존재한다
2. `getToken`, `start`, `dispose` 3개 public 메서드가 정의되어 있다
3. 내부 상태 9개(token, sessionId, expiresAt, expiresIn, renewalCount, maxRenewals, timer, isRenewing, state)가 명시되어 있다
4. `loadToken()` 메서드의 8-step 절차가 정의되어 있다
5. 토큰 로드 우선순위(파일 > env var)가 명시되어 있다
6. `jose decodeJwt` 사용이 명시되어 있다
7. 방어적 범위 검증(C-03)이 포함되어 있다
8. `[v0.9]` 태그가 추가 항목에 표기되어 있다
  </verify>
  <done>SessionManager 클래스 인터페이스(3 public + 5 internal 메서드, 9개 내부 상태, SessionManagerOptions, SessionState)와 loadToken() 8-step 토큰 로드 전략이 38-sdk-mcp-interface.md에 설계 문서 수준으로 정의됨</done>
</task>

<task type="auto">
  <name>Task 2: v0.9 objectives에 SMGR-01, SMGR-03 설계 완료 반영</name>
  <files>objectives/v0.9-session-management-automation.md</files>
  <action>
v0.9 objectives 문서에 Phase 37-01 설계 결과를 반영한다:

1. 섹션 1.2 (SessionManager 인터페이스)에 `[설계 확정 -- Phase 37-01, 상세: 38-sdk-mcp-interface.md 섹션 N]` 태그 추가
2. 섹션 1.3 (토큰 로드 전략)에 `[설계 확정 -- Phase 37-01, 상세: 38-sdk-mcp-interface.md 섹션 N]` 태그 추가
3. "영향받는 설계 문서" 테이블의 MCP-01 행에 `[설계 완료: Phase 37-01]` 표시
4. 문서 하단에 "Phase 37-01 설계 결과" 섹션 추가:
   - 핵심 설계 결정 요약:
     - SM-01: SessionManager 단일 클래스, MCP SDK 독립 (Composition 패턴)
     - SM-02: getToken/start/dispose 3개 public 메서드
     - SM-03: 내부 상태 9개 (token, sessionId, expiresAt, expiresIn, renewalCount, maxRenewals, timer, isRenewing, state)
     - SM-04: 토큰 로드 우선순위 파일 > env var
     - SM-05: jose decodeJwt 기반 무검증 디코딩 + 방어적 범위 검증 (C-03 대응)
     - SM-06: renewalCount/maxRenewals 초기값 0/Infinity, 첫 갱신 응답에서 업데이트
     - SM-07: 데몬 미기동 시 graceful degradation (로컬 JWT exp 기준 동작)
   - 설계 문서 위치: 38-sdk-mcp-interface.md 섹션 참조
5. 문서 푸터의 최종 업데이트 날짜 갱신
  </action>
  <verify>
objectives/v0.9-session-management-automation.md에서:
1. 섹션 1.2와 1.3에 `[설계 확정]` 태그가 추가되어 있다
2. Phase 37-01 설계 결과 섹션이 존재한다
3. SM-01~SM-07 핵심 설계 결정이 나열되어 있다
  </verify>
  <done>v0.9 objectives에 SMGR-01(SessionManager 인터페이스), SMGR-03(토큰 로드 우선순위) 설계 완료 상태가 반영됨</done>
</task>

</tasks>

<verification>
Phase 37-01 전체 검증:
1. grep -c "SessionManager" .planning/deliverables/38-sdk-mcp-interface.md — SessionManager 언급 횟수 확인
2. grep "getToken\|start\|dispose" .planning/deliverables/38-sdk-mcp-interface.md — 3개 public 메서드 존재 확인
3. grep "loadToken" .planning/deliverables/38-sdk-mcp-interface.md — loadToken 메서드 절차 존재 확인
4. grep "decodeJwt" .planning/deliverables/38-sdk-mcp-interface.md — jose 사용 명시 확인
5. grep "readMcpToken" .planning/deliverables/38-sdk-mcp-interface.md — Phase 36 유틸리티 연결 확인
6. grep "\[v0.9\]" .planning/deliverables/38-sdk-mcp-interface.md — v0.9 태그 존재 확인
7. grep "Phase 37-01" objectives/v0.9-session-management-automation.md — 설계 결과 반영 확인
</verification>

<success_criteria>
- SessionManager 클래스 인터페이스가 구현 가능한 수준의 명세로 38-sdk-mcp-interface.md에 정의됨
- 토큰 로드 8-step 절차가 각 단계별 에러 처리와 함께 정의됨
- Phase 36의 readMcpToken/writeMcpToken/getMcpTokenPath와의 연결이 명시됨
- v0.9 objectives에 SMGR-01, SMGR-03 설계 완료가 반영됨
</success_criteria>

<output>
After completion, create `.planning/phases/37-sessionmanager-core-design/37-01-SUMMARY.md`
</output>
