---
phase: 37-sessionmanager-core-design
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - ".planning/deliverables/38-sdk-mcp-interface.md"
  - "objectives/v0.9-session-management-automation.md"
autonomous: true

must_haves:
  truths:
    - "자동 갱신 스케줄(60% TTL 경과 시점, safeSetTimeout 래퍼, 서버 응답 기반 드리프트 보정)이 설계 문서에 정의되어 있다"
    - "5종 갱신 실패 에러(RENEWAL_TOO_EARLY/LIMIT_REACHED/LIFETIME_EXCEEDED/NETWORK_ERROR/TOKEN_EXPIRED) 각각의 대응 전략(재시도 횟수, 상태 전이)이 정의되어 있다"
    - "Lazy 401 reload(파일 재로드, 토큰 비교, 교체+스케줄재설정 또는 에러상태) 메커니즘이 정의되어 있다"
    - "safeSetTimeout 래퍼 함수(MAX_TIMEOUT_MS 체이닝, 32-bit overflow 방지)가 C-01 pitfall 대응으로 명시되어 있다"
    - "갱신 실행 시 파일-우선 쓰기 순서(writeMcpToken -> 메모리 교체)가 H-02 pitfall 대응으로 명시되어 있다"
  artifacts:
    - path: ".planning/deliverables/38-sdk-mcp-interface.md"
      provides: "자동 갱신 스케줄 + 실패 처리 + lazy reload 설계 섹션"
      contains: "scheduleRenewal"
    - path: "objectives/v0.9-session-management-automation.md"
      provides: "SMGR-04, SMGR-05, SMGR-06 설계 완료 상태 반영"
      contains: "Phase 37-02"
  key_links:
    - from: "SessionManager.renew()"
      to: "PUT /v1/sessions/:id/renew"
      via: "fetch 호출로 데몬 갱신 API 사용"
      pattern: "renew"
    - from: "SessionManager.renew()"
      to: "@waiaas/core writeMcpToken()"
      via: "갱신 성공 시 파일 먼저 쓰기 (H-02 방어)"
      pattern: "writeMcpToken"
    - from: "SessionManager.handleUnauthorized()"
      to: "@waiaas/core readMcpToken()"
      via: "401 시 파일 재로드로 외부 갱신 감지"
      pattern: "readMcpToken"
    - from: "SessionManager.scheduleRenewal()"
      to: "safeSetTimeout()"
      via: "32-bit overflow 방지 래퍼 (C-01 대응)"
      pattern: "safeSetTimeout"
---

<objective>
38-sdk-mcp-interface.md에 자동 갱신 스케줄(scheduleRenewal + safeSetTimeout + 드리프트 보정), 갱신 실행(renew + 파일-우선 쓰기), 5종 갱신 실패 대응(handleRenewalError + retryRenewal), lazy 401 reload(handleUnauthorized)를 설계 문서 수준으로 정의한다.

Purpose: Plan 37-01에서 확정된 SessionManager 인터페이스 위에 "어떻게 갱신하고, 실패하면 어떻게 복구하는가"를 구현 가능한 수준으로 완성한다. 이 플랜 완료 시 Phase 37의 5개 success criteria가 모두 충족된다.
Output: 38-sdk-mcp-interface.md에 갱신/실패/reload 설계 섹션 추가, v0.9 objectives에 SMGR-04/SMGR-05/SMGR-06 완료 반영.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 37-01 결과 (SessionManager 인터페이스 의존)
@.planning/phases/37-sessionmanager-core-design/37-01-SUMMARY.md

# Phase 36 결과 (토큰 파일 인프라 의존)
@.planning/phases/36-토큰-파일-인프라-알림-이벤트/36-01-SUMMARY.md
@.planning/phases/36-토큰-파일-인프라-알림-이벤트/36-02-SUMMARY.md

# Research
@.planning/phases/37-sessionmanager-core-design/37-RESEARCH.md

# 기존 설계 문서 (수정 대상 -- Plan 37-01에서 SessionManager 섹션 추가됨)
@.planning/deliverables/38-sdk-mcp-interface.md
# 참조 설계 문서
@.planning/deliverables/53-session-renewal-protocol.md
@.planning/deliverables/35-notification-architecture.md
@objectives/v0.9-session-management-automation.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 38-sdk-mcp-interface.md에 자동 갱신 + 실패 처리 + lazy reload 설계 추가</name>
  <files>.planning/deliverables/38-sdk-mcp-interface.md</files>
  <action>
Plan 37-01에서 추가된 SessionManager 설계 섹션에 이어서, 자동 갱신/실패 처리/lazy reload 설계를 추가한다.

추가할 내용 (한글 설계 문서):

**3. safeSetTimeout 래퍼 (C-01 Pitfall 대응) [v0.9]**

3-1. 문제: `setTimeout`에 2,147,483,647ms(약 24.85일) 초과 딜레이를 전달하면 즉시 실행됨. 기본 7일 TTL의 60%=4.2일은 안전하지만, config.toml에서 expiresIn을 42일 이상 설정 시 오버플로우 발생.

3-2. safeSetTimeout 함수 명세:
```typescript
const MAX_TIMEOUT_MS = 2_147_483_647  // 2^31 - 1

function safeSetTimeout(callback: () => void, delayMs: number): NodeJS.Timeout {
  if (delayMs > MAX_TIMEOUT_MS) {
    return setTimeout(() => {
      safeSetTimeout(callback, delayMs - MAX_TIMEOUT_MS)
    }, MAX_TIMEOUT_MS)
  }
  return setTimeout(callback, Math.max(delayMs, 0))
}
```

3-3. 사용 위치: scheduleRenewal(), handleRenewalError(), retryRenewal()
3-4. 파일 위치: `packages/mcp/src/session-manager.ts` 내 모듈 스코프 함수

**4. 자동 갱신 스케줄 (SMGR-04) [v0.9]**

4-1. scheduleRenewal() 메서드 설계:
  - Step 1: 기존 타이머 해제 (`if (this.timer) clearTimeout(this.timer)`)
  - Step 2: 절대 시간 기준 갱신 시점 계산 (드리프트 보정)
    - `renewAtMs = this.expiresAt - (this.expiresIn * (1 - RENEWAL_RATIO))`
    - `delayMs = Math.max(renewAtMs - Date.now(), 0)`
  - Step 3: delayMs === 0이면 즉시 갱신 (`setImmediate(() => this.renew())`)
  - Step 4: `this.timer = safeSetTimeout(() => this.renew(), delayMs)`
  - Step 5: `this.timer.unref()` — 프로세스 종료를 막지 않음

4-2. 드리프트 보정 원리:
  - 갱신 성공 시 서버 응답의 `expiresAt`을 기준으로 다음 갱신 시점을 재계산
  - 로컬 상대 시간 대신 서버-클라이언트 간 절대 시간 동기화 효과
  - 매 갱신마다 누적 드리프트가 0으로 리셋 (self-correcting timer)
  - 응답 전송 지연(수십 ms)은 무시 가능 (ms 단위 vs 시간 단위 갱신 주기)

4-3. 50% 규칙과의 관계:
  - 서버 측 safety guard: 잔여 50% 이하에서만 갱신 허용 (53-session-renewal-protocol.md)
  - SessionManager: 60% 경과(= 잔여 40%)에 시도 → safety guard 범위 내

4-4. 갱신 주기 예시 테이블:
  | TTL | 갱신 시점 | 잔여 시간 | delayMs | safeSetTimeout 필요 |
  |-----|----------|----------|---------|-------------------|
  | 1시간 | 36분 후 | 24분 | 2,160,000ms | 아니오 |
  | 7일 | 4.2일 후 | 2.8일 | 362,880,000ms | 아니오 |
  | 30일 | 18일 후 | 12일 | 1,555,200,000ms | 아니오 |
  | 42일+ | 25.2일+ 후 | 16.8일+ | 2,177,280,000ms+ | 예 (체이닝) |

**5. 갱신 실행 (renew 메서드) [v0.9]**

5-1. renew() 메서드 설계:
  - Step 1: 중복 갱신 방지 (`if (this.isRenewing) return`)
  - Step 2: `this.isRenewing = true`
  - Step 3: PUT /v1/sessions/{sessionId}/renew 호출
    - Headers: `Authorization: Bearer {this.token}`
    - 메서드: PUT
  - Step 4 (200 OK 성공):
    - 응답 파싱: `{ token, expiresAt, renewalCount, maxRenewals }`
    - **파일 먼저 쓰기 (H-02 방어)**: `await writeMcpToken(this.tokenFilePath, data.token)`
    - 메모리 교체: `this.token = data.token`, `this.expiresAt = new Date(data.expiresAt).getTime()`
    - 갱신 카운터 업데이트: `this.renewalCount = data.renewalCount`, `this.maxRenewals = data.maxRenewals`
    - expiresIn 재계산 (드리프트 보정): `this.expiresIn = this.expiresAt - Date.now()`
    - 다음 갱신 스케줄: `this.scheduleRenewal()`
  - Step 5 (에러 응답): `this.handleRenewalError({ status, code })`
  - Step 6 (네트워크 에러): `this.handleRenewalError({ status: 0, code: 'NETWORK_ERROR' })`
  - Step 7 (finally): `this.isRenewing = false`

5-2. 파일-우선 쓰기 순서 (H-02 Pitfall 대응):
  - 순서: writeMcpToken(파일) → 메모리 교체
  - 근거: SIGTERM이 메모리 교체 전에 오면 파일에 새 토큰이 이미 저장됨 → 프로세스 재시작 시 파일에서 유효 토큰 복원 가능
  - 역순(메모리 먼저)이면: SIGTERM 시 새 토큰 유실, 데몬 DB에서 구 token_hash 이미 교체 → 영구 인증 실패

5-3. 갱신 중 tool 호출 동시성 (Pitfall 5 대응):
  - getToken()은 항상 현재 this.token 반환 (갱신 중이면 구 토큰)
  - 갱신 API 자체가 구 토큰의 sessionAuth를 사용하므로 inflight 호출과 동일 토큰
  - 갱신 완료(메모리 교체) 후 다음 getToken() 호출부터 새 토큰

5-4. 로그:
  - 갱신 시도: `[waiaas-mcp] Renewing session {sessionId} (count: {renewalCount}/{maxRenewals})`
  - 갱신 성공: `[waiaas-mcp] Session renewed. Next renewal in {minutes}m`
  - 갱신 실패: `[waiaas-mcp] Renewal failed: {code} (HTTP {status})`

**6. 5종 갱신 실패 대응 (SMGR-05) [v0.9]**

6-1. RenewalError 인터페이스: `{ status: number, code: string }`

6-2. handleRenewalError 분기 테이블:

| 에러 코드 | HTTP 상태 | 대응 전략 | 재시도 | 상태 전이 | 알림 |
|-----------|----------|----------|--------|----------|------|
| RENEWAL_TOO_EARLY | 400 | 30초 후 1회 재시도 (서버 시간 차이 보정) | 1회 | 유지 (active) | 없음 |
| RENEWAL_LIMIT_REACHED | 403 | 갱신 포기, 현재 토큰으로 만료까지 사용 | 없음 | 유지 (active) | 데몬이 SESSION_EXPIRING_SOON 자동 발송 (NOTI-01) |
| SESSION_ABSOLUTE_LIFETIME_EXCEEDED | 403 | 갱신 포기, 현재 토큰으로 만료까지 사용 | 없음 | 유지 (active) | 데몬이 SESSION_EXPIRING_SOON 자동 발송 (NOTI-01) |
| NETWORK_ERROR | 0 (fetch 실패) | 60초 후 재시도, 최대 3회 | 최대 3회 | 3회 실패 시 error | 없음 (일시적) |
| AUTH_TOKEN_EXPIRED 등 401 | 401 | handleUnauthorized() 호출 (lazy reload) | 조건부 | 조건부 (expired/active) | 없음 |

6-3. retryRenewal(delayMs, maxRetries, attempt) 메서드:
  - attempt >= maxRetries → state = 'error' + 로그
  - else → safeSetTimeout(() => renew()) + timer.unref()
  - 재시도 시 renew() catch에서 retryRenewal(attempt + 1)

6-4. RENEWAL_TOO_EARLY 재시도:
  - 원인: 서버-클라이언트 시간 차이로 60% 미달
  - 30초 대기 후 1회만 재시도 (무한 루프 방지)
  - 2회째도 TOO_EARLY면 다음 정규 스케줄까지 대기

6-5. RENEWAL_LIMIT_REACHED / LIFETIME_EXCEEDED:
  - 갱신 스케줄 중단 (타이머 설정 없음)
  - 현재 토큰으로 잔여 TTL만큼 사용
  - SESSION_EXPIRING_SOON 알림은 데몬이 자동 처리 (Phase 36-02 설계, NOTI-01)
  - MCP SessionManager는 알림을 직접 발송하지 않음

6-6. NETWORK_ERROR 재시도:
  - 데몬 프로세스 미응답 또는 네트워크 단절
  - 60초 간격, 최대 3회
  - 3회 실패 → state = 'error'
  - error 상태에서도 getToken()은 현재 토큰 반환 (유효 기간 내라면 사용 가능)

**7. Lazy 401 Reload (SMGR-06) [v0.9]**

7-1. handleUnauthorized() 메서드 설계:
  - Step 1: `readMcpToken(this.tokenFilePath)` 파일 재로드
  - Step 2: 파일 없음 → `this.state = 'error'`, return false
  - Step 3: 파일 토큰 === 현재 토큰 → `this.state = 'expired'`, return false (진짜 만료)
  - Step 4: 파일 토큰 !== 현재 토큰 → 외부 갱신 감지 (Telegram/CLI가 새 토큰 파일 작성)
    - 새 토큰 JWT 디코딩 (loadToken과 동일 절차)
    - 내부 상태 교체 (token, sessionId, expiresAt, expiresIn)
    - `this.state = 'active'`
    - `this.scheduleRenewal()` 갱신 스케줄 재설정
    - return true (재시도 가능)

7-2. 호출 시점:
  - tool handler의 API 호출이 401을 반환할 때 (Phase 38에서 상세 통합 설계)
  - handleRenewalError에서 401 수신 시

7-3. 외부 갱신 시나리오:
  - CLI `waiaas mcp refresh-token` 실행 → 새 세션 생성 → mcp-token 파일 교체
  - Telegram `/newsession` 실행 → 새 세션 생성 → mcp-token 파일 교체
  - SessionManager의 현재 토큰은 구 세션 → 401 수신 → 파일 재로드 → 새 토큰 감지 → 교체

7-4. 로그:
  - 파일 재로드 시도: `[waiaas-mcp] 401 received. Reloading token from file...`
  - 새 토큰 감지: `[waiaas-mcp] New token detected from file. Switching session.`
  - 진짜 만료: `[waiaas-mcp] Token in file is same as current. Session truly expired.`
  - 파일 없음: `[waiaas-mcp] Token file not found. Entering error state.`

[v0.9] 태그를 모든 추가 항목에 표기한다.
  </action>
  <verify>
38-sdk-mcp-interface.md에서 다음을 확인:
1. `safeSetTimeout` 래퍼 함수 명세가 존재한다
2. `scheduleRenewal()` 메서드의 절대 시간 기준 계산과 드리프트 보정이 정의되어 있다
3. `renew()` 메서드의 파일-우선 쓰기 순서가 명시되어 있다
4. 5종 에러 대응 테이블이 존재하고 각각의 재시도 횟수/상태 전이가 정의되어 있다
5. `handleUnauthorized()` 메서드의 4-step 절차가 정의되어 있다
6. `[v0.9]` 태그가 추가 항목에 표기되어 있다
7. writeMcpToken/readMcpToken 참조가 Phase 36과 연결되어 있다
  </verify>
  <done>자동 갱신 스케줄(scheduleRenewal + safeSetTimeout + 드리프트 보정), 갱신 실행(renew + 파일-우선 쓰기), 5종 갱신 실패 대응(handleRenewalError), lazy 401 reload(handleUnauthorized)가 38-sdk-mcp-interface.md에 설계 문서 수준으로 정의됨</done>
</task>

<task type="auto">
  <name>Task 2: v0.9 objectives에 SMGR-04, SMGR-05, SMGR-06 설계 완료 반영</name>
  <files>objectives/v0.9-session-management-automation.md</files>
  <action>
v0.9 objectives 문서에 Phase 37-02 설계 결과를 반영한다:

1. 섹션 1.4 (자동 갱신 스케줄)에 `[설계 확정 -- Phase 37-02, 상세: 38-sdk-mcp-interface.md 섹션 N]` 태그 추가
2. 섹션 1.5 (갱신 실패 처리)에 `[설계 확정 -- Phase 37-02, 상세: 38-sdk-mcp-interface.md 섹션 N]` 태그 추가
3. 섹션 1.6 (갱신 성공 시 처리)에 `[설계 확정 -- Phase 37-02]` 태그 추가
4. 문서 하단에 "Phase 37-02 설계 결과" 섹션 추가:
   - 핵심 설계 결정 요약:
     - SM-08: safeSetTimeout 래퍼로 32-bit overflow 방어 (C-01)
     - SM-09: 서버 응답 expiresAt 기준 절대 시간 갱신 스케줄 (self-correcting timer, H-01 대응)
     - SM-10: 파일-우선 쓰기 순서 (writeMcpToken → 메모리 교체, H-02 대응)
     - SM-11: 5종 에러 분기 (TOO_EARLY 30초x1, LIMIT 포기, LIFETIME 포기, NETWORK 60초x3, EXPIRED lazy reload)
     - SM-12: handleUnauthorized 4-step (파일 재로드 → 비교 → 교체/에러)
     - SM-13: MCP SessionManager는 알림 직접 발송하지 않음 (데몬 자동, NOTI-01)
     - SM-14: 갱신 중 getToken()은 구 토큰 반환 (동시성 안전)
   - 설계 문서 위치: 38-sdk-mcp-interface.md 섹션 참조
   - Pitfall 대응 요약: C-01(safeSetTimeout), H-01(drift correction), H-02(file-first write), C-03(defensive parsing, Plan 37-01), Pitfall 5(concurrency)
5. 문서 푸터의 최종 업데이트 날짜 갱신
  </action>
  <verify>
objectives/v0.9-session-management-automation.md에서:
1. 섹션 1.4, 1.5, 1.6에 `[설계 확정]` 태그가 추가되어 있다
2. Phase 37-02 설계 결과 섹션이 존재한다
3. SM-08~SM-14 핵심 설계 결정이 나열되어 있다
4. Pitfall 대응 5건이 명시되어 있다
  </verify>
  <done>v0.9 objectives에 SMGR-04(자동 갱신 스케줄), SMGR-05(5종 실패 처리), SMGR-06(lazy 401 reload) 설계 완료 상태가 반영됨</done>
</task>

</tasks>

<verification>
Phase 37-02 전체 검증:
1. grep "safeSetTimeout" .planning/deliverables/38-sdk-mcp-interface.md — safeSetTimeout 래퍼 존재 확인
2. grep "scheduleRenewal" .planning/deliverables/38-sdk-mcp-interface.md — 갱신 스케줄 존재 확인
3. grep "RENEWAL_TOO_EARLY\|RENEWAL_LIMIT_REACHED\|LIFETIME_EXCEEDED\|NETWORK_ERROR\|TOKEN_EXPIRED" .planning/deliverables/38-sdk-mcp-interface.md — 5종 에러 모두 존재 확인
4. grep "handleUnauthorized" .planning/deliverables/38-sdk-mcp-interface.md — lazy reload 존재 확인
5. grep "writeMcpToken" .planning/deliverables/38-sdk-mcp-interface.md — 파일-우선 쓰기 존재 확인
6. grep "H-02\|파일.*먼저\|file.*first" .planning/deliverables/38-sdk-mcp-interface.md — 파일-우선 쓰기 순서 명시 확인
7. grep "Phase 37-02" objectives/v0.9-session-management-automation.md — 설계 결과 반영 확인

Phase 37 전체 Success Criteria 검증 (5개):
SC-1: SessionManager 클래스의 getToken/start/dispose + 내부 상태 → Plan 37-01
SC-2: 토큰 로드 우선순위 + JWT 디코딩 절차 → Plan 37-01
SC-3: 자동 갱신 스케줄(60% TTL, safeSetTimeout, 드리프트 보정) → Plan 37-02 섹션 4
SC-4: 5종 갱신 실패 에러 대응 전략 → Plan 37-02 섹션 6
SC-5: Lazy 401 reload 메커니즘 → Plan 37-02 섹션 7
</verification>

<success_criteria>
- 자동 갱신 스케줄이 구현 가능한 수준의 명세(절대 시간 계산, safeSetTimeout, unref, 드리프트 보정)로 정의됨
- 5종 갱신 실패 에러 각각의 재시도 횟수, 상태 전이, 알림 관계가 테이블로 정의됨
- renew() 메서드의 파일-우선 쓰기 순서가 H-02 pitfall 근거와 함께 명시됨
- lazy 401 reload의 4-step 절차(파일 재로드 → 비교 → 교체/에러)가 정의됨
- Phase 36의 readMcpToken/writeMcpToken 및 SESSION_EXPIRING_SOON 알림과의 연결이 명시됨
- v0.9 objectives에 SMGR-04, SMGR-05, SMGR-06 설계 완료가 반영됨
</success_criteria>

<output>
After completion, create `.planning/phases/37-sessionmanager-core-design/37-02-SUMMARY.md`
</output>
