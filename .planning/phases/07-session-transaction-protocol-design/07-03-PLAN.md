---
phase: 07-session-transaction-protocol-design
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - .planning/deliverables/32-transaction-pipeline-api.md
autonomous: true

must_haves:
  truths:
    - "거래 처리 파이프라인 6단계가 상태 전이 다이어그램 + 시퀀스 다이어그램으로 문서화됨"
    - "각 파이프라인 단계의 입력/출력/에러/DB 상태 변경이 코드 수준으로 정의됨"
    - "세션 API 엔드포인트(POST/GET/DELETE /v1/sessions + GET /v1/auth/nonce)가 Zod 요청/응답 스키마로 설계됨"
    - "거래 API 엔드포인트(POST /v1/transactions/send, GET /v1/transactions, GET /v1/transactions/pending)가 Zod 요청/응답 스키마로 설계됨"
    - "지갑 API 엔드포인트(GET /v1/wallet/balance, GET /v1/wallet/address)가 Zod 요청/응답 스키마로 설계됨"
    - "트랜잭션 상태 전이(PENDING -> QUEUED -> EXECUTING -> SUBMITTED -> CONFIRMED/FAILED/CANCELLED/EXPIRED)가 허용 전이 매트릭스로 정의됨"
  artifacts:
    - path: ".planning/deliverables/32-transaction-pipeline-api.md"
      provides: "거래 처리 파이프라인 6단계 설계 + 세션/거래/지갑 API 엔드포인트 전체 스펙"
      contains: "TransferRequestSchema"
  key_links:
    - from: "32-transaction-pipeline-api.md"
      to: "30-session-token-protocol.md"
      via: "파이프라인 Stage 2 (Session Validate)에서 세션 제약 검증 함수 참조"
      pattern: "validateSessionConstraints"
    - from: "32-transaction-pipeline-api.md"
      to: "31-solana-adapter-detail.md"
      via: "파이프라인 Stage 5 (Execute)에서 SolanaAdapter 4단계 메서드 호출"
      pattern: "adapter\\.buildTransaction"
    - from: "32-transaction-pipeline-api.md"
      to: "25-sqlite-schema.md"
      via: "transactions 테이블 상태 전이 + sessions.usageStats 갱신"
      pattern: "transactions.*status"
    - from: "32-transaction-pipeline-api.md"
      to: "29-api-framework-design.md"
      via: "CORE-06 라우트 구조의 Phase 7 엔드포인트를 Zod 스키마로 구체화"
      pattern: "/v1/sessions|/v1/transactions|/v1/wallet"
---

<objective>
거래 처리 파이프라인 6단계를 상세 설계하고, 세션/거래/지갑 API 엔드포인트를 Zod 요청/응답 스키마 수준으로 설계한다 -- 파이프라인 상태 전이, 각 단계의 입력/출력/에러/DB 변경, 트랜잭션 상태 머신, 그리고 CORE-06에서 정의된 8개 엔드포인트(#3~#10)의 완전한 API 스펙을 정의한다.

Purpose: 파이프라인은 에이전트의 거래 요청이 온체인 확정까지 가는 전체 흐름을 정의하며, API 스펙은 에이전트/SDK/MCP가 데몬과 상호작용하는 인터페이스를 확정한다. 07-01의 세션 인증과 07-02의 Solana 어댑터를 파이프라인의 Validate/Execute 단계에서 통합한다.
Output: 설계 문서 1개 -- 32-transaction-pipeline-api.md (API-02, API-03, API-04 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-session-transaction-protocol-design/07-RESEARCH.md

# 07-01, 07-02 SUMMARY 참조 (직접 의존)
@.planning/phases/07-session-transaction-protocol-design/07-01-SUMMARY.md
@.planning/phases/07-session-transaction-protocol-design/07-02-SUMMARY.md

# Phase 6 참조
@.planning/deliverables/25-sqlite-schema.md (CORE-02: transactions 테이블, sessions 테이블, audit_log 테이블)
@.planning/deliverables/27-chain-adapter-interface.md (CORE-04: IChainAdapter 4단계 tx, 공통 타입)
@.planning/deliverables/29-api-framework-design.md (CORE-06: 라우트 구조 #3~#10, 에러 포맷, Zod SSoT 패턴)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 거래 처리 파이프라인 6단계 상세 설계</name>
  <files>.planning/deliverables/32-transaction-pipeline-api.md</files>
  <action>
  설계 문서 `32-transaction-pipeline-api.md`를 작성한다. 문서 ID는 `TX-PIPE`.

  **섹션 1: 문서 개요 + 요구사항 매핑**
  - 문서 ID, 작성일, 상태, 참조 문서 (SESS-PROTO, CHAIN-SOL, CORE-02, CORE-04, CORE-06)
  - 요구사항 매핑: API-02, API-03, API-04
  - v0.1 -> v0.2 파이프라인 변경 요약 (Cloud 8단계 -> Self-Hosted 6단계, Enclave/Squads 제거)

  **섹션 2: 트랜잭션 상태 머신**
  - 8개 상태: PENDING, QUEUED, EXECUTING, SUBMITTED, CONFIRMED, FAILED, CANCELLED, EXPIRED (CORE-02 정의)
  - 허용 전이 매트릭스 (Mermaid stateDiagram):
    - PENDING -> QUEUED (정책 통과, INSTANT 티어) | CANCELLED (정책 거부) | FAILED (검증 실패)
    - QUEUED -> EXECUTING (빌드 시작) | CANCELLED (Owner 거부) | EXPIRED (대기 시간 초과)
    - EXECUTING -> SUBMITTED (제출 성공) | FAILED (시뮬/서명/제출 실패)
    - SUBMITTED -> CONFIRMED (온체인 확정) | FAILED (온체인 실패) | EXPIRED (blockhash 만료)
    - CONFIRMED, FAILED, CANCELLED, EXPIRED = 최종 상태 (terminal)
  - 각 전이의 트리거 조건, DB UPDATE 쿼리, audit_log 이벤트 타입
  - 비정상 전이 방지: CHECK 제약 + 애플리케이션 레벨 전이 함수

  **섹션 3: 파이프라인 6단계 상세**

  Stage 1 - RECEIVE (요청 접수 + Zod 검증):
  - 입력: POST /v1/transactions/send 요청 본문 (TransferRequestSchema)
  - 처리: Zod 검증 -> transactions INSERT (status=PENDING, sessionId, agentId, chain, type, amount, toAddress)
  - 출력: transactionId (UUID v7)
  - 에러: VALIDATION_ERROR (400)
  - audit_log: TX_REQUESTED

  Stage 2 - SESSION VALIDATE (세션 제약 확인):
  - 입력: transactionId + 세션 제약 (c.get('constraints')) + 사용 통계 (c.get('usageStats'))
  - 처리: 07-01의 validateSessionConstraints() 호출
    - 단건 한도 (maxAmountPerTx)
    - 누적 한도 (maxTotalAmount) -- 현재 usageStats.totalAmount + request.amount
    - 거래 횟수 (maxTransactions) -- 현재 usageStats.totalTx + 1
    - 허용 작업 (allowedOperations)
    - 허용 주소 (allowedDestinations)
  - 성공: 다음 단계로 진행
  - 실패: status=CANCELLED, error='SESSION_LIMIT_EXCEEDED', 구체적 reason 기록
  - audit_log: TX_SESSION_CHECK (성공/실패 모두)

  Stage 3 - POLICY CHECK (정책 엔진 평가):
  - **Phase 8에서 상세화.** Phase 7에서는 인터페이스만 정의
  - 입력: transactionId + agentId + 거래 내용
  - 처리: PolicyEngine.evaluate(request) -> PolicyDecision (ALLOW/DENY + tier)
  - Phase 7 기본 동작: 정책 미설정 시 ALLOW + INSTANT 티어 (passthrough)
  - 실패: status=CANCELLED, error='POLICY_VIOLATION'
  - 이 단계의 확장점(hook)만 정의하고, 실제 정책 규칙은 Phase 8

  Stage 4 - TIER CLASSIFY (보안 티어 분류):
  - **Phase 8에서 상세화.** Phase 7에서는 4개 티어의 분기 로직만 정의
  - INSTANT: 즉시 실행 (Stage 5로 직행)
  - NOTIFY: 즉시 실행 + Owner 알림 (Stage 5 + notification)
  - DELAY: 시간 지연 후 실행 (status=QUEUED, queuedAt 기록, Phase 8 타이머)
  - APPROVAL: Owner 승인 대기 (status=QUEUED, Phase 8 승인 플로우)
  - transactions UPDATE (tier=결과)
  - Phase 7 기본 동작: 모든 거래를 INSTANT로 분류

  Stage 5 - EXECUTE (IChainAdapter 4단계 실행):
  - 5a. adapter.buildTransaction(request) -> UnsignedTransaction
    - transactions UPDATE (status=QUEUED 또는 유지)
    - 07-02 SolanaAdapter.buildTransaction() 호출
  - 5b. adapter.simulateTransaction(unsignedTx) -> SimulationResult
    - 실패 시: status=FAILED, error='SIMULATION_FAILED' + 시뮬 에러 상세
  - 5c. keyStore.getPrivateKey(agentId) -> privateKey(Uint8Array)
    - adapter.signTransaction(unsignedTx, privateKey) -> signedTx
    - sodium_memzero(privateKey) -- 즉시 메모리 제거
    - transactions UPDATE (status=EXECUTING)
  - 5d. adapter.submitTransaction(signedTx) -> SubmitResult
    - transactions UPDATE (status=SUBMITTED, txHash=result.txHash)
    - audit_log: TX_SUBMITTED
  - 타임아웃: Stage 5 전체 30초 (INSTANT 티어). blockhash ~60초 수명의 절반
  - DELAY/APPROVAL 티어: 승인 후 Stage 5a부터 재실행 (새 blockhash 필요)

  Stage 6 - CONFIRM (온체인 확정 대기):
  - adapter.waitForConfirmation(txHash, timeoutMs=60000)
  - 성공: transactions UPDATE (status=CONFIRMED, executedAt=now)
  - 실패: transactions UPDATE (status=FAILED 또는 EXPIRED)
  - usageStats 갱신 (better-sqlite3 transaction 내에서 원자적):
    - totalTx += 1
    - totalAmount += request.amount (BigInt 문자열 덧셈)
    - lastTxAt = now ISO string
  - audit_log: TX_CONFIRMED 또는 TX_FAILED

  **6단계 전체 시퀀스 다이어그램 (Mermaid sequenceDiagram)**
  - 참여자: Client, API, SessionValidator, PolicyEngine, TierClassifier, ChainAdapter, KeyStore, DB
  - 정상 플로우 (INSTANT 티어, 성공 시나리오)
  - 실패 플로우 (세션 제약 위반, 시뮬레이션 실패)

  **섹션 4: 파이프라인 오케스트레이터 설계**
  - TransactionService 클래스:
    - `executeTransfer(request, session): Promise<TransactionResult>`
    - 6단계를 순차 실행하는 오케스트레이터
    - 각 단계의 에러를 캐치하여 transactions 상태를 적절히 갱신
    - 단계별 타이밍 로그 (성능 프로파일링용)
  - 에러 복구 전략:
    - Stage 5a~5c 실패 -> FAILED (재시도 불가, 새 요청 필요)
    - Stage 5d 실패 -> 재시도 1회 (네트워크 일시 오류 가능)
    - Stage 6 타임아웃 -> EXPIRED (blockhash 만료. 사용자가 재요청)

  </action>
  <verify>
  - 32-transaction-pipeline-api.md 파일이 존재하고 문서 ID가 TX-PIPE
  - 트랜잭션 상태 머신이 8개 상태 + 허용 전이 매트릭스로 정의됨 (Mermaid stateDiagram)
  - 파이프라인 6단계 각각에 입력/출력/에러/DB 변경/audit_log가 명시됨
  - 전체 시퀀스 다이어그램이 Mermaid sequenceDiagram으로 포함됨
  - Stage 3, 4의 Phase 8 확장점이 인터페이스 수준으로 정의됨
  </verify>
  <done>거래 처리 파이프라인 6단계가 상태 전이 + 시퀀스 다이어그램 + 오케스트레이터 설계와 함께 완성됨</done>
</task>

<task type="auto">
  <name>Task 2: 세션/거래/지갑 API 엔드포인트 전체 스펙 설계</name>
  <files>.planning/deliverables/32-transaction-pipeline-api.md</files>
  <action>
  32-transaction-pipeline-api.md에 다음 섹션을 추가한다.

  **섹션 5: nonce API 엔드포인트**
  - GET /v1/auth/nonce (공개, 인증 불필요):
    - 응답: `{ nonce: string, expiresAt: string }` (ISO 8601)
    - 07-01 SESS-PROTO의 nonce 관리 참조

  **섹션 6: 세션 API 엔드포인트 (CORE-06 #5~#7)**

  POST /v1/sessions (Owner 인증):
  - 요청 Zod 스키마 (SessionCreateSchema):
    - agentId: z.string().uuid() -- 대상 에이전트
    - chain: z.enum(['solana', 'ethereum'])
    - ownerAddress: z.string() -- Owner 지갑 주소
    - signature: z.string() -- SIWS/SIWE 서명 (base58 또는 hex)
    - message: z.string() -- 서명된 메시지 원문
    - constraints: SessionConstraintsSchema (07-01 참조)
  - 응답 Zod 스키마 (SessionCreateResponseSchema):
    - sessionId: z.string().uuid()
    - token: z.string() -- wai_sess_... (한 번만 반환)
    - expiresAt: z.string().datetime()
    - constraints: SessionConstraintsSchema
  - 에러: INVALID_NONCE (401), OWNER_SIGNATURE_INVALID (401), AGENT_NOT_FOUND (404), AGENT_SUSPENDED (409)
  - OpenAPI operationId, tags, security 명시

  GET /v1/sessions (Owner 인증):
  - 쿼리 파라미터: agentId (optional), status ('active' | 'all'), limit, cursor
  - 응답: `{ sessions: SessionSummary[], nextCursor?: string }`
  - SessionSummary: id, agentId, agentName, constraints, usageStats, expiresAt, createdAt
  - 인증: 07-01 SESS-PROTO의 Owner 인증 방식 (Phase 8에서 ownerAuth로 전환 예정, Phase 7에서는 세션 토큰으로 임시 접근)

  DELETE /v1/sessions/:id (Owner 인증):
  - 경로 파라미터: id (세션 UUID)
  - 응답: `{ revoked: true, revokedAt: string }`
  - 처리: sessions UPDATE (revokedAt=now), audit_log INSERT (SESSION_REVOKED)
  - 에러: SESSION_NOT_FOUND (404), SESSION_ALREADY_REVOKED (409)

  **섹션 7: 거래 API 엔드포인트 (CORE-06 #8~#10)**

  POST /v1/transactions/send (Session 인증):
  - 요청 Zod 스키마 (TransferRequestSchema):
    - to: z.string() -- 수신자 주소 (base58 for Solana, hex for EVM)
    - amount: z.string() -- 전송 금액 (최소 단위: lamports/wei)
    - type: z.enum(['TRANSFER', 'TOKEN_TRANSFER']).default('TRANSFER')
    - tokenMint: z.string().optional() -- SPL/ERC20 토큰 주소 (type=TOKEN_TRANSFER 시 필수)
    - memo: z.string().max(200).optional() -- 메모
    - priority: z.enum(['low', 'medium', 'high']).default('medium') -- 우선순위 (수수료 조정)
  - 응답 Zod 스키마 (TransactionResponseSchema):
    - transactionId: z.string().uuid() -- 내부 ID
    - status: z.enum([...8개 상태])
    - tier: z.enum(['INSTANT', 'NOTIFY', 'DELAY', 'APPROVAL']).optional()
    - txHash: z.string().optional() -- 온체인 해시 (제출 후)
    - estimatedFee: z.string().optional() -- 추정 수수료
    - createdAt: z.string().datetime()
  - 에러: SESSION_LIMIT_EXCEEDED (403), POLICY_VIOLATION (403), INSUFFICIENT_BALANCE (400), SIMULATION_FAILED (422)
  - 응답 모드: 동기식 (INSTANT 티어는 CONFIRMED까지 대기 후 응답, 최대 30초 타임아웃)
    - 비동기 모드 고려: DELAY/APPROVAL 티어는 QUEUED 상태로 즉시 응답, 이후 GET으로 폴링

  GET /v1/transactions (Session 인증):
  - 쿼리 파라미터:
    - status: z.enum([...8개]).optional() -- 상태 필터
    - limit: z.number().int().min(1).max(100).default(20) -- 페이지 크기
    - cursor: z.string().optional() -- 커서 기반 페이지네이션 (UUID v7 = 시간순)
    - order: z.enum(['asc', 'desc']).default('desc') -- 정렬
  - 응답: `{ transactions: TransactionSummary[], nextCursor?: string, total?: number }`
  - TransactionSummary: id, type, status, tier, amount, toAddress, txHash, createdAt, executedAt, error
  - 커서 기반 페이지네이션: UUID v7의 시간 순서 활용 (WHERE id < cursor ORDER BY id DESC LIMIT N)

  GET /v1/transactions/pending (Session 인증):
  - Phase 8에서 DELAY/APPROVAL 티어의 대기 중 거래 조회에 사용
  - 응답: `{ transactions: PendingTransactionSummary[] }`
  - PendingTransactionSummary: id, type, amount, toAddress, tier, queuedAt, expiresAt, status (QUEUED만)
  - Phase 7 기본 동작: 빈 배열 반환 (모든 거래가 INSTANT이므로)

  **섹션 8: 지갑 API 엔드포인트 (CORE-06 #3~#4)**

  GET /v1/wallet/balance (Session 인증):
  - 응답 Zod 스키마 (BalanceResponseSchema):
    - balance: z.string() -- 잔액 (최소 단위)
    - decimals: z.number() -- 소수점 자릿수 (SOL=9, ETH=18)
    - symbol: z.string() -- 토큰 심볼 ('SOL', 'ETH')
    - formatted: z.string() -- 사람이 읽기 좋은 포맷 ('1.5 SOL')
    - chain: z.string()
    - network: z.string()
  - 처리: AdapterRegistry.getAdapter(agent.chain, agent.network).getBalance(agent.publicKey)
  - 에러: ADAPTER_NOT_AVAILABLE (503)

  GET /v1/wallet/address (Session 인증):
  - 응답 Zod 스키마 (AddressResponseSchema):
    - address: z.string() -- 에이전트 지갑 공개키
    - chain: z.string()
    - network: z.string()
    - encoding: z.enum(['base58', 'hex']) -- 주소 인코딩 방식
  - 처리: agents 테이블에서 publicKey 조회 (온체인 조회 불필요)

  **섹션 9: 공통 패턴**
  - OpenAPIHono createRoute 패턴 (Zod 스키마 -> OpenAPI 자동 생성)
  - 인증 레벨별 미들웨어 적용 방식:
    - Session 인증 경로: sessionAuth 미들웨어가 자동 적용 (/v1/*)
    - Owner 인증 경로 (POST /v1/sessions, GET /v1/sessions, DELETE /v1/sessions/:id): Phase 7에서는 요청 본문 서명 검증, Phase 8에서 ownerAuth 미들웨어로 전환
    - 공개 경로 (/health, /doc, /v1/auth/nonce): sessionAuth 제외
  - 커서 기반 페이지네이션 공통 헬퍼 (UUID v7 활용)
  - 에러 응답 공통 팩토리 (CORE-06 에러 포맷 준수)

  </action>
  <verify>
  - 세션 API 3개 엔드포인트(POST/GET/DELETE)가 Zod 요청/응답 스키마로 정의됨
  - 거래 API 3개 엔드포인트(POST send/GET list/GET pending)가 Zod 요청/응답 스키마로 정의됨
  - 지갑 API 2개 엔드포인트(GET balance/GET address)가 Zod 요청/응답 스키마로 정의됨
  - nonce API 1개 엔드포인트가 정의됨
  - 각 엔드포인트에 에러 코드, 인증 레벨, HTTP 상태 코드가 명시됨
  - 커서 기반 페이지네이션 패턴이 문서화됨
  </verify>
  <done>세션/거래/지갑/nonce API 총 9개 엔드포인트가 Zod 요청/응답 스키마 수준으로 완전히 설계됨. API-02, API-03, API-04 요구사항 충족.</done>
</task>

</tasks>

<verification>
1. 32-transaction-pipeline-api.md가 .planning/deliverables/에 존재
2. API-02 (지갑 엔드포인트): GET /v1/wallet/balance, GET /v1/wallet/address 스키마 정의됨
3. API-03 (세션 엔드포인트): POST/GET/DELETE /v1/sessions 스키마 정의됨
4. API-04 (거래 엔드포인트): POST /v1/transactions/send, GET /v1/transactions, GET /v1/transactions/pending 스키마 정의됨
5. 파이프라인 6단계가 상태 전이 다이어그램 + 시퀀스 다이어그램으로 문서화됨
6. 각 단계에서 07-01 (세션 제약), 07-02 (Solana 어댑터)를 참조하는 연결이 명시됨
7. Phase 8 확장점 (Stage 3 Policy, Stage 4 Tier)이 인터페이스 수준으로 정의됨
</verification>

<success_criteria>
- 거래 파이프라인 + API 스펙 문서가 9개 섹션으로 구성되어 Phase 7 Success Criteria #3, #5를 충족
- 파이프라인 6단계가 Mermaid 다이어그램으로 완전히 문서화됨
- CORE-06에서 정의된 Phase 7 엔드포인트 8개(#3~#10) + nonce 1개 = 총 9개가 Zod 스키마로 설계됨
- 07-01과 07-02의 설계를 파이프라인 Stage 2, Stage 5에서 통합
</success_criteria>

<output>
After completion, create `.planning/phases/07-session-transaction-protocol-design/07-03-SUMMARY.md`
</output>
