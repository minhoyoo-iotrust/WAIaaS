---
phase: 07-session-transaction-protocol-design
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/30-session-token-protocol.md
autonomous: true

must_haves:
  truths:
    - "JWT claims 구조가 필드별 타입/용도/예시와 함께 완전히 정의됨 (HS256, jose SignJWT)"
    - "SIWS/SIWE Owner 서명 검증 플로우가 시퀀스 다이어그램으로 문서화됨 (nonce 생성 -> 서명 -> 검증 -> 세션 발급)"
    - "세션 제약 모델(constraints)이 Zod 스키마 수준으로 정의됨 (maxAmountPerTx, maxTotalAmount, maxTransactions, allowedOperations, allowedDestinations, expiresIn)"
    - "세션 사용 통계(usageStats)가 Zod 스키마 + 원자적 갱신 패턴과 함께 정의됨"
    - "세션 발급/검증/폐기/만료 전체 수명주기가 시퀀스 다이어그램으로 문서화됨"
    - "nonce 재생 방지 메커니즘이 저장소(SQLite/LRU), TTL, 검증+삭제 절차와 함께 정의됨"
    - "sessionAuth 미들웨어의 2단계 검증 로직이 코드 수준으로 설계됨 (JWT 서명 검증 -> DB lookup)"
  artifacts:
    - path: ".planning/deliverables/30-session-token-protocol.md"
      provides: "세션 토큰 프로토콜 전체 설계 -- JWT 구조, SIWS/SIWE 플로우, 제약 모델, 폐기 메커니즘, nonce 관리"
      contains: "SessionConstraintsSchema"
  key_links:
    - from: "30-session-token-protocol.md"
      to: "25-sqlite-schema.md"
      via: "sessions 테이블의 constraints/usage_stats JSON 구조를 Phase 7에서 확정"
      pattern: "constraints.*JSON"
    - from: "30-session-token-protocol.md"
      to: "29-api-framework-design.md"
      via: "sessionAuth 미들웨어 stub을 Phase 7에서 완성"
      pattern: "sessionAuthMiddleware"
---

<objective>
세션 토큰 프로토콜을 완전히 설계한다 -- JWT claims 구조, SIWS/SIWE Owner 서명 검증 플로우, 세션 제약 모델(constraints JSON), 사용 통계 모델(usageStats JSON), 토큰 발급/검증/폐기/만료 수명주기, nonce 재생 방지, sessionAuth 미들웨어 2단계 검증 로직을 구현 가능한 수준으로 정의한다.

Purpose: 세션 인증은 WAIaaS 3계층 보안의 1계층(세션 기반 인증)의 핵심이다. 이 문서가 07-03의 거래 파이프라인(Session Validate 단계)과 API 엔드포인트(POST/GET/DELETE /v1/sessions)의 기반이 된다.
Output: 설계 문서 1개 -- 30-session-token-protocol.md (SESS-01~05 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-session-transaction-protocol-design/07-RESEARCH.md

# Phase 6 참조 (직접 의존)
@.planning/deliverables/25-sqlite-schema.md (CORE-02: sessions 테이블, audit_log 테이블)
@.planning/deliverables/29-api-framework-design.md (CORE-06: sessionAuth 미들웨어 stub, 에러 포맷, AppBindings)
@.planning/deliverables/24-monorepo-data-directory.md (CORE-01: config.toml [security] 섹션)
</context>

<tasks>

<task type="auto">
  <name>Task 1: JWT 토큰 구조 + SIWS/SIWE 검증 플로우 + nonce 관리 설계</name>
  <files>.planning/deliverables/30-session-token-protocol.md</files>
  <action>
  설계 문서 `30-session-token-protocol.md`를 작성한다. 문서 ID는 `SESS-PROTO`.

  **섹션 1: 문서 개요 + 요구사항 매핑**
  - 문서 ID, 작성일, 상태, 참조 문서 (CORE-02, CORE-06, CORE-01), 요구사항 매핑 (SESS-01~05)
  - v0.1 -> v0.2 변경 요약 (API Key 영구 토큰 -> JWT 세션 토큰, OAuth -> SIWS/SIWE)

  **섹션 2: JWT 토큰 구조**
  - jose v6.x SignJWT API 기반 JWT claims 설계:
    - Header: `{ alg: 'HS256' }`
    - Registered claims: `iss` ('waiaas'), `exp`, `iat`, `jti` (= sessionId)
    - Custom claims: `sid` (세션 ID, UUID v7), `aid` (에이전트 ID, UUID v7)
    - 제약 조건은 JWT에 포함하지 않음 -- DB에서 조회 (변경 가능성 + JWT 크기 절약)
  - 토큰 포맷: `wai_sess_` prefix + JWT (예: `wai_sess_eyJhbG...`)
  - JWT Secret 관리:
    - `waiaas init` 시 `crypto.randomBytes(32).toString('hex')`로 생성
    - config.toml `[security]` 섹션의 `jwt_secret` 키에 저장 (파일 권한 600)
    - 환경변수 `WAIAAS_SECURITY_JWT_SECRET` 오버라이드
    - 비밀 키 변경 시 모든 기존 세션 자동 무효화 (의도된 동작)
    - 키스토어 마스터 패스워드와 분리 저장 (데몬 시작 시 키스토어 잠금 해제 없이 세션 검증 가능해야 함)
  - 토큰 만료 범위: 최소 300초(5분) ~ 최대 604800초(7일), 기본 86400초(24시간)
  - 토큰 크기 추정 (HS256 + minimal claims = ~250-300 bytes)

  **섹션 3: SIWS/SIWE Owner 서명 검증 플로우**
  - SIWS (Solana) 플로우:
    1. 클라이언트가 GET /v1/auth/nonce 요청
    2. 서버가 nonce 생성 + 저장 (crypto.randomBytes(16).toString('hex'), TTL 5분)
    3. 클라이언트가 SIWS 메시지 구성 (domain: 'localhost:3100', address, nonce, statement, issuedAt, expirationTime)
    4. Owner가 Phantom/Solflare 등으로 메시지 서명 (Ed25519)
    5. 클라이언트가 POST /v1/sessions에 message + signature + publicKey 전달
    6. 서버가 nonce 검증 + 삭제, SIWS 메시지 파싱, tweetnacl.sign.detached.verify로 Ed25519 서명 검증
    7. 에이전트 소유권 확인 (agents.ownerAddress == publicKey)
    - SIWS 메시지 포맷 예시 (EIP-4361 호환)
    - `@web3auth/sign-in-with-solana` SIWS 클래스 + Payload 사용 패턴
  - SIWE (Ethereum) 플로우:
    1. 동일한 nonce 엔드포인트 사용
    2. SIWE 메시지 구성 (EIP-4361 포맷)
    3. Owner가 MetaMask 등으로 personal_sign (EIP-191)
    4. `siwe` SiweMessage.verify({ signature }) 로 검증
    5. recovered address == 요청의 ownerAddress 확인
    - siwe v3.x + ethers v6 peer dependency 관계 명시
  - 두 플로우의 시퀀스 다이어그램 (Mermaid sequenceDiagram)
  - Owner 인증과 세션 인증의 경계:
    - POST /v1/sessions: Owner 서명으로 세션 생성 (owner-verifier 유틸리티)
    - Phase 8: ownerAuth 라우트 미들웨어가 동일 유틸리티 재사용

  **섹션 4: nonce 관리**
  - 서버 생성 nonce: `crypto.randomBytes(16).toString('hex')` (32 hex chars)
  - 저장: SQLite `nonces` 임시 테이블 OR 인메모리 LRU 캐시
    - 추천: 인메모리 LRU (lru-cache, max 1000 entries, TTL 5분)
    - 근거: nonce는 단기 일회성 데이터, DB 부하 불필요, 데몬 재시작 시 소멸해도 무방
  - TTL: 5분 (300초). 만료된 nonce는 자동 거부
  - 검증 + 삭제: nonce 확인 후 즉시 삭제 (replay attack 방지)
  - GET /v1/auth/nonce 엔드포인트 스펙 (요청: 없음, 응답: { nonce, expiresAt })
  - 에러: INVALID_NONCE (nonce 불일치 또는 만료), NONCE_ALREADY_USED (이미 사용됨)

  </action>
  <verify>
  - 30-session-token-protocol.md 파일이 존재하고 문서 ID가 SESS-PROTO
  - JWT claims 테이블에 모든 필드(iss, exp, iat, jti, sid, aid)가 타입/용도와 함께 정의됨
  - SIWS 시퀀스 다이어그램에 nonce 생성 -> 서명 -> 검증 -> 세션 발급 전체 흐름이 포함됨
  - SIWE 시퀀스 다이어그램에 personal_sign -> SiweMessage.verify 흐름이 포함됨
  - nonce 관리 섹션에 TTL, 저장소, 검증+삭제 절차가 명시됨
  </verify>
  <done>JWT 토큰 구조, SIWS/SIWE 검증 플로우, nonce 관리가 구현 가능한 수준으로 설계됨</done>
</task>

<task type="auto">
  <name>Task 2: 세션 제약 모델 + 수명주기 + sessionAuth 미들웨어 설계</name>
  <files>.planning/deliverables/30-session-token-protocol.md</files>
  <action>
  30-session-token-protocol.md에 다음 섹션을 추가한다.

  **섹션 5: 세션 제약 모델 (constraints JSON)**
  - Zod 스키마 정의 (SessionConstraintsSchema):
    - `maxAmountPerTx`: z.string().optional() -- 단건 최대 전송 금액 (lamports/wei, TEXT)
    - `maxTotalAmount`: z.string().optional() -- 누적 최대 전송 금액
    - `maxTransactions`: z.number().int().positive().optional() -- 최대 거래 횟수
    - `allowedOperations`: z.array(z.enum(['TRANSFER', 'TOKEN_TRANSFER', 'PROGRAM_CALL', 'BALANCE_CHECK'])).optional()
    - `allowedDestinations`: z.array(z.string()).optional() -- 전송 허용 주소 화이트리스트
    - `expiresIn`: z.number().int().positive().max(604800).optional().default(86400) -- 만료(초, 최대 7일)
  - 07-RESEARCH.md의 validateSessionConstraints 함수를 발전시킨 제약 검증 로직:
    - BigInt 비교를 사용한 금액 검증
    - 모든 제약은 optional (미설정 = 제한 없음)
    - 검증 결과 타입: `{ allowed: boolean; reason?: string; code?: string }`
  - constraints JSON이 CORE-02 sessions 테이블의 `constraints TEXT` 컬럼에 저장되는 방식 명시

  **섹션 6: 세션 사용 통계 (usageStats JSON)**
  - Zod 스키마 정의 (SessionUsageStatsSchema):
    - `totalTx`: z.number().int() -- 누적 거래 횟수
    - `totalAmount`: z.string() -- 누적 전송 금액 (TEXT = bigint safe)
    - `lastTxAt`: z.string().datetime().optional() -- 마지막 거래 시각
  - usageStats 원자적 갱신 패턴:
    - better-sqlite3 `transaction()` 내에서 Read-Modify-Write
    - `BEGIN IMMEDIATE` 트랜잭션으로 동시성 보장 (Node.js 비동기 환경에서 race condition 방지)
    - 갱신 코드 패턴 (Drizzle ORM raw SQL 사용)
  - usageStats JSON이 CORE-02 sessions 테이블의 `usage_stats TEXT` 컬럼에 저장되는 방식

  **섹션 7: 세션 수명주기 (발급 -> 검증 -> 폐기 -> 만료)**
  - 4단계 수명주기 시퀀스 다이어그램:
    1. 발급 (Issue): POST /v1/sessions -> Owner 서명 검증 -> JWT 생성 -> sessions INSERT -> 토큰 반환 (한 번만 노출)
    2. 검증 (Validate): 매 요청 -> sessionAuth 미들웨어 -> JWT 서명 검증 (빠른 거부) -> DB lookup (폐기/만료/제약 확인)
    3. 폐기 (Revoke): DELETE /v1/sessions/:id -> revokedAt 설정 -> 즉시 무효화 -> 감사 로그
    4. 만료 (Expire): BackgroundWorker 1분 주기 -> expired + revoked 세션 DELETE -> 감사 로그 (SESSION_EXPIRED)
  - 토큰 해싱: SHA-256(wai_sess_{jwt}) -> sessions.token_hash에 저장 (원본 미저장)
  - 만료 세션 정리 워커 상세:
    - 대상: expiresAt < now() OR revokedAt IS NOT NULL (revoked 후 24시간 경과)
    - 방법: DELETE (SET NULL on transactions.session_id이므로 안전)
    - 감사 로그: SESSION_EXPIRED (만료), SESSION_CLEANUP (폐기 후 정리)

  **섹션 8: sessionAuth 미들웨어 상세 설계**
  - CORE-06의 sessionAuth stub을 완성하는 2단계 검증 로직:
    - Stage 1: JWT 서명/만료 검증 (jose jwtVerify, HS256, issuer='waiaas') -- DB 불필요, 빠른 거부
    - Stage 2: DB lookup (token_hash로 sessions 조회, revokedAt IS NULL, expiresAt > now()) -- 폐기/만료 확인
  - 검증 성공 시 Hono 컨텍스트에 설정하는 값:
    - `c.set('sessionId', session.id)`
    - `c.set('agentId', payload.aid)`
    - `c.set('constraints', session.constraints)` -- 파이프라인 Stage 2에서 사용
    - `c.set('usageStats', session.usageStats)` -- 파이프라인 Stage 2에서 사용
  - 에러 코드: AUTH_TOKEN_MISSING (401), AUTH_TOKEN_INVALID (401), AUTH_TOKEN_EXPIRED (401), SESSION_REVOKED (401)
  - 인증 제외 경로: /health, /doc, /v1/auth/nonce (공개)
  - POST /v1/sessions는 sessionAuth가 아닌 요청 본문의 Owner 서명으로 인증
  - 성능 고려: idx_sessions_token_hash 인덱스 활용 -> < 1ms DB lookup

  **섹션 9: 보안 고려사항**
  - JWT Secret 수명주기 관리 (생성, 저장, 변경, 영향)
  - 토큰 탈취 대응 (짧은 만료 + 즉시 폐기 + 제약 한도)
  - 타이밍 공격 방지 (jose 라이브러리 내장 대응)
  - Phase 8과의 연계점 (ownerAuth 미들웨어, Kill Switch의 세션 일괄 폐기)

  </action>
  <verify>
  - SessionConstraintsSchema가 6개 필드와 함께 Zod 코드로 정의됨
  - SessionUsageStatsSchema가 3개 필드와 함께 Zod 코드로 정의됨
  - usageStats 원자적 갱신 패턴이 better-sqlite3 transaction() 코드 패턴으로 명시됨
  - 세션 수명주기 4단계가 시퀀스 다이어그램으로 포함됨
  - sessionAuth 미들웨어의 2단계 검증이 코드 수준(jose jwtVerify + DB query)으로 설계됨
  - 인증 제외 경로 목록이 명시됨
  </verify>
  <done>세션 제약 모델, 수명주기, sessionAuth 미들웨어가 구현 가능한 수준으로 설계됨. SESS-01~05 요구사항이 모두 충족됨.</done>
</task>

</tasks>

<verification>
1. 30-session-token-protocol.md가 .planning/deliverables/에 존재
2. SESS-01 (Owner 서명으로 세션 생성): SIWS/SIWE 플로우 + POST /v1/sessions 핸들러 로직이 정의됨
3. SESS-02 (세션 토큰에 만료/한도/허용 작업): SessionConstraintsSchema + JWT 만료가 정의됨
4. SESS-03 (세션별 사용량 추적): SessionUsageStatsSchema + 원자적 갱신 패턴이 정의됨
5. SESS-04 (Owner 즉시 폐기): DELETE /v1/sessions/:id + revokedAt 설정이 정의됨
6. SESS-05 (활성 세션 목록): GET /v1/sessions 엔드포인트가 정의됨
7. 모든 다이어그램이 Mermaid 구문으로 작성됨
</verification>

<success_criteria>
- 세션 토큰 프로토콜 문서가 9개 섹션으로 구성되어 Phase 7 Success Criteria #1, #2를 충족
- JWT claims, SIWS/SIWE 플로우, 제약 모델, 수명주기가 코드/스키마 수준으로 설계됨
- CORE-02 sessions 테이블의 constraints/usage_stats JSON 구조가 확정됨
- CORE-06 sessionAuth 미들웨어 stub이 완성됨
</success_criteria>

<output>
After completion, create `.planning/phases/07-session-transaction-protocol-design/07-01-SUMMARY.md`
</output>
