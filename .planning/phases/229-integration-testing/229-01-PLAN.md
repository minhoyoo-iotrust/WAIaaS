---
phase: 229-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts
autonomous: true
requirements:
  - C-01
  - C-02
  - C-04
  - C-05
  - C-06

must_haves:
  truths:
    - "10x addWallet/removeWallet cycles on SubscriptionMultiplexer leave exactly 0 listeners when all wallets removed"
    - "Queue push+flush cycle across 100 rapid transactions inserts all items without duplicates"
    - "Calling stop() on IncomingTxMonitorService after queuing 10 transactions results in all 10 saved to DB"
    - "Duplicate transactions (same txHash:walletId) pushed to queue result in exactly 1 DB record"
    - "EVM DETECTED tx with block_number < currentBlock-threshold stays DETECTED (not prematurely confirmed)"
  artifacts:
    - path: "packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts"
      provides: "Integration tests for 5 core pitfalls (C-01, C-02, C-04, C-05, C-06)"
      min_lines: 200
  key_links:
    - from: "IncomingTxQueue"
      to: "SubscriptionMultiplexer"
      via: "onTransaction callback wiring"
      pattern: "queue\\.push.*onTransaction"
    - from: "IncomingTxMonitorService.stop()"
      to: "IncomingTxQueue.drain()"
      via: "graceful shutdown path"
      pattern: "queue\\.drain"
---

<objective>
Create integration tests verifying the 5 core pitfalls (C-01 WebSocket listener leak, C-02 SQLite event loop contention, C-04 duplicate events, C-05 shutdown data loss, C-06 EVM reorg) are defended by the incoming TX monitoring pipeline.

Purpose: The existing unit tests cover individual components in isolation. These integration tests verify that components work together correctly, especially under edge conditions that only manifest when multiple layers interact.

Output: `packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts` with ~15-20 test cases.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Implementation files (read these to understand the actual APIs)
@packages/daemon/src/services/incoming/incoming-tx-queue.ts
@packages/daemon/src/services/incoming/subscription-multiplexer.ts
@packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
@packages/daemon/src/services/incoming/incoming-tx-workers.ts
@packages/daemon/src/services/incoming/safety-rules.ts
@packages/core/src/interfaces/connection-state.ts
@packages/core/src/interfaces/IChainSubscriber.ts
@packages/core/src/interfaces/chain-subscriber.types.ts

# Existing test patterns (follow these conventions exactly)
@packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts
@packages/daemon/src/services/incoming/__tests__/subscription-multiplexer.test.ts
@packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration-pitfall.test.ts with C-01, C-02, C-04 tests</name>
  <files>packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts</files>
  <action>
Create the integration test file. Follow the exact vitest patterns from the existing test files (import style, mock factories, helper functions).

**Mock Strategy:** Create mock IChainSubscriber instances with controllable connect/disconnect/subscribe behavior. Create mock better-sqlite3 Database with in-memory tracking of run/prepare/transaction calls. Do NOT use real SQLite -- mock at the same level as existing tests.

**Section 1: C-01 - WebSocket Listener Leak (3-4 tests)**

Test that repeated addWallet/removeWallet cycles on SubscriptionMultiplexer do not accumulate leaked listeners:

1. Add 10 wallets to the same chain:network, then remove all 10. Verify: subscriberFactory called once, subscriber.unsubscribe called 10 times, subscriber.destroy called once, getActiveConnections returns [].
2. Add wallet, remove wallet, add wallet (re-create connection). Repeat 10 times. Verify: subscriberFactory called 10 times (new subscriber each cycle), all previous subscribers have destroy() called.
3. Add 5 wallets, call stopAll(), verify: 5 unsubscribe calls + 1 destroy call. Then addWallet again -- should create fresh subscriber (not reuse destroyed one).

**Section 2: C-02 - SQLite Event Loop Contention (2-3 tests)**

Test that IncomingTxQueue batches writes to prevent SQLITE_BUSY:

1. Push 500 transactions into queue rapidly (simulating burst from WebSocket), then call flush() repeatedly until queue is empty. Verify: flush() returns items in MAX_BATCH=100 chunks (5 flush calls needed), no data lost. Use a mock DB that tracks all stmt.run() calls.
2. Push 50 transactions, flush with a mock DB where transaction() wraps the callback atomically. Verify all 50 are processed in a single transaction() call (batch atomicity).

**Section 3: C-04 - Duplicate Event Prevention (3-4 tests)**

Test the two-layer dedup (Map in queue + ON CONFLICT in DB):

1. Push the same transaction (same txHash + walletId) 10 times to queue. Verify queue.size === 1. Flush to mock DB. Verify stmt.run called once.
2. Push 5 unique transactions + 5 duplicates of the first. Verify queue.size === 5. Flush all. Verify 5 DB inserts.
3. Simulate DB-level dedup: push unique transactions, but mock DB returns changes=0 for 2 of them (ON CONFLICT skipped). Verify flush() returns only the successfully inserted ones (3 out of 5).
4. Integration: push transactions to queue through the SubscriptionMultiplexer's onTransaction callback wiring, then flush. Verify the callback correctly routes to queue.push and dedup works end-to-end.

Each test should have descriptive names following the pattern: `it('C-0X: [specific behavior being tested]', ...)`.
  </action>
  <verify>
Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts --reporter=verbose`

All tests pass. No warnings except intentionally mocked console.warn calls.
  </verify>
  <done>
8-11 tests pass covering C-01 (listener leak), C-02 (batch write contention), and C-04 (duplicate prevention). Tests verify multi-component interaction, not single-component behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add C-05 (shutdown data loss) and C-06 (EVM reorg) integration tests</name>
  <files>packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts</files>
  <action>
Append to the same test file created in Task 1.

**Section 4: C-05 - Shutdown Data Loss Prevention (3-4 tests)**

Test that IncomingTxMonitorService.stop() drains all queued items:

1. Create IncomingTxMonitorService with real IncomingTxQueue (not mocked) and mock everything else. Push 10 transactions into the internal queue by accessing it via `(service as any).queue.push(tx)`. Call `service.stop()`. Verify: mock DB received exactly 10 stmt.run() calls from the drain operation.
2. Push 250 transactions (more than MAX_BATCH=100). Call stop(). Verify: drain loops multiple flush cycles (100+100+50), all 250 recorded in mock DB.
3. Push 0 transactions. Call stop(). Verify: no DB calls for flush (empty drain is a no-op), but multiplexer.stopAll() is still called.
4. Push 10 transactions, stop() with a mock DB that throws on 1 transaction (simulate a conflict). Verify: the remaining 9 are still processed (transaction-level atomicity preserves partial results -- this depends on how better-sqlite3 transaction() behaves; if it throws, verify the error is handled gracefully).

**Section 5: C-06 - EVM Reorg Safety (3-4 tests)**

Test that the confirmation worker does not prematurely confirm transactions during potential reorgs:

1. Create confirmation handler with mock DB returning an EVM DETECTED tx at block 100, network "mainnet" (threshold=12). Mock getBlockNumber returns 111n (11 confirmations). Verify: tx is NOT upgraded to CONFIRMED (111-100=11 < 12).
2. Same setup but getBlockNumber returns 112n (12 confirmations). Verify: tx IS upgraded to CONFIRMED.
3. Simulate reorg: first call returns block 115n (confirmed). But in a second cycle, DB still has a different DETECTED tx at block 113. getBlockNumber now returns 120n (7 confirmations for block 113). Verify: first tx confirmed at cycle 1, second tx NOT confirmed at cycle 2 until enough blocks pass.
4. Mix Solana and EVM DETECTED transactions in the same confirmation worker cycle. Verify: Solana tx uses checkSolanaFinalized (not block numbers), EVM tx uses block number comparison. Both chains handled independently in a single worker run.

Each test should clearly reference the pitfall ID: `it('C-05: [behavior]', ...)` and `it('C-06: [behavior]', ...)`.
  </action>
  <verify>
Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts --reporter=verbose`

All tests pass including both Task 1 and Task 2 sections.
  </verify>
  <done>
15-20 total tests pass in integration-pitfall.test.ts, covering all 5 core pitfalls (C-01 through C-06). The file validates multi-component interactions that unit tests cannot catch.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts --reporter=verbose
```

Expected: 15-20 tests pass, organized in 5 describe blocks (C-01, C-02, C-04, C-05, C-06). No test failures. No uncaught warnings.

Also verify existing tests are not broken:
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/services/incoming/__tests__/ --reporter=verbose
```

Expected: All existing tests (106 total from prior phases + 15-20 new) pass.
</verification>

<success_criteria>
1. integration-pitfall.test.ts exists with 15-20 passing tests
2. Tests are organized by pitfall ID (C-01, C-02, C-04, C-05, C-06)
3. Tests verify multi-component interaction, not isolated unit behavior
4. Mock strategy: mock at RPC/DB boundary, use real Queue/Multiplexer/Service classes
5. All prior unit tests remain passing
</success_criteria>

<output>
After completion, create `.planning/phases/229-integration-testing/229-01-SUMMARY.md`
</output>
