---
phase: 09-integration-client-interface-design
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - .planning/deliverables/40-telegram-bot-docker.md
autonomous: true

must_haves:
  truths:
    - "Telegram Bot 명령어 체계가 /sessions, /revoke, /killswitch, /status + 인라인 키보드 승인/거부로 설계됨"
    - "Telegram 거래 승인 인증 갭이 2-tier 모델로 해결됨 (DELAY reject만 Telegram, APPROVAL은 Desktop/CLI)"
    - "Bot Long Polling 아키텍처가 native fetch 기반으로 설계됨 (프레임워크 미사용)"
    - "Docker multi-stage 빌드 + docker-compose가 named volume + secrets로 설계됨"
    - "Docker 환경에서 SQLite WAL + named volume 호환성이 고려됨"
    - "Telegram Bot + Docker의 환경변수/시크릿 관리가 정의됨"
  artifacts:
    - path: ".planning/deliverables/40-telegram-bot-docker.md"
      provides: "Telegram Bot 상세 설계 + Docker 배포 스펙"
      contains: "TelegramBotService"
  key_links:
    - from: "40-telegram-bot-docker.md"
      to: "37-rest-api-complete-spec.md"
      via: "Bot 명령어가 Owner API 엔드포인트를 호출"
      pattern: "/v1/owner.*sessions.*kill-switch"
    - from: "40-telegram-bot-docker.md"
      to: "35-notification-architecture.md"
      via: "TelegramBotService가 INotificationChannel 구현을 확장 (알림 수신 + 명령 입력)"
      pattern: "INotificationChannel.*TelegramBot"
    - from: "40-telegram-bot-docker.md"
      to: "34-owner-wallet-connection.md"
      via: "Telegram 인증 갭: SIWS/SIWE 불가 -> chatId + botToken 기반 간접 인증"
      pattern: "chatId.*ownerAuth.*gap"
    - from: "40-telegram-bot-docker.md"
      to: "28-daemon-lifecycle-cli.md"
      via: "Docker에서 데몬 라이프사이클 (healthcheck, graceful shutdown)"
      pattern: "healthcheck.*shutdown"
---

<objective>
Telegram 인터랙티브 봇의 명령 체계/인라인 키보드/인증 모델과 Docker 배포 스펙(Dockerfile, docker-compose, 볼륨, 시크릿)을 상세 설계한다 -- Bot Long Polling, 명령어 핸들러, 거래 승인 2-tier 모델, Docker multi-stage 빌드, named volume, Docker Secrets를 구현 가능한 수준으로 정의한다.

Purpose: Telegram Bot은 Owner가 모바일에서 WAIaaS를 관리하는 채널이다. Docker는 CLI 사용자를 위한 간편 배포 경로를 제공한다. 두 주제를 하나의 설계 문서로 통합하여 Phase 9를 완성한다.
Output: 설계 문서 1개 -- 40-telegram-bot-docker.md (TGBOT-01, TGBOT-02, DOCK-01 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-integration-client-interface-design/09-RESEARCH.md

# 09-01 SUMMARY (직접 의존 -- API 전체 스펙)
@.planning/phases/09-integration-client-interface-design/09-01-SUMMARY.md

# Phase 8 참조
@.planning/deliverables/35-notification-architecture.md (NOTI-ARCH: Telegram 알림 채널, native fetch)
@.planning/deliverables/34-owner-wallet-connection.md (OWNR-CONN: ownerAuth, 인증 모델)
@.planning/deliverables/36-killswitch-autostop-evm.md (KILL-AUTO-EVM: Kill Switch API)

# Phase 6 참조
@.planning/deliverables/28-daemon-lifecycle-cli.md (CORE-05: 데몬 라이프사이클, Docker 호환)
@.planning/deliverables/24-monorepo-data-directory.md (CORE-01: ~/.waiaas/ 디렉토리)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Telegram 인터랙티브 봇 명령 체계 + 인라인 키보드 + 인증 모델 설계</name>
  <files>.planning/deliverables/40-telegram-bot-docker.md</files>
  <action>
  설계 문서 `40-telegram-bot-docker.md`를 작성한다. 문서 ID는 `TGBOT-DOCK`.

  **섹션 1: 문서 개요**
  - 문서 ID: TGBOT-DOCK
  - 목적: Telegram 인터랙티브 봇 + Docker 배포 스펙 설계
  - 요구사항 매핑: TGBOT-01 (인라인 키보드 거래 승인/거부), TGBOT-02 (봇 명령어), DOCK-01 (Docker 이미지 + docker-compose)
  - v0.1과의 핵심 차이: Webhook 수신 -> Long Polling (Self-Hosted에 외부 Webhook URL 불필요)

  **섹션 2: TelegramBotService 아키텍처**
  - 위치: packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts
  - 역할: NOTI-ARCH의 TelegramNotificationChannel (알림 발송)을 확장하여 명령 수신 + 인터랙션 처리 추가
  - 구조:
    ```
    TelegramBotService
    ├── Long Polling Loop (getUpdates)
    ├── Command Handler Registry
    ├── Callback Query Handler
    ├── Message Formatter (MarkdownV2)
    └── TelegramNotificationChannel (NOTI-ARCH 구현, 알림 발송 전용)
    ```
  - 관계: TelegramBotService는 TelegramNotificationChannel을 내부적으로 포함/확장. INotificationChannel.send()는 기존 알림 발송, TelegramBotService는 여기에 명령 수신 기능을 추가.

  **섹션 3: Long Polling 설계**
  - Telegram Bot API: `getUpdates` 메서드로 Long Polling
  - 폴링 파라미터:
    - offset: 마지막 처리한 update_id + 1
    - timeout: 30초 (long poll)
    - allowed_updates: ['message', 'callback_query']
  - 폴링 루프:
    ```
    while (running) {
      const updates = await fetch(`${TELEGRAM_API}/getUpdates`, {
        method: 'POST',
        body: JSON.stringify({ offset, timeout: 30, allowed_updates: [...] }),
      })
      for (const update of updates.result) {
        if (update.message) handleCommand(update.message)
        if (update.callback_query) handleCallbackQuery(update.callback_query)
        offset = update.update_id + 1
      }
    }
    ```
  - 에러 핸들링: 네트워크 에러 시 5초 대기 후 재시도, 3회 연속 실패 시 30초 대기
  - 데몬 종료 시: running=false -> 폴링 루프 종료 (graceful)

  **섹션 4: 봇 명령어 체계 (TGBOT-02)**

  명령어 1 -- /start:
  - 동작: 봇 소개 메시지 + Owner 인증 안내
  - 응답: "WAIaaS Wallet Bot. Use /auth to link your Telegram account."

  명령어 2 -- /auth:
  - 동작: Owner chatId 등록 (봇이 데몬에 Owner Telegram chatId를 연결)
  - 플로우:
    1. 봇이 6자리 인증 코드 생성 -> 데몬 메모리에 5분 TTL 저장
    2. "Enter this code in WAIaaS Desktop or CLI: `{code}`" 메시지 전송
    3. Owner가 Desktop Settings 또는 CLI에서 코드 입력 -> chatId 확인 -> notification_channels에 등록
  - 이유: Telegram Bot API에서 chatId를 안전하게 검증하는 유일한 경로

  명령어 3 -- /status:
  - 동작: 시스템 상태 요약
  - 내부: GET /health + GET /v1/owner/dashboard (내부 호출, HTTP 불필요 -- 직접 서비스 호출)
  - 응답 형식 (MarkdownV2):
    ```
    *WAIaaS Status*
    State: `NORMAL`
    Balance: `1.5 SOL`
    Active Sessions: `2`
    Pending Approvals: `1`
    Uptime: `2h 30m`
    ```

  명령어 4 -- /sessions:
  - 동작: 활성 세션 목록
  - 내부: SessionService.listActive()
  - 응답: 세션 목록 (에이전트명, 만료 시간, [Revoke] 인라인 버튼)

  명령어 5 -- /revoke <sessionId>:
  - 동작: 특정 세션 즉시 폐기
  - 인증: chatId 검증 (등록된 Owner chatId만 허용)
  - 응답: "Session {id} revoked." 또는 인라인 키보드에서 세션 선택

  명령어 6 -- /killswitch:
  - 동작: Kill Switch 발동
  - 인증: chatId 검증 + 확인 단계 (인라인 키보드 [Confirm] [Cancel])
  - 주의: Telegram에서의 Kill Switch는 "긴급 발동" 경로 -- 복구는 Desktop/CLI만 가능
  - 내부: KillSwitchService.activate(reason='telegram_command', actor='owner_telegram')

  명령어 7 -- /pending:
  - 동작: 대기 중 거래 목록 + 인라인 키보드
  - 응답: 각 거래에 [Approve] [Reject] 버튼

  명령어 8 -- /help:
  - 동작: 명령어 목록 안내

  **섹션 5: 인라인 키보드 거래 승인/거부 (TGBOT-01)**

  5.1 승인 요청 알림 (Push):
  - APPROVAL 티어 거래 발생 시 TelegramNotificationChannel이 자동 발송
  - 메시지 형식:
    ```
    *Transaction Approval Required*

    Amount: `0.5 SOL`
    To: `7xKX...pqR8`
    Agent: `trading-bot`
    Tier: `APPROVAL`

    _Expires in 1 hour_
    ```
  - 인라인 키보드: [[Approve, callback_data: `approve:{txId}`], [Reject, callback_data: `reject:{txId}`]]
  - callback_data: 최대 64바이트, txId 짧은 참조만 (UUID v7 = 36자, 접두사 7자 = `approve:` + 36자 = 44자 -- 64바이트 이내)

  5.2 Callback Query 처리:
  - callback_data 파싱: action:txId 형식
  - 항상 먼저 answerCallbackQuery 호출 (Telegram 로딩 표시 제거)
  - 서버 측 검증: txId가 실제 PENDING_APPROVAL 상태인지 DB 확인
  - 만료 검증: 거래가 이미 만료/처리됨이면 "This transaction has already been processed" 메시지
  - 메시지 편집: editMessageText로 결과 표시 ("Transaction APPROVED" 또는 "Transaction REJECTED")

  **섹션 6: Telegram 거래 승인 인증 갭 해결 -- 2-Tier 모델**

  6.1 인증 갭 분석:
  - OWNR-CONN의 ownerAuth는 per-request SIWS/SIWE 서명을 요구
  - Telegram에서는 지갑 서명 불가능 (Telegram 앱 내에서 Phantom/MetaMask 호출 불가)
  - 따라서 Telegram에서의 "승인"은 ownerAuth를 직접 충족할 수 없음

  6.2 2-Tier 승인 모델:

  Tier 1 -- Telegram 허용 동작 (chatId 인증만):
  - DELAY 티어 거래의 reject (지연 중 취소): 정책이 이미 허가한 거래의 취소이므로 낮은 인증 수준 허용
  - 세션 revoke: 기존 세션 폐기는 방어적 동작
  - Kill Switch activate: 긴급 정지는 방어적 동작 (복구는 이중 인증 필요)
  - /status, /sessions, /pending: 읽기 전용

  Tier 2 -- Desktop/CLI 필수 (ownerAuth SIWS/SIWE 필요):
  - APPROVAL 티어 거래의 approve: 자금 이동 최종 승인은 지갑 서명 필수
  - Kill Switch recover: 시스템 복구는 이중 인증 필수
  - 세션 생성: 새 에이전트 권한 부여는 지갑 서명 필수
  - 설정 변경: 보안 설정 변경은 지갑 서명 필수

  6.3 Telegram Approve 처리:
  - Telegram에서 [Approve] 클릭 시:
    - "Approval noted. Please confirm with your wallet signature in Desktop or CLI within {remaining_time}."
    - 거래 상태를 PENDING_APPROVAL -> TELEGRAM_PRE_APPROVED (신규 상태, DB 기록)
    - Desktop/CLI에서 Owner가 최종 ownerAuth 서명 시 APPROVED로 전이
  - 대안 방안 (config 설정): `telegram_direct_approve: true`
    - 소액 APPROVAL (예: <1 SOL)에 대해 Telegram chatId 인증만으로 직접 승인 허용
    - 기본값: false (보안 최우선)
    - 활성화 시 경고: "Telegram direct approve enabled. Transactions under {threshold} SOL can be approved without wallet signature."

  6.4 chatId 인증 구현:
  - 등록된 Owner chatId와 callback_query.from.id 비교
  - 미등록 chatId: "Unauthorized. Use /auth to register." 응답
  - chatId 스푸핑 방지: Telegram Bot API가 from.id를 서버 측에서 검증 (봇 토큰 보안 범위 내에서 신뢰 가능)

  **섹션 7: Bot 관리 인터페이스**
  - Bot 시작/중지: 데몬 설정 (config.toml [telegram_bot]) 또는 런타임 API
  - 설정 항목:
    - enabled: boolean (기본 false)
    - bot_token: string (BotFather에서 발급)
    - owner_chat_id: string (자동 등록 via /auth)
    - direct_approve_enabled: boolean (기본 false)
    - direct_approve_threshold: string (기본 '0' -- 비활성)
  - Bot 토큰 보안: notification_channels 테이블에 저장, API 응답 시 마지막 4자만 노출

  </action>
  <verify>
  - 40-telegram-bot-docker.md 파일이 존재하고 문서 ID가 TGBOT-DOCK
  - 봇 명령어 8개가 동작/인증/응답 형식으로 정의됨
  - 인라인 키보드 승인/거부가 callback_data 형식 + 서버 검증으로 설계됨
  - 2-Tier 승인 모델이 Tier 1 (chatId) / Tier 2 (ownerAuth) 로 구분됨
  - Long Polling 루프가 native fetch 기반으로 설계됨
  - chatId 인증 + /auth 등록 플로우가 정의됨
  </verify>
  <done>Telegram Bot 명령 체계, 인라인 키보드, 2-tier 인증 모델이 구현 가능한 수준으로 설계됨. TGBOT-01, TGBOT-02 충족.</done>
</task>

<task type="auto">
  <name>Task 2: Docker 배포 스펙 (Dockerfile + docker-compose + 볼륨 + 시크릿)</name>
  <files>.planning/deliverables/40-telegram-bot-docker.md</files>
  <action>
  40-telegram-bot-docker.md에 다음 섹션을 추가한다.

  **섹션 8: Docker 배포 아키텍처 (DOCK-01)**

  8.1 Docker 이미지 설계:
  - Base image: node:22-alpine (LTS, 최소 크기)
  - Multi-stage build:
    - Stage 1 (builder): pnpm install + build (전체 모노레포)
    - Stage 2 (production): 빌드 결과물만 복사, devDependencies 제외
  - Non-root user: waiaas (uid 1001, gid 1001) -- 보안 최소 권한
  - Expose: 3100 (localhost 전용)

  8.2 Dockerfile 상세:
  ```dockerfile
  # Stage 1: Build
  FROM node:22-alpine AS builder
  WORKDIR /app
  RUN corepack enable
  COPY pnpm-workspace.yaml pnpm-lock.yaml package.json ./
  COPY packages/ ./packages/
  RUN pnpm install --frozen-lockfile
  RUN pnpm --filter @waiaas/daemon build

  # Stage 2: Production
  FROM node:22-alpine AS production
  RUN addgroup -g 1001 -S waiaas && adduser -S waiaas -u 1001 -G waiaas
  WORKDIR /app
  COPY --from=builder --chown=waiaas:waiaas /app/packages/daemon/dist ./dist
  COPY --from=builder --chown=waiaas:waiaas /app/node_modules ./node_modules
  USER waiaas
  EXPOSE 3100
  HEALTHCHECK --interval=30s --timeout=5s --retries=3 --start-period=10s \
    CMD wget --no-verbose --tries=1 --spider http://127.0.0.1:3100/health || exit 1
  CMD ["node", "dist/index.js"]
  ```

  8.3 native addon 고려:
  - sodium-native: Alpine에서 빌드 필요 (apk add python3 make g++ -- builder stage에서)
  - better-sqlite3: Alpine에서 빌드 필요 (동일)
  - .dockerignore: node_modules, .git, .planning, *.md 제외

  **섹션 9: docker-compose.yml 스펙**
  ```yaml
  version: '3.8'

  services:
    waiaas:
      build:
        context: .
        dockerfile: Dockerfile
        target: production
      container_name: waiaas-daemon
      restart: unless-stopped
      ports:
        - "127.0.0.1:3100:3100"   # localhost만 바인딩 (0.0.0.0 금지)
      volumes:
        - waiaas-data:/home/node/.waiaas  # named volume (bind mount 금지)
      environment:
        - NODE_ENV=production
        - WAIAAS_DAEMON_PORT=3100
        - WAIAAS_MASTER_PASSWORD_FILE=/run/secrets/master_password
        - WAIAAS_WALLETCONNECT_PROJECT_ID=${WALLETCONNECT_PROJECT_ID:-}
      secrets:
        - master_password
      healthcheck:
        test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:3100/health"]
        interval: 30s
        timeout: 5s
        retries: 3
        start_period: 10s

  volumes:
    waiaas-data:
      driver: local

  secrets:
    master_password:
      file: ./secrets/master_password.txt
  ```

  **섹션 10: 볼륨 + 데이터 영속화**

  10.1 Named Volume 필수:
  - 경로: /home/node/.waiaas (컨테이너 내부)
  - 포함 데이터: SQLite DB (wallet.db, -wal, -shm), 키스토어 파일, config.toml, 로그
  - bind mount 금지 이유: SQLite WAL 모드 + macOS Docker Desktop VirtioFS 호환성 문제 (09-RESEARCH Pitfall 6)

  10.2 백업:
  - `docker run --rm -v waiaas-data:/data -v $(pwd):/backup alpine tar czf /backup/waiaas-backup.tar.gz -C /data .`
  - 복원: tar xzf -> named volume
  - 자동 백업 cron 예시 (docker-compose.yml에 별도 서비스 추가 가능성 언급)

  10.3 초기 설정:
  - 첫 실행 시 waiaas init 자동 실행 여부: Docker entrypoint에서 ~/.waiaas/config.toml 존재 확인
  - 미존재 시: `waiaas init --non-interactive --master-password-file /run/secrets/master_password` 실행
  - 이후: `waiaas start` 실행

  **섹션 11: Docker Secrets + 환경변수 관리**

  11.1 시크릿 (docker-compose secrets):
  - master_password: 키스토어 마스터 패스워드 (파일 기반)
  - 컨테이너 내부 경로: /run/secrets/master_password
  - 데몬이 WAIAAS_MASTER_PASSWORD_FILE 환경변수로 파일 경로 인식 -> fs.readFileSync() -> trim()
  - 환경변수로 직접 전달 금지: `docker inspect`에 노출됨

  11.2 환경변수:
  | 변수 | 필수 | 기본값 | 설명 |
  |------|------|--------|------|
  | NODE_ENV | no | production | 환경 |
  | WAIAAS_DAEMON_PORT | no | 3100 | 데몬 포트 |
  | WAIAAS_MASTER_PASSWORD_FILE | yes | - | 마스터 패스워드 파일 경로 |
  | WAIAAS_WALLETCONNECT_PROJECT_ID | no | - | WalletConnect 프로젝트 ID |
  | WAIAAS_TELEGRAM_BOT_TOKEN_FILE | no | - | Telegram Bot 토큰 파일 경로 |
  | WAIAAS_LOG_LEVEL | no | info | 로그 레벨 |

  11.3 `.env` 파일 예시:
  ```
  WALLETCONNECT_PROJECT_ID=abc123...
  ```

  **섹션 12: Docker 네트워킹 + 보안**
  - ports: "127.0.0.1:3100:3100" (0.0.0.0 바인딩 절대 금지)
  - 컨테이너 내부에서도 127.0.0.1 바인딩 (Hono config 동일)
  - 외부 접근 필요 시: SSH 터널 또는 reverse proxy (설계 문서에 예시)
  - SSH 터널 예시: `ssh -L 3100:127.0.0.1:3100 user@server`
  - Docker network: 기본 bridge (다른 컨테이너와 통신 불필요)

  **섹션 13: Docker 라이프사이클**
  - 시작: `docker compose up -d`
  - 중지: `docker compose down` (graceful -- SIGTERM -> 10-step shutdown)
  - 로그: `docker compose logs -f waiaas`
  - 업데이트: `docker compose pull && docker compose up -d` (named volume 유지)
  - healthcheck: wget /health 30초 주기 (Docker가 unhealthy 자동 감지)
  - restart: unless-stopped (크래시 시 자동 재시작, 수동 stop 시 유지)

  **섹션 14: Telegram Bot + Docker 통합 시나리오**
  - Docker 내에서 Telegram Bot 활성화:
    1. WAIAAS_TELEGRAM_BOT_TOKEN_FILE=/run/secrets/telegram_bot_token secret 추가
    2. docker-compose.yml에 telegram_bot_token secret 추가
    3. 데몬 시작 시 Bot 자동 활성화 (config 설정)
  - Bot Long Polling은 Docker 내부에서 외부(api.telegram.org)로 outbound HTTP만 필요 (인바운드 포트 불필요)

  **섹션 15: 보안 고려사항**
  - Non-root 사용자 (waiaas:1001)
  - Read-only filesystem 옵션: `read_only: true` + tmpfs for /tmp (권장)
  - Docker image 서명: Docker Content Trust (DCT) 또는 cosign
  - 이미지 취약점 스캔: Trivy or Snyk (CI 통합)
  - named volume 암호화: Docker volume driver 또는 OS-level disk encryption에 의존
  - 시크릿 파일 권한: 600 (owner read only)

  </action>
  <verify>
  - Docker multi-stage Dockerfile이 builder + production 2단계로 정의됨
  - docker-compose.yml이 named volume + secrets + healthcheck로 정의됨
  - 환경변수 테이블이 필수/선택/기본값으로 정리됨
  - SQLite WAL + named volume 호환성이 언급됨
  - Docker 보안 (non-root, localhost binding, secrets)이 정의됨
  - Telegram Bot + Docker 통합 시나리오가 포함됨
  </verify>
  <done>Docker 배포 스펙이 Dockerfile + docker-compose + 볼륨 + 시크릿 + 보안으로 완성됨. DOCK-01 충족. TGBOT-DOCK 문서 완성.</done>
</task>

</tasks>

<verification>
1. 40-telegram-bot-docker.md가 .planning/deliverables/에 존재
2. TGBOT-01: 인라인 키보드 거래 승인/거부 + callback_data 형식 + 서버 검증이 설계됨
3. TGBOT-02: 봇 명령어 8개 (/start, /auth, /status, /sessions, /revoke, /killswitch, /pending, /help)가 정의됨
4. DOCK-01: Dockerfile (multi-stage) + docker-compose (named volume, secrets, healthcheck)가 정의됨
5. 2-Tier 승인 모델이 Telegram 인증 갭을 해결함
6. Docker 보안 (non-root, localhost, secrets file)이 정의됨
7. Telegram Bot + Docker 통합이 설계됨
</verification>

<success_criteria>
- Telegram Bot이 8개 명령어 + 인라인 키보드 + 2-tier 인증으로 설계됨
- Docker가 Dockerfile + docker-compose + 15개 섹션으로 완성됨
- Phase 9 Success Criteria #5 충족
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration-client-interface-design/09-04-SUMMARY.md`
</output>
