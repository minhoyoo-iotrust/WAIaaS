---
phase: 211-api-wallet-selection
plan: 02
type: execute
wave: 2
depends_on: ["211-01"]
files_modified:
  - packages/daemon/src/api/routes/wallet.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/routes/x402.ts
  - packages/daemon/src/api/routes/actions.ts
  - packages/daemon/src/api/routes/wc.ts
  - packages/daemon/src/__tests__/wallet-id-selection.test.ts
autonomous: true
requirements: [API-02, API-03]

must_haves:
  truths:
    - "GET 요청에서 ?walletId= 쿼리 파라미터로 특정 지갑을 지정할 수 있다"
    - "POST/PUT 요청에서 body walletId 필드로 특정 지갑을 지정할 수 있다"
    - "walletId 미지정 시 기본 지갑이 자동 선택되어 기존 코드가 무변경으로 동작한다"
    - "모든 지갑 스코프 엔드포인트가 resolveWalletId 헬퍼를 사용한다"
  artifacts:
    - path: "packages/daemon/src/api/routes/wallet.ts"
      provides: "GET /wallet/* 엔드포인트에 ?walletId= 쿼리 파라미터 지원"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "POST /transactions/send,sign body walletId + GET /transactions ?walletId= 쿼리"
    - path: "packages/daemon/src/api/routes/x402.ts"
      provides: "POST /x402/fetch body walletId 지원"
    - path: "packages/daemon/src/api/routes/actions.ts"
      provides: "POST /actions/:p/:a body walletId 지원"
    - path: "packages/daemon/src/api/routes/wc.ts"
      provides: "WC session routes ?walletId= 쿼리 지원"
    - path: "packages/daemon/src/__tests__/wallet-id-selection.test.ts"
      provides: "walletId 선택 통합 테스트"
  key_links:
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/api/helpers/resolve-wallet-id.ts"
      via: "resolveWalletId import"
      pattern: "resolveWalletId"
    - from: "packages/daemon/src/api/routes/wallet.ts"
      to: "packages/daemon/src/api/helpers/resolve-wallet-id.ts"
      via: "resolveWalletId import"
      pattern: "resolveWalletId"
---

<objective>
모든 지갑 스코프 엔드포인트에서 c.get('walletId') 참조를 resolveWalletId() 호출로 교체하여, GET 요청은 ?walletId= 쿼리 파라미터, POST/PUT 요청은 body walletId 필드로 특정 지갑을 선택할 수 있게 한다.

Purpose: walletId 미지정 시 기본 지갑이 자동 선택되어 기존 API 호출이 무변경으로 동작하면서, 명시적 지갑 지정도 가능하게 한다.
Output: 5개 라우트 파일 변경, 통합 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/211-api-wallet-selection/211-01-SUMMARY.md
@packages/daemon/src/api/helpers/resolve-wallet-id.ts
@packages/daemon/src/api/routes/wallet.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/routes/x402.ts
@packages/daemon/src/api/routes/actions.ts
@packages/daemon/src/api/routes/wc.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: 전 엔드포인트 c.get('walletId') → resolveWalletId() 교체</name>
  <files>
    packages/daemon/src/api/routes/wallet.ts
    packages/daemon/src/api/routes/transactions.ts
    packages/daemon/src/api/routes/x402.ts
    packages/daemon/src/api/routes/actions.ts
    packages/daemon/src/api/routes/wc.ts
  </files>
  <action>
각 파일에 resolveWalletId를 import하고 `c.get('walletId' as never) as string` 패턴을 교체한다. deps.db를 함수에 전달한다.

**패턴 규칙:**
- GET/DELETE 요청: `resolveWalletId(c, deps.db)` -- query 파라미터에서 walletId를 자동 읽음
- POST/PUT 요청: body에서 walletId를 꺼내 `resolveWalletId(c, deps.db, body.walletId)` 전달

**wallet.ts** (4곳):
- walletAddressRoute (GET): `const walletId = resolveWalletId(c, deps.db);`
- walletBalanceRoute (GET): `const walletId = resolveWalletId(c, deps.db);`
- walletAssetsRoute (GET): `const walletId = resolveWalletId(c, deps.db);`
- walletDefaultNetworkRoute (PUT): `const body = c.req.valid('json'); const walletId = resolveWalletId(c, deps.db, body.walletId);`
  - 단, PUT body에서 walletId는 optional field. UpdateDefaultNetworkRequestSchema에 walletId 추가 불필요 -- body에서 raw JSON으로 읽거나, 직접 `await c.req.json()` 후 `json.walletId` 전달. 기존 Zod 스키마를 변경하지 않고 `c.req.raw` 접근이 복잡하므로, PUT /wallet/default-network의 경우 walletId는 body가 아닌 **query param**으로 받는 게 일관적이다. 하지만 설계 결정에 따라 POST/PUT은 body에서만 walletId를 받아야 한다. **해결**: body에서 `walletId`를 optional field로 추가하되, OpenAPIHono의 `c.req.valid('json')`에서 walletId를 뽑을 수 있도록 기존 스키마에 `.extend({ walletId: z.string().uuid().optional() })` 적용은 하지 않는다. 대신 raw body에서 추출: `const rawBody = await c.req.json(); const bodyWalletId = rawBody?.walletId;` 후 `resolveWalletId(c, deps.db, bodyWalletId)` 호출.
  - 실제로는 PUT /wallet/default-network은 세션 스코프 라우트이므로 walletId를 지정하지 않으면 기본 지갑이 자동 선택되며, 기존과 동일하게 동작한다.
  - **간단한 접근**: 기존 `c.req.valid('json')`의 Zod 스키마에는 walletId가 없으므로, valid body에서 walletId를 읽을 수 없다. 하지만 **query param으로 통일하면 안 된다** (설계 규칙 위반). 따라서 wallet.ts의 GET 라우트(address/balance/assets)는 `resolveWalletId(c, deps.db)` (query에서 자동 읽음)으로 처리하고, PUT default-network은 기본 지갑만 허용하는 것이 현실적이다 (별도 walletId 지정이 필요하면 PUT /wallets/:id/default-network 마스터Auth 라우트 사용).
  - **최종 결정**: wallet.ts의 GET 3개 라우트는 `resolveWalletId(c, deps.db)` 호출. PUT default-network은 `resolveWalletId(c, deps.db)` 호출 (query에서도 walletId를 읽을 수 있으므로, PUT이지만 실질적으로 세션 기본 지갑이나 query walletId 사용).

**transactions.ts** (5곳):
- sendTransactionRoute (POST): body에서 walletId 추출. `const request = await c.req.json(); const walletId = resolveWalletId(c, deps.db, request.walletId);` -- 기존 raw JSON 파싱 패턴 활용
- signTransactionRoute (POST): `const body = c.req.valid('json'); const walletId = resolveWalletId(c, deps.db, body.walletId);` -- TxSignRequestSchema에 walletId가 있으면 사용, 없으면 기본 지갑. **주의**: body.walletId가 Zod 스키마에 없으므로 raw body에서 추출: `const rawBody = await c.req.json(); resolveWalletId(c, deps.db, rawBody.walletId);`
  - **간단한 방법**: POST /transactions/send는 이미 `await c.req.json()`으로 raw body를 읽으므로 `request.walletId`를 자연스럽게 전달. POST /transactions/sign은 `c.req.valid('json')` 사용 중이므로 별도로 raw body를 읽어야 한다. 하지만 Hono에서 body를 두 번 읽을 수 없다. **실용적 해결**: `c.req.valid('json')` 결과에 walletId가 Zod passthrough로 없어도, `(c.req.valid('json') as any).walletId` 패턴으로 접근 불가 (strict Zod가 strip함). 따라서 sign에서는 `c.req.raw.clone()` 후 JSON 파싱하여 walletId 추출. 또는 더 간단하게 **TxSignRequestSchema에 optional walletId 필드 추가**가 가장 깔끔하다. 기존 스키마에 `.extend({ walletId: z.string().uuid().optional() })` 적용. 이를 다른 스키마에도 동일 적용.
  - **최종 결정**: 각 POST/PUT body 스키마를 수정하지 않고, **transactions/send는 이미 raw JSON을 읽으므로 request.walletId 전달, 나머지 POST 라우트는 c.req.header() 대신 request URL query에서 읽기가 불가능하므로**, POST body에서 walletId를 읽을 수 있도록 관련 Zod 스키마(openapi-schemas.ts)에 `walletId: z.string().uuid().optional()` 추가하지 않는다. 대신 각 POST 핸들러에서 `(await c.req.json()).walletId` 호출 전에 이미 `c.req.valid('json')` 호출이 있으면 body가 consumed 된다. Hono는 body를 한번만 읽을 수 있다.
  - **실용적 최종안**: **모든 POST 핸들러에서 기존 body 파싱 방식을 유지하되, 추가로 `c.req.query('walletId')`를 허용**하는 방식은 설계 원칙에 어긋난다. 따라서: POST /transactions/send는 raw `c.req.json()`을 사용하므로 `request.walletId` 바로 전달. POST /transactions/sign, POST /x402/fetch, POST /actions/:p/:a는 `c.req.valid('json')`을 사용하므로, **각 OpenAPI schema에 walletId optional field를 추가하는 것이 가장 깔끔하다**. openapi-schemas.ts에서:
    - `TxSignRequestSchema` → `.extend({ walletId: z.string().uuid().optional() })` 또는 스키마 원본에 추가
    - x402 FetchRoute body schema → walletId optional 추가
    - ActionExecuteRequestSchema → walletId optional 추가
  - 이렇게 하면 `c.req.valid('json').walletId`로 깔끔하게 접근 가능.

  **최종 접근법 (이것을 따를 것):**
  - POST /transactions/send: 이미 `await c.req.json()` 사용 → `request.walletId` 전달
  - POST /transactions/sign: TxSignRequestSchema에 `walletId: z.string().uuid().optional()` 추가 (openapi-schemas.ts)
  - POST /x402/fetch: x402FetchRoute 인라인 스키마에 `walletId: z.string().uuid().optional()` 추가
  - POST /actions/:p/:a: ActionExecuteRequestSchema에 `walletId: z.string().uuid().optional()` 추가
  - PUT /wallet/default-network: body 스키마 수정 대신 `resolveWalletId(c, deps.db)` 호출 (query walletId도 fallback으로 읽음)

- listTransactionsRoute (GET): `const walletId = resolveWalletId(c, deps.db);`
- pendingTransactionsRoute (GET): `const walletId = resolveWalletId(c, deps.db);`
- cancelTransactionRoute (POST): `const sessionWalletId = resolveWalletId(c, deps.db);` -- cancel은 body에 walletId가 없으므로 기본 지갑 사용. 하지만 cancel은 txId로 이미 지갑을 식별하므로 resolveWalletId 대신 기본 지갑 비교 로직 유지. **사실 cancel에서 walletId는 tx.walletId와 비교하는 용도**이므로, 여기서는 `c.get('defaultWalletId' as never)` 를 사용하는 것이 맞다. 하지만 일관성을 위해 resolveWalletId를 사용하되, cancel의 경우 body walletId가 없으므로 기본 지갑이 선택됨.
  - **주의**: cancel 핸들러에서는 tx.walletId와 세션의 walletId를 비교하여 자기 트랜잭션만 취소 가능하도록 한다. 멀티 지갑 시나리오에서는 세션의 어떤 지갑이든 tx.walletId와 일치하면 취소 허용해야 한다. 하지만 이는 API 변경이므로, 현재는 resolveWalletId로 결정된 walletId와 비교하는 기존 패턴 유지. cancel에서 특정 지갑 지정이 필요하면 body에 walletId를 추가할 수 있지만, 현 단계에서는 **cancel은 defaultWalletId만 사용**. 실제로는 cancel 시 tx를 먼저 찾고, 그 tx.walletId가 세션에 연결된 지갑인지 확인하는 것이 더 정확하다. **최종**: cancel에서는 `resolveWalletId(c, deps.db)` 호출이 아니라, tx.walletId가 세션에 연결된 지갑인지 session_wallets 조회로 확인. 이를 위해 별도 헬퍼 `verifyWalletAccess(sessionId, walletId, db)` 를 resolve-wallet-id.ts에 추가 export.

**x402.ts** (1곳):
- x402FetchRoute (POST): 인라인 body 스키마에 `walletId: z.string().uuid().optional()` 추가. `const body = c.req.valid('json'); const walletId = resolveWalletId(c, deps.db, body.walletId);`

**actions.ts** (1곳):
- executeActionRoute (POST): ActionExecuteRequestSchema에 `walletId: z.string().uuid().optional()` 추가 (actions.ts 내 인라인). `const walletId = resolveWalletId(c, deps.db, body.walletId);`

**wc.ts** (4곳 -- sessionAuth 스코프 라우트만):
- wcSessionRoutes의 `getWalletId` 헬퍼를 `resolveWalletId(c, deps.db)` 호출로 교체. deps에 db가 이미 있음.
- 4개 핸들러(pair, session get, session delete, pair status)에서 `getWalletId(c)` → `resolveWalletId(c, db)` 교체

**추가 변경 -- resolve-wallet-id.ts에 verifyWalletAccess 헬퍼 추가:**
```typescript
export function verifyWalletAccess(
  sessionId: string, walletId: string, db: BetterSQLite3Database
): void {
  const link = db.select().from(sessionWallets)
    .where(and(eq(sessionWallets.sessionId, sessionId), eq(sessionWallets.walletId, walletId)))
    .get();
  if (!link) throw new WAIaaSError('WALLET_ACCESS_DENIED');
}
```
transactions.ts cancel 핸들러에서 사용: tx 조회 후 `verifyWalletAccess(callerSessionId, tx.walletId, deps.db)` 호출하여 tx 소유 지갑이 세션에 연결되어 있는지 확인.

**openapi-schemas.ts 또는 인라인 스키마 변경:**
- TxSignRequestSchema: walletId optional field 추가
- x402 fetch 인라인 body: walletId optional field 추가
- ActionExecuteRequestSchema: walletId optional field 추가
  </action>
  <verify>
    `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/daemon` -- 전체 타입체크 통과 (walletId 참조가 모두 교체되었으므로 에러 0건 목표)
  </verify>
  <done>
    모든 지갑 스코프 엔드포인트(wallet 3개 GET + 1개 PUT, transactions 5개, x402 1개, actions 1개, wc 4개)가 resolveWalletId를 사용하여 walletId 선택적 파라미터를 지원한다. 미지정 시 기본 지갑이 자동 선택된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: walletId 선택 통합 테스트</name>
  <files>
    packages/daemon/src/__tests__/wallet-id-selection.test.ts
  </files>
  <action>
`packages/daemon/src/__tests__/wallet-id-selection.test.ts` 신규 생성.

테스트 환경:
- pushSchema()로 in-memory DB, 2개 지갑(walletA, walletB) 생성
- 세션 1개에 walletA(기본) + walletB 연결 (session_wallets)
- JWT 발급 (wlt: walletA.id)

테스트 케이스 (엔드포인트 통합 테스트):

1. **GET /v1/wallet/address (기본 지갑)**: walletId 미지정 → walletA 주소 반환
2. **GET /v1/wallet/address?walletId={walletB}**: walletB 주소 반환
3. **GET /v1/wallet/address?walletId={unlinked}**: WALLET_ACCESS_DENIED 403/401
4. **POST /v1/transactions/send { walletId: walletB.id, ... }**: walletB로 트랜잭션 생성 (DB 확인)
5. **POST /v1/transactions/send (walletId 미지정)**: walletA(기본)로 트랜잭션 생성
6. **GET /v1/transactions?walletId={walletB}**: walletB의 트랜잭션 목록 반환

테스트는 createApp()으로 전체 앱을 생성하여 실제 HTTP 요청 시뮬레이션. adapterPool은 모킹 또는 null로 처리 (balance/assets 테스트는 어댑터 필요하므로 address 테스트에 집중).

기존 테스트 패턴 참고: `packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts` (전체 앱 생성 + HTTP 요청)
  </action>
  <verify>
    `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/__tests__/wallet-id-selection.test.ts --reporter=verbose` -- 전체 통과
  </verify>
  <done>
    6+ 통합 테스트가 walletId 선택 로직을 검증: 기본 지갑 자동 선택, 쿼리 파라미터 지정, body 필드 지정, 미연결 지갑 거부.
  </done>
</task>

</tasks>

<verification>
- GET 요청에서 ?walletId= 쿼리로 특정 지갑 지정 가능
- POST/PUT 요청에서 body walletId로 특정 지갑 지정 가능
- walletId 미지정 시 기본 지갑 자동 선택
- 미연결 지갑 접근 시 WALLET_ACCESS_DENIED
- 모든 기존 테스트 통과 (backward compat)
- `pnpm turbo run typecheck --filter=@waiaas/daemon` 통과
</verification>

<success_criteria>
- 14+ 엔드포인트가 resolveWalletId를 사용
- 타입체크 에러 0건
- 6+ 통합 테스트 통과
- 기존 API 호출이 무변경으로 동작 (기본 지갑 자동 선택)
</success_criteria>

<output>
After completion, create `.planning/phases/211-api-wallet-selection/211-02-SUMMARY.md`
</output>
