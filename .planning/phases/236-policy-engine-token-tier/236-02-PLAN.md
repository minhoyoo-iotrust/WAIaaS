---
phase: 236-policy-engine-token-tier
plan: 02
type: tdd
wave: 2
depends_on: ["236-01"]
files_modified:
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
autonomous: true
requirements: [ENGN-03, ENGN-04, ENGN-05, ENGN-06, ENGN-07, ENGN-08, ENGN-09, ENGN-10]

must_haves:
  truths:
    - "evaluateSpendingLimit accepts tokenContext parameter and passes it to evaluateTokenTier"
    - "evaluateTokenTier matches CAIP-19 keys in correct priority order (exact -> native:chain -> native -> raw fallback)"
    - "TOKEN_TRANSFER with matching token_limits key is evaluated in human-readable units via decimal conversion"
    - "TRANSFER with native:chain or native key is evaluated using NATIVE_DECIMALS"
    - "No token_limits match falls back to raw fields, no raw fields skips native tier entirely"
    - "Final per-tx tier is maxTier(USD tier, token tier)"
    - "CONTRACT_CALL and BATCH skip token_limits evaluation"
    - "APPROVE + APPROVE_TIER_OVERRIDE skips evaluateSpendingLimit entirely"
    - "evaluateNativeTier returns INSTANT when raw fields are undefined (proper guards)"
  artifacts:
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateTokenTier function + evaluateSpendingLimit tokenContext extension + evaluateNativeTier undefined guards"
      contains: "evaluateTokenTier"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "Tests for token_limits evaluation, CAIP-19 matching, decimal conversion, fallback, and type-specific rules"
      contains: "token_limits"
  key_links:
    - from: "evaluateSpendingLimit"
      to: "evaluateTokenTier"
      via: "tokenContext parameter forwarding"
      pattern: "evaluateTokenTier"
    - from: "evaluateTokenTier"
      to: "NATIVE_DECIMALS"
      via: "decimal lookup for TRANSFER native tokens"
      pattern: "NATIVE_DECIMALS"
---

<objective>
Implement evaluateTokenTier() function with CAIP-19 key matching and human-readable decimal conversion, extend evaluateSpendingLimit() with tokenContext parameter, and fix evaluateNativeTier() undefined guards.

Purpose: Enable the policy engine to evaluate per-token spending limits using human-readable amounts instead of raw units, with correct CAIP-19 matching priority.
Output: Working token tier evaluation with comprehensive TDD test coverage.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/236-policy-engine-token-tier/236-01-SUMMARY.md
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/daemon/src/pipeline/resolve-effective-amount-usd.ts
@packages/daemon/src/__tests__/database-policy-engine.test.ts
@internal/objectives/m27-03-token-aware-spending-limit.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for evaluateTokenTier + evaluateSpendingLimit tokenContext</name>
  <files>packages/daemon/src/__tests__/database-policy-engine.test.ts</files>
  <action>
Add a new `describe('evaluateSpendingLimit with token_limits')` block in the test file. Create test policies with `token_limits` in their rules JSON. Tests should call the policy engine's `evaluate()` or `evaluateAndReserve()` methods with TransactionParam that includes tokenDecimals.

**Test cases to write (each as a separate `it()`):**

1. **TOKEN_TRANSFER with matching CAIP-19 key evaluated in human-readable units:**
   - Policy: `token_limits: { "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": { instant_max: "1000", notify_max: "5000", delay_max: "50000" } }`
   - Transaction: TOKEN_TRANSFER, amount "500000000" (500 USDC with 6 decimals), tokenDecimals=6, assetId matching
   - Expected: INSTANT tier (500 <= 1000)

2. **TOKEN_TRANSFER exceeding token_limits threshold returns NOTIFY:**
   - Same policy as above
   - Transaction: amount "2000000000" (2000 USDC with 6 decimals), tokenDecimals=6
   - Expected: NOTIFY tier (1000 < 2000 <= 5000)

3. **TRANSFER with native:solana key evaluated using NATIVE_DECIMALS:**
   - Policy: `token_limits: { "native:solana": { instant_max: "1", notify_max: "5", delay_max: "50" } }`
   - Transaction: TRANSFER, chain="solana", amount "2000000000" (2 SOL, 9 decimals)
   - Expected: NOTIFY tier (1 < 2 <= 5)

4. **TRANSFER with native shorthand key when policy has network:**
   - Policy with network="solana-mainnet": `token_limits: { "native": { instant_max: "1", notify_max: "10", delay_max: "100" } }`
   - Transaction: TRANSFER, chain="solana", amount "500000000" (0.5 SOL)
   - Expected: INSTANT tier (0.5 <= 1)

5. **No token_limits match falls back to raw fields:**
   - Policy with raw fields: `instant_max: "1000000000", notify_max: "5000000000", delay_max: "50000000000"` and `token_limits: { "native:ethereum": { ... } }` (mismatch for solana)
   - Transaction: TRANSFER, chain="solana", amount "2000000000"
   - Expected: uses raw fields, NOTIFY tier (1000000000 < 2000000000 <= 5000000000)

6. **No raw fields + no token_limits match -> USD only evaluation:**
   - Policy: no raw fields, no matching token_limits, has USD thresholds: `instant_max_usd: 100, notify_max_usd: 500`
   - Transaction: TRANSFER, amount "anything"
   - Expected: tier determined by USD only (native tier evaluation skipped)

7. **maxTier(USD tier, token tier) -- token tier is more conservative:**
   - Policy: `instant_max_usd: 1000` (USD says INSTANT) + `token_limits: { "native:solana": { instant_max: "0.1", notify_max: "1", delay_max: "10" } }` (token says NOTIFY)
   - Transaction: TRANSFER, chain="solana", amount "500000000" (0.5 SOL = ~$75 < $1000)
   - Expected: NOTIFY (max of INSTANT from USD, NOTIFY from token)

8. **APPROVE with CAIP-19 token_limits (no APPROVE_TIER_OVERRIDE):**
   - Policy: `token_limits: { "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": { instant_max: "100", notify_max: "1000", delay_max: "10000" } }`
   - Transaction: APPROVE, matching assetId, amount "500000000" (500 tokens, 6 decimals), tokenDecimals=6
   - Expected: NOTIFY (100 < 500 <= 1000)

9. **APPROVE + APPROVE_TIER_OVERRIDE skips token_limits:**
   - Same spending limit policy + APPROVE_TIER_OVERRIDE policy with tier "DELAY"
   - Transaction: APPROVE with matching token_limits key
   - Expected: DELAY (from override, token_limits never evaluated)

10. **CONTRACT_CALL skips token_limits:**
    - Policy with `token_limits: { "native:solana": { ... } }`
    - Transaction: CONTRACT_CALL, amount "5000000000"
    - Expected: uses raw fields or USD only, NOT token_limits

11. **evaluateNativeTier undefined guard -- raw fields undefined returns INSTANT:**
    - Policy: no raw fields, only token_limits (no match) and no USD
    - Transaction: any type with amount
    - Expected: native tier is INSTANT (skipped), not crash

**Test setup pattern:** Use the same in-memory SQLite + DatabasePolicyEngine setup as existing tests in the file. Insert SPENDING_LIMIT policies with appropriate rules JSON. Call `engine.evaluate(walletId, transactionParam)`.

Run tests and confirm ALL FAIL (RED phase).
  </action>
  <verify>
```bash
pnpm vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts --reporter=verbose 2>&1 | grep -E '(FAIL|PASS|token_limits)'
```
All new token_limits tests should FAIL (functions not yet implemented).
  </verify>
  <done>
11+ failing test cases covering token_limits evaluation, CAIP-19 matching, decimal conversion, fallback logic, type-specific rules, and undefined guards
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement evaluateTokenTier + evaluateSpendingLimit tokenContext + evaluateNativeTier guards</name>
  <files>packages/daemon/src/pipeline/database-policy-engine.ts</files>
  <action>
**1. Add NATIVE_DECIMALS constant** (duplicate from resolve-effective-amount-usd.ts to avoid cross-file dependency complexity):
```typescript
// Near top of file, after imports
const NATIVE_DECIMALS: Record<string, number> = {
  solana: 9,
  ethereum: 18,
};
```

**2. Fix evaluateNativeTier() (~line 1314):** Replace non-null assertions with proper undefined guards:
```typescript
private evaluateNativeTier(amountBig: bigint, rules: SpendingLimitRules): PolicyTier {
  // Phase 236: raw fields are now optional -- skip native tier if all undefined
  if (rules.instant_max === undefined && rules.notify_max === undefined && rules.delay_max === undefined) {
    return 'INSTANT'; // No raw thresholds -> permissive (USD/token_limits will handle)
  }

  const instantMax = rules.instant_max !== undefined ? BigInt(rules.instant_max) : 0n;
  const notifyMax = rules.notify_max !== undefined ? BigInt(rules.notify_max) : 0n;
  const delayMax = rules.delay_max !== undefined ? BigInt(rules.delay_max) : 0n;

  if (amountBig <= instantMax) return 'INSTANT';
  if (amountBig <= notifyMax) return 'NOTIFY';
  if (amountBig <= delayMax) return 'DELAY';
  return 'APPROVAL';
}
```

**3. Extend evaluateSpendingLimit() signature (~line 1279):** Add `tokenContext?` parameter:
```typescript
private evaluateSpendingLimit(
  resolved: PolicyRow[],
  amount: string,
  usdAmount?: number,
  tokenContext?: {
    type: string;
    tokenAddress?: string;
    tokenDecimals?: number;
    chain?: string;
    assetId?: string;
    policyNetwork?: string;
  },
): PolicyEvaluation | null
```

**4. Update evaluateSpendingLimit() body:** Replace the single `evaluateNativeTier` call with token-aware logic:
```typescript
// 1. Token-specific tier (NEW - Phase 236)
let tokenTier: PolicyTier = 'INSTANT';
if (tokenContext && rules.token_limits) {
  const tokenResult = this.evaluateTokenTier(BigInt(amount), rules, tokenContext);
  if (tokenResult !== null) {
    tokenTier = tokenResult;
  } else {
    // No token_limits match -> fall back to raw fields
    tokenTier = this.evaluateNativeTier(BigInt(amount), rules);
  }
} else {
  // No tokenContext or no token_limits -> use raw fields (existing behavior)
  tokenTier = this.evaluateNativeTier(BigInt(amount), rules);
}

// 2. USD tier (existing)
let finalTier = tokenTier;
if (usdAmount !== undefined && usdAmount > 0 && this.hasUsdThresholds(rules)) {
  const usdTier = this.evaluateUsdTier(usdAmount, rules);
  finalTier = maxTier(tokenTier, usdTier);
}
```

**5. Implement evaluateTokenTier() as a new private method:**
```typescript
/**
 * Evaluate token-specific tier using token_limits with CAIP-19 key matching.
 * Returns PolicyTier if a matching token limit is found, null otherwise (-> raw fallback).
 *
 * Matching priority:
 * 1. Exact CAIP-19 asset ID match (TOKEN_TRANSFER, APPROVE)
 * 2. "native:{chain}" match (TRANSFER)
 * 3. "native" shorthand match (TRANSFER, only when policy has network set)
 * 4. No match -> return null (caller falls back to raw fields)
 */
private evaluateTokenTier(
  amountBig: bigint,
  rules: SpendingLimitRules,
  tokenContext: {
    type: string;
    tokenAddress?: string;
    tokenDecimals?: number;
    chain?: string;
    assetId?: string;
    policyNetwork?: string;
  },
): PolicyTier | null {
  if (!rules.token_limits) return null;

  // Skip for CONTRACT_CALL and BATCH (they don't use token_limits)
  if (tokenContext.type === 'CONTRACT_CALL' || tokenContext.type === 'BATCH') {
    return null;
  }

  let matchedLimit: { instant_max: string; notify_max: string; delay_max: string } | undefined;
  let decimals: number | undefined;

  if (tokenContext.type === 'TOKEN_TRANSFER' || tokenContext.type === 'APPROVE') {
    // Try exact CAIP-19 asset ID match
    if (tokenContext.assetId && rules.token_limits[tokenContext.assetId]) {
      matchedLimit = rules.token_limits[tokenContext.assetId];
      decimals = tokenContext.tokenDecimals;
    }
  } else if (tokenContext.type === 'TRANSFER') {
    // Try "native:{chain}" match
    const nativeChainKey = tokenContext.chain ? `native:${tokenContext.chain}` : undefined;
    if (nativeChainKey && rules.token_limits[nativeChainKey]) {
      matchedLimit = rules.token_limits[nativeChainKey];
      decimals = tokenContext.chain ? NATIVE_DECIMALS[tokenContext.chain] : undefined;
    }
    // Fallback: try "native" shorthand (only when policy has a network set)
    if (!matchedLimit && tokenContext.policyNetwork && rules.token_limits['native']) {
      matchedLimit = rules.token_limits['native'];
      decimals = tokenContext.chain ? NATIVE_DECIMALS[tokenContext.chain] : undefined;
    }
  }

  if (!matchedLimit || decimals === undefined) {
    return null; // No match -> caller falls back to raw fields
  }

  // Convert raw amount to human-readable using decimals
  // amountBig is in smallest unit, divide by 10^decimals
  const divisor = 10n ** BigInt(decimals);
  // Use fixed-point comparison: multiply limit by divisor instead of dividing amount (avoids precision loss)
  const instantMaxRaw = parseDecimalToBigInt(matchedLimit.instant_max, decimals);
  const notifyMaxRaw = parseDecimalToBigInt(matchedLimit.notify_max, decimals);
  const delayMaxRaw = parseDecimalToBigInt(matchedLimit.delay_max, decimals);

  if (amountBig <= instantMaxRaw) return 'INSTANT';
  if (amountBig <= notifyMaxRaw) return 'NOTIFY';
  if (amountBig <= delayMaxRaw) return 'DELAY';
  return 'APPROVAL';
}
```

**6. Add parseDecimalToBigInt() helper** (file-level, near top or before evaluateTokenTier):
```typescript
/**
 * Parse a human-readable decimal string (e.g. "1.5", "1000") to raw bigint units.
 * Multiplies the value by 10^decimals for precise BigInt comparison.
 *
 * Examples:
 *   parseDecimalToBigInt("1.5", 9) -> 1500000000n (1.5 SOL in lamports)
 *   parseDecimalToBigInt("1000", 6) -> 1000000000n (1000 USDC in raw)
 */
function parseDecimalToBigInt(value: string, decimals: number): bigint {
  const parts = value.split('.');
  const integerPart = parts[0] ?? '0';
  let fractionalPart = parts[1] ?? '';

  // Pad or truncate fractional part to exactly `decimals` digits
  if (fractionalPart.length > decimals) {
    fractionalPart = fractionalPart.slice(0, decimals);
  } else {
    fractionalPart = fractionalPart.padEnd(decimals, '0');
  }

  return BigInt(integerPart + fractionalPart);
}
```

Run tests and confirm ALL pass (GREEN phase).
  </action>
  <verify>
```bash
pnpm vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts --reporter=verbose
```
All tests (both existing and new token_limits tests) should PASS.
Also run typecheck:
```bash
pnpm turbo run typecheck --filter=@waiaas/daemon
```
  </verify>
  <done>
- evaluateTokenTier() implemented with CAIP-19 matching priority (exact -> native:chain -> native -> null)
- evaluateSpendingLimit() extended with tokenContext parameter
- evaluateNativeTier() has proper undefined guards for optional raw fields
- parseDecimalToBigInt() helper for precision-safe decimal conversion
- All tests pass (existing + new token_limits tests)
- No type errors
  </done>
</task>

</tasks>

<verification>
1. All existing database-policy-engine tests still pass (regression)
2. All new token_limits tests pass (11+ test cases)
3. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
4. evaluateNativeTier no longer uses non-null assertions
5. evaluateTokenTier handles all 5 transaction types correctly
</verification>

<success_criteria>
- evaluateSpendingLimit accepts tokenContext and routes to evaluateTokenTier
- evaluateTokenTier matches CAIP-19 keys in priority order: exact -> native:chain -> native -> null (raw fallback)
- Human-readable decimal conversion is precision-safe via parseDecimalToBigInt
- CONTRACT_CALL and BATCH skip token_limits, APPROVE+OVERRIDE skips evaluateSpendingLimit entirely
- Raw field undefined does not crash (evaluateNativeTier returns INSTANT)
- Final per-tx tier = maxTier(USD tier, token/native tier)
- All tests green
</success_criteria>

<output>
After completion, create `.planning/phases/236-policy-engine-token-tier/236-02-SUMMARY.md`
</output>
