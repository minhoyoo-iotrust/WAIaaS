---
phase: 236-policy-engine-token-tier
plan: 03
type: execute
wave: 2
depends_on: ["236-01"]
files_modified:
  - packages/daemon/src/pipeline/database-policy-engine.ts
autonomous: true
requirements: [ENGN-03, ENGN-08, ENGN-09, ENGN-10]

must_haves:
  truths:
    - "evaluateSingle callsite passes tokenContext with type, tokenAddress, tokenDecimals, chain, assetId, policyNetwork"
    - "evaluateBatch callsite passes undefined for tokenContext (BATCH skips token_limits)"
    - "evaluateAndReserve callsite passes tokenContext identical to evaluateSingle"
    - "APPROVE_TIER_OVERRIDE still short-circuits before evaluateSpendingLimit, so token_limits is never reached"
  artifacts:
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "All 3 evaluateSpendingLimit callsites pass tokenContext"
      contains: "tokenContext"
  key_links:
    - from: "evaluate() line ~258"
      to: "evaluateSpendingLimit"
      via: "tokenContext constructed from transaction param"
      pattern: "tokenContext"
    - from: "evaluateBatch() line ~361"
      to: "evaluateSpendingLimit"
      via: "undefined tokenContext (BATCH skip)"
      pattern: "evaluateSpendingLimit.*undefined"
    - from: "evaluateAndReserve() line ~571"
      to: "evaluateSpendingLimit"
      via: "tokenContext from transaction param (same as evaluate)"
      pattern: "tokenContext"
---

<objective>
Wire tokenContext through all 3 evaluateSpendingLimit() callsites in database-policy-engine.ts, connecting the TransactionParam fields to the new tokenContext parameter.

Purpose: Complete the data flow so that evaluateSpendingLimit receives token context at all evaluation points, enabling token-specific limit evaluation for single transactions while correctly skipping it for batches.
Output: All 3 callsites passing tokenContext, completing the Phase 236 evaluation pipeline integration.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/236-policy-engine-token-tier/236-01-SUMMARY.md
@.planning/phases/236-policy-engine-token-tier/236-02-SUMMARY.md
@packages/daemon/src/pipeline/database-policy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire tokenContext at evaluateSingle callsite (line ~258)</name>
  <files>packages/daemon/src/pipeline/database-policy-engine.ts</files>
  <action>
In the `evaluate()` method (~line 257-258), find:
```typescript
const spendingResult = this.evaluateSpendingLimit(resolved, transaction.amount);
```

Replace with:
```typescript
// Step 5: Evaluate SPENDING_LIMIT with token context for token_limits evaluation
const spending = resolved.find((p) => p.type === 'SPENDING_LIMIT');
const spendingResult = this.evaluateSpendingLimit(resolved, transaction.amount, undefined, {
  type: transaction.type,
  tokenAddress: transaction.tokenAddress,
  tokenDecimals: transaction.tokenDecimals,
  chain: transaction.chain,
  assetId: transaction.assetId,
  policyNetwork: spending?.network ?? undefined,
});
```

Note: The `evaluate()` method does not receive `usdAmount`, so the 3rd arg stays `undefined`. The tokenContext is constructed directly from the TransactionParam fields. `policyNetwork` comes from the SPENDING_LIMIT policy's `network` column (for resolving `"native"` shorthand key).
  </action>
  <verify>
`pnpm turbo run typecheck --filter=@waiaas/daemon` passes. Grep for the change:
```bash
grep -n 'policyNetwork' packages/daemon/src/pipeline/database-policy-engine.ts
```
  </verify>
  <done>evaluateSingle callsite passes full tokenContext from TransactionParam fields</done>
</task>

<task type="auto">
  <name>Task 2: Wire tokenContext at evaluateBatch + evaluateAndReserve callsites</name>
  <files>packages/daemon/src/pipeline/database-policy-engine.ts</files>
  <action>
**1. evaluateBatch callsite (~line 361):**
Find:
```typescript
const amountTier = this.evaluateSpendingLimit(resolved, totalNativeAmount.toString(), batchUsdAmount);
```

This is BATCH evaluation. BATCH transactions should NOT use token_limits (per design: batch sums native amounts and evaluates against raw/USD only). Leave the 4th argument as `undefined` (omit it):
```typescript
// BATCH: token_limits not applicable -- aggregate native amount evaluated via raw/USD only
const amountTier = this.evaluateSpendingLimit(resolved, totalNativeAmount.toString(), batchUsdAmount);
```
Add a comment to make it explicit that the 4th arg (tokenContext) is intentionally omitted for BATCH. No code change needed here since the parameter is optional and already defaults to undefined.

**2. evaluateAndReserve callsite (~line 571):**
Find the existing call:
```typescript
const spendingResult = this.evaluateSpendingLimit(
  resolved,
  effectiveAmount.toString(),
  usdAmount,
);
```

Replace with:
```typescript
const spending = resolved.find((p) => p.type === 'SPENDING_LIMIT');
const spendingResult = this.evaluateSpendingLimit(
  resolved,
  effectiveAmount.toString(),
  usdAmount,
  {
    type: transaction.type,
    tokenAddress: transaction.tokenAddress,
    tokenDecimals: transaction.tokenDecimals,
    chain: transaction.chain,
    assetId: transaction.assetId,
    policyNetwork: spending?.network ?? undefined,
  },
);
```

Note: The `spending` variable may already exist from the earlier `const spendingPolicy = resolved.find(...)` on ~line 552. If so, reuse it instead of re-finding. Just use `spendingPolicy?.network ?? undefined` for policyNetwork. Check the variable name in context.

**3. Verify APPROVE_TIER_OVERRIDE short-circuit:**
Confirm that `approveTierResult` check (~line 251-254 in evaluate(), ~line 545-548 in evaluateAndReserve()) returns BEFORE reaching evaluateSpendingLimit. This is already the case (no code change needed), but add or verify the comment: `// FINAL result, skips SPENDING_LIMIT (including token_limits)`.

Run all tests to confirm nothing broke.
  </action>
  <verify>
```bash
pnpm vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts --reporter=verbose
pnpm turbo run typecheck --filter=@waiaas/daemon
```
All tests pass, no type errors.
  </verify>
  <done>
- evaluateBatch callsite explicitly omits tokenContext (BATCH skips token_limits)
- evaluateAndReserve callsite passes full tokenContext from TransactionParam
- APPROVE_TIER_OVERRIDE short-circuit documented as skipping token_limits
- All tests pass including new token_limits tests from plan 02
  </done>
</task>

</tasks>

<verification>
1. All 3 evaluateSpendingLimit callsites verified:
   - evaluate(): tokenContext from TransactionParam
   - evaluateBatch(): tokenContext omitted (undefined)
   - evaluateAndReserve(): tokenContext from TransactionParam
2. `pnpm vitest run packages/daemon/src/__tests__/database-policy-engine.test.ts` all pass
3. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
4. APPROVE_TIER_OVERRIDE short-circuit confirmed before evaluateSpendingLimit
</verification>

<success_criteria>
- tokenContext flows from TransactionParam to evaluateSpendingLimit at evaluate() and evaluateAndReserve() callsites
- BATCH evaluation explicitly skips token_limits (no tokenContext passed)
- APPROVE_TIER_OVERRIDE continues to short-circuit before SPENDING_LIMIT evaluation
- All existing and new tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/236-policy-engine-token-tier/236-03-SUMMARY.md`
</output>
