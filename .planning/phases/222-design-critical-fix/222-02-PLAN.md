---
phase: 222-design-critical-fix
plan: 02
type: execute
wave: 2
depends_on:
  - 222-01
files_modified:
  - docs/design/76-incoming-transaction-monitoring.md
autonomous: true
requirements:
  - GAP-2
  - GAP-3
  - FLOW-2

must_haves:
  truths:
    - "incoming_transactions DDL에 is_suspicious INTEGER NOT NULL DEFAULT 0 컬럼이 포함된다"
    - "v21 마이그레이션 CREATE TABLE에 is_suspicious 컬럼이 포함된다"
    - "§7.6 Summary SQL이 is_suspicious 컬럼을 사용하며 incoming_tx_suspicious 테이블 참조가 제거되었다"
    - "§8.9 Step 6에 incoming-tx-poll-solana, incoming-tx-poll-evm 2개 폴링 워커가 등록되어 있다"
    - "§3.7 SolanaIncomingSubscriber에 pollAll() 메서드가 정의되어 있다"
    - "§5.1 상태 머신에 POLLING 진입 시 폴링 워커 활성화 트리거가 명시되어 있다"
    - "FLOW-2 E2E 흐름(WS 실패 → 폴링 워커 활성화 → TX 감지 → DB 기록 → WS 복구)이 한 곳에 요약되어 있다"
  artifacts:
    - path: "docs/design/76-incoming-transaction-monitoring.md"
      provides: "GAP-2, GAP-3, FLOW-2 수정된 설계 문서"
      contains: "incoming-tx-poll-solana"
  key_links:
    - from: "§5.1 상태 머신 POLLING"
      to: "§8.9 incoming-tx-poll-* 워커"
      via: "connectionState === 'POLLING' 조건부 활성화"
      pattern: "connectionState.*POLLING"
    - from: "§2.1 DDL is_suspicious"
      to: "§7.6 Summary SQL"
      via: "is_suspicious 컬럼 참조"
      pattern: "is_suspicious"
    - from: "§8.9 폴링 워커"
      to: "§3.7/§4.7 pollAll()"
      via: "subscriber.pollAll() 호출"
      pattern: "pollAll\\(\\)"
---

<objective>
폴링 BackgroundWorker를 DaemonLifecycle에 등록하고, Summary SQL의 미정의 테이블 참조를 is_suspicious 컬럼으로 교체하며, FLOW-2 E2E 흐름을 완성한다.

Purpose: 폴링 워커 미등록(GAP-2)으로 인해 POLLING 상태에서 실제 TX 감지가 수행되지 않는 Critical 결함과, 존재하지 않는 테이블을 참조하는 Summary SQL(GAP-3) Critical 결함을 수정하고, WebSocket 실패에서 폴링 폴백까지의 E2E 흐름(FLOW-2)을 완성한다.
Output: docs/design/76-incoming-transaction-monitoring.md 내 §2.1, §2.6, §2.7, §3.7, §5.1, §5.2, §7.6, §8.9 섹션이 수정됨
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/222-design-critical-fix/222-RESEARCH.md
@.planning/phases/222-design-critical-fix/222-01-SUMMARY.md
@docs/design/76-incoming-transaction-monitoring.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: is_suspicious 컬럼 추가 (DDL + 마이그레이션 + INSERT + Summary SQL)</name>
  <files>docs/design/76-incoming-transaction-monitoring.md</files>
  <action>
GAP-3 수정: 존재하지 않는 incoming_tx_suspicious 테이블 참조를 is_suspicious 컬럼으로 교체한다. 4개 섹션을 일관되게 수정한다.

**§2.1 incoming_transactions DDL (L151-168 부근):**
`confirmed_at INTEGER,` 줄 다음, `UNIQUE(tx_hash, wallet_id)` 줄 전에 다음 컬럼을 추가:

```sql
  is_suspicious INTEGER NOT NULL DEFAULT 0,             -- 의심 TX 플래그 (IIncomingSafetyRule 판정)
```

**§2.6 flush 패턴 (222-01에서 수정된 상태 기준):**
flush() 내부의 INSERT 문에 is_suspicious 컬럼을 추가한다.

INSERT 문의 컬럼 목록:
```sql
INSERT INTO incoming_transactions
  (id, tx_hash, wallet_id, from_address, amount, token_address,
   chain, network, status, block_number, detected_at, is_suspicious)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(tx_hash, wallet_id) DO NOTHING
```

stmt.run 호출에 `tx.isSuspicious ?? 0`을 마지막 인자로 추가.

flush() 아래에 다음 설명을 추가:
```
**참고:** is_suspicious는 IncomingTxQueue.push() 시점에는 0으로 설정.
IIncomingSafetyRule 평가는 flush 후 별도 단계에서 수행하며,
의심 판정 시 UPDATE incoming_transactions SET is_suspicious = 1 WHERE id = ? 실행.
```

**§2.7 v21 마이그레이션 (L333-349 부근):**
CREATE TABLE incoming_transactions 내 `confirmed_at INTEGER,` 줄 다음에 추가:

```sql
        is_suspicious INTEGER NOT NULL DEFAULT 0,
```

**§7.6 Summary SQL (L1897-1911 부근):**
기존 서브쿼리를 is_suspicious 컬럼으로 교체:

기존:
```sql
COUNT(CASE WHEN id IN (SELECT incoming_tx_id FROM incoming_tx_suspicious) THEN 1 END) AS suspicious_count
```

수정:
```sql
COUNT(CASE WHEN is_suspicious = 1 THEN 1 END) AS suspicious_count
```

그리고 §7.6 끝의 "참고: 의심 TX 카운트를 위해 별도 테이블이 필요할 수 있으나..." 코멘트 문단을 삭제한다 (결정 완료되었으므로). 대신 다음으로 교체:

```
**참고:** is_suspicious 컬럼은 §2.1 DDL에 정의. IIncomingSafetyRule(§6.5) 평가 후 UPDATE로 설정.
```

주의사항:
- §2.1, §2.6, §2.7, §7.6 네 곳의 is_suspicious 참조가 모두 일관되어야 한다.
- IncomingTransaction 타입(§1.2)에는 is_suspicious를 추가하지 않는다 (DB 전용 필드 — Research의 Open Question 2번 결정 따름).
  </action>
  <verify>
docs/design/76-incoming-transaction-monitoring.md에서 다음을 확인:
1. §2.1 DDL에 `is_suspicious INTEGER NOT NULL DEFAULT 0` 컬럼 존재
2. §2.6 INSERT 문에 is_suspicious 컬럼 포함
3. §2.7 v21 마이그레이션 CREATE TABLE에 is_suspicious 포함
4. §7.6 SQL에 `COUNT(CASE WHEN is_suspicious = 1 THEN 1 END) AS suspicious_count` 존재
5. §7.6에 `incoming_tx_suspicious` 테이블 참조가 없음
6. §7.6 끝의 "구현 시 결정" 코멘트가 삭제됨
7. §1.2 IncomingTransaction 타입에 is_suspicious가 추가되지 않음
  </verify>
  <done>is_suspicious 컬럼이 §2.1 DDL, §2.6 INSERT, §2.7 마이그레이션, §7.6 Summary SQL에서 일관되게 사용되며, 미정의 incoming_tx_suspicious 테이블 참조가 완전히 제거됨</done>
</task>

<task type="auto">
  <name>Task 2: 폴링 BackgroundWorker 등록 + SolanaIncomingSubscriber pollAll() + FLOW-2 E2E 완성</name>
  <files>docs/design/76-incoming-transaction-monitoring.md</files>
  <action>
GAP-2 + FLOW-2 수정: 폴링 워커를 §8.9에 등록하고, SolanaIncomingSubscriber에 pollAll()을 추가하며, FLOW-2 E2E 흐름을 완성한다.

**§3.7 SolanaIncomingSubscriber (L631-702 부근):**
destroy() 메서드 위, 222-01에서 추가된 waitForDisconnect() 아래에 pollAll() 메서드를 추가:

```typescript
  /**
   * 폴링 모드에서 BackgroundWorkers가 호출.
   * 구독 중인 모든 지갑에 대해 getSignaturesForAddress 폴링 수행.
   * §3.5의 pollSolanaTransactions 로직을 클래스 메서드로 통합.
   */
  async pollAll(): Promise<void> {
    for (const [walletId, sub] of this.subscriptions) {
      try {
        const cursor = await getCursor(walletId); // incoming_tx_cursors에서 조회
        const signatures = await pollSolanaTransactions(
          this.rpc, sub.address, cursor?.lastSignature ?? null,
        );

        for (const sig of signatures) {
          const txDetail = await this.rpc.getTransaction(sig, {
            commitment: 'confirmed',
            maxSupportedTransactionVersion: 0,
          }).send();

          if (txDetail) {
            const parsed = this.parseTransaction(txDetail, walletId, sub.network);
            if (parsed) sub.onTransaction(parsed);
          }
        }

        // 커서 업데이트
        if (signatures.length > 0) {
          await updateCursor(walletId, { lastSignature: signatures[signatures.length - 1] });
        }
      } catch (err) {
        // Per-wallet error isolation
        console.warn(`Solana poll failed for wallet ${walletId}:`, err);
      }
    }
  }
```

§3.5 끝에 다음 참고를 추가:
```
**참고:** 이 standalone 함수는 §3.7 SolanaIncomingSubscriber.pollAll() 내부에서 호출된다.
pollAll()이 구독된 모든 지갑을 순회하면서 per-wallet 단위로 이 함수를 사용.
```

**§8.9 DaemonLifecycle Step 6 (L2131-2135 부근):**
기존 Step 6의 4개 워커 목록 뒤에 2개 폴링 워커를 추가:

기존:
```
Step 6: BackgroundWorkers
  ├── incoming-tx-flush (5초, 메모리 큐 → DB)
  ├── incoming-tx-retention (1시간, 보존 정책)
  ├── incoming-tx-confirm-solana (30초, DETECTED → CONFIRMED)
  └── incoming-tx-confirm-evm (30초, DETECTED → CONFIRMED)
```

수정:
```
Step 6: BackgroundWorkers
  ├── incoming-tx-flush (5초, 메모리 큐 → DB)
  ├── incoming-tx-retention (1시간, 보존 정책)
  ├── incoming-tx-confirm-solana (30초, DETECTED → CONFIRMED)
  ├── incoming-tx-confirm-evm (30초, DETECTED → CONFIRMED)
  ├── incoming-tx-poll-solana (incoming_poll_interval, POLLING 상태에서만 활성)
  └── incoming-tx-poll-evm (incoming_poll_interval, POLLING 상태에서만 활성)
```

그리고 §8.9 끝에 폴링 워커 등록 코드를 추가:

```typescript
// POLLING 상태일 때만 실행하는 폴링 워커
workers.register('incoming-tx-poll-solana', {
  interval: config.incoming.incoming_poll_interval * 1000, // 기본 30초
  handler: async () => {
    if (multiplexer.connectionState !== 'POLLING') return; // WEBSOCKET 상태에서는 skip
    await solanaSubscriber.pollAll();
  },
});

workers.register('incoming-tx-poll-evm', {
  interval: config.incoming.incoming_poll_interval * 1000,
  handler: async () => {
    if (multiplexer.connectionState !== 'POLLING') return; // WEBSOCKET 상태에서는 skip
    await evmSubscriber.pollAll();
  },
});
```

**§5.1 상태 머신 (L1040-1051 부근):**
상태 전환 규칙 테이블 아래에 폴링 워커 활성화 트리거를 명시:

```
**폴링 워커 연동:**
- `→ POLLING` 진입: incoming-tx-poll-solana, incoming-tx-poll-evm 워커가 다음 interval부터 pollAll() 실행 시작.
  워커 handler 내부에서 `multiplexer.connectionState === 'POLLING'` 조건을 확인하여 활성화.
- `→ WEBSOCKET` 복귀: 폴링 워커가 connectionState 체크에서 skip 처리되어 자동 비활성화.
  별도 unregister 불필요 — 워커는 항상 등록된 상태이며, 조건부 실행으로 제어.
```

**§5.2 재연결 루프 (L1082-1107 부근):**
reconnectLoop 코드 블록 다음에 FLOW-2 E2E 흐름 요약을 추가:

```
**WebSocket → 폴링 폴백 E2E 흐름 (FLOW-2):**

```
1. WS 연결 실패
   → reconnectLoop에서 subscriber.connect() throw
   → attempt++ (3회까지 재시도)

2. 3회 실패 시 폴링 전환
   → onStateChange('POLLING')
   → multiplexer.connectionState = 'POLLING'

3. 폴링 워커 활성화
   → incoming-tx-poll-{chain} 워커의 다음 interval에서 connectionState 체크 통과
   → subscriber.pollAll() 실행
   → getSignaturesForAddress(Solana) / getLogs(EVM) 호출

4. TX 감지 → DB 기록
   → pollAll()에서 감지된 TX → onTransaction 콜백 → memoryQueue.push()
   → incoming-tx-flush 워커(5초)가 큐 → DB 기록
   → eventBus.emit('transaction:incoming', IncomingTxEvent) per TX

5. WS 재연결 성공 시 복귀
   → reconnectLoop 백그라운드 재시도에서 subscriber.connect() 성공
   → onStateChange('WEBSOCKET')
   → 폴링 워커 자동 비활성화 (connectionState 체크에서 skip)
   → 블라인드 구간 복구: 마지막 커서 이후 gap 보상 폴링 1회 실행
```
```

주의사항:
- pollAll()은 IChainSubscriber 인터페이스에 추가하지 않는다 (Research Open Question 1번 결정: 구현체 전용 메서드로 유지).
- 폴링 워커는 항상 등록된 상태이되, handler 내부에서 connectionState 체크로 조건부 실행한다.
- §3.5의 standalone pollSolanaTransactions 함수는 삭제하지 않고 "§3.7에서 호출" 참조만 추가한다.
  </action>
  <verify>
docs/design/76-incoming-transaction-monitoring.md에서 다음을 확인:
1. §3.7 SolanaIncomingSubscriber에 pollAll() 메서드 존재
2. §8.9 Step 6 목록에 incoming-tx-poll-solana, incoming-tx-poll-evm 포함 (총 6개 워커)
3. §8.9에 폴링 워커 등록 코드가 connectionState 체크 포함
4. §5.1에 "폴링 워커 연동" 섹션 추가
5. §5.2에 FLOW-2 E2E 흐름 요약 추가
6. §3.5 끝에 "§3.7에서 호출" 참조 추가
7. pollAll()이 IChainSubscriber 인터페이스(§1.4)에 추가되지 않음
  </verify>
  <done>§8.9에 2개 폴링 워커가 등록되고, §3.7에 pollAll()이 추가되고, §5.1에 폴링 워커 연동이 명시되고, §5.2에 FLOW-2 E2E 흐름이 완성됨</done>
</task>

</tasks>

<verification>
GAP-2 검증:
- §8.9 Step 6에 incoming-tx-poll-solana, incoming-tx-poll-evm 워커가 등록 확인
- 워커 handler에 connectionState === 'POLLING' 조건 체크 확인
- §3.7 SolanaIncomingSubscriber에 pollAll() 메서드 확인

GAP-3 검증:
- §2.1 DDL에 is_suspicious 컬럼 확인
- §2.6 INSERT에 is_suspicious 포함 확인
- §2.7 마이그레이션에 is_suspicious 포함 확인
- §7.6 SQL에서 is_suspicious 컬럼 사용 + incoming_tx_suspicious 참조 제거 확인

FLOW-2 검증:
- §5.1에 POLLING 진입/이탈 시 폴링 워커 활성화/비활성화 설명 확인
- §5.2에 FLOW-2 E2E 흐름 요약(5단계) 확인
- E2E 흐름이 WS 실패 → 폴링 활성화 → TX 감지 → DB 기록 → WS 복귀까지 빠짐없이 커버 확인
</verification>

<success_criteria>
1. incoming_transactions DDL, INSERT, 마이그레이션, Summary SQL에서 is_suspicious가 일관되게 사용된다
2. incoming_tx_suspicious 테이블 참조가 문서 전체에서 완전히 제거되었다
3. §8.9 Step 6에 6개 BackgroundWorkers가 등록되어 있다 (기존 4 + 폴링 2)
4. SolanaIncomingSubscriber에 pollAll() 메서드가 정의되어 있다
5. FLOW-2 E2E 흐름이 WS 실패부터 WS 복귀까지 5단계로 요약되어 있다
6. POLLING 상태에서만 폴링 워커가 활성화되는 메커니즘이 명시되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/222-design-critical-fix/222-02-SUMMARY.md`
</output>
