---
phase: 73-notification-log-infra
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/enums/notification.ts
  - packages/core/src/enums/index.ts
  - packages/daemon/src/infrastructure/database/schema.ts
  - packages/daemon/src/infrastructure/database/migrate.ts
  - packages/daemon/src/infrastructure/database/index.ts
  - packages/daemon/src/notifications/notification-service.ts
  - packages/daemon/src/__tests__/notification-log.test.ts
autonomous: true

must_haves:
  truths:
    - "notification_logs 테이블이 데몬 시작 시 CREATE TABLE IF NOT EXISTS로 생성된다"
    - "schema_version 테이블이 존재하고 notification_logs 마이그레이션 버전이 기록된다"
    - "NotificationService.notify() 성공 시 notification_logs에 status='sent' + channel명이 기록된다"
    - "NotificationService.notify() 실패 시 notification_logs에 status='failed' + error 메시지가 기록된다"
    - "broadcast 이벤트는 각 채널별로 개별 로그 레코드가 생성된다"
    - "기존 847 테스트가 깨지지 않는다"
  artifacts:
    - path: "packages/daemon/src/infrastructure/database/schema.ts"
      provides: "notificationLogs Drizzle 테이블 정의"
      contains: "notificationLogs"
    - path: "packages/daemon/src/infrastructure/database/migrate.ts"
      provides: "notification_logs CREATE TABLE IF NOT EXISTS + schema_version 테이블"
      contains: "notification_logs"
    - path: "packages/daemon/src/notifications/notification-service.ts"
      provides: "notify()에서 발송 결과를 notification_logs에 기록하는 로직"
      contains: "notificationLogs"
    - path: "packages/daemon/src/__tests__/notification-log.test.ts"
      provides: "notification_logs 마이그레이션 + 로깅 통합 테스트"
      min_lines: 80
    - path: "packages/core/src/enums/notification.ts"
      provides: "NOTIFICATION_LOG_STATUSES enum 배열"
      contains: "NOTIFICATION_LOG_STATUSES"
  key_links:
    - from: "packages/daemon/src/infrastructure/database/migrate.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "notification_logs DDL matches Drizzle schema"
      pattern: "notification_logs"
    - from: "packages/daemon/src/notifications/notification-service.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "db.insert(notificationLogs)"
      pattern: "notificationLogs"
    - from: "packages/daemon/src/infrastructure/database/index.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "barrel export notificationLogs"
      pattern: "notificationLogs"
---

<objective>
notification_logs 테이블 스키마를 정의하고, 증분 마이그레이션으로 생성하며, NotificationService의 notify()가 발송 결과(성공/실패)를 자동으로 DB에 기록하도록 통합한다.

Purpose: 알림 발송 이력을 DB에 저장하여, Phase 75의 어드민 알림 로그 조회 API와 UI의 데이터 소스를 확보한다.
Output: notification_logs 테이블 + NotificationService 로깅 통합 + 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/infrastructure/database/migrate.ts
@packages/daemon/src/infrastructure/database/connection.ts
@packages/daemon/src/infrastructure/database/index.ts
@packages/daemon/src/infrastructure/database/id.ts
@packages/daemon/src/notifications/notification-service.ts
@packages/daemon/src/__tests__/notification-service.test.ts
@packages/core/src/enums/notification.ts
@packages/core/src/enums/index.ts
@packages/daemon/src/lifecycle/daemon.ts
@objectives/v1.3.4-notification-trigger-integration.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: notification_logs 테이블 스키마 + 증분 마이그레이션</name>
  <files>
    packages/core/src/enums/notification.ts
    packages/core/src/enums/index.ts
    packages/daemon/src/infrastructure/database/schema.ts
    packages/daemon/src/infrastructure/database/migrate.ts
    packages/daemon/src/infrastructure/database/index.ts
  </files>
  <action>
**1. @waiaas/core enum 추가** (`packages/core/src/enums/notification.ts`):

기존 파일 끝에 NOTIFICATION_LOG_STATUSES 배열 + 타입 + Zod enum을 추가한다:

```typescript
export const NOTIFICATION_LOG_STATUSES = ['sent', 'failed'] as const;
export type NotificationLogStatus = (typeof NOTIFICATION_LOG_STATUSES)[number];
export const NotificationLogStatusEnum = z.enum(NOTIFICATION_LOG_STATUSES);
```

`packages/core/src/enums/index.ts`에 새 export를 추가한다:

```typescript
export {
  // ... existing exports ...
  NOTIFICATION_LOG_STATUSES,
  type NotificationLogStatus,
  NotificationLogStatusEnum,
} from './notification.js';
```

**2. Drizzle 스키마 정의** (`packages/daemon/src/infrastructure/database/schema.ts`):

기존 import에 `NOTIFICATION_LOG_STATUSES`를 추가하고, `keyValueStore` 테이블 아래에 Table 8: notification_logs를 추가한다:

```typescript
// Table 8: notification_logs -- notification delivery history
export const notificationLogs = sqliteTable(
  'notification_logs',
  {
    id: text('id').primaryKey(), // UUID v7
    eventType: text('event_type').notNull(),
    agentId: text('agent_id'),
    channel: text('channel').notNull(), // telegram / discord / ntfy
    status: text('status').notNull(), // sent / failed
    error: text('error'), // failure error message (nullable)
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  },
  (table) => [
    index('idx_notification_logs_event_type').on(table.eventType),
    index('idx_notification_logs_agent_id').on(table.agentId),
    index('idx_notification_logs_status').on(table.status),
    index('idx_notification_logs_created_at').on(table.createdAt),
    check('check_notif_log_status', buildCheckSql('status', NOTIFICATION_LOG_STATUSES)),
  ],
);
```

파일 상단 주석의 테이블 수를 `7 tables` -> `8 tables`로 업데이트한다. agents, sessions, transactions, policies, pending_approvals, audit_log, key_value_store, notification_logs.

**3. 증분 마이그레이션** (`packages/daemon/src/infrastructure/database/migrate.ts`):

기존 import에 `NOTIFICATION_LOG_STATUSES`를 추가한다.

`getCreateTableStatements()` 함수 내 `key_value_store` 테이블 DDL 아래에 Table 8을 추가한다:

```sql
CREATE TABLE IF NOT EXISTS notification_logs (
  id TEXT PRIMARY KEY,
  event_type TEXT NOT NULL,
  agent_id TEXT,
  channel TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('sent', 'failed')),
  error TEXT,
  created_at INTEGER NOT NULL
)
```

CHECK 제약에는 `NOTIFICATION_LOG_STATUSES` SSoT 배열을 사용한다: `CHECK (status IN (${inList(NOTIFICATION_LOG_STATUSES)}))`

`getCreateIndexStatements()` 함수에 notification_logs 인덱스 4개를 추가한다:

```
CREATE INDEX IF NOT EXISTS idx_notification_logs_event_type ON notification_logs(event_type)
CREATE INDEX IF NOT EXISTS idx_notification_logs_agent_id ON notification_logs(agent_id)
CREATE INDEX IF NOT EXISTS idx_notification_logs_status ON notification_logs(status)
CREATE INDEX IF NOT EXISTS idx_notification_logs_created_at ON notification_logs(created_at)
```

**schema_version 테이블 추가**:

`getCreateTableStatements()`에 schema_version 테이블도 추가한다 (MIG-01 정책 준수):

```sql
CREATE TABLE IF NOT EXISTS schema_version (
  version INTEGER PRIMARY KEY,
  applied_at INTEGER NOT NULL,
  description TEXT NOT NULL
)
```

`pushSchema()` 함수 끝에 schema_version INSERT 로직을 추가한다:

```typescript
// Record schema version 1 if not already recorded
const existing = sqlite.prepare('SELECT version FROM schema_version WHERE version = 1').get();
if (!existing) {
  sqlite.prepare('INSERT INTO schema_version (version, applied_at, description) VALUES (?, ?, ?)')
    .run(1, Math.floor(Date.now() / 1000), 'Add notification_logs table');
}
```

migrate.ts 상단 주석의 `7 tables` -> `9 tables`로 업데이트 (기존 7 + schema_version + notification_logs).

**4. Barrel export 업데이트** (`packages/daemon/src/infrastructure/database/index.ts`):

schema export에 `notificationLogs`를 추가한다:

```typescript
export {
  agents,
  sessions,
  transactions,
  policies,
  pendingApprovals,
  auditLog,
  keyValueStore,
  notificationLogs,
} from './schema.js';
```

**주의사항:**
- 기존 7개 테이블 DDL은 변경하지 않는다
- CREATE TABLE IF NOT EXISTS를 사용하여 기존 DB에서도 안전하게 적용된다
- schema_version도 IF NOT EXISTS로 생성하여 멱등성을 보장한다
- `NOTIFICATION_LOG_STATUSES` SSoT 배열을 CHECK 제약에 사용하여 Zod-Drizzle 일관성을 유지한다

core 패키지 변경 후 `pnpm -C packages/core run build`로 빌드한다.
  </action>
  <verify>
1. `pnpm -C packages/core run build` 성공 (enum 추가)
2. `pnpm -C packages/daemon run build` 성공 (schema + migrate 변경)
3. `pnpm -C packages/daemon run test -- --run` 기존 테스트 통과 (특히 notification-service.test.ts)
  </verify>
  <done>
- notification_logs Drizzle 스키마가 schema.ts에 정의되어 있다
- migrate.ts에 notification_logs + schema_version CREATE TABLE IF NOT EXISTS가 포함되어 있다
- pushSchema() 호출 시 schema_version에 version=1이 기록된다
- index.ts에서 notificationLogs가 export된다
- core에 NOTIFICATION_LOG_STATUSES enum이 존재한다
- 기존 테스트가 깨지지 않는다
  </done>
</task>

<task type="auto">
  <name>Task 2: NotificationService 로깅 통합 + 테스트</name>
  <files>
    packages/daemon/src/notifications/notification-service.ts
    packages/daemon/src/__tests__/notification-log.test.ts
  </files>
  <action>
**1. NotificationService 로깅 통합** (`packages/daemon/src/notifications/notification-service.ts`):

`notify()` 메서드를 수정하여 채널 발송 결과를 notification_logs에 기록한다. 로깅은 fire-and-forget으로 파이프라인을 차단하지 않는다.

기존 import에 `generateId`를 추가한다:

```typescript
import { generateId } from '../infrastructure/database/id.js';
```

**sendToChannel()** 메서드를 수정하여 성공 시 로그를 기록한다:

```typescript
private async sendToChannel(
  channel: INotificationChannel,
  payload: NotificationPayload,
): Promise<void> {
  if (this.isRateLimited(channel.name)) {
    throw new Error(`Rate limited: ${channel.name}`);
  }
  await channel.send(payload);
  this.recordSend(channel.name);
  // Log successful delivery
  this.logDelivery(channel.name, payload, 'sent');
}
```

**sendWithFallback()** 메서드를 수정하여 각 채널 실패 시 실패 로그를 기록한다:

```typescript
private async sendWithFallback(payload: NotificationPayload): Promise<void> {
  for (const channel of this.channels) {
    try {
      await this.sendToChannel(channel, payload);
      return; // Success -- stop trying
    } catch (err) {
      // Log failed delivery attempt
      const errorMsg = err instanceof Error ? err.message : String(err);
      this.logDelivery(channel.name, payload, 'failed', errorMsg);
      continue;
    }
  }
  // All channels failed
  await this.logCriticalFailure(payload);
}
```

**broadcast()** 메서드를 수정하여 각 채널 결과를 로깅한다. `sendToChannel()` 내부에서 성공 로그는 이미 기록되므로, 실패한 채널만 추가 로깅한다:

```typescript
private async broadcast(payload: NotificationPayload): Promise<void> {
  const results = await Promise.allSettled(
    this.channels.map(async (ch) => {
      try {
        await this.sendToChannel(ch, payload);
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : String(err);
        this.logDelivery(ch.name, payload, 'failed', errorMsg);
        throw err; // re-throw so allSettled records rejection
      }
    }),
  );

  const allFailed = results.every((r) => r.status === 'rejected');
  if (allFailed) {
    await this.logCriticalFailure(payload, results);
  }
}
```

**주의**: broadcast에서 `sendToChannel()`이 성공하면 내부에서 `logDelivery('sent')`가 호출된다. `sendToChannel()`이 rate limit으로 throw하면 catch에서 `logDelivery('failed')`가 호출된다. 채널의 `send()`가 throw하면 `sendToChannel()`에서 예외가 전파되어 catch에서 `logDelivery('failed')`가 호출된다.

**logDelivery() 메서드 추가** (private):

```typescript
/**
 * Record notification delivery result to notification_logs table.
 * Fire-and-forget: errors are swallowed to never block the pipeline.
 */
private logDelivery(
  channelName: string,
  payload: NotificationPayload,
  status: 'sent' | 'failed',
  error?: string,
): void {
  if (!this.db) return;

  try {
    // Dynamic import to avoid circular deps (same pattern as logCriticalFailure)
    // Use synchronous approach since we have db reference
    const { notificationLogs } = require('../infrastructure/database/schema.js') as typeof import('../infrastructure/database/schema.js');
    // ... 아래 참고
  } catch {
    // Fire-and-forget: swallow errors
  }
}
```

**중요**: 순환 의존성 방지를 위해 `notificationLogs`는 기존 `logCriticalFailure()`와 동일한 동적 import 패턴을 사용한다. 하지만 `logDelivery()`는 동기 함수여야 fire-and-forget이 보장된다. 따라서 다음 접근법을 사용한다:

클래스에 `private notificationLogsTable` 필드를 추가하고, 첫 호출 시 lazy 로딩한다:

```typescript
// At class level:
private notificationLogsTable: typeof import('../infrastructure/database/schema.js').notificationLogs | null = null;

private getNotificationLogsTable() {
  if (!this.notificationLogsTable) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const schemaModule = require('../infrastructure/database/schema.js') as typeof import('../infrastructure/database/schema.js');
    this.notificationLogsTable = schemaModule.notificationLogs;
  }
  return this.notificationLogsTable;
}
```

실제로는 ESM-only 프로젝트이므로 `require`는 사용할 수 없다. 대신 상단의 기존 import를 활용한다. `notification-service.ts`는 이미 `import type * as schema from '../infrastructure/database/schema.js'`를 import하고 있으므로, 이를 `import * as schema from` (type 제거)로 변경하여 런타임에도 접근 가능하게 한다.

**최종 logDelivery 구현:**

```typescript
private logDelivery(
  channelName: string,
  payload: NotificationPayload,
  status: 'sent' | 'failed',
  error?: string,
): void {
  if (!this.db) return;

  try {
    this.db
      .insert(schema.notificationLogs)
      .values({
        id: generateId(),
        eventType: payload.eventType,
        agentId: payload.agentId,
        channel: channelName,
        status,
        error: error ?? null,
        createdAt: new Date(payload.timestamp * 1000),
      })
      .run();
  } catch {
    // Fire-and-forget: swallow DB errors to never block notification flow
  }
}
```

이를 위해 파일 상단의 `import type * as schema`를 `import * as schema`로 변경한다. 그리고 `logCriticalFailure()`에서 사용하는 동적 `import('../infrastructure/database/schema.js')` 대신 이미 import된 `schema.auditLog`을 사용하도록 리팩터링한다 (코드 단순화).

**2. 테스트 작성** (`packages/daemon/src/__tests__/notification-log.test.ts`):

새 테스트 파일을 생성한다. 기존 `notification-service.test.ts`의 `createTestDb()` 패턴을 따른다.

테스트 케이스:

**A. 마이그레이션 테스트:**
1. `pushSchema()` 호출 후 notification_logs 테이블이 존재한다 (sqlite pragma table_info)
2. `pushSchema()` 호출 후 schema_version 테이블이 존재하고 version=1 레코드가 있다
3. `pushSchema()` 두 번 호출해도 에러 없이 멱등하게 동작한다
4. notification_logs CHECK 제약: status='sent'와 'failed'만 허용, 다른 값 INSERT 시 예외

**B. 로깅 통합 테스트:**
5. 단일 채널 성공 시 notification_logs에 status='sent', channel, eventType 기록
6. 첫 채널 실패 → 두 번째 성공: 두 레코드 (failed + sent)
7. 모든 채널 실패: 실패 레코드 N개 + audit_log CRITICAL 레코드
8. broadcast 성공: 모든 채널에 대해 각각 sent 레코드
9. broadcast 부분 실패: 실패 채널은 failed, 성공 채널은 sent
10. DB 없이 생성된 NotificationService는 로그 기록 없이 정상 동작 (기존 동작 유지)
11. 로깅 실패가 알림 발송을 차단하지 않는다 (fire-and-forget 검증)

테스트에서는 `createDatabase(':memory:')` + `pushSchema()` 패턴을 사용한다. mock channel은 기존 `createMockChannel()` 패턴을 따른다.

```typescript
import { createDatabase, pushSchema, notificationLogs, auditLog } from '../infrastructure/database/index.js';
```

**주의사항:**
- `logDelivery()`는 동기적으로 실행되므로 (Drizzle의 `.run()`은 better-sqlite3의 동기 메서드), fire-and-forget이 자연스럽게 보장된다
- 기존 `notification-service.test.ts`의 테스트는 수정하지 않는다 (DB 없는 인스턴스 테스트는 그대로 통과해야 함)
- broadcast 내부의 `sendToChannel()` 호출에서 이미 성공 로그가 기록되므로, broadcast 외부에서 중복 로깅하지 않도록 주의한다
  </action>
  <verify>
1. `pnpm -C packages/daemon run build` 성공
2. `pnpm -C packages/daemon run test -- --run` 전체 통과
3. `pnpm -C packages/daemon run test -- --run notification-log` 신규 테스트 통과
4. `pnpm -C packages/daemon run test -- --run notification-service` 기존 테스트 통과 (회귀 없음)
5. `pnpm run test --run` 모노레포 전체 테스트 통과 (847+ 테스트)
  </verify>
  <done>
- NotificationService.notify() 성공 시 notification_logs에 status='sent' 레코드가 존재한다
- 채널 발송 실패 시 notification_logs에 status='failed' + error 메시지가 기록된다
- broadcast 이벤트는 각 채널별 개별 로그 레코드가 생성된다
- DB 없는 NotificationService는 기존과 동일하게 동작한다 (로그 기록 없음)
- 신규 테스트 11개+ 통과
- 기존 notification-service.test.ts 전체 통과 (회귀 없음)
  </done>
</task>

</tasks>

<verification>
1. `pnpm run build` 모노레포 전체 빌드 성공
2. `pnpm run test --run` 전체 테스트 통과 (기존 847+ 신규)
3. notification_logs 테이블이 pushSchema()로 생성됨 (테스트 검증)
4. schema_version 테이블에 version=1 기록됨 (테스트 검증)
5. 알림 성공/실패 시 notification_logs에 올바른 레코드 기록됨 (테스트 검증)
</verification>

<success_criteria>
- LOG-01: notification_logs 테이블이 증분 마이그레이션으로 생성된다 (schema_version 관리)
- LOG-02: 알림 발송 성공 시 notification_logs에 status='sent' 레코드가 저장된다
- LOG-03: 알림 발송 실패 시 notification_logs에 status='failed' + error 메시지가 저장된다
- 기존 847 테스트 전체 통과
</success_criteria>

<output>
After completion, create `.planning/phases/73-notification-log-infra/73-01-SUMMARY.md`
</output>
