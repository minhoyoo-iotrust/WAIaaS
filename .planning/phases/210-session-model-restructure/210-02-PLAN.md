---
phase: 210-session-model-restructure
plan: 02
type: execute
wave: 2
depends_on: [210-01]
files_modified:
  - packages/daemon/src/api/middleware/session-auth.ts
  - packages/daemon/src/api/routes/sessions.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
  - packages/daemon/src/__tests__/session-auth.test.ts
  - packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts
autonomous: true
requirements: [SESS-01, SESS-02, SESS-03, SESS-04, SESS-05, SESS-06]

must_haves:
  truths:
    - "세션 생성 시 walletIds 배열로 여러 지갑을 한 번에 연결할 수 있다"
    - "기존 walletId 단수 파라미터가 하위 호환으로 동작한다"
    - "POST /v1/sessions/:id/wallets로 지갑을 동적으로 추가할 수 있다"
    - "DELETE /v1/sessions/:id/wallets/:walletId로 지갑을 동적으로 제거할 수 있다"
    - "PATCH /v1/sessions/:id/wallets/:walletId/default로 기본 지갑을 변경할 수 있다"
    - "GET /v1/sessions/:id/wallets로 연결된 지갑 목록을 조회할 수 있다"
    - "session-auth 미들웨어가 walletId 대신 defaultWalletId를 context에 설정한다"
  artifacts:
    - path: "packages/daemon/src/api/routes/sessions.ts"
      provides: "Session CRUD + 4 session-wallet management endpoints"
      contains: "session_wallets"
    - path: "packages/daemon/src/api/middleware/session-auth.ts"
      provides: "Updated session-auth setting defaultWalletId"
      contains: "defaultWalletId"
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "Updated session schemas for multi-wallet"
      contains: "walletIds"
  key_links:
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "sessionWallets table import"
      pattern: "import.*sessionWallets"
    - from: "packages/daemon/src/api/middleware/session-auth.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "session_wallets query for defaultWalletId"
      pattern: "sessionWallets"
    - from: "packages/daemon/src/api/routes/sessions.ts"
      to: "packages/core/src/errors/error-codes.ts"
      via: "new error codes usage"
      pattern: "WALLET_ALREADY_LINKED|CANNOT_REMOVE_DEFAULT_WALLET|SESSION_REQUIRES_WALLET"
---

<objective>
세션 생성 로직을 walletIds/walletId 정규화로 변경하고, 세션-지갑 CRUD 4개 엔드포인트를 구현하며, session-auth 미들웨어를 defaultWalletId 기반으로 전환한다.

Purpose: 1:N 세션-지갑 모델의 서비스 레이어와 API를 완성하여 에이전트가 단일 토큰으로 여러 지갑에 접근할 수 있게 한다.
Output: 갱신된 세션 생성/목록/갱신 API, 4개 세션-지갑 관리 엔드포인트, 갱신된 session-auth 미들웨어
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/objectives/m26-04-multi-wallet-session.md
@.planning/phases/210-session-model-restructure/210-01-SUMMARY.md
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/api/routes/sessions.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/daemon/src/api/middleware/session-auth.ts
@packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
@packages/core/src/schemas/session.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: session-auth 미들웨어 + 세션 생성 변경 + OpenAPI 스키마</name>
  <files>
    packages/daemon/src/api/middleware/session-auth.ts
    packages/daemon/src/api/routes/sessions.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
    packages/daemon/src/infrastructure/jwt/jwt-secret-manager.ts
  </files>
  <action>
**1. session-auth 미들웨어 변경** (`session-auth.ts`):

a. `sessionWallets` 테이블을 schema import에 추가한다.
b. `c.set('walletId', payload.wlt)` 를 `c.set('defaultWalletId', payload.wlt)` 로 변경한다.
c. JWT의 `wlt` 클레임은 여전히 기본 지갑 ID를 담는다 (하위 호환).

```typescript
// Line 67 변경:
c.set('defaultWalletId', payload.wlt);  // was: c.set('walletId', payload.wlt)
```

**2. OpenAPI 스키마 변경** (`openapi-schemas.ts`):

a. `SessionCreateResponseSchema`에 `wallets` 배열 필드를 추가한다 (하위 호환 유지: walletId 필드도 유지):

```typescript
export const SessionCreateResponseSchema = z
  .object({
    id: z.string().uuid(),
    token: z.string(),
    expiresAt: z.number().int(),
    walletId: z.string().uuid(), // backward compat: default wallet
    wallets: z.array(z.object({
      id: z.string().uuid(),
      name: z.string(),
      isDefault: z.boolean(),
    })),
  })
  .openapi('SessionCreateResponse');
```

b. `SessionListItemSchema`에 `wallets` 배열을 추가한다:

```typescript
export const SessionListItemSchema = z
  .object({
    id: z.string().uuid(),
    walletId: z.string().uuid(),  // backward compat: default wallet
    walletName: z.string().nullable(),  // backward compat: default wallet name
    wallets: z.array(z.object({
      id: z.string().uuid(),
      name: z.string(),
      isDefault: z.boolean(),
    })),
    status: z.string(),
    renewalCount: z.number().int(),
    maxRenewals: z.number().int(),
    expiresAt: z.number().int(),
    absoluteExpiresAt: z.number().int(),
    createdAt: z.number().int(),
    lastRenewedAt: z.number().int().nullable(),
    source: z.enum(['api', 'mcp']),
  })
  .openapi('SessionListItem');
```

c. 세션-지갑 관리 엔드포인트용 응답 스키마를 추가한다:

```typescript
export const SessionWalletSchema = z.object({
  sessionId: z.string().uuid(),
  walletId: z.string().uuid(),
  isDefault: z.boolean(),
  createdAt: z.number().int(),
}).openapi('SessionWallet');

export const SessionWalletListSchema = z.object({
  wallets: z.array(z.object({
    id: z.string().uuid(),
    name: z.string(),
    chain: z.string(),
    isDefault: z.boolean(),
    createdAt: z.number().int(),
  })),
}).openapi('SessionWalletList');

export const SessionDefaultWalletSchema = z.object({
  sessionId: z.string().uuid(),
  defaultWalletId: z.string().uuid(),
}).openapi('SessionDefaultWallet');
```

**3. 세션 생성 변경** (`sessions.ts`):

a. `sessionWallets` 와 `wallets` 테이블을 schema import에 추가한다.

b. `createSessionRoute`의 body schema를 `CreateSessionRequestOpenAPI`로 유지한다 (core 패키지에서 이미 walletIds/walletId 확장됨).

c. POST /sessions 핸들러를 변경한다:

```typescript
// walletId/walletIds 정규화
const walletIds: string[] = parsed.walletIds ?? (parsed.walletId ? [parsed.walletId] : []);
const defaultWalletId = parsed.defaultWalletId ?? walletIds[0];

// 모든 지갑 존재 + 활성 검증
for (const wId of walletIds) {
  const wallet = deps.db.select().from(wallets).where(eq(wallets.id, wId)).get();
  if (!wallet) throw new WAIaaSError('WALLET_NOT_FOUND');
  if (wallet.status === 'TERMINATED') throw new WAIaaSError('WALLET_TERMINATED');
}

// 각 지갑의 max_sessions_per_wallet 체크 (session_wallets JOIN)
for (const wId of walletIds) {
  const activeCount = deps.db
    .select({ count: sql<number>`count(*)` })
    .from(sessionWallets)
    .innerJoin(sessions, eq(sessionWallets.sessionId, sessions.id))
    .where(and(
      eq(sessionWallets.walletId, wId),
      isNull(sessions.revokedAt),
      gt(sessions.expiresAt, nowDate),
    ))
    .get();
  if ((activeCount?.count ?? 0) >= maxSessions) {
    throw new WAIaaSError('SESSION_LIMIT_EXCEEDED', {
      message: `Wallet ${wId} has reached session limit (max: ${maxSessions})`,
    });
  }
}

// JWT에는 defaultWalletId만
const jwtPayload: JwtPayload = {
  sub: sessionId,
  wlt: defaultWalletId,
  iat: nowSec,
  exp: expiresAt,
};

// DB insert: sessions 행 (walletId 없음)
deps.db.insert(sessions).values({
  id: sessionId,
  tokenHash,
  expiresAt: new Date(expiresAt * 1000),
  absoluteExpiresAt: new Date(absoluteExpiresAtSec * 1000),
  createdAt: new Date(nowSec * 1000),
  renewalCount: 0,
  maxRenewals: deps.config.security.session_max_renewals,
  constraints: parsed.constraints ? JSON.stringify(parsed.constraints) : null,
}).run();

// session_wallets 행 insert (각 지갑별)
for (const wId of walletIds) {
  deps.db.insert(sessionWallets).values({
    sessionId,
    walletId: wId,
    isDefault: wId === defaultWalletId,
    createdAt: new Date(nowSec * 1000),
  }).run();
}

// 응답에 wallets 배열 포함
const walletRows = walletIds.map(wId => {
  const w = deps.db.select().from(wallets).where(eq(wallets.id, wId)).get()!;
  return { id: w.id, name: w.name, isDefault: wId === defaultWalletId };
});

return c.json({
  id: sessionId,
  token,
  expiresAt,
  walletId: defaultWalletId,
  wallets: walletRows,
}, 201);
```

d. GET /sessions (목록) 변경: sessions를 조회한 후 각 세션의 session_wallets를 JOIN하여 wallets 배열과 기본 지갑 정보를 포함한다. 하위 호환을 위해 walletId(기본 지갑)와 walletName(기본 지갑 이름) 필드를 유지한다.

e. PUT /sessions/:id/renew 변경: session.walletId 대신 session_wallets에서 is_default=1인 지갑을 조회하여 JWT wlt 클레임에 설정한다.

```typescript
// renew 핸들러에서
const defaultWallet = deps.db
  .select()
  .from(sessionWallets)
  .where(and(
    eq(sessionWallets.sessionId, sessionId),
    eq(sessionWallets.isDefault, true),
  ))
  .get();

const newPayload: JwtPayload = {
  sub: sessionId,
  wlt: defaultWallet!.walletId,
  iat: nowSec,
  exp: newExpiresAt,
};
```

f. 알림 발송의 walletId 파라미터를 defaultWalletId로 변경한다.
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/daemon` 가 통과한다 (또는 `c.get('walletId')` 참조를 모두 `c.get('defaultWalletId')`로 변경한 후 통과). 다른 파일에서 `c.get('walletId' as never)`를 사용하는 곳은 Phase 211에서 처리하므로, 이 Plan에서는 sessions.ts + session-auth.ts + openapi-schemas.ts의 typecheck만 확인한다.
  </verify>
  <done>
POST /sessions가 walletIds/walletId 파라미터를 정규화하고 session_wallets에 행을 삽입한다. GET /sessions가 wallets 배열을 포함한다. PUT /sessions/:id/renew가 session_wallets에서 기본 지갑을 조회하여 JWT를 발급한다. session-auth가 defaultWalletId를 context에 설정한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: 세션-지갑 CRUD 4개 엔드포인트 + 테스트</name>
  <files>
    packages/daemon/src/api/routes/sessions.ts
    packages/daemon/src/__tests__/session-auth.test.ts
    packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts
  </files>
  <action>
**1. 세션-지갑 관리 4개 엔드포인트** (`sessions.ts`에 추가):

모든 4개 엔드포인트는 masterAuth로 보호된다 (기존 sessions 라우터가 masterAuth 하위에 마운트되므로 자동 적용). 단, renew는 sessionAuth이므로 별도 분기 필요.

a. **POST /sessions/:id/wallets** (지갑 추가):

```typescript
const addWalletRoute = createRoute({
  method: 'post',
  path: '/sessions/{id}/wallets',
  tags: ['Sessions'],
  summary: 'Add wallet to session',
  request: {
    params: z.object({ id: z.string().uuid() }),
    body: { content: { 'application/json': { schema: z.object({ walletId: z.string().uuid() }) } } },
  },
  responses: {
    201: { description: 'Wallet added', content: { 'application/json': { schema: SessionWalletSchema } } },
    ...buildErrorResponses(['SESSION_NOT_FOUND', 'WALLET_NOT_FOUND', 'WALLET_ALREADY_LINKED']),
  },
});

// 핸들러:
// 1. 세션 존재 확인 (not revoked)
// 2. 지갑 존재 확인 (not TERMINATED)
// 3. 이미 연결된 지갑인지 확인 -> WALLET_ALREADY_LINKED
// 4. session_wallets에 삽입 (is_default = false)
// 5. max_sessions_per_wallet 체크 (한도 초과 시 롤백 + SESSION_LIMIT_EXCEEDED)
```

b. **DELETE /sessions/:id/wallets/:walletId** (지갑 제거):

```typescript
const removeWalletRoute = createRoute({
  method: 'delete',
  path: '/sessions/{id}/wallets/{walletId}',
  tags: ['Sessions'],
  summary: 'Remove wallet from session',
  request: {
    params: z.object({ id: z.string().uuid(), walletId: z.string().uuid() }),
  },
  responses: {
    204: { description: 'Wallet removed' },
    ...buildErrorResponses(['SESSION_NOT_FOUND', 'CANNOT_REMOVE_DEFAULT_WALLET', 'SESSION_REQUIRES_WALLET']),
  },
});

// 핸들러:
// 1. session_wallets에서 해당 행 조회
// 2. 행이 없으면 404 SESSION_NOT_FOUND
// 3. is_default=true이면 400 CANNOT_REMOVE_DEFAULT_WALLET
// 4. 남은 지갑 수 조회 -> 1개면 400 SESSION_REQUIRES_WALLET
// 5. session_wallets에서 삭제
// 6. 204 No Content 반환
```

c. **PATCH /sessions/:id/wallets/:walletId/default** (기본 지갑 변경):

```typescript
const setDefaultWalletRoute = createRoute({
  method: 'patch',
  path: '/sessions/{id}/wallets/{walletId}/default',
  tags: ['Sessions'],
  summary: 'Set default wallet for session',
  request: {
    params: z.object({ id: z.string().uuid(), walletId: z.string().uuid() }),
  },
  responses: {
    200: { description: 'Default wallet changed', content: { 'application/json': { schema: SessionDefaultWalletSchema } } },
    ...buildErrorResponses(['SESSION_NOT_FOUND']),
  },
});

// 핸들러:
// 1. session_wallets에서 해당 세션의 walletId 행 확인
// 2. 없으면 404 (세션에 연결되지 않은 지갑)
// 3. 트랜잭션 내에서:
//    a. 기존 is_default=true를 false로 변경
//    b. 새 walletId를 is_default=true로 변경
// 4. { sessionId, defaultWalletId } 반환
```

d. **GET /sessions/:id/wallets** (연결된 지갑 목록):

```typescript
const listSessionWalletsRoute = createRoute({
  method: 'get',
  path: '/sessions/{id}/wallets',
  tags: ['Sessions'],
  summary: 'List wallets linked to session',
  request: {
    params: z.object({ id: z.string().uuid() }),
  },
  responses: {
    200: { description: 'Session wallet list', content: { 'application/json': { schema: SessionWalletListSchema } } },
    ...buildErrorResponses(['SESSION_NOT_FOUND']),
  },
});

// 핸들러:
// 1. 세션 존재 확인
// 2. session_wallets JOIN wallets -> { id, name, chain, isDefault, createdAt } 배열 반환
```

**2. 테스트 업데이트**:

a. `session-auth.test.ts`:
- `c.get('walletId')` 검증을 `c.get('defaultWalletId')`로 변경한다.
- 새 테스트 추가: session-auth가 defaultWalletId를 올바르게 설정하는지 확인.

b. `session-lifecycle-e2e.test.ts`:
- 기존 세션 생성 테스트를 walletId 단수 파라미터로 유지 (하위 호환 검증).
- 새 테스트 추가:
  - walletIds 복수 파라미터 세션 생성
  - 지갑 동적 추가 (POST /sessions/:id/wallets)
  - 지갑 동적 제거 (DELETE /sessions/:id/wallets/:walletId)
  - 기본 지갑 변경 (PATCH /sessions/:id/wallets/:walletId/default)
  - 연결된 지갑 목록 조회 (GET /sessions/:id/wallets)
  - 에러 케이스: WALLET_ALREADY_LINKED, CANNOT_REMOVE_DEFAULT_WALLET, SESSION_REQUIRES_WALLET

c. `c.get('walletId' as never)`를 사용하는 **다른** 파일(wallet.ts, transactions.ts, actions.ts, x402.ts, wc.ts, owner-auth.ts 등)은 Phase 211에서 일괄 변경한다. 이 Plan에서는 sessions.ts와 session-auth.ts 내부에서만 변경하고, 다른 파일은 `c.get('walletId' as never)`를 **임시로 유지**한다. session-auth 미들웨어가 `defaultWalletId`를 설정하면 다른 파일에서 `walletId`를 읽으면 undefined가 되는 문제가 있다.

**중요 호환성 전략**: session-auth.ts에서 **두 가지 모두 설정**하여 기존 코드 호환을 유지한다:
```typescript
c.set('sessionId', payload.sub);
c.set('defaultWalletId', payload.wlt);
c.set('walletId', payload.wlt);  // 하위 호환: Phase 211에서 제거
```

이렇게 하면 기존 `c.get('walletId')` 코드가 Phase 211 전까지 계속 동작한다.
  </action>
  <verify>
1. `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/daemon` 통과
2. `pnpm vitest run packages/daemon/src/__tests__/session-auth.test.ts` 통과
3. `pnpm vitest run packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts` 통과
4. 4개 세션-지갑 관리 엔드포인트 라우트가 sessions.ts에 존재
  </verify>
  <done>
POST /sessions가 walletIds/walletId를 정규화하여 session_wallets에 행을 삽입한다. 4개 세션-지갑 관리 엔드포인트(추가/제거/기본변경/목록)가 동작한다. session-auth가 defaultWalletId + walletId(하위 호환) 모두를 context에 설정한다. 세션 생성/관리/에러 케이스 테스트가 통과한다.
  </done>
</task>

</tasks>

<verification>
1. Daemon 패키지 typecheck 통과
2. 세션 인증 테스트 통과
3. 세션 라이프사이클 E2E 테스트 통과
4. walletIds 복수 파라미터 세션 생성이 동작
5. walletId 단수 파라미터 세션 생성이 하위 호환으로 동작
6. 4개 세션-지갑 관리 엔드포인트 전부 동작
7. WALLET_ALREADY_LINKED, CANNOT_REMOVE_DEFAULT_WALLET, SESSION_REQUIRES_WALLET 에러 코드가 올바른 상황에서 반환
</verification>

<success_criteria>
- POST /sessions { walletIds: ["w1", "w2"] } -> 201, session_wallets에 2행 (w1 default)
- POST /sessions { walletId: "w1" } -> 201, session_wallets에 1행 (w1 default, 하위 호환)
- POST /sessions/:id/wallets { walletId: "w3" } -> 201 (추가)
- POST /sessions/:id/wallets { walletId: "w1" } -> 409 WALLET_ALREADY_LINKED
- DELETE /sessions/:id/wallets/w2 -> 204 (제거)
- DELETE default wallet -> 400 CANNOT_REMOVE_DEFAULT_WALLET
- DELETE last wallet -> 400 SESSION_REQUIRES_WALLET
- PATCH /sessions/:id/wallets/w2/default -> 200 (기본 변경)
- GET /sessions/:id/wallets -> 200 (목록)
- PUT /sessions/:id/renew -> JWT wlt = 기본 지갑
</success_criteria>

<output>
After completion, create `.planning/phases/210-session-model-restructure/210-02-SUMMARY.md`
</output>
