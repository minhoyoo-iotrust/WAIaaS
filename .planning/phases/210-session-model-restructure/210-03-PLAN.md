---
phase: 210-session-model-restructure
plan: 03
type: execute
wave: 3
depends_on: [210-02]
files_modified:
  - packages/daemon/src/api/routes/wallets.ts
  - packages/daemon/src/__tests__/session-wallet-cascade.test.ts
autonomous: true
requirements: [SESS-10]

must_haves:
  truths:
    - "지갑 삭제(TERMINATE) 시 해당 지갑이 기본 지갑이면 다른 지갑이 자동 승격된다"
    - "지갑 삭제 시 해당 지갑이 세션의 마지막 지갑이면 세션이 자동 revoke된다"
    - "자동 승격 시 created_at ASC 순서로 가장 먼저 연결된 지갑이 승격된다"
    - "is_default 불변량(세션당 정확히 1개)이 어떤 삭제 시나리오에서도 유지된다"
  artifacts:
    - path: "packages/daemon/src/api/routes/wallets.ts"
      provides: "Wallet TERMINATE cascade defense logic"
      contains: "session_wallets"
    - path: "packages/daemon/src/__tests__/session-wallet-cascade.test.ts"
      provides: "Cascade defense and edge case tests"
      contains: "auto-promote"
  key_links:
    - from: "packages/daemon/src/api/routes/wallets.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "sessionWallets table for cascade defense"
      pattern: "sessionWallets"
    - from: "packages/daemon/src/api/routes/wallets.ts"
      to: "packages/daemon/src/api/routes/sessions.ts"
      via: "session revoke on last wallet delete"
      pattern: "revokedAt"
---

<objective>
지갑 삭제(TERMINATE) 시 session_wallets의 is_default 불변량이 파손되지 않도록 cascade 방어 로직을 구현하고, 엣지 케이스 테스트로 불변량 보장을 검증한다.

Purpose: ON DELETE CASCADE로 junction 행이 자동 삭제될 때 is_default=1 행이 사라질 수 있는 문제를 방어하여, 어떤 시나리오에서도 세션당 기본 지갑이 정확히 1개 존재하도록 보장한다.
Output: TERMINATE 핸들러의 cascade 방어 로직, 포괄적 엣지 케이스 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/objectives/m26-04-multi-wallet-session.md
@.planning/phases/210-session-model-restructure/210-01-SUMMARY.md
@.planning/phases/210-session-model-restructure/210-02-SUMMARY.md
@packages/daemon/src/api/routes/wallets.ts
@packages/daemon/src/infrastructure/database/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TERMINATE 핸들러 cascade 방어 로직</name>
  <files>
    packages/daemon/src/api/routes/wallets.ts
  </files>
  <action>
`wallets.ts`의 DELETE /wallets/:id (TERMINATE) 핸들러를 수정한다. 현재 로직은 wallets 상태를 TERMINATED로 변경한 후 sessions를 삭제하는데, session_wallets에 ON DELETE CASCADE가 설정되어 있으므로 wallets 행 삭제 시가 아니라 sessions 행 삭제 시에 cascade가 동작한다.

**핵심 문제**: 현재 코드는 `DELETE FROM sessions WHERE wallet_id = ?`로 세션을 삭제하지만, sessions 테이블에 더이상 wallet_id 컬럼이 없다. session_wallets의 ON DELETE CASCADE는 wallets 테이블 삭제 시 동작하지만, TERMINATE는 wallets를 삭제하지 않고 status만 변경한다. 따라서 cascade 방어는 **TERMINATE가 아닌, session_wallets를 직접 정리**하는 방식이어야 한다.

**변경 로직** (DELETE /wallets/:id 핸들러):

```typescript
// 기존: sessions 삭제 (wallet_id 컬럼 제거됨 -> 더 이상 동작하지 않음)
// 변경: session_wallets 기반으로 처리

// Step 1: 이 지갑이 연결된 모든 session_wallets 행을 조회
const linkedSessions = deps.db
  .select({
    sessionId: sessionWallets.sessionId,
    isDefault: sessionWallets.isDefault,
  })
  .from(sessionWallets)
  .where(eq(sessionWallets.walletId, walletId))
  .all();

// Step 2: 각 세션별로 cascade 방어 처리
for (const link of linkedSessions) {
  // 이 세션에 연결된 다른 지갑이 있는지 확인
  const otherWallets = deps.db
    .select({
      walletId: sessionWallets.walletId,
      createdAt: sessionWallets.createdAt,
    })
    .from(sessionWallets)
    .where(and(
      eq(sessionWallets.sessionId, link.sessionId),
      sql`${sessionWallets.walletId} != ${walletId}`,
    ))
    .orderBy(sessionWallets.createdAt) // ASC: 가장 먼저 연결된 지갑
    .all();

  if (otherWallets.length === 0) {
    // 마지막 지갑 -> 세션 자동 revoke
    const nowDate = new Date(Math.floor(Date.now() / 1000) * 1000);
    deps.db
      .update(sessions)
      .set({ revokedAt: nowDate })
      .where(eq(sessions.id, link.sessionId))
      .run();
  } else if (link.isDefault) {
    // 기본 지갑이 삭제됨 -> 가장 먼저 연결된 다른 지갑으로 자동 승격
    const promotee = otherWallets[0];
    deps.db
      .update(sessionWallets)
      .set({ isDefault: true })
      .where(and(
        eq(sessionWallets.sessionId, link.sessionId),
        eq(sessionWallets.walletId, promotee.walletId),
      ))
      .run();
  }
  // 기본 지갑이 아닌 경우: junction 행만 삭제되면 됨 (아래에서 처리)
}

// Step 3: 해당 지갑의 모든 session_wallets 행 삭제
deps.db
  .delete(sessionWallets)
  .where(eq(sessionWallets.walletId, walletId))
  .run();

// Step 4: 기존 pending transactions 취소 (기존 코드 유지)
// Step 5: 지갑 상태를 TERMINATED로 변경 (기존 코드 유지)
```

**삭제해야 할 기존 코드**: `DELETE FROM sessions WHERE wallet_id = walletId` 행 (sessions에 wallet_id 컬럼이 없으므로 제거).

**import 추가**: `sessionWallets`를 schema import에 추가한다.

**순서 주의**: cascade 방어 로직(Step 1-3)을 **지갑 상태 변경 전에** 실행해야 한다. 지갑을 TERMINATED로 변경한 후에는 새로운 세션-지갑 연결이 거부되므로, 순서는:
1. cascade 방어 (session_wallets 처리)
2. pending transactions 취소
3. wallets.status = TERMINATED
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/daemon` 통과.
`grep 'sessionWallets' packages/daemon/src/api/routes/wallets.ts` 에서 import 및 사용 확인.
  </verify>
  <done>
TERMINATE 핸들러가 지갑 삭제 전에 session_wallets를 조회하여: (1) 마지막 지갑이면 세션 revoke, (2) 기본 지갑이면 가장 먼저 연결된 다른 지갑으로 자동 승격, (3) session_wallets 행을 삭제한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: cascade 방어 + is_default 불변량 엣지 케이스 테스트</name>
  <files>
    packages/daemon/src/__tests__/session-wallet-cascade.test.ts
  </files>
  <action>
새 테스트 파일 `session-wallet-cascade.test.ts`를 생성한다. 기존 E2E 테스트 패턴(session-lifecycle-e2e.test.ts)을 참고하여 in-memory DB + 직접 API 호출 방식으로 작성한다.

**테스트 시나리오**:

1. **기본 지갑 삭제 -> 자동 승격**
   - 세션에 w1(default) + w2 + w3 연결
   - w1 TERMINATE
   - session_wallets에서 w2가 is_default=1 (created_at ASC 순서)
   - w1은 session_wallets에서 삭제됨

2. **비기본 지갑 삭제 -> 변화 없음**
   - 세션에 w1(default) + w2 연결
   - w2 TERMINATE
   - w1은 여전히 is_default=1
   - session_wallets에서 w2만 삭제됨

3. **마지막 지갑 삭제 -> 세션 자동 revoke**
   - 세션에 w1(default) 1개만 연결
   - w1 TERMINATE
   - sessions.revoked_at이 NOT NULL
   - session_wallets에 해당 세션 행 없음

4. **여러 세션에 걸친 지갑 삭제**
   - 세션 A에 w1(default) + w2, 세션 B에 w1(default)
   - w1 TERMINATE
   - 세션 A: w2가 자동 승격 (is_default=1)
   - 세션 B: 자동 revoke (마지막 지갑)

5. **is_default 불변량 검증**
   - 모든 테스트 후 검증 helper:
   ```typescript
   function assertDefaultInvariant(db, sessionId) {
     const defaults = db.select().from(sessionWallets)
       .where(and(
         eq(sessionWallets.sessionId, sessionId),
         eq(sessionWallets.isDefault, true),
       )).all();
     // 세션이 active이면 정확히 1개, revoked이면 0개
     const session = db.select().from(sessions).where(eq(sessions.id, sessionId)).get();
     if (session.revokedAt === null) {
       expect(defaults.length).toBe(1);
     }
   }
   ```

6. **승격 순서 검증**
   - w1(default), w2, w3 순서로 추가 (created_at 차이)
   - w1 TERMINATE -> w2가 승격 (w3가 아닌 created_at ASC 기준)

7. **TERMINATE + 동시 세션 갱신 (경합 시나리오)**
   - 세션 갱신(renew)이 is_default 지갑을 조회하는 시점과 TERMINATE가 동시 발생
   - 이 테스트는 단순히 두 작업을 순차 실행하여 데이터 정합성을 확인한다 (SQLite는 단일 writer이므로 실제 동시성은 직렬화됨)

**테스트 helper**: 기존 테스트에서 사용하는 `createDatabase`, `pushSchema`, `generateId` 패턴을 재사용한다. 필요하면 JwtSecretManager mock을 설정하여 실제 API 라우트를 테스트한다.
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/__tests__/session-wallet-cascade.test.ts` 전체 통과.
테스트 수가 7개 이상.
  </verify>
  <done>
7개 이상의 cascade 방어 테스트가 통과한다. 기본 지갑 삭제 시 자동 승격, 마지막 지갑 삭제 시 세션 자동 revoke, 여러 세션에 걸친 삭제, is_default 불변량이 모든 시나리오에서 보장된다.
  </done>
</task>

</tasks>

<verification>
1. Daemon 패키지 typecheck 통과
2. cascade 테스트 전체 통과 (7개+ 시나리오)
3. 기존 테스트 회귀 없음: `pnpm vitest run packages/daemon/src/__tests__/`
4. TERMINATE 핸들러가 session_wallets를 사전 처리한 후 지갑 상태를 변경
</verification>

<success_criteria>
- w1(default)+w2 세션에서 w1 TERMINATE -> w2가 자동 승격 (is_default=1)
- w1(default) 유일 지갑 세션에서 w1 TERMINATE -> 세션 자동 revoke
- w1이 세션 A(default)+B(default)에 있을 때 TERMINATE -> A는 다른 지갑 승격, B는 revoke
- 모든 cascade 후 is_default 불변량: active 세션마다 is_default=1 행이 정확히 1개
</success_criteria>

<output>
After completion, create `.planning/phases/210-session-model-restructure/210-03-SUMMARY.md`
</output>
