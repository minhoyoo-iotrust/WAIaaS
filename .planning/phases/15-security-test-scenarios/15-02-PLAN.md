---
phase: 15-security-test-scenarios
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/v0.4/44-layer2-policy-bypass-attacks.md
  - docs/v0.4/45-layer3-killswitch-recovery-attacks.md
autonomous: true

must_haves:
  truths:
    - "Layer 2 정책 우회 공격 시나리오 6개 이상이 정의되어 있고, TOCTOU 등 동시성 공격이 포함되어 있다"
    - "Layer 3 Kill Switch/AutoStop 시나리오 6개 이상이 정의되어 있고, 복구 흐름까지 포함한다"
    - "모든 시나리오에 Given-When-Then이 있고, Given절에 Mock 설정이 명시되어 있다"
    - "각 시나리오에 Critical/High/Medium 우선순위 태그가 부여되어 있다"
  artifacts:
    - path: "docs/v0.4/44-layer2-policy-bypass-attacks.md"
      provides: "Layer 2 정책 우회 공격 시나리오 전체"
      contains: "SEC-02"
      min_lines: 120
    - path: "docs/v0.4/45-layer3-killswitch-recovery-attacks.md"
      provides: "Layer 3 Kill Switch/AutoStop 공격 시나리오 전체"
      contains: "SEC-03"
      min_lines: 120
  key_links:
    - from: "docs/v0.4/44-layer2-policy-bypass-attacks.md"
      to: ".planning/deliverables/33-time-lock-approval-mechanism.md"
      via: "정책 엔진 공격 벡터 원본"
      pattern: "DatabasePolicyEngine|SPENDING_LIMIT|BEGIN IMMEDIATE"
    - from: "docs/v0.4/45-layer3-killswitch-recovery-attacks.md"
      to: ".planning/deliverables/36-killswitch-autostop-evm.md"
      via: "Kill Switch 공격 벡터 원본"
      pattern: "killSwitchGuard|ACTIVATED|RECOVERING|AutoStop"
    - from: "docs/v0.4/44-layer2-policy-bypass-attacks.md"
      to: "docs/v0.4/42-mock-boundaries-interfaces-contracts.md"
      via: "Given절 Mock 참조"
      pattern: "FakeClock|MockPolicyEngine|MockChainAdapter"
---

<objective>
Layer 2 정책 엔진 우회 공격과 Layer 3 Kill Switch/AutoStop 공격 시나리오를 Given-When-Then 테스트 케이스 수준으로 정의한다.

Purpose: WAIaaS의 두 번째(정책 + Time-Lock) 및 세 번째(Kill Switch + AutoStop) 방어선이 올바르게 동작하는지를 검증하는 공격 시나리오를 문서화한다.
Output: `docs/v0.4/44-layer2-policy-bypass-attacks.md` (SEC-02), `docs/v0.4/45-layer3-killswitch-recovery-attacks.md` (SEC-03)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-security-test-scenarios/15-CONTEXT.md
@.planning/phases/15-security-test-scenarios/15-RESEARCH.md

# Phase 14 outputs
@docs/v0.4/41-test-levels-matrix-coverage.md
@docs/v0.4/42-mock-boundaries-interfaces-contracts.md

# Layer 2 공격 벡터 원본 설계 문서
@.planning/deliverables/33-time-lock-approval-mechanism.md
@.planning/deliverables/32-transaction-pipeline-api.md

# Layer 3 공격 벡터 원본 설계 문서
@.planning/deliverables/36-killswitch-autostop-evm.md
@.planning/deliverables/35-notification-architecture.md
@.planning/deliverables/34-owner-wallet-connection.md

# 에러 코드 SSoT
@.planning/deliverables/45-enum-unified-mapping.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Layer 2 정책 우회 공격 시나리오 9건 정의 (SEC-02)</name>
  <files>docs/v0.4/44-layer2-policy-bypass-attacks.md</files>
  <action>
Layer 2 정책 우회 공격 시나리오 문서를 생성한다. 15-RESEARCH.md의 시나리오 템플릿 표준을 따른다.

**문서 헤더:**
- 제목: Layer 2: 정책 엔진 우회 공격 시나리오
- 요구사항: SEC-02
- 관련 설계 문서: 33-time-lock-approval-mechanism.md, 32-transaction-pipeline-api.md
- 위협 모델: 악의적 AI 에이전트가 정책 평가를 우회하여 허용 범위를 초과하는 거래를 실행하려 시도

**시나리오 9건:**

1. SEC-02-01: TOCTOU -- 동시 거래로 한도 초과 (Critical)
   - 테스트 레벨: Integration (실제 SQLite + BEGIN IMMEDIATE 필수)
   - Mock: 실제 SQLite tmpdir, MockChainAdapter
   - Given: maxTotalAmount=10 SOL, 현재 8 SOL. When: 2개 동시 요청 각 3 SOL. Then: 1개 성공, 1개 POLICY_LIMIT_EXCEEDED
   - RESEARCH의 Pitfall 3 참조: Unit에서는 불가, Integration에서 실제 SQLite로 검증

2. SEC-02-02: 금액 티어 경계값 조작 (High)
   - 테스트 레벨: Unit
   - Mock: FakeClock, MockDb
   - Given: INSTANT 한도 = 1 SOL. When: 정확히 1_000_000_000 lamports 전송. Then: INSTANT 처리 (경계 포함). When: 1_000_000_001 lamports. Then: NOTIFY 티어로 전환
   - BigInt 비교 명시

3. SEC-02-03: WHITELIST 우회 -- 주소 대소문자 (High)
   - 테스트 레벨: Unit
   - EVM 주소 체크섬 차이 (0xAbC vs 0xabc), Solana는 base58이므로 대소문자 구분됨
   - Given: whitelist = ["EVM_ADDR_CHECKSUM"]. When: 소문자 변환 주소로 요청. Then: WHITELIST 정책에서 거부

4. SEC-02-04: TIME_RESTRICTION 우회 (High)
   - 테스트 레벨: Unit
   - Mock: FakeClock
   - Given: 허용 시간 09:00~18:00, FakeClock = 17:59:59. When: 전송 요청. Then: 허용. When: FakeClock.advance(1000). Then: 거부

5. SEC-02-05: RATE_LIMIT 우회 -- 시간 윈도우 경계 (High)
   - 테스트 레벨: Unit
   - Mock: FakeClock, MockDb
   - 1시간 윈도우 내 max_count - 1건 실행 후, 윈도우 경계에서 집중 거래

6. SEC-02-06: DELAY 쿨다운 조기 실행 시도 (High)
   - 테스트 레벨: Unit
   - Mock: FakeClock
   - Given: DELAY 15분 쿨다운, FakeClock = 쿨다운 시작 + 14분 59초. When: 실행 시도. Then: 차단. When: FakeClock.advance(1000). Then: 실행 허용

7. SEC-02-07: APPROVAL 타임아웃 후 승인 시도 (High)
   - 테스트 레벨: Unit
   - Mock: FakeClock, FakeOwnerSigner
   - Given: APPROVAL 1시간 타임아웃, FakeClock = 요청 + 3601초. When: Owner 승인. Then: TX_APPROVAL_TIMEOUT

8. SEC-02-08: 정책 에이전트별 오버라이드 우회 (Medium)
   - 테스트 레벨: Unit
   - Given: 글로벌 정책 maxAmount=10 SOL, 에이전트 오버라이드 maxAmount=5 SOL. When: 7 SOL 전송. Then: 에이전트 정책 우선 적용으로 거부

9. SEC-02-09: 정책 미설정 시 기본 동작 (Medium)
   - 테스트 레벨: Unit
   - Given: policies 테이블 비어있음. When: 임의 금액 전송. Then: 기본 정책(ALLOW INSTANT 또는 DENY) -- 설계 문서의 기본 동작 확인

**추가 섹션:**
- "TOCTOU 방어 메커니즘 검증 상세": BEGIN IMMEDIATE + reserved_amount 패턴을 도식으로 설명
- "정책 평가 순서 검증": WHITELIST -> TIME_RESTRICTION -> RATE_LIMIT -> SPENDING_LIMIT 순서에서 DENY 우선 평가 검증 시나리오
- "시나리오 우선순위 요약" 표

**주의사항:**
- TOCTOU 테스트는 반드시 Integration 레벨로 표시 (Pitfall 3)
- 금액은 lamport 단위 BigInt 문자열
- FakeClock와 Jest useFakeTimers 구분 명확히 (Pitfall 2)
  </action>
  <verify>
1. SEC-02-01 ~ SEC-02-09 시나리오 9건이 모두 존재
2. SEC-02-01(TOCTOU)이 Integration 레벨로 명시
3. 각 시나리오에 우선순위, Given-When-Then, Mock 참조 포함
4. BigInt 금액 비교가 명시
  </verify>
  <done>
SEC-02 요구사항 충족: Layer 2 정책 우회 공격 시나리오 9건(>= 6건 요구)이 정의되어 있고, TOCTOU 동시성 공격(SEC-02-01)이 포함되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Layer 3 Kill Switch/AutoStop 공격 시나리오 8건 정의 (SEC-03)</name>
  <files>docs/v0.4/45-layer3-killswitch-recovery-attacks.md</files>
  <action>
Layer 3 Kill Switch 및 AutoStop 공격 시나리오 문서를 생성한다.

**문서 헤더:**
- 제목: Layer 3: Kill Switch & AutoStop 공격 및 복구 시나리오
- 요구사항: SEC-03
- 관련 설계 문서: 36-killswitch-autostop-evm.md, 34-owner-wallet-connection.md, 35-notification-architecture.md
- 위협 모델: Kill Switch 우회/복구 brute-force + AutoStop 회피

**시나리오 8건:**

1. SEC-03-01: Kill Switch 우회 -- ACTIVATED 상태에서 API 접근 (Critical)
   - Mock: MockDb (system_state=ACTIVATED)
   - Given: ACTIVATED 상태. When: 유효 세션 토큰으로 /v1/wallet/balance. Then: SYSTEM_LOCKED
   - 추가: /health는 200 OK, /v1/owner/recover는 접근 가능 확인

2. SEC-03-02: 복구 brute-force -- 마스터 패스워드 (High)
   - Mock: MockDb, FakeOwnerSigner
   - Given: ACTIVATED 상태. When: 5회 잘못된 마스터 패스워드로 복구 시도. Then: 5회 실패 후 RECOVERY_LOCKED (30분 lockout)

3. SEC-03-03: 복구 시 Owner 서명 위조 (Critical)
   - Mock: FakeOwnerSigner (다른 키쌍)
   - Given: ACTIVATED 상태. When: 다른 키쌍의 FakeOwnerSigner로 서명한 복구 요청. Then: INVALID_SIGNATURE

4. SEC-03-04: AutoStop CONSECUTIVE_FAILURES 우회 (High)
   - Mock: FakeClock, MockChainAdapter (실패 반환)
   - Given: 연속 실패 임계값 = 3. When: 3회 연속 FAILED 후 추가 요청. Then: AutoStop 트리거, SYSTEM_LOCKED

5. SEC-03-05: Kill Switch 이중 발동 (Medium)
   - Mock: MockDb (system_state=ACTIVATED)
   - Given: 이미 ACTIVATED. When: 다시 activate() 호출. Then: 중복 발동 무시 또는 ALREADY_ACTIVATED

6. SEC-03-06: 복구 후 세션 재사용 (High)
   - Mock: MockDb, FakeOwnerSigner
   - Given: Kill Switch 발동 -> 모든 세션 폐기 -> Owner dual-auth 복구 -> NORMAL. When: 발동 전 세션 토큰으로 접근. Then: SESSION_REVOKED (세션이 이미 폐기됨)

7. SEC-03-07: Kill Switch 캐스케이드 부분 실패 (Medium)
   - Mock: MockKeyStore (lock() 실패 시뮬레이션), MockNotificationChannel
   - Given: Step 1-3 성공, Step 4(keystore.lock) 실패. When: 캐스케이드 실행. Then: 상태는 ACTIVATED 유지, 알림 전송 시도됨, 에러 로그 기록
   - 핵심: Step 1-3 원자적(BEGIN IMMEDIATE), Step 4-6 best-effort. Pitfall 5 참조

8. SEC-03-08: RECOVERING 상태에서 API 접근 (High)
   - Mock: MockDb (system_state=RECOVERING)
   - Given: RECOVERING 상태. When: 세션 토큰으로 API 접근. Then: SYSTEM_LOCKED (ACTIVATED와 동일하게 차단)
   - /v1/owner/recover + /health + /v1/admin/status만 허용 확인

**추가 섹션:**
- "AutoStop 5가지 규칙 검증 요약": consecutive_failures, time_window, anomaly_hours, threshold_proximity, velocity 각각에 대한 트리거 조건 표
- "Kill Switch 3-state 전이 검증": NORMAL->ACTIVATED->RECOVERING->NORMAL 전이 규칙과 잘못된 전이 거부 확인
- "복구 E2E 흐름": ACTIVATED -> recover 요청 -> dual-auth 확인 -> RECOVERING -> 30분 쿨다운 -> NORMAL 전체 흐름
- "시나리오 우선순위 요약" 표

**주의사항:**
- Kill Switch 캐스케이드의 원자성 범위를 정확히 구분 (Step 1-3 vs Step 4-6)
- 복구 dual-auth: Owner 서명 + 마스터 패스워드 동시 요구
- killSwitchGuard 미들웨어 위치: Rate Limiter 이후, sessionAuth 이전
  </action>
  <verify>
1. SEC-03-01 ~ SEC-03-08 시나리오 8건이 모두 존재
2. 복구 흐름 시나리오(SEC-03-02, SEC-03-03, SEC-03-06)가 E2E 복구까지 포함
3. AutoStop 트리거 시나리오(SEC-03-04) 존재
4. Kill Switch 캐스케이드 원자성 구분(SEC-03-07)이 Step 1-3 vs 4-6으로 분리
5. 각 시나리오에 Given-When-Then + Mock 참조 포함
  </verify>
  <done>
SEC-03 요구사항 충족: Layer 3 Kill Switch/AutoStop 시나리오 8건(>= 6건 요구)이 정의되어 있고, 복구 흐름(dual-auth, 30분 쿨다운)까지 포함하며, AutoStop 트리거 및 캐스케이드 부분 실패 검증이 포함되어 있다.
  </done>
</task>

</tasks>

<verification>
- docs/v0.4/44-layer2-policy-bypass-attacks.md: 120줄 이상, SEC-02-01~09 전체 존재
- docs/v0.4/45-layer3-killswitch-recovery-attacks.md: 120줄 이상, SEC-03-01~08 전체 존재
- TOCTOU 시나리오가 Integration 레벨로 명시
- Kill Switch 복구 E2E 흐름이 dual-auth까지 포함
- 모든 시나리오에 우선순위 + Given-When-Then + Mock 참조
</verification>

<success_criteria>
Layer 2 정책 우회 9건 + Layer 3 Kill Switch/AutoStop 8건 = 17건의 공격 시나리오가 테스트 케이스 수준으로 정의되어, 구현 시 Security 테스트를 바로 작성할 수 있는 상태
</success_criteria>

<output>
After completion, create `.planning/phases/15-security-test-scenarios/15-02-SUMMARY.md`
</output>
