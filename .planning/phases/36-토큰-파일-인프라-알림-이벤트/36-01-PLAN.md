---
phase: 36-토큰-파일-인프라-알림-이벤트
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/24-monorepo-data-directory.md
  - objectives/v0.9-session-management-automation.md
autonomous: true

must_haves:
  truths:
    - "~/.waiaas/mcp-token 파일의 경로, 포맷(wai_sess_ + JWT), 권한(0o600), 인코딩(UTF-8), symlink 거부 사양이 설계 문서에 명확히 정의되어 있다"
    - "원자적 토큰 파일 쓰기 패턴(write-then-rename)이 POSIX rename 원자성 기반으로 정의되고, Windows NTFS EPERM 재시도 전략이 포함되어 있다"
    - "getMcpTokenPath(), writeMcpToken(), readMcpToken() 3개 공유 유틸리티 함수의 시그니처, 동작, 에러 처리가 설계 문서에 정의되어 있다"
    - "24-monorepo-data-directory.md 데이터 디렉토리 트리에 mcp-token 파일이 추가되어 있다"
  artifacts:
    - path: ".planning/deliverables/24-monorepo-data-directory.md"
      provides: "데이터 디렉토리 트리에 mcp-token 파일 추가 + 토큰 파일 사양 섹션"
      contains: "mcp-token"
    - path: "objectives/v0.9-session-management-automation.md"
      provides: "토큰 파일 인프라 설계 결과 섹션 (Phase 36-01 결과물)"
      contains: "token-file.ts"
  key_links:
    - from: "24-monorepo-data-directory.md"
      to: "objectives/v0.9-session-management-automation.md"
      via: "mcp-token 파일 경로 일관성"
      pattern: "mcp-token"
---

<objective>
Phase 36의 Plan 01: MCP/CLI/Telegram 3개 컴포넌트가 공유하는 토큰 파일 사양과 원자적 쓰기 패턴을 설계한다.

Purpose: 토큰 파일 유틸리티는 Phase 37(SessionManager), Phase 38(MCP 통합), Phase 39(CLI+Telegram)의 공통 기반이므로, 사양이 먼저 확정되어야 후속 설계가 진행 가능하다.
Output: (1) 24-monorepo-data-directory.md에 mcp-token 파일 추가 + 토큰 파일 사양 섹션 신설, (2) v0.9 objectives에 토큰 파일 인프라 설계 결과 정리
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-토큰-파일-인프라-알림-이벤트/36-RESEARCH.md
@.planning/deliverables/24-monorepo-data-directory.md
@objectives/v0.9-session-management-automation.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 24-monorepo-data-directory.md에 mcp-token 파일 사양 추가</name>
  <files>.planning/deliverables/24-monorepo-data-directory.md</files>
  <action>
24-monorepo-data-directory.md를 수정하여 다음을 추가한다:

**1. 데이터 디렉토리 트리 업데이트:**
기존 `~/.waiaas/` 트리에 `mcp-token` 파일을 추가한다. `daemon.lock` 아래, `data/` 위에 배치:

```
├── mcp-token                          # [v0.9] MCP 세션 토큰 (600)
```

**2. 새 섹션 추가: "토큰 파일 사양 (v0.9)"**
기존 섹션 다음에 새 섹션을 추가한다. 다음 내용을 포함:

(a) **파일 사양 테이블:**
| 항목 | 값 | 근거 |
|------|-----|------|
| 경로 | `~/.waiaas/mcp-token` | 데이터 디렉토리 체계 확장. `WAIAAS_DATA_DIR` 환경변수로 오버라이드 가능 |
| 포맷 | `wai_sess_` + JWT 문자열 (개행 없음) | 30-session-token-protocol.md 토큰 포맷. JSON 메타데이터 포함 금지 (AF-7) |
| 인코딩 | UTF-8 | JWT는 ASCII-safe base64url이지만 파일 인코딩으로 UTF-8 명시 |
| 권한 | `0o600` (POSIX, Owner read/write only) | SSH keys, AWS credentials와 동일한 업계 표준 |
| 디렉토리 권한 | `0o700` | 데이터 디렉토리 기존 사양과 동일 |
| symlink | 거부 (`lstatSync` 검사) | 보안 시나리오 S-04: 공격자가 symlink로 토큰 탈취 방지 |
| 최대 크기 | ~500 bytes | JWT Claims 기준 (header ~50 + payload ~200 + sig ~50 + prefix 9) |
| 소유권 모델 | Last-Writer-Wins | MCP/CLI/Telegram 3개 쓰기 주체 중 마지막 쓰기가 유효 |
| Windows 제한 | `0o600` 미적용, 사용자 프로필 격리에 의존 | NTFS ACL은 POSIX 모델과 다름. 경고 로그 출력 |

(b) **공유 유틸리티 API 설계:**
`@waiaas/core` 패키지의 `utils/token-file.ts`에 3개 함수를 정의:

```typescript
// 1. 토큰 파일 경로 계산
export function getMcpTokenPath(dataDir?: string): string
// - WAIAAS_DATA_DIR 환경변수 > 인자 > os.homedir()/.waiaas 순서
// - 반환: 절대 경로 문자열

// 2. 원자적 토큰 파일 쓰기 (비동기)
export async function writeMcpToken(filePath: string, token: string): Promise<void>
// - mkdir(dir, { recursive: true, mode: 0o700 })
// - lstat로 symlink 검사 -> symlink이면 Error throw
// - 임시 파일: ${dir}/.mcp-token.${pid}.${randomBytes(4).hex()}.tmp
// - writeFile(tmp, token, { encoding: 'utf-8', mode: 0o600 })
// - rename(tmp, filePath) -- POSIX 원자적
// - 실패 시 임시 파일 unlink (cleanup)
// - Windows EPERM: 10-50ms 랜덤 대기 후 최대 3회 재시도

// 3. 토큰 파일 읽기 (동기)
export function readMcpToken(filePath: string): string | null
// - lstatSync: symlink이면 console.error + return null
// - readFileSync + trim
// - wai_sess_ 접두어 확인 -> 없으면 null
// - JWT 3-part 구조 확인 (split('.').length === 3) -> 아니면 null
// - 반환: 유효한 토큰 문자열 또는 null
```

readMcpToken은 동기 함수로 설계한다. MCP tool handler에서 토큰 확인은 동기적으로 수행해야 하며(I/O 비용 무시 가능한 ~500byte 파일), 비동기 버전은 필요 시 Phase 37에서 추가한다.

(c) **원자적 쓰기 패턴 상세:**

write-then-rename 패턴의 단계별 설명:
1. 데이터 디렉토리 보장: `mkdir(dir, { recursive: true, mode: 0o700 })` -- 최초 생성 또는 no-op
2. 기존 파일 symlink 검사: `lstat(filePath)` -> `isSymbolicLink()` -> Error throw
3. 임시 파일 생성: PID + randomBytes(4) 접미사로 충돌 방지
4. 임시 파일에 토큰 쓰기: `writeFile(tmp, token, { encoding: 'utf-8', mode: 0o600 })`
5. 원자적 이름 변경: `rename(tmp, filePath)` -- POSIX에서 원자적 보장
6. 실패 시 정리: `unlink(tmp)` -- best-effort (catch 무시)

플랫폼별 동작 테이블:
| 플랫폼 | rename 원자성 | 파일 권한 0o600 | 추가 대응 |
|--------|:----------:|:---------:|----------|
| macOS (APFS/HFS+) | O | O | 없음 |
| Linux (ext4/xfs) | O | O | 없음 |
| Windows (NTFS) | 조건부 | X (제한적) | EPERM 재시도 (10-50ms 랜덤 대기, 최대 3회) + 권한 경고 로그 |
| Docker (bind mount) | O (호스트 FS 의존) | O (호스트 FS 의존) | 없음 |

3개 쓰기 주체와 Last-Writer-Wins 정책:
| 컴포넌트 | 프로세스 | 쓰기 시점 | 사용 함수 |
|----------|---------|----------|----------|
| MCP SessionManager | Claude Desktop 자식 프로세스 | 갱신 성공 시 | writeMcpToken() |
| Telegram Bot | 데몬 메인 프로세스 | /newsession 시 | writeMcpToken() |
| CLI | 독립 프로세스 | mcp setup, mcp refresh-token | writeMcpToken() |

(d) **모노레포 패키지 구조 업데이트:**
`packages/core/src/` 디렉토리 트리에 `utils/token-file.ts` 추가:
```
├── utils/
│   └── token-file.ts           # [v0.9] getMcpTokenPath, writeMcpToken, readMcpToken
```

모든 추가 내용에 `[v0.9]` 태그를 부여하여 버전별 변경 추적을 가능하게 한다.
  </action>
  <verify>
24-monorepo-data-directory.md에서 다음을 확인:
1. 데이터 디렉토리 트리에 `mcp-token` 항목이 있는지 grep
2. "토큰 파일 사양" 또는 관련 섹션이 존재하는지 확인
3. getMcpTokenPath, writeMcpToken, readMcpToken 함수명이 포함되어 있는지 확인
4. write-then-rename 패턴이 기술되어 있는지 확인
5. [v0.9] 태그가 새 콘텐츠에 포함되어 있는지 확인
  </verify>
  <done>
24-monorepo-data-directory.md에 (1) 데이터 디렉토리 트리의 mcp-token 항목, (2) 토큰 파일 사양 테이블 (경로/포맷/권한/인코딩/symlink/크기/소유권/Windows), (3) 3개 공유 유틸리티 함수 시그니처+동작+에러 처리, (4) 원자적 쓰기 패턴 상세 (단계별, 플랫폼별, 쓰기 주체별)가 모두 포함되어 있다.
  </done>
</task>

<task type="auto">
  <name>Task 2: v0.9 objectives에 토큰 파일 인프라 설계 결과 반영</name>
  <files>objectives/v0.9-session-management-automation.md</files>
  <action>
v0.9 objectives 문서에 Phase 36-01 설계 결과를 반영한다. 문서의 관련 섹션(토큰 파일 관련)에 설계 완료 상태를 표시하고, 핵심 설계 결정 사항을 요약한다.

**구체적 수정:**

1. SMGR-02 요구사항 상태를 "설계 완료"로 업데이트 (체크박스 또는 상태 표시가 있다면)
2. SMGR-07 요구사항 상태를 "설계 완료"로 업데이트
3. 토큰 파일 관련 섹션에 다음 설계 결정 요약 추가 (이미 있는 내용은 "[설계 확정]" 태그 추가):
   - 공유 유틸리티: `@waiaas/core` `utils/token-file.ts` (getMcpTokenPath, writeMcpToken, readMcpToken)
   - 원자적 쓰기: write-then-rename 패턴, 외부 라이브러리 없음
   - readMcpToken: 동기 함수 (`readFileSync`)
   - Windows EPERM: 10-50ms 랜덤 대기, 최대 3회 재시도
   - Windows 파일 권한: 0o600 미적용, 경고 로그 출력, 사용자 프로필 격리에 의존
   - 설계 문서 위치: 24-monorepo-data-directory.md

문서의 기존 구조와 어조를 유지하면서 최소한의 변경으로 설계 결과를 반영한다.
  </action>
  <verify>
v0.9 objectives 문서에서:
1. SMGR-02, SMGR-07 관련 내용에 설계 완료 표시가 있는지 확인
2. token-file.ts 또는 공유 유틸리티 참조가 포함되어 있는지 확인
3. 기존 문서 구조가 유지되었는지 확인 (불필요한 내용 삭제 없음)
  </verify>
  <done>
v0.9 objectives 문서에 SMGR-02, SMGR-07의 설계 완료 상태가 반영되고, 토큰 파일 인프라의 핵심 설계 결정(공유 유틸리티 위치, 원자적 쓰기 패턴, readMcpToken 동기 API, Windows 대응)이 요약되어 있다.
  </done>
</task>

</tasks>

<verification>
Phase 36 Success Criteria 중 Plan 01이 담당하는 항목:
1. [SC-1] ~/.waiaas/mcp-token 파일 사양(경로, 포맷, 권한 0o600, 인코딩, symlink 거부)이 설계 문서에 명확히 정의되어 있다 -> 24-monorepo-data-directory.md 토큰 파일 사양 테이블 확인
2. [SC-2] 원자적 토큰 파일 쓰기 패턴(write-then-rename, Windows NTFS 대응)이 설계 문서에 정의되어 있다 -> 24-monorepo-data-directory.md 원자적 쓰기 패턴 섹션 확인
</verification>

<success_criteria>
- 24-monorepo-data-directory.md에 mcp-token 파일이 데이터 디렉토리 트리에 추가됨
- 토큰 파일 사양 9개 항목(경로, 포맷, 인코딩, 권한, 디렉토리 권한, symlink, 최대 크기, 소유권 모델, Windows 제한)이 모두 정의됨
- 공유 유틸리티 3개 함수(getMcpTokenPath, writeMcpToken, readMcpToken)의 시그니처와 동작이 정의됨
- 원자적 쓰기 패턴의 6단계 절차와 4개 플랫폼별 동작이 정의됨
- 3개 쓰기 주체(MCP, CLI, Telegram)와 Last-Writer-Wins 정책이 정의됨
- v0.9 objectives에 SMGR-02, SMGR-07 설계 완료 상태가 반영됨
</success_criteria>

<output>
After completion, create `.planning/phases/36-토큰-파일-인프라-알림-이벤트/36-01-SUMMARY.md`
</output>
