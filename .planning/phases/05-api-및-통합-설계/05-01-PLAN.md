---
phase: 05-api-및-통합-설계
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/18-authentication-model.md
  - .planning/deliverables/19-permission-policy-model.md
autonomous: true

must_haves:
  truths:
    - "API Key 인증 방식이 키 생성, 해싱, 스코프, IP 화이트리스트, 만료/로테이션을 포함하여 완전히 설계됨"
    - "OAuth 2.1 Client Credentials Grant 흐름이 PKCE, Dynamic Client Registration과 함께 정의됨"
    - "MCP Authorization 레이어가 OAuth 2.1 기반으로 Protected Resource Metadata 노출과 함께 설계됨"
    - "RBAC + ABAC 하이브리드 권한 모델에서 4가지 역할과 4가지 정책 속성이 매핑됨"
    - "에이전트 정책(금액 한도, 화이트리스트, 시간 제어, 에스컬레이션)이 API 요청/응답 스키마로 변환됨"
    - "Rate Limiting 3-Layer 전략(IP, API Key, 에이전트별)이 기본값과 함께 설계됨"
  artifacts:
    - path: ".planning/deliverables/18-authentication-model.md"
      provides: "에이전트 인증 모델 설계 (API-02)"
      contains: "wai_live_"
    - path: ".planning/deliverables/19-permission-policy-model.md"
      provides: "권한 및 정책 모델 설계 (API-03)"
      contains: "AgentPolicy"
  key_links:
    - from: "18-authentication-model.md"
      to: "08-dual-key-architecture.md"
      via: "API Key가 Owner/Agent Key 구조와 연동 - 소유자가 API Key 생성, 에이전트가 사용"
      pattern: "Owner.*API Key|Agent.*API Key"
    - from: "19-permission-policy-model.md"
      to: "13-fund-deposit-process.md"
      via: "BudgetConfig 인터페이스가 정책 모델의 ABAC 속성으로 매핑"
      pattern: "BudgetConfig|AgentPolicy"
    - from: "18-authentication-model.md"
      to: "19-permission-policy-model.md"
      via: "인증(Authentication) 후 권한(Authorization) 검증 - 스코프가 RBAC 역할에 매핑"
      pattern: "ApiScope|ApiRole"
---

<objective>
에이전트 인증 모델(API-02)과 권한/정책 모델(API-03) 설계 문서를 작성한다.

Purpose: API 접근의 인증(Authentication)과 인가(Authorization) 체계를 정의한다. 인증 모델은 API Key, OAuth 2.1, MCP Authorization의 3계층 인증을 설계하고, 정책 모델은 Phase 4에서 확정된 4가지 정책(금액 한도, 화이트리스트, 시간 제어, 에스컬레이션)을 API 레벨의 RBAC+ABAC 하이브리드 모델로 변환한다. 이 두 문서는 Phase 5의 나머지 설계(OpenAPI 스펙, SDK, MCP 통합)의 기반이 된다.

Output: .planning/deliverables/18-authentication-model.md, .planning/deliverables/19-permission-policy-model.md
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5 research (MUST READ - all patterns, standards, code examples)
@.planning/phases/05-api-및-통합-설계/05-RESEARCH.md

# Phase 3 deliverables (Dual Key architecture, system components)
@.planning/deliverables/08-dual-key-architecture.md
@.planning/deliverables/09-system-components.md
@.planning/deliverables/10-transaction-flow.md

# Phase 4 deliverables (funding/withdrawal process, agent lifecycle, emergency, multi-agent)
@.planning/deliverables/13-fund-deposit-process.md
@.planning/deliverables/14-fund-withdrawal-process.md
@.planning/deliverables/15-agent-lifecycle-management.md
@.planning/deliverables/16-emergency-recovery.md
@.planning/deliverables/17-multi-agent-management.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 에이전트 인증 모델 설계 문서 작성 (API-02)</name>
  <files>.planning/deliverables/18-authentication-model.md</files>
  <action>
  API-02 에이전트 인증 모델 설계 문서를 작성한다. 문서 상단에 "문서 ID: API-02", 작성일, 상태, 참조 문서를 기재한다. 아래 섹션을 반드시 포함할 것.

  **1. 개요: 인증 계층 구조**
  - 3계층 인증 모델 다이어그램 (ASCII 또는 Mermaid):
    - Layer 1: API Key Authentication (에이전트/서비스 직접 접근 - Primary)
    - Layer 2: OAuth 2.1 Client Credentials (서드파티 위임 접근 - Secondary)
    - Layer 3: MCP Authorization (AI 에이전트 프레임워크 전용)
  - 각 계층의 사용 시나리오 테이블: "누가, 어떤 상황에, 어떤 인증 방식을" 매핑
  - 핵심 원칙: AI 에이전트는 비인터랙티브(non-interactive), 브라우저 리다이렉트 불가, API Key가 Primary

  **2. API Key Authentication 상세 설계**
  - API Key 구조: 접두사 체계 (wai_live_*, wai_test_*), 키 길이 (32바이트 랜덤 + 접두사), 키 ID(key_xxxx)
  - ApiKey TypeScript 인터페이스 (05-RESEARCH.md Pattern 2 기반, 그대로 활용): id, prefix, hashedKey(SHA-256, 원본 저장 금지), ownerId, projectId, scopes, ipWhitelist, expiresAt, lastUsedAt, createdAt
  - ApiScope 타입 정의 (05-RESEARCH.md 기반): agents:read/write/delete, transactions:read/execute, wallets:read/fund, policies:read/write, dashboard:read, admin:all
  - 키 생명주기: 생성(POST /api/v1/auth/keys) -> 사용(Authorization: Bearer wai_live_xxx) -> 로테이션(새 키 생성 -> 기존 키 비활성 -> 유예기간 -> 폐기) -> 폐기(DELETE /api/v1/auth/keys/:keyId)
  - 키 저장: SHA-256 해싱 저장, 원본은 생성 시 한 번만 반환 (Stripe 패턴)
  - IP 화이트리스트: CIDR 표기 지원, 빈 목록 = 모든 IP 허용
  - Rate Limiting 연동: API Key별 rate limit 적용 (19-permission-policy-model.md에서 상세화)

  **3. OAuth 2.1 Client Credentials 설계**
  - 사용 시나리오: 서드파티 에이전트 프레임워크, 마이크로서비스 간 통신, 위임 접근
  - OAuth 2.1 핵심 요구사항: PKCE 필수 (Implicit Grant 폐지), S256 code challenge method
  - Client Credentials Grant 플로우 시퀀스 다이어그램 (Mermaid):
    Client -> Authorization Server: POST /oauth/token (client_id, client_secret, grant_type=client_credentials, scope)
    Authorization Server -> Client: access_token (JWT, 15분), refresh_token (7일)
  - Dynamic Client Registration (DCR): POST /oauth/register로 에이전트별 고유 client_id 발급. 에이전트 생성 시 자동 등록 옵션.
  - 토큰 구조: JWT claims (sub, iss, aud, exp, iat, scope, agent_id, owner_id, jti)
  - 토큰 수명: access_token 15분, refresh_token 7일, refresh_token rotation 적용
  - 스코프와 API Key scopes의 일관성 유지 (동일한 ApiScope 체계 공유)

  **4. MCP Authorization 설계**
  - MCP 스펙 요구사항: OAuth 2.1 기반 인증, Protected Resource Metadata (PRM) 노출
  - PRM 엔드포인트: GET /.well-known/oauth-protected-resource -> resource, authorization_servers, scopes_supported, bearer_methods_supported
  - OAuth Authorization Server Metadata: GET /.well-known/oauth-authorization-server -> issuer, token_endpoint, registration_endpoint, scopes_supported
  - MCP + API Key 어댑터: MCP 클라이언트가 API Key를 Bearer Token으로 직접 전달하는 경로 지원 (05-RESEARCH.md Open Question 2 해결)
  - MCP 인증 플로우 다이어그램 (Mermaid): MCP Client -> PRM Discovery -> OAuth Token -> MCP Server -> WAIaaS API

  **5. 보안 고려사항**
  - 키 유출 시 대응: 즉시 폐기 API + 관련 에이전트 SUSPENDED 전환
  - 비정상 사용 탐지: 동일 키 다중 IP, 비정상 시간대 접근, 실패 횟수 임계값
  - TLS 필수: HTTPS only, HTTP 요청 거부
  - CORS 정책: API 서버는 서비스 간 통신이므로 기본 비활성, 대시보드 UI 별도
  - 감사 로그: 모든 인증 이벤트 기록 (성공/실패, IP, User-Agent, 타임스탬프)

  **6. 인증 관련 API 엔드포인트 요약**
  - POST /api/v1/auth/keys (API Key 생성), GET /api/v1/auth/keys (목록), DELETE /api/v1/auth/keys/:keyId (폐기)
  - POST /oauth/token (토큰 발급), POST /oauth/register (DCR)
  - GET /.well-known/oauth-protected-resource (MCP PRM)
  - GET /.well-known/oauth-authorization-server (OAuth 메타데이터)
  - 각 엔드포인트의 요청/응답 요약 (상세 스키마는 API-01 OpenAPI 스펙에서)

  최소 3개의 다이어그램 포함: 3계층 인증 구조, OAuth 2.1 Client Credentials 플로우, MCP 인증 플로우.
  05-RESEARCH.md의 Pattern 2 (Dual Authentication Model) 코드 예시를 기반으로 하되, 문서 맥락에 맞게 확장할 것.
  Phase 3 문서(08-dual-key-architecture.md)와의 연결: API Key가 Owner/Agent Key 구조 위에 어떻게 레이어링되는지 명시.
  </action>
  <verify>
  파일 존재: ls .planning/deliverables/18-authentication-model.md
  3계층 인증: grep -c "API Key\|OAuth 2.1\|MCP Authorization" .planning/deliverables/18-authentication-model.md (6 이상)
  API Key 설계: grep -c "wai_live_\|wai_test_\|SHA-256\|hashedKey" .planning/deliverables/18-authentication-model.md (3 이상)
  OAuth 요소: grep -c "client_credentials\|PKCE\|refresh_token\|Dynamic Client Registration" .planning/deliverables/18-authentication-model.md (3 이상)
  MCP 메타데이터: grep -c "oauth-protected-resource\|oauth-authorization-server" .planning/deliverables/18-authentication-model.md (2 이상)
  다이어그램: grep -c "```mermaid" .planning/deliverables/18-authentication-model.md (3 이상)
  스코프 체계: grep -c "agents:read\|transactions:execute\|ApiScope" .planning/deliverables/18-authentication-model.md (3 이상)
  </verify>
  <done>
  - 3계층 인증 모델(API Key, OAuth 2.1, MCP Authorization)이 사용 시나리오와 함께 설계됨
  - API Key 구조, 생명주기, 저장 방식, IP 화이트리스트가 상세 명세됨
  - OAuth 2.1 Client Credentials Grant가 PKCE, DCR, 토큰 구조와 함께 정의됨
  - MCP Authorization이 PRM, OAuth 메타데이터, API Key 어댑터와 함께 설계됨
  - 보안 고려사항(키 유출 대응, 비정상 탐지, TLS, 감사 로그)이 포함됨
  - 최소 3개의 Mermaid 다이어그램이 포함됨
  </done>
</task>

<task type="auto">
  <name>Task 2: 권한 및 정책 모델 설계 문서 작성 (API-03)</name>
  <files>.planning/deliverables/19-permission-policy-model.md</files>
  <action>
  API-03 권한 및 정책 모델 설계 문서를 작성한다. 문서 상단에 "문서 ID: API-03", 작성일, 상태, 참조 문서를 기재한다. 아래 섹션을 반드시 포함할 것.

  **1. 개요: RBAC + ABAC 하이브리드 권한 모델**
  - RBAC: API 접근 수준의 역할 기반 제어 (누가 어떤 API를 호출 가능한지)
  - ABAC: 에이전트 정책 수준의 속성 기반 제어 (어떤 조건에서 트랜잭션이 허용되는지)
  - 두 모델의 결합 다이어그램: 요청 -> 인증(API Key/OAuth) -> RBAC 검사(역할+스코프) -> ABAC 검사(정책 속성) -> 허용/거부
  - Phase 4에서 확정된 3-Layer 정책 검증과의 관계 (서버 정책 -> Enclave 서명 -> Squads 온체인)

  **2. RBAC: API 역할 및 스코프 매핑**
  - 역할 정의 테이블:
    - owner: 에이전트 생성/삭제, 정책 변경, 자금 충전/회수, 대시보드, 비상 조작. 모든 스코프
    - agent: 트랜잭션 실행, 잔액 조회, 정책 조회. transactions:execute/read, wallets:read, policies:read
    - viewer: 읽기 전용. agents:read, transactions:read, wallets:read, policies:read, dashboard:read
    - auditor: 감사 목적 읽기. 모든 :read 스코프 + 감사 로그 접근
  - 역할-스코프 매트릭스 테이블 (role x scope -> allow/deny)
  - API Key 생성 시 스코프 제한: 소유자가 키 생성 시 부여 가능한 스코프는 자신의 역할 이하
  - 엔드포인트별 필요 스코프 매핑 테이블 (최소 20개 주요 엔드포인트)

  **3. ABAC: 에이전트 정책 속성 모델**
  - Phase 4 확정 4가지 정책을 API 레벨로 변환:
    1. 금액 한도 (AgentPolicy.limits): perTransaction, daily, weekly, monthly. bigint(lamports). 05-RESEARCH.md의 AgentPolicy 인터페이스 기반
    2. 화이트리스트 (AgentPolicy.whitelist): allowedDestinations(주소), allowedPrograms(프로그램 ID), allowedTokenMints(토큰). 빈 배열 = 전체 허용
    3. 시간 제어 (AgentPolicy.timeControl): operatingHoursUtc(start/end), blackoutDates. null = 24/7
    4. 에스컬레이션 (AgentPolicy.escalation): 4단계 임계값 (low/medium/high/critical). Phase 3 ARCH-03 확정 4-tier 에스컬레이션과 매핑
  - AgentPolicy TypeScript 인터페이스 전체 정의 (05-RESEARCH.md Pattern 4 기반, Phase 4 인터페이스와 일관성 유지)
  - 정책 검증 흐름 다이어그램 (Mermaid): 트랜잭션 요청 -> 금액 한도 검사 -> 화이트리스트 검사 -> 시간 제어 검사 -> 에스컬레이션 레벨 결정 -> 허용/거부/승인대기

  **4. 정책 관리 API 설계**
  - GET /api/v1/agents/:agentId/policy: 현재 정책 조회. 응답 스키마: AgentPolicy 전체
  - PUT /api/v1/agents/:agentId/policy: 정책 변경. 요청: 변경할 필드만 (partial update). 변경 시 Squads Spending Limit도 동기 업데이트 필요
  - GET /api/v1/agents/:agentId/policy/usage: 현재 사용량 조회. 응답: 일일/주간/월간 사용량, 남은 한도, 마지막 리셋 시점
  - 정책 변경 이력 기록: policy_change_log 테이블 (변경자, 변경 전/후, 타임스탬프, 변경 사유)
  - 정책 변경의 즉시 적용 vs 다음 기간 적용 규칙: 한도 증가는 즉시, 한도 감소는 현재 기간 사용량 초과 시 다음 기간부터

  **5. Rate Limiting 전략**
  - 3-Layer Rate Limiting 구조 (05-RESEARCH.md Open Question 5 반영):
    - Layer 1: IP 기반 글로벌 한도 (DDoS 방어, 1000 req/min per IP)
    - Layer 2: API Key별 한도 (등급별 차등, 기본 100 req/min, 프리미엄 500 req/min)
    - Layer 3: 에이전트별 트랜잭션 빈도 한도 (정책 시간 제어와 연동, 기본 10 tx/min)
  - @fastify/rate-limit + Redis 기반 분산 Rate Limiting 설계 참조
  - Rate Limit 응답 헤더: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, Retry-After
  - 429 Too Many Requests 에러 응답 형식 (RFC 9457 기반 - API-04 에러 코드와 연동)
  - Rate Limit 초과 시 에스컬레이션: 반복 초과 시 일시 차단 -> 소유자 알림

  **6. 정책 템플릿 (사전 정의)**
  - 에이전트 유형별 정책 프리셋 테이블:
    - conservative: 낮은 한도, 좁은 화이트리스트, 영업시간만, 모든 에스컬레이션 활성
    - standard: 중간 한도, 넓은 화이트리스트, 24/7, HIGH부터 에스컬레이션
    - permissive: 높은 한도, 화이트리스트 없음, 24/7, CRITICAL만 에스컬레이션
  - 에이전트 생성 시 프리셋 선택 또는 커스텀 정책 직접 정의

  **7. 온체인-오프체인 정책 동기화**
  - 서버 정책(오프체인) 변경 시 Squads Spending Limit(온체인) 자동 동기화
  - 동기화 실패 시 처리: 서버 정책을 온체인 한도보다 항상 엄격하게 유지 (defense-in-depth)
  - 동기화 상태 추적: sync_status (synced/pending/failed), last_synced_at

  최소 2개의 다이어그램 포함: RBAC+ABAC 결합 흐름, 정책 검증 순서.
  Phase 4 문서(13, 14, 15, 16, 17)에서 정의된 인터페이스와의 일관성을 명시적으로 유지할 것.
  Task 1의 18-authentication-model.md와 상호 참조: 인증(who) -> 권한(what) 연결.
  </action>
  <verify>
  파일 존재: ls .planning/deliverables/19-permission-policy-model.md
  RBAC+ABAC: grep -c "RBAC\|ABAC" .planning/deliverables/19-permission-policy-model.md (4 이상)
  4가지 정책: grep -c "금액 한도\|화이트리스트\|시간 제어\|에스컬레이션" .planning/deliverables/19-permission-policy-model.md (4 이상)
  역할 정의: grep -c "owner\|agent\|viewer\|auditor" .planning/deliverables/19-permission-policy-model.md (4 이상)
  AgentPolicy 인터페이스: grep -c "interface AgentPolicy\|AgentPolicy" .planning/deliverables/19-permission-policy-model.md (2 이상)
  Rate Limiting: grep -c "Rate Limit\|X-RateLimit\|429" .planning/deliverables/19-permission-policy-model.md (3 이상)
  다이어그램: grep -c "```mermaid" .planning/deliverables/19-permission-policy-model.md (2 이상)
  정책 템플릿: grep -c "conservative\|standard\|permissive" .planning/deliverables/19-permission-policy-model.md (3 이상)
  </verify>
  <done>
  - RBAC + ABAC 하이브리드 모델이 역할(owner/agent/viewer/auditor)과 정책 속성(한도/화이트리스트/시간/에스컬레이션)으로 정의됨
  - 역할-스코프 매트릭스와 엔드포인트별 필요 스코프가 매핑됨
  - Phase 4 확정 4가지 정책이 AgentPolicy TypeScript 인터페이스로 API 레벨 변환됨
  - 정책 관리 API(조회/변경/사용량)가 요청/응답과 함께 설계됨
  - 3-Layer Rate Limiting 전략이 기본값과 함께 정의됨
  - 정책 템플릿(conservative/standard/permissive)이 프리셋으로 제공됨
  - 온체인-오프체인 정책 동기화 메커니즘이 설계됨
  - 최소 2개의 Mermaid 다이어그램이 포함됨
  </done>
</task>

</tasks>

<verification>
Phase 5 Plan 01 전체 검증:
1. 두 문서가 .planning/deliverables/에 존재: ls .planning/deliverables/18-authentication-model.md .planning/deliverables/19-permission-policy-model.md
2. 18번 문서에 3계층 인증(API Key, OAuth 2.1, MCP Authorization)이 설계됨
3. 19번 문서에 RBAC+ABAC 하이브리드 모델, 4가지 정책, Rate Limiting이 설계됨
4. 두 문서 간 상호 참조가 존재 (인증 -> 권한 연결)
5. 총 Mermaid 다이어그램 5개 이상 (18번 3+, 19번 2+)
6. Phase 3/4 문서와의 연결 참조 존재 (특히 08, 13, 15)
7. 스코프 체계(ApiScope)가 두 문서에서 일관됨
</verification>

<success_criteria>
- API-02 충족: API Key, OAuth 2.1 등 인증 방식이 설계됨
- API-03 충족: 한도, 화이트리스트, 시간 제어가 설계됨
- 인증-권한 연결: 인증(who) -> RBAC(what role) -> ABAC(what conditions) 파이프라인이 명확
- Phase 4 일관성: AgentPolicy가 Phase 4 문서의 BudgetConfig, 정책 속성과 일관됨
- 보안 원칙: Fail-safe(거부 기본), defense-in-depth(서버 정책 >= 온체인 한도)
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-및-통합-설계/05-01-SUMMARY.md`
</output>
