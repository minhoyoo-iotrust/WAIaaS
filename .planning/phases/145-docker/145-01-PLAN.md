---
phase: 145-docker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - docker-compose.yml
  - docker/entrypoint.sh
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "docker build로 이미지가 성공적으로 빌드된다"
    - "컨테이너 내부에서 데몬이 non-root(UID 1001, waiaas) 프로세스로 실행된다"
    - "docker compose up 후 /health 엔드포인트가 200을 반환한다"
    - "_FILE 패턴으로 시크릿 파일에서 환경변수가 안전하게 주입된다"
    - "named volume에 데이터가 영속되어 compose down 후 up해도 유지된다"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Docker 이미지 빌드 (builder + runner)"
      contains: "FROM node:22-slim"
    - path: "docker-compose.yml"
      provides: "원클릭 배포 compose 설정"
      contains: "waiaas-data"
    - path: "docker/entrypoint.sh"
      provides: "_FILE 패턴 시크릿 처리 + exec node"
      contains: "_FILE"
    - path: ".dockerignore"
      provides: "빌드 컨텍스트 최소화"
      contains: "node_modules"
  key_links:
    - from: "Dockerfile"
      to: "docker/entrypoint.sh"
      via: "COPY + ENTRYPOINT"
      pattern: "ENTRYPOINT.*entrypoint"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
    - from: "docker/entrypoint.sh"
      to: "packages/daemon/dist"
      via: "exec node로 데몬 실행"
      pattern: "exec node"
---

<objective>
Dockerfile + docker-compose.yml + entrypoint.sh 생성 -- Multi-stage 빌드로 WAIaaS 데몬 Docker 이미지를 빌드하고, docker compose up 한 줄로 실행할 수 있는 인프라를 구축한다.

Purpose: Docker 원클릭 배포 인프라 구축 (DOCK-01, DOCK-02, DOCK-03, DOCK-06)
Output: Dockerfile, docker-compose.yml, docker/entrypoint.sh, .dockerignore
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@package.json
@pnpm-workspace.yaml
@turbo.json
@packages/daemon/package.json
@packages/core/package.json
@packages/admin/package.json
@packages/cli/package.json
@packages/daemon/src/index.ts
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/infrastructure/config/loader.ts
@packages/cli/src/commands/start.ts
@packages/cli/src/utils/password.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: .dockerignore + Multi-stage Dockerfile</name>
  <files>.dockerignore, Dockerfile</files>
  <action>
**1. .dockerignore 생성 (프로젝트 루트)**

빌드 컨텍스트에서 불필요한 파일을 제외한다:
```
node_modules
dist
.turbo
coverage
.git
.gitignore
.env*
*.md
!README.md
.DS_Store
.idea
.vscode
*.swp
*.swo
*.tsbuildinfo
how-to-test
.planning
objectives
docs
packages/daemon/public
```

**2. Multi-stage Dockerfile 생성 (프로젝트 루트)**

**Stage 1: builder**
```dockerfile
FROM node:22-slim AS builder
```
- `RUN corepack enable && corepack prepare pnpm@9.15.4 --activate` (package.json의 packageManager와 일치)
- 작업 디렉토리: `/app`
- 복사 순서 (레이어 캐싱 최적화):
  1. `pnpm-workspace.yaml`, `package.json`, `pnpm-lock.yaml`, `turbo.json` 먼저 복사
  2. 각 패키지의 `package.json`만 복사: `packages/core/package.json`, `packages/daemon/package.json`, `packages/admin/package.json`, `packages/adapters/solana/package.json`, `packages/adapters/evm/package.json`, `packages/cli/package.json`, `packages/sdk/package.json`, `packages/mcp/package.json`
  3. `RUN pnpm install --frozen-lockfile` (의존성 레이어 분리)
  4. 전체 소스 복사: `COPY . .`
  5. `RUN pnpm turbo build --filter=@waiaas/daemon...` (daemon과 모든 의존 패키지 빌드. turbo.json에서 @waiaas/daemon#build가 @waiaas/admin#build + ^build에 의존하므로 admin build 포함)

**주의: native addon (sodium-native, better-sqlite3, argon2)**
- `node:22-slim`은 glibc 기반이므로 prebuildify 바이너리 호환
- builder 단계에서 build-essential 필요 여부 확인: `RUN apt-get update && apt-get install -y python3 make g++ --no-install-recommends && rm -rf /var/lib/apt/lists/*` (native addon 빌드에 필요할 수 있음)

**Stage 2: runner**
```dockerfile
FROM node:22-slim AS runner
```
- native addon 런타임 의존성 설치 (slim 이미지에 누락될 수 있는 라이브러리):
  - `RUN apt-get update && apt-get install -y curl --no-install-recommends && rm -rf /var/lib/apt/lists/*` (curl은 HEALTHCHECK에 필요)
- non-root 유저 생성: `RUN groupadd -g 1001 waiaas && useradd -u 1001 -g waiaas -m -s /bin/sh waiaas`
- 작업 디렉토리: `/app`
- pnpm 활성화: `RUN corepack enable && corepack prepare pnpm@9.15.4 --activate`
- builder에서 필요한 파일만 복사:
  1. `COPY --from=builder /app/package.json /app/pnpm-workspace.yaml /app/pnpm-lock.yaml /app/turbo.json /app/`
  2. 각 패키지의 `package.json` 복사
  3. `RUN pnpm install --frozen-lockfile --prod` (production 의존성만)
  4. 빌드 산출물 복사: 각 패키지의 `dist/` 디렉토리 복사
     - `COPY --from=builder /app/packages/core/dist /app/packages/core/dist`
     - `COPY --from=builder /app/packages/daemon/dist /app/packages/daemon/dist`
     - `COPY --from=builder /app/packages/daemon/public /app/packages/daemon/public` (admin UI 빌드 산출물)
     - `COPY --from=builder /app/packages/adapters/solana/dist /app/packages/adapters/solana/dist`
     - `COPY --from=builder /app/packages/adapters/evm/dist /app/packages/adapters/evm/dist`
     - `COPY --from=builder /app/packages/cli/dist /app/packages/cli/dist`
     - `COPY --from=builder /app/packages/cli/bin /app/packages/cli/bin`
     - `COPY --from=builder /app/packages/sdk/dist /app/packages/sdk/dist` (daemon에서 직접 의존하지 않지만 workspace 무결성)
     - `COPY --from=builder /app/packages/mcp/dist /app/packages/mcp/dist`
- entrypoint 복사: `COPY docker/entrypoint.sh /app/entrypoint.sh`
- 실행 권한: `RUN chmod +x /app/entrypoint.sh`
- 데이터 디렉토리 생성 + 소유권: `RUN mkdir -p /data && chown -R waiaas:waiaas /data /app`
- ENV 설정:
  - `ENV NODE_ENV=production`
  - `ENV WAIAAS_DATA_DIR=/data` (데몬이 사용할 데이터 디렉토리)
  - `ENV WAIAAS_DAEMON_HOSTNAME=0.0.0.0` (컨테이너 내부에서 모든 인터페이스 바인딩 -- compose에서 포트 매핑으로 localhost 제한)
- EXPOSE: `EXPOSE 3100`
- HEALTHCHECK: `HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 CMD curl -f http://localhost:3100/health || exit 1` (health route가 `/health`에 마운트됨, NOT `/v1/health`)
- USER: `USER waiaas`
- ENTRYPOINT: `ENTRYPOINT ["/app/entrypoint.sh"]`

**보안 사항:**
- 시크릿(MASTER_PASSWORD 등)은 build-time ARG로 전달하지 않는다 (레이어에 기록됨)
- runner 스테이지에는 devDependencies, 소스코드(.ts), 빌드 도구가 포함되지 않는다
- .dockerignore로 .env, .git, node_modules 등 민감한 파일이 빌드 컨텍스트에 포함되지 않는다
  </action>
  <verify>
1. `docker build -t waiaas:test .` 가 에러 없이 완료된다
2. `docker run --rm waiaas:test whoami` 가 `waiaas`를 출력한다
3. `docker run --rm waiaas:test id -u` 가 `1001`을 출력한다
4. `docker image inspect waiaas:test --format='{{.Config.Healthcheck}}'` 가 HEALTHCHECK 설정을 보여준다
  </verify>
  <done>
Multi-stage Dockerfile이 성공적으로 빌드되고, runner 이미지에서 non-root waiaas(UID 1001) 유저로 실행되며, HEALTHCHECK가 설정된다. .dockerignore로 빌드 컨텍스트가 최소화된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: entrypoint.sh + docker-compose.yml</name>
  <files>docker/entrypoint.sh, docker-compose.yml</files>
  <action>
**1. docker/entrypoint.sh 생성**

Docker Secrets + _FILE 패턴 처리 쉘 스크립트:
```bash
#!/bin/sh
set -e

# _FILE 패턴 처리: *_FILE 환경변수의 파일 내용을 원본 환경변수로 설정
# 예: WAIAAS_SECURITY_MASTER_PASSWORD_FILE=/run/secrets/master_password
#     -> WAIAAS_SECURITY_MASTER_PASSWORD=$(cat /run/secrets/master_password)
file_env() {
  local var="$1"
  local fileVar="${var}_FILE"
  local val=""

  eval val="\${$var:-}"
  local fileVal=""
  eval fileVal="\${$fileVar:-}"

  if [ -n "$val" ] && [ -n "$fileVal" ]; then
    echo "ERROR: Both $var and $fileVar are set. Use only one." >&2
    exit 1
  fi

  if [ -n "$fileVal" ]; then
    if [ ! -r "$fileVal" ]; then
      echo "ERROR: $fileVar=$fileVal is not readable" >&2
      exit 1
    fi
    val="$(cat "$fileVal")"
    export "$var"="$val"
    unset "$fileVar"
  fi
}

# 지원하는 _FILE 패턴 환경변수 목록
file_env WAIAAS_MASTER_PASSWORD
file_env WAIAAS_TELEGRAM_BOT_TOKEN
file_env WAIAAS_NOTIFICATIONS_TELEGRAM_BOT_TOKEN

echo "WAIaaS daemon starting..."
echo "Data directory: ${WAIAAS_DATA_DIR:-/data}"

# exec로 PID 1 교체 (시그널 전달 보장)
exec node /app/packages/cli/dist/index.js start --data-dir "${WAIAAS_DATA_DIR:-/data}"
```

**주의:**
- `#!/bin/sh` 사용 (bash 아님 -- slim 이미지에 bash 없을 수 있음)
- `set -e`로 에러 시 즉시 종료
- `exec`로 node 프로세스가 PID 1이 되도록 (SIGTERM 직접 수신)
- `file_env` 함수: 같은 변수에 직접 값과 _FILE이 동시 설정되면 에러
- `WAIAAS_MASTER_PASSWORD`는 CLI의 `resolvePassword()`가 `WAIAAS_MASTER_PASSWORD` 환경변수를 먼저 확인하므로 entrypoint에서 _FILE을 읽어 환경변수로 설정하면 자동 동작
- `WAIAAS_TELEGRAM_BOT_TOKEN`은 `WAIAAS_TELEGRAM_BOT_TOKEN` -> config loader가 `telegram.bot_token`으로 매핑 (applyEnvOverrides 함수)

**2. docker-compose.yml 생성 (프로젝트 루트)**

```yaml
services:
  daemon:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: waiaas-daemon
    ports:
      - "127.0.0.1:3100:3100"
    volumes:
      - waiaas-data:/data
    environment:
      - WAIAAS_DATA_DIR=/data
      - WAIAAS_DAEMON_HOSTNAME=0.0.0.0
    env_file:
      - path: .env
        required: false
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3100/health"]
      interval: 30s
      timeout: 5s
      start_period: 10s
      retries: 3

volumes:
  waiaas-data:
    driver: local
```

**Docker Secrets 사용 예제 (docker-compose.secrets.yml 주석):**
docker-compose.yml 상단에 주석으로 Docker Secrets 사용법을 안내한다:
```yaml
# Docker Secrets 사용법:
# 1. echo "your_master_password" | docker secret create waiaas_master_password -
# 2. docker compose -f docker-compose.yml -f docker-compose.secrets.yml up -d
#
# docker-compose.secrets.yml 예제:
# services:
#   daemon:
#     secrets:
#       - waiaas_master_password
#     environment:
#       - WAIAAS_MASTER_PASSWORD_FILE=/run/secrets/waiaas_master_password
# secrets:
#   waiaas_master_password:
#     external: true
```

또는 file-based secrets (Swarm 없이):
```yaml
# File-based secrets (Docker Compose without Swarm):
# services:
#   daemon:
#     secrets:
#       - waiaas_master_password
#     environment:
#       - WAIAAS_MASTER_PASSWORD_FILE=/run/secrets/waiaas_master_password
# secrets:
#   waiaas_master_password:
#     file: ./secrets/master_password.txt
```

기본 docker-compose.yml에서는 환경변수 직접 설정 또는 .env 파일 사용을 기본으로 한다. 시크릿 관리는 오버라이드 파일로 분리하여 유연성을 제공한다.

**포트 매핑 보안:**
- `127.0.0.1:3100:3100` -- localhost에서만 접근 가능 (외부 노출 방지)
- 컨테이너 내부에서는 `0.0.0.0:3100`으로 바인딩 (ENV WAIAAS_DAEMON_HOSTNAME=0.0.0.0)

**데이터 영속성:**
- `waiaas-data` named volume이 `/data`에 마운트
- 데몬이 `/data/config.toml`, `/data/data/waiaas.db`, `/data/keystore/` 사용
- `docker compose down`해도 named volume은 유지됨 (`docker compose down -v`로만 삭제)
  </action>
  <verify>
1. `ls docker/entrypoint.sh` 파일이 존재한다
2. `ls docker-compose.yml` 파일이 존재한다
3. `docker compose config` 가 문법 에러 없이 설정을 출력한다
4. `head -1 docker/entrypoint.sh` 가 `#!/bin/sh`를 출력한다
  </verify>
  <done>
entrypoint.sh가 _FILE 패턴으로 시크릿을 안전하게 주입하고, docker-compose.yml이 named volume + 포트 매핑 + HEALTHCHECK + restart 정책을 정의한다. `docker compose up` 한 줄로 데몬이 실행 가능하다.
  </done>
</task>

</tasks>

<verification>
1. `docker build -t waiaas:test .` -- 이미지 빌드 성공
2. `docker compose up -d` -- 컨테이너 시작 성공
3. `docker compose ps` -- daemon 서비스가 healthy 상태
4. `curl http://localhost:3100/health` -- 200 + `{"status":"ok"}` 응답
5. `docker compose exec daemon whoami` -- `waiaas` 출력
6. `docker compose exec daemon id -u` -- `1001` 출력
</verification>

<success_criteria>
- DOCK-01: Multi-stage Dockerfile이 builder(pnpm + turbo build)와 runner(non-root UID 1001)로 구성된다
- DOCK-02: docker-compose.yml이 named volume + 포트 매핑(127.0.0.1:3100:3100) + HEALTHCHECK를 정의한다
- DOCK-03: entrypoint.sh가 _FILE 패턴으로 MASTER_PASSWORD_FILE -> WAIAAS_MASTER_PASSWORD 시크릿을 주입한다
- DOCK-06: 컨테이너 프로세스가 non-root(UID 1001, waiaas)로 실행된다
</success_criteria>

<output>
After completion, create `.planning/phases/145-docker/145-01-SUMMARY.md`
</output>
