---
phase: 233-db-migration-schema-policy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/schemas/transaction.schema.ts
  - packages/daemon/src/pipeline/stages.ts
autonomous: true
requirements:
  - TXSC-01
  - TXSC-02
  - TXSC-03

must_haves:
  truths:
    - "TokenInfoSchema accepts optional assetId field (Caip19Schema.optional())"
    - "When assetId and address are both provided, cross-validation ensures the address in assetId matches the provided address"
    - "When assetId is provided with mismatched address, Zod validation fails with a clear error"
    - "Existing transactions without assetId field work identically (backward compatible)"
    - "TransactionParam in stages.ts includes optional assetId field and buildTransactionParam extracts it"
  artifacts:
    - path: "packages/core/src/schemas/transaction.schema.ts"
      provides: "TokenInfoSchema with optional assetId + superRefine cross-validation"
      contains: "assetId"
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "TransactionParam.assetId field + buildTransactionParam extraction"
      contains: "assetId"
  key_links:
    - from: "packages/core/src/schemas/transaction.schema.ts"
      to: "@waiaas/core caip/caip19.ts"
      via: "imports Caip19Schema and parseCaip19 for validation"
      pattern: "Caip19Schema\\.optional"
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/core/src/schemas/transaction.schema.ts"
      via: "TokenTransferRequest and ApproveRequest types carry assetId"
      pattern: "token\\.assetId"
---

<objective>
Extend TokenInfoSchema to accept optional CAIP-19 assetId with cross-validation against address, and propagate assetId through the pipeline's TransactionParam for use by policy evaluation.

Purpose: Enable transaction requests to specify tokens via CAIP-19 identifiers while maintaining backward compatibility with address-only requests. Cross-validation ensures data integrity when both are provided.

Output: Extended TokenInfoSchema with superRefine validation, updated TransactionParam interface and buildTransactionParam function.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/233-db-migration-schema-policy/233-RESEARCH.md
@packages/core/src/schemas/transaction.schema.ts
@packages/daemon/src/pipeline/stages.ts
@packages/core/src/caip/caip19.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TokenInfoSchema assetId extension with cross-validation</name>
  <files>
    packages/core/src/schemas/transaction.schema.ts
  </files>
  <action>
**Import additions at the top of the file:**

Add imports from the CAIP module (same package internal import):
```typescript
import { Caip19Schema, parseCaip19 } from '../caip/index.js';
```

**TokenInfoSchema changes:**

Replace the existing `TokenInfoSchema` (line 54-58) from a plain `z.object()` to a schema with `.superRefine()` for cross-validation. The base object gains an optional `assetId` field:

```typescript
/** Token metadata for TOKEN_TRANSFER and APPROVE requests. */
const TokenInfoBaseSchema = z.object({
  address: z.string().min(1), // mint address (SPL) or contract address (ERC-20)
  decimals: z.number().int().min(0).max(18),
  symbol: z.string().min(1).max(10),
  assetId: Caip19Schema.optional(),
});

/** TokenInfoSchema with cross-validation: when assetId is provided, its address must match the address field. */
const TokenInfoSchema = TokenInfoBaseSchema.superRefine((data, ctx) => {
  if (!data.assetId) return; // No assetId -> skip cross-validation (TXSC-03)

  try {
    const parsed = parseCaip19(data.assetId);
    const extractedAddress = parsed.assetReference;

    // Cross-validate: case-insensitive for EVM (Pitfall 1: checksummed vs lowercased)
    if (extractedAddress.toLowerCase() !== data.address.toLowerCase()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `assetId address '${extractedAddress}' does not match provided address '${data.address}'`,
        path: ['assetId'],
      });
    }
  } catch {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Invalid CAIP-19 assetId: ${data.assetId}`,
      path: ['assetId'],
    });
  }
});
```

**Key constraints:**
- `address` remains REQUIRED (per research decision: keep address required, assetId cross-validates but doesn't replace)
- `assetId` is `.optional()` so existing requests without it pass through unchanged (TXSC-03)
- Cross-validation uses `toLowerCase()` for both sides to handle EVM address casing (Pitfall 1: EVM checksummed addresses vs CAIP-19 lowercased)
- For Solana, `toLowerCase()` comparison is technically wrong (base58 is case-sensitive), but `tokenAssetId()` for Solana uses the `token:` namespace which preserves original casing, so both sides will have the same case. The comparison still works because Solana addresses are base58-encoded and `toLowerCase()` on two identical base58 strings still matches.

**No changes needed to other schemas:** `TokenTransferRequestSchema` and `ApproveRequestSchema` reference `TokenInfoSchema` by variable, so they automatically get the new field and validation.
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/core` to verify type correctness. Run `pnpm turbo run test --filter=@waiaas/core` to verify existing tests pass. Manually verify that the `z` import at the top is from `zod` (not `@hono/zod-openapi`) and that `Caip19Schema` import resolves correctly.
  </verify>
  <done>
TokenInfoSchema accepts optional assetId field. When assetId is provided, superRefine cross-validates that the embedded address matches the provided address field (case-insensitive). Existing requests without assetId pass through unchanged. TypeScript types for TokenTransferRequest and ApproveRequest auto-include the optional assetId.
  </done>
</task>

<task type="auto">
  <name>Task 2: TransactionParam assetId field + buildTransactionParam extraction</name>
  <files>
    packages/daemon/src/pipeline/stages.ts
  </files>
  <action>
**TransactionParam interface update (line ~177):**

Add optional `assetId` field to the `TransactionParam` interface:
```typescript
interface TransactionParam {
  type: string;
  amount: string;
  toAddress: string;
  chain: string;
  network?: string;
  tokenAddress?: string;
  assetId?: string;       // NEW: CAIP-19 asset identifier from token.assetId
  contractAddress?: string;
  selector?: string;
  spenderAddress?: string;
  approveAmount?: string;
}
```

**buildTransactionParam function update:**

In the `TOKEN_TRANSFER` case (line ~196-204), extract `assetId` from the token info:
```typescript
case 'TOKEN_TRANSFER': {
  const r = req as TokenTransferRequest;
  return {
    type: 'TOKEN_TRANSFER',
    amount: r.amount,
    toAddress: r.to,
    chain,
    tokenAddress: r.token.address,
    assetId: r.token.assetId,  // NEW: propagate CAIP-19 to policy engine
  };
}
```

In the `APPROVE` case, also extract assetId from the token info:
```typescript
case 'APPROVE': {
  const r = req as ApproveRequest;
  return {
    type: 'APPROVE',
    amount: r.amount,
    toAddress: r.spender,
    chain,
    tokenAddress: r.token.address,
    assetId: r.token.assetId,  // NEW: propagate CAIP-19 to policy engine
    spenderAddress: r.spender,
    approveAmount: r.amount,
  };
}
```

**Batch instruction handling update (line ~344 area):**

In the batch instruction mapping within `stage3Policy()`, add assetId extraction for instructions that have a token field:
```typescript
assetId: 'token' in instr ? (instr as { token?: { assetId?: string } }).token?.assetId : undefined,
```
Add this field to the instruction object construction, alongside the existing `tokenAddress` extraction.

**TXSC-03 backward compatibility:** When `assetId` is undefined (existing requests), `TransactionParam.assetId` is simply `undefined`. All downstream code (policy engine) treats undefined as "not provided" and falls back to address-only matching.
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/daemon` to verify no type errors. Run `pnpm turbo run test --filter=@waiaas/daemon -- --grep "stage"` to check pipeline tests. Verify that `TransactionParam` interface has `assetId?: string` and both TOKEN_TRANSFER and APPROVE cases in buildTransactionParam extract `r.token.assetId`.
  </verify>
  <done>
TransactionParam interface includes optional assetId field. buildTransactionParam extracts assetId from token info for TOKEN_TRANSFER and APPROVE types. Batch instruction mapping also extracts assetId. Existing requests without assetId produce undefined (backward compatible).
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/core` passes
2. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
3. `pnpm turbo run test --filter=@waiaas/core` passes (existing schema tests)
4. `pnpm turbo run test --filter=@waiaas/daemon -- --grep "stage"` passes (pipeline tests)
5. TokenInfoSchema has `assetId: Caip19Schema.optional()` field
6. TokenInfoSchema.superRefine cross-validates address when assetId is provided
7. TransactionParam interface has `assetId?: string`
8. buildTransactionParam extracts assetId for TOKEN_TRANSFER and APPROVE types
</verification>

<success_criteria>
- TokenInfoSchema accepts optional assetId (CAIP-19 format, validated by Caip19Schema)
- Cross-validation rejects mismatched assetId/address pairs with clear error messages
- Existing requests without assetId continue to work identically
- TransactionParam carries assetId through the pipeline for policy engine consumption
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/233-db-migration-schema-policy/233-02-SUMMARY.md`
</output>
