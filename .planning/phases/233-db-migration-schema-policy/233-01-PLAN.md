---
phase: 233-db-migration-schema-policy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/infrastructure/database/migrate.ts
  - packages/daemon/src/infrastructure/database/schema.ts
  - packages/daemon/src/infrastructure/token-registry/token-registry-service.ts
  - packages/daemon/src/api/routes/tokens.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
autonomous: true
requirements:
  - TOKN-02
  - TOKN-03
  - TOKN-04

must_haves:
  truths:
    - "DB v22 migration adds asset_id TEXT column to token_registry"
    - "Existing token_registry records have correct CAIP-19 asset_id backfilled from (network, address)"
    - "GET /v1/tokens response includes assetId field for each token"
    - "Fresh DB DDL includes asset_id column and LATEST_SCHEMA_VERSION is 22"
    - "Drizzle schema tokenRegistry table includes assetId column"
  artifacts:
    - path: "packages/daemon/src/infrastructure/database/migrate.ts"
      provides: "v22 migration with ALTER TABLE + application-level CAIP-19 backfill"
      contains: "version: 22"
    - path: "packages/daemon/src/infrastructure/database/schema.ts"
      provides: "Drizzle tokenRegistry.assetId column"
      contains: "assetId: text('asset_id')"
    - path: "packages/daemon/src/infrastructure/token-registry/token-registry-service.ts"
      provides: "RegistryToken with assetId field, getTokensForNetwork returns assetId"
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "TokenRegistryItemSchema with assetId field"
    - path: "packages/daemon/src/api/routes/tokens.ts"
      provides: "GET /v1/tokens response mapping includes assetId"
  key_links:
    - from: "packages/daemon/src/infrastructure/database/migrate.ts"
      to: "@waiaas/core tokenAssetId()"
      via: "import for CAIP-19 backfill generation"
      pattern: "tokenAssetId\\(row\\.network"
    - from: "packages/daemon/src/infrastructure/token-registry/token-registry-service.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle select reads assetId column"
      pattern: "row\\.assetId"
    - from: "packages/daemon/src/api/routes/tokens.ts"
      to: "token-registry-service.ts"
      via: "getTokensForNetwork returns assetId in RegistryToken"
      pattern: "t\\.assetId"
---

<objective>
Add CAIP-19 asset_id column to token_registry DB table via v22 migration, backfill existing records using tokenAssetId(), update Drizzle schema, and include assetId in Token API responses.

Purpose: Enable persistent CAIP-19 asset identification for all registered tokens, making it available through the REST API for downstream consumers (MCP tools, SDK, Admin UI).

Output: DB migration v22 with backfill, updated Drizzle schema, updated RegistryToken type, updated OpenAPI schema, updated GET /v1/tokens response.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/233-db-migration-schema-policy/233-RESEARCH.md
@packages/daemon/src/infrastructure/database/migrate.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/infrastructure/token-registry/token-registry-service.ts
@packages/daemon/src/api/routes/tokens.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/core/src/caip/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB v22 migration + DDL + Drizzle schema for asset_id column</name>
  <files>
    packages/daemon/src/infrastructure/database/migrate.ts
    packages/daemon/src/infrastructure/database/schema.ts
  </files>
  <action>
**migrate.ts changes (3 updates):**

1. **Bump LATEST_SCHEMA_VERSION** from 21 to 22 (line 55).

2. **Update DDL** in `getCreateTableStatements()` -- add `asset_id TEXT` column to the `token_registry` CREATE TABLE statement (after the `source` column, before `created_at`):
   ```sql
   asset_id TEXT,
   ```

3. **Add v22 migration** after the v21 migration block. Import `tokenAssetId` and `NETWORK_TO_CAIP2` from `@waiaas/core` at the top of the file (add to the existing import from `@waiaas/core`). Also import `type NetworkType` from `@waiaas/core`.

   Migration pattern (application-level backfill, following the established v6a pattern):
   ```typescript
   MIGRATIONS.push({
     version: 22,
     description: 'Add asset_id column to token_registry with CAIP-19 backfill',
     managesOwnTransaction: false,
     up: (sqlite) => {
       // Step 1: Add nullable column
       sqlite.exec('ALTER TABLE token_registry ADD COLUMN asset_id TEXT');

       // Step 2: Application-level backfill using tokenAssetId()
       const rows = sqlite
         .prepare('SELECT id, network, address FROM token_registry')
         .all() as Array<{ id: string; network: string; address: string }>;

       const updateStmt = sqlite.prepare(
         'UPDATE token_registry SET asset_id = ? WHERE id = ?'
       );

       for (const row of rows) {
         // Guard: only backfill for known networks (Pitfall 4)
         if (!(row.network in NETWORK_TO_CAIP2)) continue;
         try {
           const assetId = tokenAssetId(row.network as NetworkType, row.address);
           updateStmt.run(assetId, row.id);
         } catch {
           // Skip on error -- rows with unknown networks get asset_id = NULL
         }
       }
     },
   });
   ```

**schema.ts changes (1 update):**

Add `assetId` column to the `tokenRegistry` table definition, between `source` and `createdAt`:
```typescript
assetId: text('asset_id'),
```

This is a nullable TEXT column (no `.notNull()`) matching the DDL.
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/daemon` to verify no type errors. Run `pnpm turbo run test --filter=@waiaas/daemon -- --grep "migration"` to verify migration chain tests still pass. Manually verify that LATEST_SCHEMA_VERSION is 22, DDL includes `asset_id TEXT`, and the v22 migration is present.
  </verify>
  <done>
LATEST_SCHEMA_VERSION is 22. DDL includes `asset_id TEXT` in token_registry. Migration v22 adds the column and backfills via tokenAssetId(). Drizzle schema includes `assetId: text('asset_id')`. Typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Token registry service + API response assetId field</name>
  <files>
    packages/daemon/src/infrastructure/token-registry/token-registry-service.ts
    packages/daemon/src/api/routes/tokens.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
  </files>
  <action>
**token-registry-service.ts changes:**

1. Update `RegistryToken` interface to include optional `assetId`:
   ```typescript
   export interface RegistryToken extends TokenEntry {
     source: 'builtin' | 'custom';
     assetId?: string | null;
   }
   ```

2. In `getTokensForNetwork()`, update the merge logic:
   - For built-in tokens: generate `assetId` on-the-fly using `tokenAssetId(network, t.address)` from `@waiaas/core`. Import `tokenAssetId` and `type NetworkType` from `@waiaas/core`. Use try/catch so unknown networks don't break (return `null` on failure).
   - For custom DB tokens: read `row.assetId` from Drizzle (now available after schema.ts update). If `row.assetId` is null (pre-backfill or unknown network), try generating on-the-fly.

   Updated builtin merge loop:
   ```typescript
   for (const t of builtins) {
     let assetId: string | null = null;
     try {
       assetId = tokenAssetId(network as NetworkType, t.address);
     } catch { /* unknown network */ }
     merged.set(t.address.toLowerCase(), { ...t, source: 'builtin', assetId });
   }
   ```

   Updated custom merge loop:
   ```typescript
   for (const row of customRows) {
     let assetId: string | null = row.assetId ?? null;
     if (!assetId) {
       try {
         assetId = tokenAssetId(network as NetworkType, row.address);
       } catch { /* fallback null */ }
     }
     merged.set(row.address.toLowerCase(), {
       address: row.address,
       symbol: row.symbol,
       name: row.name,
       decimals: row.decimals,
       source: row.source as 'builtin' | 'custom',
       assetId,
     });
   }
   ```

**openapi-schemas.ts changes:**

Add `assetId` field to `TokenRegistryItemSchema`:
```typescript
export const TokenRegistryItemSchema = z
  .object({
    address: z.string(),
    symbol: z.string(),
    name: z.string(),
    decimals: z.number().int(),
    source: z.enum(['builtin', 'custom']),
    assetId: z.string().nullable(),
  })
  .openapi('TokenRegistryItem');
```

**tokens.ts changes:**

Update the GET `/tokens` response mapping to include `assetId`:
```typescript
tokens: tokens.map((t) => ({
  address: t.address,
  symbol: t.symbol,
  name: t.name,
  decimals: t.decimals,
  source: t.source,
  assetId: t.assetId ?? null,
})),
```
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/daemon` to verify no type errors. Run `pnpm turbo run test --filter=@waiaas/daemon -- --grep "token"` to verify token registry tests pass. Verify that TokenRegistryItemSchema includes `assetId: z.string().nullable()`.
  </verify>
  <done>
RegistryToken includes assetId field. getTokensForNetwork() returns assetId for both builtin (generated on-the-fly) and custom (from DB with fallback generation) tokens. GET /v1/tokens response includes assetId for every token entry. OpenAPI schema documents the new field.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
2. `pnpm turbo run test --filter=@waiaas/daemon -- --grep "migration"` passes (schema equivalence)
3. LATEST_SCHEMA_VERSION is 22 in migrate.ts
4. DDL token_registry includes `asset_id TEXT`
5. Drizzle schema includes `assetId: text('asset_id')`
6. TokenRegistryItemSchema includes `assetId: z.string().nullable()`
7. GET /v1/tokens response mapping includes `assetId: t.assetId ?? null`
</verification>

<success_criteria>
- DB migration v22 adds nullable asset_id column to token_registry and backfills existing records using tokenAssetId() with per-row error handling
- Fresh DB DDL includes asset_id column, LATEST_SCHEMA_VERSION bumped to 22
- Drizzle schema synced with DDL (assetId TEXT nullable)
- Token API responses include assetId for all entries (builtin via on-the-fly generation, custom from DB)
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/233-db-migration-schema-policy/233-01-SUMMARY.md`
</output>
