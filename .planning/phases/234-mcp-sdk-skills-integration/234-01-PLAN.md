---
phase: 234-mcp-sdk-skills-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp/src/tools/send-token.ts
  - packages/mcp/src/tools/approve-token.ts
  - packages/mcp/src/tools/send-batch.ts
  - packages/mcp/src/__tests__/tools.test.ts
autonomous: true
requirements: [MCPS-01, MCPS-02]

must_haves:
  truths:
    - "send_token MCP tool accepts optional assetId in its token object and passes it through to the daemon"
    - "approve_token MCP tool accepts optional assetId in its token object and passes it through to the daemon"
    - "send_batch MCP tool description documents that instructions can include assetId in token objects"
    - "MCP tool descriptions explain CAIP-19 assetId format with examples so AI agents can construct valid URIs"
    - "Existing calls without assetId continue to work unchanged (backward compatible)"
  artifacts:
    - path: "packages/mcp/src/tools/send-token.ts"
      provides: "send_token tool with assetId parameter in token Zod object"
      contains: "assetId"
    - path: "packages/mcp/src/tools/approve-token.ts"
      provides: "approve_token tool with assetId parameter in token Zod object"
      contains: "assetId"
    - path: "packages/mcp/src/tools/send-batch.ts"
      provides: "send_batch tool with updated description mentioning assetId"
      contains: "assetId"
    - path: "packages/mcp/src/__tests__/tools.test.ts"
      provides: "Tests verifying assetId passthrough for send_token and approve_token"
      contains: "assetId"
  key_links:
    - from: "packages/mcp/src/tools/send-token.ts"
      to: "/v1/transactions/send"
      via: "args.token passed directly to body (includes assetId)"
      pattern: "if \\(args\\.token\\) body\\.token = args\\.token"
    - from: "packages/mcp/src/tools/approve-token.ts"
      to: "/v1/transactions/send"
      via: "args.token passed directly to body (includes assetId)"
      pattern: "token: args\\.token"
---

<objective>
Add optional CAIP-19 assetId parameter to MCP token-related tools (send_token, approve_token, send_batch) and update tool descriptions with CAIP-19 format documentation so AI agents can identify tokens using standard asset URIs.

Purpose: AI agents consuming MCP tools need to pass CAIP-19 assetId through to the daemon for cross-chain token identification. The daemon already validates assetId (Phase 233), so MCP tools just need to include it in their Zod schemas and pass it through.

Output: 3 updated MCP tool files + extended test file with assetId passthrough verification.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/234-mcp-sdk-skills-integration/234-RESEARCH.md
@packages/mcp/src/tools/send-token.ts
@packages/mcp/src/tools/approve-token.ts
@packages/mcp/src/tools/send-batch.ts
@packages/mcp/src/__tests__/tools.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add assetId to MCP tool Zod schemas + update descriptions</name>
  <files>
    packages/mcp/src/tools/send-token.ts
    packages/mcp/src/tools/approve-token.ts
    packages/mcp/src/tools/send-batch.ts
  </files>
  <action>
**send-token.ts:**
1. Add `assetId` as an optional z.string() field inside the `token` z.object():
   ```typescript
   token: z.object({
     address: z.string().describe('Token mint (SPL) or contract address (ERC-20)'),
     decimals: z.number().describe('Token decimals (e.g., 6 for USDC)'),
     symbol: z.string().describe('Token symbol (e.g., USDC)'),
     assetId: z.string().optional().describe(
       'CAIP-19 asset identifier (e.g., "eip155:1/erc20:0xa0b8..." or "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5..."). When provided, the daemon cross-validates address against assetId. EVM addresses must be lowercase in CAIP-19.'
     ),
   }).optional().describe('Required for TOKEN_TRANSFER. Token metadata with optional CAIP-19 assetId.'),
   ```
2. The handler already uses `if (args.token) body.token = args.token;` which passes the entire token object including assetId -- no handler changes needed.

**approve-token.ts:**
1. Add `assetId` as an optional z.string() field inside the `token` z.object():
   ```typescript
   token: z.object({
     address: z.string().describe('Token mint (SPL) or contract address (ERC-20)'),
     decimals: z.number().describe('Token decimals (e.g., 6 for USDC)'),
     symbol: z.string().describe('Token symbol (e.g., USDC)'),
     assetId: z.string().optional().describe(
       'CAIP-19 asset identifier (e.g., "eip155:1/erc20:0xa0b8..." or "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5..."). When provided, the daemon cross-validates address against assetId. EVM addresses must be lowercase in CAIP-19.'
     ),
   }).describe('Token info. Includes optional CAIP-19 assetId for standard asset identification.'),
   ```
2. The handler uses `token: args.token` in the body construction -- assetId is already passed through. No handler changes needed.

**send-batch.ts:**
1. Keep the `instructions` schema as `z.array(z.record(z.unknown()))` (research recommendation -- no schema duplication).
2. Update the description string for `instructions` to mention assetId support:
   ```typescript
   .describe('Array of instruction objects (each is a TRANSFER/TOKEN_TRANSFER/CONTRACT_CALL/APPROVE without the type field). TOKEN_TRANSFER/APPROVE instructions can include an optional assetId field in the token object for CAIP-19 asset identification (e.g., "eip155:1/erc20:0xa0b8...").')
   ```
3. No handler changes needed -- instructions are passed through as-is.

**IMPORTANT:** Do NOT add CAIP-19 validation in MCP tools. The daemon's TokenInfoSchema already handles validation via Caip19Schema with superRefine cross-validation. MCP tools are thin clients that pass through.
  </action>
  <verify>
    Run `pnpm turbo run typecheck --filter=@waiaas/mcp` to verify no type errors.
    Run `pnpm turbo run lint --filter=@waiaas/mcp` to verify no lint issues.
  </verify>
  <done>
    send_token and approve_token Zod schemas include optional assetId field in their token objects. send_batch description documents assetId in instructions. All three tool descriptions mention CAIP-19 format. No handler logic changes needed (passthrough already works).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add assetId passthrough tests for send_token and approve_token</name>
  <files>
    packages/mcp/src/__tests__/tools.test.ts
  </files>
  <action>
Add new test cases to verify assetId is passed through to the daemon API:

**In `describe('send_token tool')` block, add:**

1. Test: `'passes assetId in token object through to API (CAIP-19)'`
   - Call handler with: `{ to: 'addr', amount: '5000000', type: 'TOKEN_TRANSFER', token: { address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', decimals: 6, symbol: 'USDC', assetId: 'eip155:1/erc20:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' } }`
   - Assert `apiClient.post` was called with body containing `token.assetId` equal to `'eip155:1/erc20:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'`

2. Test: `'sends token without assetId when omitted (backward compat)'`
   - Call handler with: `{ to: 'addr', amount: '1000', type: 'TOKEN_TRANSFER', token: { address: 'mint1', decimals: 6, symbol: 'USDC' } }`
   - Assert `apiClient.post` was called with body containing `token` WITHOUT `assetId` property (use `expect.not.objectContaining` or check the exact token object has no assetId key)

**In `describe('approve_token tool')` block, add:**

3. Test: `'passes assetId in token object through to API (CAIP-19)'`
   - Call handler with: `{ spender: '0xDEFiRouter', token: { address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6, symbol: 'USDC', assetId: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp/token:EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' }, amount: '1000000000' }`
   - Assert `apiClient.post` was called with body containing `token.assetId` equal to the Solana CAIP-19 URI

Follow the existing test patterns exactly: use `createMockApiClient`, `getToolHandler`, and `expect(apiClient.post).toHaveBeenCalledWith(...)`.
  </action>
  <verify>
    Run `pnpm turbo run test --filter=@waiaas/mcp` and verify all tests pass including the new assetId passthrough tests.
  </verify>
  <done>
    3 new test cases pass: send_token assetId passthrough, send_token backward compat without assetId, approve_token assetId passthrough. No existing tests broken.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/mcp` passes with 0 errors
2. `pnpm turbo run lint --filter=@waiaas/mcp` passes with 0 errors
3. `pnpm turbo run test --filter=@waiaas/mcp` passes with all tests green (existing + 3 new)
4. Grep for `assetId` in all 3 tool files confirms presence
5. The token Zod objects in send_token and approve_token include `assetId: z.string().optional()`
6. send_batch description mentions assetId
</verification>

<success_criteria>
- MCP send_token tool Zod schema includes optional assetId in token object
- MCP approve_token tool Zod schema includes optional assetId in token object
- MCP send_batch tool description documents assetId in instructions
- All 3 tool descriptions explain CAIP-19 format with examples
- 3 new tests verify assetId passthrough and backward compatibility
- All existing MCP tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/234-mcp-sdk-skills-integration/234-01-SUMMARY.md`
</output>
