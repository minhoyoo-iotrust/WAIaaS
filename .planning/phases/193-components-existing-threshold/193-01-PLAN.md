---
phase: 193-components-existing-threshold
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/admin/src/__tests__/empty-state.test.tsx
  - packages/admin/src/__tests__/unsaved-dialog.test.tsx
  - packages/admin/src/__tests__/settings-search.test.tsx
  - packages/admin/src/__tests__/policy-rules-summary.test.tsx
  - packages/admin/src/__tests__/dirty-guard.test.ts
autonomous: true
requirements:
  - COMP-01
  - COMP-02
  - COMP-03
  - COMP-04
  - COMP-05

must_haves:
  truths:
    - "empty-state.test.tsx가 존재하고 렌더링 + CTA 버튼 클릭 테스트가 통과한다"
    - "unsaved-dialog.test.tsx가 존재하고 Save/Discard/Cancel 3개 핸들러 테스트가 통과한다"
    - "settings-search.test.tsx가 존재하고 검색어 필터링 + 키보드 네비게이션 + 결과 선택 테스트가 통과한다"
    - "policy-rules-summary.test.tsx가 존재하고 12개 정책 타입별 렌더링 테스트가 통과한다"
    - "dirty-guard.test.ts가 존재하고 register/unregister/saveAll/discardAll/hasDirty 테스트가 통과한다"
  artifacts:
    - path: "packages/admin/src/__tests__/empty-state.test.tsx"
      provides: "EmptyState 컴포넌트 테스트"
      min_lines: 30
    - path: "packages/admin/src/__tests__/unsaved-dialog.test.tsx"
      provides: "UnsavedDialog 컴포넌트 테스트"
      min_lines: 60
    - path: "packages/admin/src/__tests__/settings-search.test.tsx"
      provides: "SettingsSearch 컴포넌트 테스트"
      min_lines: 80
    - path: "packages/admin/src/__tests__/policy-rules-summary.test.tsx"
      provides: "PolicyRulesSummary 12-type 테스트"
      min_lines: 150
    - path: "packages/admin/src/__tests__/dirty-guard.test.ts"
      provides: "dirty-guard 유틸리티 테스트"
      min_lines: 50
  key_links:
    - from: "packages/admin/src/__tests__/empty-state.test.tsx"
      to: "packages/admin/src/components/empty-state.tsx"
      via: "import EmptyState"
      pattern: "import.*EmptyState.*from.*components/empty-state"
    - from: "packages/admin/src/__tests__/unsaved-dialog.test.tsx"
      to: "packages/admin/src/components/unsaved-dialog.tsx"
      via: "import UnsavedDialog + pendingAction"
      pattern: "import.*UnsavedDialog.*from.*components/unsaved-dialog"
    - from: "packages/admin/src/__tests__/dirty-guard.test.ts"
      to: "packages/admin/src/utils/dirty-guard.ts"
      via: "import registerDirty, unregisterDirty, saveAllDirty, discardAllDirty, hasDirty"
      pattern: "import.*from.*utils/dirty-guard"
---

<objective>
empty-state, unsaved-dialog, settings-search, policy-rules-summary, dirty-guard 5개 공용 컴포넌트/유틸에 대한 테스트 파일을 작성한다.

Purpose: v2.3 메뉴 재구성으로 추가된 공용 컴포넌트들의 테스트 커버리지 확보. 현재 0% 커버리지인 5개 모듈에 테스트를 추가하여 전체 admin 패키지 커버리지를 끌어올린다.
Output: 5개 테스트 파일 (empty-state.test.tsx, unsaved-dialog.test.tsx, settings-search.test.tsx, policy-rules-summary.test.tsx, dirty-guard.test.ts)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/admin/src/components/empty-state.tsx
@packages/admin/src/components/unsaved-dialog.tsx
@packages/admin/src/components/settings-search.tsx
@packages/admin/src/components/policy-rules-summary.tsx
@packages/admin/src/utils/dirty-guard.ts
@packages/admin/src/__tests__/setup.ts
@packages/admin/src/__tests__/shared-components.test.tsx
@packages/admin/src/utils/settings-search-index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: empty-state + unsaved-dialog + dirty-guard 테스트 작성</name>
  <files>
    packages/admin/src/__tests__/empty-state.test.tsx
    packages/admin/src/__tests__/unsaved-dialog.test.tsx
    packages/admin/src/__tests__/dirty-guard.test.ts
  </files>
  <action>
3개 테스트 파일을 생성한다. 이 3개는 가장 작은 컴포넌트/유틸이므로 한 태스크로 묶는다.

**1. empty-state.test.tsx** (COMP-01):

import: `{ describe, it, expect, vi, afterEach }` from vitest, `{ render, screen, fireEvent, cleanup }` from @testing-library/preact, `{ EmptyState }` from '../components/empty-state'.

afterEach(cleanup).

**describe('EmptyState'):**
1. `it('renders title')` — render `<EmptyState title="No items" />`, verify screen.getByText('No items') exists
2. `it('renders description when provided')` — render `<EmptyState title="No items" description="Try creating one" />`, verify 'Try creating one' visible
3. `it('does not render description when omitted')` — render `<EmptyState title="No items" />`, verify queryByText('Try creating one') is null
4. `it('renders action button when both actionLabel and onAction provided')` — `const onClick = vi.fn()`, render `<EmptyState title="Empty" actionLabel="Add" onAction={onClick} />`, verify button 'Add' visible, fireEvent.click, verify onClick called once
5. `it('does not render button when actionLabel is missing')` — render `<EmptyState title="Empty" onAction={() => {}} />`, verify container has no button element
6. `it('does not render button when onAction is missing')` — render `<EmptyState title="Empty" actionLabel="Add" />`, verify queryByText('Add') is null (button not rendered because both are required)

**2. dirty-guard.test.ts** (COMP-05):

import: `{ describe, it, expect, vi, beforeEach }` from vitest, `{ registerDirty, unregisterDirty, saveAllDirty, discardAllDirty, hasDirty }` from '../utils/dirty-guard'.

**주의:** dirty-guard는 모듈 레벨 signal을 사용하므로 테스트 간 상태 격리가 필요. beforeEach에서 모든 등록을 unregister하는 cleanup 함수 필요. 방법: 테스트 시작 시 `unregisterDirty('test-1'); unregisterDirty('test-2');` 등으로 cleanup하거나, 각 테스트에서 고유 id를 사용하여 충돌 방지.

**접근법:** `vi.resetModules()` + 매번 `await import('../utils/dirty-guard')` 를 사용하면 signal 상태가 격리됨. 하지만 이는 복잡하므로, 대신 각 테스트 afterEach에서 `unregisterDirty`로 cleanup.

```typescript
beforeEach(() => {
  // Clean slate - unregister any leftover
  unregisterDirty('test-a');
  unregisterDirty('test-b');
});
```

**describe('dirty-guard'):**
1. `it('hasDirty is false when no registrations')` — verify `hasDirty.value === false`
2. `it('registerDirty + hasDirty detects dirty state')` — register { id: 'test-a', isDirty: () => true, save: vi.fn(), discard: vi.fn() }, verify `hasDirty.value === true`
3. `it('hasDirty is false when registered but not dirty')` — register { id: 'test-a', isDirty: () => false, save: vi.fn(), discard: vi.fn() }, verify `hasDirty.value === false`
4. `it('unregisterDirty removes registration')` — register test-a (dirty), unregisterDirty('test-a'), verify `hasDirty.value === false`
5. `it('registerDirty replaces duplicate id')` — register test-a isDirty: () => true, register test-a isDirty: () => false (same id, different isDirty), verify `hasDirty.value === false` (replaced)
6. `it('saveAllDirty calls save on all dirty registrations')` — register test-a (dirty, save: saveFn), register test-b (not dirty, save: saveFn2), `await saveAllDirty()`, verify saveFn called once, saveFn2 NOT called
7. `it('saveAllDirty returns true on success')` — register test-a (dirty, save: vi.fn().mockResolvedValue(undefined)), result = await saveAllDirty(), verify result === true
8. `it('saveAllDirty returns false when save throws')` — register test-a (dirty, save: vi.fn().mockRejectedValue(new Error('fail'))), result = await saveAllDirty(), verify result === false
9. `it('discardAllDirty calls discard on all dirty registrations')` — register test-a (dirty, discard: discardFn), register test-b (not dirty, discard: discardFn2), discardAllDirty(), verify discardFn called once, discardFn2 NOT called

afterEach: `unregisterDirty('test-a'); unregisterDirty('test-b');`

**3. unsaved-dialog.test.tsx** (COMP-02):

Mock 설정 (파일 상단, vi.mock):
- `../utils/dirty-guard` — `{ saveAllDirty: vi.fn(), discardAllDirty: vi.fn() }` (unsaved-dialog imports these)

import: `{ describe, it, expect, vi, afterEach, beforeEach }` from vitest, `{ render, screen, fireEvent, waitFor, cleanup }` from @testing-library/preact, `{ UnsavedDialog, pendingAction, showUnsavedDialog }` from '../components/unsaved-dialog'.

const { saveAllDirty, discardAllDirty } = await import('../utils/dirty-guard') 로 mocked 함수 접근. 또는 `vi.mocked`로 접근.

beforeEach: `pendingAction.value = null; vi.clearAllMocks();`
afterEach: `pendingAction.value = null; cleanup();`

**describe('UnsavedDialog'):**
1. `it('renders nothing when pendingAction is null')` — render `<UnsavedDialog />`, verify container.innerHTML is empty (또는 queryByText('Unsaved Changes') is null)
2. `it('renders dialog when pendingAction is set')` — `showUnsavedDialog({ type: 'tab', execute: vi.fn() })`, render `<UnsavedDialog />`, verify 'Unsaved Changes' heading visible, 'Cancel' button, 'Discard & Navigate' button, 'Save & Navigate' button visible
3. `it('Cancel closes dialog')` — set pendingAction via showUnsavedDialog, render, click 'Cancel', verify pendingAction.value is null
4. `it('Discard & Navigate calls discardAllDirty and executes action')` — `const executeFn = vi.fn()`, showUnsavedDialog({ type: 'nav', execute: executeFn }), render, click 'Discard & Navigate' (use getByText('Discard & Navigate') which is actually Button children), verify discardAllDirty called, verify executeFn called, verify pendingAction.value is null
5. `it('Save & Navigate calls saveAllDirty and executes action on success')` — `vi.mocked(saveAllDirty).mockResolvedValueOnce(true)`, `const executeFn = vi.fn()`, showUnsavedDialog({ type: 'nav', execute: executeFn }), render, click 'Save & Navigate', waitFor executeFn called, verify saveAllDirty called, verify pendingAction.value is null
6. `it('Save & Navigate keeps dialog open when save fails')` — `vi.mocked(saveAllDirty).mockResolvedValueOnce(false)`, `const executeFn = vi.fn()`, showUnsavedDialog({ type: 'tab', execute: executeFn }), render, click 'Save & Navigate', waitFor(() => expect(saveAllDirty).toHaveBeenCalled()), verify executeFn NOT called, verify pendingAction.value is NOT null (dialog still open)
7. `it('clicking overlay calls cancel')` — showUnsavedDialog({ type: 'tab', execute: vi.fn() }), render, click the .modal-overlay element directly (container.querySelector('.modal-overlay')), verify pendingAction.value is null
8. `it('clicking modal-card does not close dialog (stopPropagation)')` — showUnsavedDialog({ type: 'tab', execute: vi.fn() }), render, click the .modal-card element (container.querySelector('.modal-card')), verify pendingAction.value is NOT null (still open)
  </action>
  <verify>pnpm --filter @waiaas/admin test:unit -- --reporter=verbose empty-state.test dirty-guard.test unsaved-dialog.test 실행 시 전체 통과</verify>
  <done>empty-state.test.tsx 6개 + dirty-guard.test.ts 9개 + unsaved-dialog.test.tsx 8개 = ~23개 테스트가 모두 통과한다</done>
</task>

<task type="auto">
  <name>Task 2: settings-search + policy-rules-summary 테스트 작성</name>
  <files>
    packages/admin/src/__tests__/settings-search.test.tsx
    packages/admin/src/__tests__/policy-rules-summary.test.tsx
  </files>
  <action>
2개 테스트 파일을 생성한다. 이 2개는 컴포넌트 크기가 크므로 별도 태스크.

**1. settings-search.test.tsx** (COMP-03):

Mock 설정 (파일 상단, vi.mock):
- `../utils/settings-search-index` — 직접 테스트용 index 데이터를 제공:
```typescript
vi.mock('../utils/settings-search-index', () => ({
  SETTINGS_SEARCH_INDEX: [
    { id: 'wallets.rpc.solana_mainnet', label: 'Solana Mainnet', description: 'RPC endpoint for Solana mainnet', page: '/wallets', tab: 'rpc', fieldName: 'rpc.solana_mainnet', keywords: ['blockchain', 'rpc', 'solana'] },
    { id: 'sessions.settings.default_ttl', label: 'Default TTL', description: 'Session default time-to-live', page: '/sessions', tab: 'settings', fieldName: 'settings.default_ttl', keywords: ['session', 'ttl', 'timeout'] },
    { id: 'system.oracle.provider', label: 'Oracle Provider', description: 'Price oracle data source', page: '/system', tab: '', fieldName: 'oracle.provider', keywords: ['oracle', 'price'] },
  ],
}));
```

import: `{ describe, it, expect, vi, afterEach, beforeEach }` from vitest, `{ render, screen, fireEvent, cleanup }` from @testing-library/preact, `{ signal }` from '@preact/signals', `{ SettingsSearch, pendingNavigation, highlightField }` from '../components/settings-search'.

```typescript
const openSignal = signal(false);

beforeEach(() => {
  openSignal.value = false;
  pendingNavigation.value = null;
  highlightField.value = '';
  vi.clearAllMocks();
});

afterEach(cleanup);
```

**describe('SettingsSearch'):**
1. `it('renders nothing when open is false')` — render `<SettingsSearch open={openSignal} />`, verify container.innerHTML is empty
2. `it('renders search input when open is true')` — `openSignal.value = true`, render, verify screen.getByPlaceholderText('Search settings...') exists
3. `it('shows no results text for non-matching query')` — `openSignal.value = true`, render, fireEvent.input the search input with value 'zzzznonexistent', verify 'No settings found' visible
4. `it('filters results by label match')` — `openSignal.value = true`, render, fireEvent.input with value 'Solana', verify 'Solana Mainnet' result visible, verify 'Default TTL' NOT visible
5. `it('filters results by keyword match')` — `openSignal.value = true`, render, fireEvent.input with value 'ttl', verify 'Default TTL' visible
6. `it('filters results by description match')` — `openSignal.value = true`, render, fireEvent.input with value 'Price oracle', verify 'Oracle Provider' visible
7. `it('Escape key closes the dialog')` — `openSignal.value = true`, render, fireEvent.keyDown(container.querySelector('.search-popover'), { key: 'Escape' }), verify openSignal.value === false
8. `it('ArrowDown moves selection down')` — `openSignal.value = true`, render, fireEvent.input with value 'rpc solana' (matches Solana Mainnet), verify first result has 'selected' class, fireEvent.keyDown with { key: 'ArrowDown' } — 이 경우 결과가 1개이므로 ArrowDown은 min(1, 0) = 0으로 유지됨. 대신: 검색어를 '' (모든 건 안보임) 대신 좀 더 여러 결과가 나오는 검색어 사용. 'RPC'나 's'를 검색하면 여러 건 매칭. 아, 빈 쿼리는 결과 없음. 'sol'을 검색하면 Solana Mainnet 1건. 더 좋은 방법: 모든 결과가 나오도록 ' '를 검색? 아니, filterEntries는 trim() 후 빈 문자열이면 빈 배열 반환. 'a'를 검색하면 'Solana Mainnet' (Solana), 'Oracle Provider' (oracle data) 두 건 매칭. 그럼 ArrowDown 테스트 가능.
   - `openSignal.value = true`, render, fireEvent.input with value 'a' (matches Solana Mainnet + Oracle Provider = 2 results), verify first result (.search-result-item) has 'selected' class, fireEvent.keyDown { key: 'ArrowDown' }, verify second result has 'selected' class
9. `it('ArrowUp moves selection up')` — 위 상태에서 ArrowUp, verify first result has 'selected' class again. 또는: input 'a', ArrowDown, ArrowUp 순서.
10. `it('Enter navigates to selected result with tab')` — `openSignal.value = true`, render, fireEvent.input with value 'Solana', verify result visible, fireEvent.keyDown { key: 'Enter' }, verify window.location.hash set to '#/wallets', verify pendingNavigation.value equals { tab: 'rpc', fieldName: 'rpc.solana_mainnet' }, verify openSignal.value === false
11. `it('Enter navigates to result without tab (sets highlightField)')` — `openSignal.value = true`, render, fireEvent.input with value 'Oracle', fireEvent.keyDown { key: 'Enter' }, verify window.location.hash set to '#/system', verify pendingNavigation.value is null (no tab), setTimeout을 사용하므로 `vi.useFakeTimers` + `vi.advanceTimersByTime(150)` 로 highlightField.value === 'oracle.provider' 확인. beforeEach에 vi.useFakeTimers(), afterEach에 vi.useRealTimers() 추가. 또는 이 테스트만 fakeTimers 사용. 간단히: vi.useFakeTimers({ shouldAdvanceTime: true }) 사용 후 waitFor로 확인.
12. `it('clicking overlay closes dialog')` — `openSignal.value = true`, render, click the .search-overlay element directly, verify openSignal.value === false
13. `it('clicking result item navigates')` — `openSignal.value = true`, render, fireEvent.input with value 'Default TTL', click the result button (screen.getByText('Default TTL').closest('button')), verify window.location.hash === '#/sessions', verify pendingNavigation.value equals { tab: 'settings', fieldName: 'settings.default_ttl' }
14. `it('shows breadcrumb with page > tab format')` — `openSignal.value = true`, render, fireEvent.input with value 'Solana', verify 'Wallets > rpc' breadcrumb text visible in .search-result-path
15. `it('shows breadcrumb with page only when no tab')` — `openSignal.value = true`, render, fireEvent.input with value 'Oracle', verify 'System' breadcrumb visible (no '>')

**타이머 처리:** 테스트 11번에서 setTimeout(100)을 사용하므로, 해당 테스트에서만 `vi.useFakeTimers()` + `vi.advanceTimersByTime(150)` 사용. 다른 테스트는 real timers. requestAnimationFrame mock도 필요할 수 있음 (useEffect에서 사용). 전체 describe에 `beforeEach(() => { vi.useFakeTimers({ shouldAdvanceTime: true }); })` + `afterEach(() => { vi.useRealTimers(); })` 추가하는 것이 안전.

**2. policy-rules-summary.test.tsx** (COMP-04):

import: `{ describe, it, expect, afterEach }` from vitest, `{ render, screen, cleanup }` from @testing-library/preact, `{ PolicyRulesSummary }` from '../components/policy-rules-summary'.

afterEach(cleanup).

**describe('PolicyRulesSummary'):**

12개 policy type + default fallback = 13 케이스. 각 type별 1-2개 테스트. 주요 분기를 커버.

1. `it('SPENDING_LIMIT: renders tier bars')` — render `<PolicyRulesSummary type="SPENDING_LIMIT" rules={{ instant_max: '100', notify_max: '500', delay_max: '1000' }} />`, verify 'Instant', 'Notify', 'Delay', 'Approval' text visible, verify '100', '500', '1,000' formatted values visible
2. `it('SPENDING_LIMIT: renders cumulative limits')` — render with rules `{ instant_max: '100', notify_max: '500', delay_max: '1000', daily_limit_usd: 5000, monthly_limit_usd: 50000 }`, verify 'Daily (24h)' and '$5,000' visible, 'Monthly (30d)' and '$50,000' visible
3. `it('SPENDING_LIMIT: no cumulative section when limits absent')` — render with only tier rules, verify queryByText('Cumulative Limits') is null
4. `it('ALLOWED_TOKENS: renders symbol badges')` — render with rules `{ tokens: [{ symbol: 'USDC' }, { symbol: 'SOL' }] }`, verify 'USDC' and 'SOL' badge text visible
5. `it('ALLOWED_TOKENS: truncated address when no symbol')` — render with rules `{ tokens: [{ address: '0x1234567890abcdef' }] }`, verify '0x123456...' visible (첫 8자 + '...')
6. `it('ALLOWED_TOKENS: empty tokens shows No tokens')` — render with rules `{ tokens: [] }`, verify 'No tokens' visible
7. `it('RATE_LIMIT: renders formatted rate')` — render with rules `{ max_requests: 100, window_seconds: 3600 }`, verify '100 req / 1h' visible
8. `it('RATE_LIMIT: seconds format')` — render with rules `{ max_requests: 10, window_seconds: 30 }`, verify '10 req / 30s' visible
9. `it('WHITELIST: renders address count')` — render with rules `{ allowed_addresses: ['addr1', 'addr2', 'addr3'] }`, verify '3 addresses' visible
10. `it('TIME_RESTRICTION: renders days and hours')` — render with rules `{ allowed_days: [1, 2, 3, 4, 5], allowed_hours: { start: 9, end: 17 } }`, verify 'Mon-Fri' visible, '09:00-17:00' visible
11. `it('TIME_RESTRICTION: non-consecutive days')` — render with rules `{ allowed_days: [0, 3, 6] }`, verify 'Sun, Wed, Sat' visible
12. `it('CONTRACT_WHITELIST: renders contract names, max 3 + overflow')` — render with rules `{ contracts: [{ name: 'Uniswap' }, { name: 'Aave' }, { name: 'Compound' }, { name: 'Curve' }] }`, verify 'Uniswap', 'Aave', 'Compound' visible, '+1 more' visible
13. `it('CONTRACT_WHITELIST: empty shows No contracts')` — render with rules `{ contracts: [] }`, verify 'No contracts' visible
14. `it('METHOD_WHITELIST: renders counts')` — render with rules `{ methods: [{ contractAddress: '0x1', selectors: ['0xaa', '0xbb'] }, { contractAddress: '0x2', selectors: ['0xcc'] }] }`, verify '2 contracts, 3 methods' visible
15. `it('APPROVED_SPENDERS: renders spender count')` — render with rules `{ spenders: [{ address: '0x1' }, { address: '0x2' }] }`, verify '2 spenders' visible
16. `it('APPROVE_AMOUNT_LIMIT: maxAmount + blockUnlimited')` — render with rules `{ maxAmount: '1000000', blockUnlimited: true }`, verify 'Max: 1,000,000 + Block unlimited' visible
17. `it('APPROVE_AMOUNT_LIMIT: maxAmount only')` — render with rules `{ maxAmount: '500' }`, verify 'Max: 500' visible
18. `it('APPROVE_AMOUNT_LIMIT: blockUnlimited only')` — render with rules `{ blockUnlimited: true }`, verify 'Block unlimited only' visible
19. `it('APPROVE_AMOUNT_LIMIT: no limits')` — render with rules `{}`, verify 'No limits' visible
20. `it('APPROVE_TIER_OVERRIDE: renders tier badge')` — render with rules `{ tier: 'INSTANT' }`, verify 'INSTANT' badge visible
21. `it('APPROVE_TIER_OVERRIDE: default tier DELAY')` — render with rules `{}`, verify 'DELAY' badge visible (default)
22. `it('ALLOWED_NETWORKS: renders network badges, max 3 + overflow')` — render with rules `{ networks: [{ network: 'ethereum' }, { network: 'polygon' }, { network: 'arbitrum' }, { network: 'optimism' }] }`, verify 'ethereum', 'polygon', 'arbitrum' visible, '+1 more' visible
23. `it('ALLOWED_NETWORKS: empty shows No networks')` — render with rules `{ networks: [] }`, verify 'No networks' visible
24. `it('X402_ALLOWED_DOMAINS: renders domain badges, max 3 + overflow')` — render with rules `{ domains: ['example.com', 'api.test', 'foo.bar', 'baz.qux'] }`, verify first 3 visible, '+1 more' visible
25. `it('X402_ALLOWED_DOMAINS: empty shows No domains')` — render with rules `{ domains: [] }`, verify 'No domains' visible
26. `it('default: renders JSON fallback')` — render with rules `{ foo: 'bar' }` and type 'UNKNOWN_TYPE', verify '{"foo":"bar"}' visible
27. `it('default: truncates long JSON')` — render with rules that produce >60 char JSON (예: `{ a: 'x'.repeat(80) }`), verify '...' at end

  </action>
  <verify>pnpm --filter @waiaas/admin test:unit -- --reporter=verbose settings-search.test policy-rules-summary.test 실행 시 전체 통과</verify>
  <done>settings-search.test.tsx ~15개 + policy-rules-summary.test.tsx ~27개 = ~42개 테스트가 모두 통과한다</done>
</task>

</tasks>

<verification>
```bash
pnpm --filter @waiaas/admin test:unit -- --reporter=verbose empty-state.test dirty-guard.test unsaved-dialog.test settings-search.test policy-rules-summary.test
```
5개 테스트 파일의 모든 테스트 통과, 0 failures.
</verification>

<success_criteria>
1. packages/admin/src/__tests__/empty-state.test.tsx 존재, 6개 이상 테스트 통과
2. packages/admin/src/__tests__/dirty-guard.test.ts 존재, 9개 이상 테스트 통과
3. packages/admin/src/__tests__/unsaved-dialog.test.tsx 존재, 8개 이상 테스트 통과
4. packages/admin/src/__tests__/settings-search.test.tsx 존재, 13개 이상 테스트 통과
5. packages/admin/src/__tests__/policy-rules-summary.test.tsx 존재, 25개 이상 테스트 통과
6. `pnpm --filter @waiaas/admin test:unit` 전체 테스트 통과 (기존 테스트 깨지지 않음)
</success_criteria>

<output>
After completion, create `.planning/phases/193-components-existing-threshold/193-01-SUMMARY.md`
</output>
