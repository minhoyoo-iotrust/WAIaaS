---
phase: 185-ux-enhancements
plan: 02
type: execute
wave: 2
depends_on: [185-01]
files_modified:
  - packages/admin/src/utils/dirty-guard.ts
  - packages/admin/src/components/unsaved-dialog.tsx
  - packages/admin/src/components/layout.tsx
  - packages/admin/src/components/tab-nav.tsx
  - packages/admin/src/pages/wallets.tsx
  - packages/admin/src/pages/sessions.tsx
  - packages/admin/src/pages/policies.tsx
  - packages/admin/src/pages/notifications.tsx
  - packages/admin/src/pages/security.tsx
  - packages/admin/src/pages/system.tsx
  - packages/admin/src/styles/global.css
autonomous: true
requirements: [DIRTY-01, DIRTY-02]

must_haves:
  truths:
    - "When a settings tab has unsaved changes (dirty state) and user clicks a different tab, a 3-button dialog appears"
    - "When a settings tab has unsaved changes and user clicks a sidebar nav link, a 3-button dialog appears"
    - "The dialog has 3 buttons: Save & Navigate (saves then navigates), Discard & Navigate (discards then navigates), Cancel (stays)"
    - "Save & Navigate triggers the tab's existing save handler, then navigates"
    - "Discard & Navigate clears dirty state, then navigates"
    - "Cancel closes the dialog and stays on the current tab/page"
    - "When no dirty state exists, tab switches and sidebar navigation happen immediately without a dialog"
  artifacts:
    - path: "packages/admin/src/utils/dirty-guard.ts"
      provides: "Global dirty state registry with register/unregister/hasDirty/getSaveHandler/getDiscardHandler functions"
      exports: ["dirtyGuard", "registerDirty", "unregisterDirty"]
    - path: "packages/admin/src/components/unsaved-dialog.tsx"
      provides: "3-button unsaved changes confirmation dialog component"
      exports: ["UnsavedDialog", "unsavedDialogState"]
    - path: "packages/admin/src/components/tab-nav.tsx"
      provides: "Updated TabNav that checks dirty guard before switching tabs"
    - path: "packages/admin/src/components/layout.tsx"
      provides: "Updated sidebar nav that checks dirty guard before navigating"
  key_links:
    - from: "packages/admin/src/components/tab-nav.tsx"
      to: "packages/admin/src/utils/dirty-guard.ts"
      via: "imports dirtyGuard to check hasDirty before calling onTabChange"
      pattern: "dirtyGuard"
    - from: "packages/admin/src/components/layout.tsx"
      to: "packages/admin/src/utils/dirty-guard.ts"
      via: "intercepts sidebar link clicks to check dirtyGuard before navigating"
      pattern: "dirtyGuard"
    - from: "packages/admin/src/pages/wallets.tsx"
      to: "packages/admin/src/utils/dirty-guard.ts"
      via: "registers dirty state from RPC/Monitoring/WalletConnect tabs"
      pattern: "registerDirty|unregisterDirty"
    - from: "packages/admin/src/components/unsaved-dialog.tsx"
      to: "packages/admin/src/utils/dirty-guard.ts"
      via: "reads dirtyGuard to call save/discard handlers then execute pending navigation"
      pattern: "dirtyGuard"
---

<objective>
Implement unsaved changes guard: when any settings tab has dirty (modified but unsaved) state, intercept tab switches and sidebar navigation with a 3-button confirmation dialog (Save & Navigate / Discard & Navigate / Cancel).

Purpose: Prevent users from accidentally losing unsaved settings changes when navigating away.
Output: Global dirty state registry, 3-button unsaved dialog component, intercepted tab and sidebar navigation.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/185-ux-enhancements/185-01-SUMMARY.md
@packages/admin/src/components/layout.tsx
@packages/admin/src/components/tab-nav.tsx
@packages/admin/src/components/modal.tsx
@packages/admin/src/components/form.tsx
@packages/admin/src/styles/global.css
@packages/admin/src/pages/wallets.tsx
@packages/admin/src/pages/sessions.tsx
@packages/admin/src/pages/policies.tsx
@packages/admin/src/pages/notifications.tsx
@packages/admin/src/pages/security.tsx
@packages/admin/src/pages/system.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dirty guard registry and unsaved dialog component</name>
  <files>
    packages/admin/src/utils/dirty-guard.ts
    packages/admin/src/components/unsaved-dialog.tsx
    packages/admin/src/styles/global.css
  </files>
  <action>
**1. Create `packages/admin/src/utils/dirty-guard.ts`**

This module provides a global registry for dirty state across all settings tabs. Each tab registers its dirty check, save handler, and discard handler when it mounts, and unregisters when it unmounts.

```typescript
import { signal, computed } from '@preact/signals';

export interface DirtyRegistration {
  id: string;                    // unique id, e.g. "wallets-rpc", "sessions-settings"
  isDirty: () => boolean;        // returns true if this tab has unsaved changes
  save: () => Promise<void>;     // the tab's save handler
  discard: () => void;           // the tab's discard handler (clears dirty)
}

const registry = signal<DirtyRegistration[]>([]);

/** True if ANY registered tab has dirty state */
export const hasDirty = computed(() => registry.value.some(r => r.isDirty()));

/** Register a tab's dirty state handlers. Call on mount. */
export function registerDirty(reg: DirtyRegistration): void {
  // Avoid duplicates
  registry.value = [...registry.value.filter(r => r.id !== reg.id), reg];
}

/** Unregister a tab's dirty state handlers. Call on unmount/cleanup. */
export function unregisterDirty(id: string): void {
  registry.value = registry.value.filter(r => r.id !== id);
}

/** Save all dirty tabs, returns true if all succeeded */
export async function saveAllDirty(): Promise<boolean> {
  const dirtyRegs = registry.value.filter(r => r.isDirty());
  try {
    for (const reg of dirtyRegs) {
      await reg.save();
    }
    return true;
  } catch {
    return false;
  }
}

/** Discard all dirty tabs */
export function discardAllDirty(): void {
  const dirtyRegs = registry.value.filter(r => r.isDirty());
  for (const reg of dirtyRegs) {
    reg.discard();
  }
}
```

**2. Create `packages/admin/src/components/unsaved-dialog.tsx`**

This is a specialized 3-button dialog for unsaved changes confirmation. It uses the existing Modal overlay pattern but renders 3 action buttons.

```typescript
import { signal } from '@preact/signals';
import { Button } from './form';
import { saveAllDirty, discardAllDirty } from '../utils/dirty-guard';

export interface PendingAction {
  type: 'tab' | 'nav';
  execute: () => void;    // the navigation/tab switch to perform after resolution
}

export const pendingAction = signal<PendingAction | null>(null);
export const dialogSaving = signal(false);

export function showUnsavedDialog(action: PendingAction): void {
  pendingAction.value = action;
}

export function UnsavedDialog() {
  const action = pendingAction.value;
  if (!action) return null;

  const handleSaveAndNavigate = async () => {
    dialogSaving.value = true;
    const ok = await saveAllDirty();
    dialogSaving.value = false;
    if (ok) {
      pendingAction.value = null;
      action.execute();
    }
    // If save failed, keep dialog open -- user sees toast error from save handler
  };

  const handleDiscardAndNavigate = () => {
    discardAllDirty();
    pendingAction.value = null;
    action.execute();
  };

  const handleCancel = () => {
    pendingAction.value = null;
  };

  return (
    <div class="modal-overlay" onClick={handleCancel}>
      <div class="modal-card" onClick={(e) => e.stopPropagation()}>
        <div class="modal-header">Unsaved Changes</div>
        <div class="modal-body">
          <p>You have unsaved changes. What would you like to do?</p>
        </div>
        <div class="modal-footer unsaved-dialog-footer">
          <Button variant="secondary" onClick={handleCancel} disabled={dialogSaving.value}>
            Cancel
          </Button>
          <Button variant="ghost" onClick={handleDiscardAndNavigate} disabled={dialogSaving.value}>
            Discard & Navigate
          </Button>
          <Button variant="primary" onClick={handleSaveAndNavigate} loading={dialogSaving.value}>
            Save & Navigate
          </Button>
        </div>
      </div>
    </div>
  );
}
```

**3. Add CSS to `packages/admin/src/styles/global.css`**

Append before the `@media` query:

```css
/* Unsaved Dialog 3-button footer */
.unsaved-dialog-footer {
  justify-content: flex-end;
  gap: var(--space-2);
}
```

The existing `.modal-overlay`, `.modal-card`, `.modal-header`, `.modal-body`, `.modal-footer` styles are already defined and sufficient. The only addition is the footer class for 3-button layout, which uses flex-end (already the default in .modal-footer) with explicit gap.
  </action>
  <verify>
1. `ls packages/admin/src/utils/dirty-guard.ts` -- file exists
2. `ls packages/admin/src/components/unsaved-dialog.tsx` -- file exists
3. `npx tsc --noEmit --project packages/admin/tsconfig.json 2>&1 | head -20` -- no type errors
4. `grep "registerDirty" packages/admin/src/utils/dirty-guard.ts` -- export exists
5. `grep "UnsavedDialog" packages/admin/src/components/unsaved-dialog.tsx` -- component exists
  </verify>
  <done>
- dirty-guard.ts exports registerDirty, unregisterDirty, hasDirty, saveAllDirty, discardAllDirty
- unsaved-dialog.tsx exports UnsavedDialog component with 3 buttons (Save & Navigate / Discard & Navigate / Cancel)
- Dialog reuses existing modal CSS classes
- All files pass TypeScript type checking
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dirty guard into TabNav, sidebar, and all settings pages</name>
  <files>
    packages/admin/src/components/tab-nav.tsx
    packages/admin/src/components/layout.tsx
    packages/admin/src/pages/wallets.tsx
    packages/admin/src/pages/sessions.tsx
    packages/admin/src/pages/policies.tsx
    packages/admin/src/pages/notifications.tsx
    packages/admin/src/pages/security.tsx
    packages/admin/src/pages/system.tsx
    packages/admin/src/styles/global.css
  </files>
  <action>
**1. Update `packages/admin/src/components/tab-nav.tsx` -- intercept tab switches**

Import dirty guard and unsaved dialog:
```typescript
import { hasDirty } from '../utils/dirty-guard';
import { showUnsavedDialog } from './unsaved-dialog';
```

Modify the `onTabChange` call in the tab button click handler:

```typescript
export function TabNav({ tabs, activeTab, onTabChange }: TabNavProps) {
  return (
    <div class="tab-nav">
      {tabs.map((tab) => (
        <button
          key={tab.key}
          class={`tab-btn ${activeTab === tab.key ? 'active' : ''}`}
          onClick={() => {
            if (tab.key === activeTab) return; // no-op if already active
            if (hasDirty.value) {
              showUnsavedDialog({
                type: 'tab',
                execute: () => onTabChange(tab.key),
              });
            } else {
              onTabChange(tab.key);
            }
          }}
        >
          {tab.label}
        </button>
      ))}
    </div>
  );
}
```

**2. Update `packages/admin/src/components/layout.tsx` -- intercept sidebar navigation**

Import dirty guard, unsaved dialog, and render the UnsavedDialog component:

```typescript
import { hasDirty } from '../utils/dirty-guard';
import { showUnsavedDialog, UnsavedDialog } from './unsaved-dialog';
```

Modify sidebar nav links. Change from `<a href={...}>` to `<a href={...} onClick={handleNavClick}>`:

```tsx
{NAV_ITEMS.map((item) => {
  const isActive = item.path === '/wallets'
    ? currentPath.value.startsWith('/wallets')
    : currentPath.value === item.path;
  return (
    <a
      href={`#${item.path}`}
      class={`sidebar-link ${isActive ? 'active' : ''}`}
      onClick={(e) => {
        if (hasDirty.value) {
          e.preventDefault();
          showUnsavedDialog({
            type: 'nav',
            execute: () => {
              window.location.hash = `#${item.path}`;
            },
          });
        }
        // If no dirty state, let default <a> behavior handle navigation
      }}
    >
      {item.label}
    </a>
  );
})}
```

Render the UnsavedDialog component inside the Layout, right after SettingsSearch:
```tsx
<SettingsSearch open={searchOpen} />
<UnsavedDialog />
```

**3. Register dirty state in each settings tab component**

Each settings tab that has dirty state needs to register with the dirty guard on mount and unregister on unmount.

**Pattern to apply in each tab:**

```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// or if already importing from dirty-guard, just add these

// Inside the tab component function, add this useEffect:
useEffect(() => {
  registerDirty({
    id: 'UNIQUE_TAB_ID',    // e.g. 'wallets-rpc'
    isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('PREFIX.')).length > 0,
    save: handleSave,
    discard: handleDiscard,
  });
  return () => unregisterDirty('UNIQUE_TAB_ID');
}, []);
```

Apply to each tab with its specific dirty check logic:

**wallets.tsx - RpcEndpointsTab:**
```typescript
registerDirty({
  id: 'wallets-rpc',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('rpc.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**wallets.tsx - BalanceMonitoringTab:**
```typescript
registerDirty({
  id: 'wallets-monitoring',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('monitoring.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**wallets.tsx - WalletConnectTab:**
```typescript
registerDirty({
  id: 'wallets-walletconnect',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('walletconnect.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**sessions.tsx - SessionSettingsTab:**
```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// ...
registerDirty({
  id: 'sessions-settings',
  isDirty: () => Object.keys(dirty.value).filter(k => SESSION_KEYS.includes(k)).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**policies.tsx - PolicyDefaultsTab:**
```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// ...
registerDirty({
  id: 'policies-defaults',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('security.') || k.startsWith('policy.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```
(PolicyDefaultsTab dirty keys may use `security.default_deny_*` -- check the actual filter logic used in handleSave.)

**notifications.tsx - NotificationSettingsTab:**
```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// ...
registerDirty({
  id: 'notifications-settings',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('notifications.') || k.startsWith('telegram.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**security.tsx - AutoStopTab:**
```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// ...
registerDirty({
  id: 'security-autostop',
  isDirty: () => Object.keys(dirty.value).filter(k => k.startsWith('autostop.')).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**system.tsx - SystemPage:**
```typescript
import { registerDirty, unregisterDirty } from '../utils/dirty-guard';
// ...
registerDirty({
  id: 'system-settings',
  isDirty: () => Object.keys(dirty.value).filter(k => isSystemSetting(k)).length > 0,
  save: handleSave,
  discard: handleDiscard,
});
```

**IMPORTANT NOTES:**
- Use `useEffect` with empty deps `[]` for the register call in each tab
- The `isDirty` function must be a closure that reads `dirty.value` at call time (not captured at registration time) -- since `dirty` is a signal, reading `.value` inside the function will always get the current state
- The `save` and `discard` references should point to the existing `handleSave` and `handleDiscard` functions already defined in each tab
- `registerDirty` is called inside `useEffect` so it runs after mount
- `unregisterDirty` is called in the cleanup function so it runs on unmount

**4. Verify typecheck and lint**

Run `pnpm turbo run typecheck --filter=@waiaas/admin` to ensure no type errors.
Run `pnpm turbo run lint --filter=@waiaas/admin` to ensure no lint errors.
  </action>
  <verify>
1. `pnpm turbo run typecheck --filter=@waiaas/admin` -- passes with no errors
2. `pnpm turbo run lint --filter=@waiaas/admin` -- passes with no errors
3. `grep "hasDirty" packages/admin/src/components/tab-nav.tsx` -- dirty guard check in tab switch
4. `grep "hasDirty" packages/admin/src/components/layout.tsx` -- dirty guard check in sidebar nav
5. `grep "UnsavedDialog" packages/admin/src/components/layout.tsx` -- dialog rendered in Layout
6. `grep "registerDirty" packages/admin/src/pages/wallets.tsx` -- wallets tabs register dirty state
7. `grep "registerDirty" packages/admin/src/pages/sessions.tsx` -- sessions tab registers dirty state
8. `grep "registerDirty" packages/admin/src/pages/security.tsx` -- security tab registers dirty state
9. `grep "registerDirty" packages/admin/src/pages/system.tsx` -- system page registers dirty state
10. `grep "registerDirty" packages/admin/src/pages/policies.tsx` -- policies tab registers dirty state
11. `grep "registerDirty" packages/admin/src/pages/notifications.tsx` -- notifications tab registers dirty state
  </verify>
  <done>
- TabNav intercepts tab switches: checks hasDirty before calling onTabChange, shows 3-button dialog if dirty
- Sidebar nav links intercept clicks: checks hasDirty before navigating, shows 3-button dialog if dirty
- UnsavedDialog renders in Layout with Save & Navigate / Discard & Navigate / Cancel buttons
- All 8 settings tabs register their dirty state with the global dirty guard (wallets x3, sessions, policies, notifications, security, system)
- Clean navigation (no dirty state) is unaffected -- immediate tab switch / page navigation
- TypeScript type check and lint both pass
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `pnpm turbo run typecheck --filter=@waiaas/admin` passes
2. Lint: `pnpm turbo run lint --filter=@waiaas/admin` passes
3. Tab switch with dirty state shows 3-button dialog (Save & Navigate / Discard & Navigate / Cancel)
4. Sidebar nav click with dirty state shows 3-button dialog
5. "Save & Navigate" calls the tab's save handler, then performs the navigation
6. "Discard & Navigate" clears dirty state, then performs the navigation
7. "Cancel" closes the dialog, no navigation occurs
8. Clean tab switch (no dirty state) navigates immediately
9. Clean sidebar nav (no dirty state) navigates immediately
</verification>

<success_criteria>
- 3-button unsaved dialog appears on tab switch when dirty
- 3-button unsaved dialog appears on sidebar nav when dirty
- Save & Navigate saves then navigates
- Discard & Navigate discards then navigates
- Cancel stays on current page/tab
- No dialog when no unsaved changes exist
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/185-ux-enhancements/185-02-SUMMARY.md`
</output>
