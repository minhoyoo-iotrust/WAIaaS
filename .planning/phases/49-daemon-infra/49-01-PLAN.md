---
phase: 49-daemon-infra
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/package.json
  - packages/daemon/src/infrastructure/database/schema.ts
  - packages/daemon/src/infrastructure/database/connection.ts
  - packages/daemon/src/infrastructure/database/migrate.ts
  - packages/daemon/src/infrastructure/database/index.ts
  - packages/daemon/src/__tests__/database.test.ts
autonomous: true

must_haves:
  truths:
    - "7 tables are created (agents, sessions, transactions, policies, pending_approvals, audit_log, key_value_store) with Drizzle ORM schema definitions matching doc 25"
    - "7 PRAGMAs are applied on connection open (journal_mode=WAL, synchronous=NORMAL, foreign_keys=ON, busy_timeout=5000, cache_size=-64000, mmap_size=268435456, temp_store=MEMORY)"
    - "All TEXT enum columns have CHECK constraints derived from @waiaas/core enum SSoT arrays"
    - "UUID v7 is used for all id fields with ms-precision time ordering"
    - "Drizzle push creates all tables and indexes in a fresh SQLite file"
  artifacts:
    - path: "packages/daemon/src/infrastructure/database/schema.ts"
      provides: "7 table Drizzle ORM definitions with CHECK constraints from enum SSoT"
      contains: "sqliteTable"
    - path: "packages/daemon/src/infrastructure/database/connection.ts"
      provides: "createDatabase() function applying 7 PRAGMAs and returning Drizzle instance"
      exports: ["createDatabase"]
    - path: "packages/daemon/src/infrastructure/database/migrate.ts"
      provides: "pushSchema() function for schema push migration"
      exports: ["pushSchema"]
    - path: "packages/daemon/src/__tests__/database.test.ts"
      provides: "Tests for schema creation, PRAGMA verification, UUID v7 ordering, CHECK constraints"
  key_links:
    - from: "packages/daemon/src/infrastructure/database/schema.ts"
      to: "@waiaas/core enums"
      via: "import { AGENT_STATUSES, TRANSACTION_STATUSES, ... } from '@waiaas/core'"
      pattern: "AGENT_STATUSES|TRANSACTION_STATUSES|POLICY_TYPES"
    - from: "packages/daemon/src/infrastructure/database/connection.ts"
      to: "better-sqlite3"
      via: "new Database(dbPath) + pragma calls"
      pattern: "sqlite\\.pragma"
---

<objective>
SQLite 7-table Drizzle ORM schema with PRAGMA initialization, UUID v7, and CHECK constraints derived from @waiaas/core enum SSoT.

Purpose: The daemon needs a persistent storage layer. All 7 tables (agents, sessions, transactions, policies, pending_approvals, audit_log, key_value_store) must be defined as Drizzle ORM schemas with proper indexes, foreign keys, and CHECK constraints. The database connection must apply 7 PRAGMAs for WAL mode, performance, and safety.

Output: Drizzle schema module, database connection module with PRAGMA setup, migration module, and comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-monorepo-scaffold-core/48-01-SUMMARY.md
@.planning/phases/48-monorepo-scaffold-core/48-02-SUMMARY.md
@.planning/deliverables/25-sqlite-schema.md (SSoT for all 7 table definitions, PRAGMA, indexes, CHECK constraints)
@packages/core/src/enums/index.ts (12 enum SSoT arrays to derive CHECK constraints)
@packages/core/src/schemas/config.schema.ts (ConfigSchema for reference)
@packages/daemon/package.json (current daemon package -- needs native dependencies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies + Drizzle 7-table schema with CHECK constraints from enum SSoT</name>
  <files>
    packages/daemon/package.json
    packages/daemon/src/infrastructure/database/schema.ts
    packages/daemon/src/infrastructure/database/connection.ts
    packages/daemon/src/infrastructure/database/migrate.ts
    packages/daemon/src/infrastructure/database/index.ts
  </files>
  <action>
**1. Install daemon dependencies** (add to packages/daemon/package.json):

Production dependencies:
- `better-sqlite3` ^12.6.0 (SQLite driver)
- `drizzle-orm` ^0.45.0 (ORM)
- `uuidv7` ^1.0.2 (UUID v7 generation -- TD-09 decision: use npm package for correctness, not manual implementation)

Dev dependencies:
- `@types/better-sqlite3` ^7.6.0
- `drizzle-kit` ^0.30.0

Run `pnpm install` from workspace root after adding dependencies.

**2. Create `schema.ts`** (packages/daemon/src/infrastructure/database/schema.ts):

Define 7 tables following doc 25 (25-sqlite-schema.md) exactly:

**Table 1: agents** (doc 25 section 2.1)
- id: text PK (UUID v7)
- name: text NOT NULL
- chain: text NOT NULL with CHECK from `CHAIN_TYPES` array imported from `@waiaas/core`
- network: text NOT NULL with CHECK from `NETWORK_TYPES` array
- publicKey: text('public_key') NOT NULL, UNIQUE index
- status: text NOT NULL DEFAULT 'CREATING' with CHECK from `AGENT_STATUSES` array
- ownerAddress: text('owner_address') nullable
- ownerVerified: integer('owner_verified', { mode: 'boolean' }) NOT NULL DEFAULT false, CHECK IN (0,1)
- createdAt, updatedAt: integer({ mode: 'timestamp' }) NOT NULL
- suspendedAt: integer({ mode: 'timestamp' }) nullable
- suspensionReason: text nullable
- Indexes: unique(publicKey), idx(status), idx(chain,network), idx(ownerAddress)

**Table 2: sessions** (doc 25 section 2.2)
- id: text PK (UUID v7)
- agentId: text FK -> agents(id) ON DELETE CASCADE
- tokenHash: text NOT NULL
- expiresAt: integer({ mode: 'timestamp' }) NOT NULL
- constraints: text nullable (JSON)
- usageStats: text('usage_stats') nullable (JSON)
- revokedAt: integer({ mode: 'timestamp' }) nullable
- renewalCount: integer NOT NULL DEFAULT 0
- maxRenewals: integer('max_renewals') NOT NULL DEFAULT 30
- lastRenewedAt: integer('last_renewed_at', { mode: 'timestamp' }) nullable
- absoluteExpiresAt: integer('absolute_expires_at', { mode: 'timestamp' }) NOT NULL
- createdAt: integer({ mode: 'timestamp' }) NOT NULL
- Indexes: idx(agentId), idx(expiresAt), idx(tokenHash)

**Table 3: transactions** (doc 25 section 2.3)
- id: text PK (UUID v7)
- agentId: text FK -> agents(id) ON DELETE RESTRICT
- sessionId: text FK -> sessions(id) ON DELETE SET NULL, nullable
- chain: text NOT NULL
- txHash: text nullable, UNIQUE index
- type: text NOT NULL with CHECK from `TRANSACTION_TYPES` array
- amount: text nullable (bigint as string)
- toAddress: text('to_address') nullable
- tokenMint: text('token_mint') nullable
- contractAddress: text('contract_address') nullable
- methodSignature: text('method_signature') nullable
- spenderAddress: text('spender_address') nullable
- approvedAmount: text('approved_amount') nullable
- parentId: text('parent_id') self-ref FK ON DELETE CASCADE, nullable
- batchIndex: integer('batch_index') nullable
- status: text NOT NULL DEFAULT 'PENDING' with CHECK from `TRANSACTION_STATUSES` array (include PARTIAL_FAILURE)
- tier: text nullable with CHECK from `POLICY_TIERS` array (allow NULL)
- queuedAt, executedAt: integer({ mode: 'timestamp' }) nullable
- createdAt: integer({ mode: 'timestamp' }) NOT NULL
- error: text nullable
- metadata: text nullable (JSON)
- Indexes: idx(agentId,status), idx(sessionId), unique(txHash), idx(queuedAt), idx(createdAt), idx(type), idx(contractAddress), idx(parentId)

**Table 4: policies** (doc 25 section 2.4)
- id: text PK (UUID v7)
- agentId: text FK -> agents(id) ON DELETE CASCADE, nullable (NULL = global)
- type: text NOT NULL with CHECK from `POLICY_TYPES` array (10 types)
- rules: text NOT NULL (JSON)
- priority: integer NOT NULL DEFAULT 0
- enabled: integer({ mode: 'boolean' }) NOT NULL DEFAULT true
- createdAt, updatedAt: integer({ mode: 'timestamp' }) NOT NULL
- Indexes: idx(agentId,enabled), idx(type)

**Table 5: pending_approvals** (doc 25 section 2.6)
- id: text PK (UUID v7)
- txId: text('tx_id') FK -> transactions(id) ON DELETE CASCADE, NOT NULL
- requiredBy: integer('required_by', { mode: 'timestamp' }) NOT NULL
- expiresAt: integer({ mode: 'timestamp' }) NOT NULL
- approvedAt: integer({ mode: 'timestamp' }) nullable
- rejectedAt: integer({ mode: 'timestamp' }) nullable
- ownerSignature: text('owner_signature') nullable
- createdAt: integer({ mode: 'timestamp' }) NOT NULL
- Indexes: idx(txId), idx(expiresAt)

**Table 6: audit_log** (doc 25 section 2.5)
- id: integer PK AUTOINCREMENT
- timestamp: integer({ mode: 'timestamp' }) NOT NULL
- eventType: text('event_type') NOT NULL
- actor: text NOT NULL
- agentId: text('agent_id') nullable (NO FK -- preserve after agent deletion)
- sessionId: text('session_id') nullable (NO FK)
- txId: text('tx_id') nullable (NO FK)
- details: text NOT NULL (JSON)
- severity: text NOT NULL DEFAULT 'info' with CHECK IN ('info', 'warning', 'critical')
- ipAddress: text('ip_address') nullable
- Indexes: idx(timestamp), idx(eventType), idx(agentId), idx(severity), idx(agentId,timestamp)

**Table 7: key_value_store** (system state -- JWT secret, daemon metadata)
- key: text PK
- value: text NOT NULL
- updatedAt: integer('updated_at', { mode: 'timestamp' }) NOT NULL

**CHECK constraint pattern:** Use `sql` tagged template from drizzle-orm to generate CHECK constraints from the SSoT arrays. Import the enum arrays from `@waiaas/core` and construct the SQL string dynamically:
```typescript
import { AGENT_STATUSES, CHAIN_TYPES, NETWORK_TYPES, ... } from '@waiaas/core';
import { sql } from 'drizzle-orm';
// Build CHECK: sql`status IN ('CREATING', 'ACTIVE', ...)`
const buildCheckSql = (column: string, values: readonly string[]) =>
  sql.raw(`${column} IN (${values.map(v => `'${v}'`).join(', ')})`);
```

**3. Create `connection.ts`** (packages/daemon/src/infrastructure/database/connection.ts):

```typescript
export function createDatabase(dbPath: string): { sqlite: Database; db: BetterSQLite3Database } {
  const sqlite = new Database(dbPath);
  // Apply 7 PRAGMAs in order (doc 25 section 1.2)
  sqlite.pragma('journal_mode = WAL');
  sqlite.pragma('synchronous = NORMAL');
  sqlite.pragma('foreign_keys = ON');
  sqlite.pragma('busy_timeout = 5000');
  sqlite.pragma('cache_size = -64000');
  sqlite.pragma('mmap_size = 268435456');
  sqlite.pragma('temp_store = MEMORY');
  const db = drizzle(sqlite);
  return { sqlite, db };
}
export function closeDatabase(sqlite: Database): void {
  sqlite.pragma('wal_checkpoint(TRUNCATE)');
  sqlite.close();
}
```

**4. Create `migrate.ts`** (packages/daemon/src/infrastructure/database/migrate.ts):

Use Drizzle's `push` API (not generate+migrate) to create tables from schema at daemon startup. This is simpler for v1.1 and avoids migration files.

```typescript
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
// OR use drizzle-kit push approach:
export async function pushSchema(db: BetterSQLite3Database): Promise<void> {
  // For v1.1, use the schema directly to create tables
  // Alternative: use sql statements derived from schema
}
```

Since drizzle push is a CLI tool, for programmatic use, create tables via raw SQL derived from the Drizzle schema. Use `db.run(sql.raw(...))` with CREATE TABLE IF NOT EXISTS statements. This is the most reliable approach for daemon startup.

**5. Create `index.ts`** barrel export for database module.

**UUID v7 utility:** Create a `generateId()` function using the `uuidv7` package that generates time-ordered UUID v7 strings.
  </action>
  <verify>
- `pnpm install` succeeds with better-sqlite3 native addon compiled
- `pnpm build --filter=@waiaas/daemon` compiles without TypeScript errors
- Drizzle schema module imports enum arrays from @waiaas/core without circular dependencies
  </verify>
  <done>
- 7 Drizzle table definitions exist in schema.ts with correct columns, types, indexes, and CHECK constraints
- createDatabase() applies 7 PRAGMAs and returns Drizzle instance
- closeDatabase() runs WAL checkpoint(TRUNCATE) before closing
- generateId() returns UUID v7 strings with ms-precision time ordering
- All files compile and build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Database tests -- schema creation, PRAGMA verification, UUID v7 ordering, CHECK constraints</name>
  <files>
    packages/daemon/src/__tests__/database.test.ts
  </files>
  <action>
Create comprehensive tests for the database module using Vitest. Use in-memory SQLite (`:memory:`) for tests to avoid filesystem side effects.

**Test categories:**

1. **Schema creation tests:**
   - createDatabase(':memory:') succeeds and returns sqlite + db instances
   - After schema push, all 7 tables exist (query sqlite_master)
   - agents table has correct columns (verify column names and types via PRAGMA table_info)
   - transactions table has correct columns including v0.6 and v0.10 additions
   - audit_log id column is AUTOINCREMENT (not UUID v7)

2. **PRAGMA verification tests:**
   - journal_mode is 'wal' after createDatabase
   - foreign_keys is ON (1)
   - busy_timeout is 5000
   - synchronous is NORMAL (1)
   - cache_size is -64000
   - temp_store is MEMORY (2)
   - mmap_size is 268435456

3. **CHECK constraint tests:**
   - INSERT agent with valid status 'ACTIVE' succeeds
   - INSERT agent with invalid status 'INVALID_STATUS' throws constraint error
   - INSERT agent with valid chain 'solana' succeeds
   - INSERT agent with invalid chain 'bitcoin' throws constraint error
   - INSERT transaction with valid type 'TRANSFER' succeeds
   - INSERT transaction with invalid type 'INVALID_TYPE' throws constraint error
   - INSERT audit_log with valid severity 'info' succeeds
   - INSERT audit_log with invalid severity 'debug' throws constraint error

4. **UUID v7 ordering tests:**
   - Generate 10 UUID v7 IDs with small delay between each
   - Verify string sort order matches generation order
   - Insert agents with generated IDs, SELECT ORDER BY id matches chronological order

5. **Foreign key tests:**
   - INSERT session with non-existent agentId fails (FK constraint)
   - DELETE agent cascades to sessions (ON DELETE CASCADE)
   - DELETE agent with transactions is restricted (ON DELETE RESTRICT)

6. **closeDatabase tests:**
   - closeDatabase runs WAL checkpoint and closes connection
   - After close, further queries throw error

**Test setup pattern:**
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
let sqlite: Database;
let db: BetterSQLite3Database;
beforeEach(() => {
  const result = createDatabase(':memory:');
  sqlite = result.sqlite;
  db = result.db;
  pushSchema(db); // or equivalent
});
afterEach(() => {
  sqlite.close();
});
```
  </action>
  <verify>
- `pnpm test --filter=@waiaas/daemon` passes all database tests
- Tests cover schema creation, PRAGMA, CHECK constraints, UUID v7 ordering, FK behavior, close behavior
  </verify>
  <done>
- All 7 tables are verified to exist after schema creation
- All 7 PRAGMAs are verified to be correctly applied
- CHECK constraints reject invalid enum values and accept valid ones
- UUID v7 IDs sort chronologically by string comparison
- Foreign key constraints enforce referential integrity (CASCADE/RESTRICT/SET NULL)
- At least 20 test assertions pass covering all categories
  </done>
</task>

</tasks>

<verification>
1. `pnpm build --filter=@waiaas/daemon` succeeds
2. `pnpm test --filter=@waiaas/daemon` passes all database tests
3. Database module exports: createDatabase, closeDatabase, pushSchema, generateId, all table schemas
4. In-memory database test creates all 7 tables with correct structure
</verification>

<success_criteria>
- 7 Drizzle ORM table definitions matching doc 25 with indexes and CHECK constraints
- 7 PRAGMAs applied on every database connection
- UUID v7 used for all text PK fields (except audit_log which uses AUTOINCREMENT)
- CHECK constraints derived from @waiaas/core enum SSoT arrays (not hardcoded strings)
- Comprehensive test suite verifying schema, PRAGMAs, constraints, and UUID v7 ordering
</success_criteria>

<output>
After completion, create `.planning/phases/49-daemon-infra/49-01-SUMMARY.md`
</output>
