---
phase: 117-sign-only-pipeline-rest-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/pipeline/sign-only.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/sign-only-pipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "executeSignOnly()가 unsigned tx를 파싱하고, 정책 평가 후, INSTANT/NOTIFY tier이면 서명하여 SignOnlyResult를 반환한다"
    - "DELAY/APPROVAL tier sign-only 요청은 즉시 POLICY_DENIED 에러로 거부된다"
    - "sign-only 서명 후 transactions 테이블에 type='SIGN', status='SIGNED'로 기록된다"
    - "서명 시 reserved_amount에 누적되어 SPENDING_LIMIT 이중 지출이 방지된다"
    - "SIGNED 상태 트랜잭션의 reserved_amount가 evaluateAndReserve SUM 쿼리에 포함된다"
  artifacts:
    - path: "packages/daemon/src/pipeline/sign-only.ts"
      provides: "executeSignOnly() 함수, SignOnlyDeps/SignOnlyRequest/SignOnlyResult 인터페이스, mapOperationToParam 헬퍼"
      min_lines: 150
    - path: "packages/daemon/src/__tests__/sign-only-pipeline.test.ts"
      provides: "sign-only 파이프라인 유닛 테스트 (happy path, policy deny, DELAY/APPROVAL 거부, reservation, multi-op)"
      min_lines: 200
  key_links:
    - from: "packages/daemon/src/pipeline/sign-only.ts"
      to: "packages/daemon/src/pipeline/database-policy-engine.ts"
      via: "evaluateAndReserve() / evaluateBatch() 호출"
      pattern: "policyEngine\\.evaluateAndReserve|policyEngine\\.evaluateBatch"
    - from: "packages/daemon/src/pipeline/sign-only.ts"
      to: "packages/core/src/interfaces/chain-adapter.types.ts"
      via: "ParsedTransaction, SignedTransaction 타입 사용"
      pattern: "adapter\\.parseTransaction|adapter\\.signExternalTransaction"
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "reservation SUM 쿼리에 SIGNED 상태 포함"
      pattern: "status IN.*SIGNED"
---

<objective>
sign-only 파이프라인 모듈(executeSignOnly)과 reserved_amount SUM 쿼리 확장을 구현한다.

Purpose: 외부 dApp이 빌드한 unsigned tx를 정책 평가 후 서명하는 핵심 비즈니스 로직을 분리된 모듈로 구현하여, REST API 라우트(Plan 02)가 이를 호출할 수 있게 한다.
Output: sign-only.ts 파이프라인 모듈 + database-policy-engine.ts reservation 쿼리 수정 + 유닛 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/117-sign-only-pipeline-rest-api/117-RESEARCH.md
@.planning/phases/115-core-types-db-migration-parsers/115-01-SUMMARY.md

@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/enums/transaction.ts
@packages/core/src/errors/error-codes.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/infrastructure/database/id.ts
@packages/daemon/src/infrastructure/keystore/keystore.ts
@packages/daemon/src/notifications/notification-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: sign-only.ts 파이프라인 모듈 생성 + evaluateAndReserve SIGNED 쿼리 확장</name>
  <files>
    packages/daemon/src/pipeline/sign-only.ts
    packages/daemon/src/pipeline/database-policy-engine.ts
  </files>
  <action>
**1. `packages/daemon/src/pipeline/sign-only.ts` 신규 생성**

Research 파일의 Pattern 1 (executeSignOnly) + Pattern 2 (mapOperationToParam)를 기반으로 구현한다. 핵심 구조:

```
export interface SignOnlyDeps {
  db: BetterSQLite3Database<typeof schema>;
  sqlite?: SQLiteDatabase;
  adapter: IChainAdapter;
  keyStore: LocalKeyStore;
  policyEngine: IPolicyEngine;
  masterPassword: string;
  notificationService?: NotificationService;
}

export interface SignOnlyRequest {
  transaction: string;   // base64 (Solana) or 0x-hex (EVM)
  chain: string;
  network?: string;
}

export interface SignOnlyResult {
  id: string;
  signedTransaction: string;
  txHash?: string;
  operations: Array<{ type: string; to?: string; amount?: string; token?: string; programId?: string; method?: string; }>;
  policyResult: { tier: string; };
}
```

executeSignOnly() 10-step 파이프라인:
1. `adapter.parseTransaction(request.transaction)` -> ParsedTransaction. catch -> WAIaaSError('INVALID_TRANSACTION')
2. `mapOperationToParam()` 헬퍼로 ParsedOperation[] -> TransactionParam[] 변환 (research Pattern 2 참고). chain, network를 각 param에 주입. NATIVE_TRANSFER->TRANSFER, TOKEN_TRANSFER->TOKEN_TRANSFER, CONTRACT_CALL->CONTRACT_CALL, APPROVE->APPROVE, UNKNOWN->CONTRACT_CALL 매핑.
3. `generateId()` UUID v7 생성
4. `db.insert(transactions)` type='SIGN', status='PENDING', firstOp의 amount/toAddress, sessionId
5. 정책 평가: single op이고 DatabasePolicyEngine + sqlite -> `evaluateAndReserve(walletId, txParams[0], txId)`. multi-op이고 DatabasePolicyEngine -> `evaluateBatch(walletId, txParams)` 후 수동 reserved_amount 설정 (native amount 합산). fallback: `evaluate(walletId, txParams[0])`
6. `!evaluation.allowed` -> status='CANCELLED' UPDATE + throw WAIaaSError('POLICY_DENIED')
7. `evaluation.tier === 'DELAY' || 'APPROVAL'` -> status='CANCELLED' UPDATE + throw WAIaaSError('POLICY_DENIED', { message: `Sign-only request requires ${tier} tier which is not supported. Use POST /v1/transactions/send for high-value transactions.` })
8. tier UPDATE on transaction row
9. 서명: `let privateKey = null; try { privateKey = keyStore.decryptPrivateKey(walletId, masterPassword); signed = await adapter.signExternalTransaction(rawTx, privateKey); } catch { ... } finally { if (privateKey) keyStore.releaseKey(privateKey); }`. catch에서는 status='FAILED' UPDATE 후 ChainError->WAIaaSError('CHAIN_ERROR') 변환. releaseKey는 반드시 finally에서만 호출 (catch에서 호출 금지).
10. status='SIGNED', executedAt UPDATE -> SignOnlyResult 반환

Notification: step 1 이후 `void notificationService?.notify('TX_REQUESTED', walletId, ...)`, step 10 이후 `void notificationService?.notify('TX_SUBMITTED', walletId, ...)` (fire-and-forget, 메타데이터에 signOnly: true 포함)

**2. `packages/daemon/src/pipeline/database-policy-engine.ts` 수정**

evaluateAndReserve() 내 reservation SUM 쿼리 (현재 L529-534 부근):
```sql
-- 기존: AND status IN ('PENDING', 'QUEUED')
-- 변경: AND status IN ('PENDING', 'QUEUED', 'SIGNED')
```
'SIGNED' 상태를 reservation SUM에 포함하여 sign-only 트랜잭션의 reserved_amount가 SPENDING_LIMIT 평가에 반영되도록 한다.

**주의사항:**
- 기존 stages.ts를 수정하지 않음 (별도 모듈로 분리)
- downgradeIfNoOwner() 호출 생략 (DELAY/APPROVAL 모두 거부하므로 다운그레이드 결과 무의미)
- amount 처리는 bigint 문자열 (evaluateAndReserve가 문자열 amount 기대)
- timestamp는 초 단위로 절삭: `new Date(Math.floor(Date.now() / 1000) * 1000)`
  </action>
  <verify>
`npx turbo run build --filter=@waiaas/daemon` 빌드 성공. sign-only.ts에서 executeSignOnly, SignOnlyDeps, SignOnlyRequest, SignOnlyResult가 export됨.
  </verify>
  <done>
sign-only.ts 모듈이 executeSignOnly() 10-step 파이프라인을 제공하고, database-policy-engine.ts의 reservation SUM 쿼리에 'SIGNED'가 포함된다.
  </done>
</task>

<task type="auto">
  <name>Task 2: sign-only 파이프라인 유닛 테스트</name>
  <files>
    packages/daemon/src/__tests__/sign-only-pipeline.test.ts
  </files>
  <action>
`packages/daemon/src/__tests__/sign-only-pipeline.test.ts` 신규 생성.

기존 `api-transactions.test.ts` 패턴을 따라 in-memory SQLite + mock adapter + mock keyStore로 구성. DatabasePolicyEngine 실제 인스턴스 사용 (토글 테스트 116-02 패턴 참고).

**테스트 셋업:**
- createDatabase + pushSchema로 in-memory DB
- 테스트용 wallet INSERT (chain='solana', environment='testnet')
- MockAdapter: parseTransaction -> 미리 정의된 ParsedTransaction 반환, signExternalTransaction -> 서명 결과 반환
- MockKeyStore: decryptPrivateKey -> 32-byte 키 반환, releaseKey -> no-op
- DatabasePolicyEngine with sqlite (evaluateAndReserve 실제 호출)
- SPENDING_LIMIT 정책 설정 (instant_max, notify_max, delay_max로 tier 결정)

**테스트 케이스 (9개 이상):**

1. **happy path: INSTANT tier NATIVE_TRANSFER** - 파싱 성공 -> policy INSTANT -> 서명 -> status='SIGNED' DB 기록 + signedTransaction 반환
2. **happy path: NOTIFY tier** - SPENDING_LIMIT notify 범위 금액 -> NOTIFY tier -> 서명 정상 진행 (NOTIFY도 서명 가능)
3. **parse failure** - adapter.parseTransaction throws -> WAIaaSError('INVALID_TRANSACTION') 반환
4. **policy denied** - WHITELIST 정책으로 거부 -> status='CANCELLED' + WAIaaSError('POLICY_DENIED')
5. **DELAY tier rejection** - SPENDING_LIMIT delay 범위 금액 -> 즉시 WAIaaSError('POLICY_DENIED', message에 'DELAY tier' 포함, '/v1/transactions/send' 안내)
6. **APPROVAL tier rejection** - SPENDING_LIMIT approval 범위 금액 -> 즉시 WAIaaSError('POLICY_DENIED', message에 'APPROVAL tier' 포함)
7. **reserved_amount 누적** - 첫 번째 sign-only 5 SOL -> 두 번째 sign-only 3 SOL -> reserved_amount SUM이 8 SOL
8. **SIGNED 상태 reservation 포함** - sign-only로 status='SIGNED' 기록된 후, 다음 evaluateAndReserve에서 해당 reserved_amount가 SUM에 포함됨
9. **signing error -> key release** - signExternalTransaction throws -> status='FAILED' + privateKey가 releaseKey 호출됨 (releaseKey spy 검증)
10. **multi-op transaction** - 2개 operation ParsedTransaction -> evaluateBatch 호출 + 수동 reserved_amount 설정

**검증 패턴:** 각 테스트에서 DB SELECT로 transaction row의 status, type, tier, reserved_amount, error 필드 확인.
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/sign-only-pipeline.test.ts` 전체 통과. 기존 테스트 회귀 없음: `npx turbo run test --filter=@waiaas/daemon`
  </verify>
  <done>
sign-only 파이프라인의 10개 이상 테스트가 통과하고, happy path (INSTANT/NOTIFY), policy deny, DELAY/APPROVAL 거부, reservation 누적, signing error, multi-op이 모두 검증된다.
  </done>
</task>

</tasks>

<verification>
1. `npx turbo run build --filter=@waiaas/daemon` 빌드 성공
2. `npx vitest run packages/daemon/src/__tests__/sign-only-pipeline.test.ts` 전체 통과
3. `npx turbo run test --filter=@waiaas/daemon` 기존 테스트 회귀 없음
4. database-policy-engine.ts의 reservation SUM 쿼리에 'SIGNED' 포함 확인 (grep)
</verification>

<success_criteria>
- sign-only.ts 모듈이 executeSignOnly() 10-step 파이프라인을 export한다
- DELAY/APPROVAL tier는 POLICY_DENIED로 즉시 거부된다
- 서명 결과가 type='SIGN', status='SIGNED'로 DB에 기록된다
- reserved_amount SUM 쿼리에 'SIGNED' 상태가 포함되어 이중 지출을 방지한다
- 유닛 테스트 10개 이상 통과
</success_criteria>

<output>
After completion, create `.planning/phases/117-sign-only-pipeline-rest-api/117-01-SUMMARY.md`
</output>
