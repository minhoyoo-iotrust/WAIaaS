---
phase: 117-sign-only-pipeline-rest-api
plan: 02
type: execute
wave: 2
depends_on: ["117-01"]
files_modified:
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/__tests__/sign-only-api.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/transactions/sign에 valid unsigned tx를 보내면 200 + signedTransaction이 반환된다"
    - "POST /v1/transactions/sign에 invalid rawTx를 보내면 400 INVALID_TRANSACTION이 반환된다"
    - "POST /v1/transactions/sign에 DELAY 범위 금액을 보내면 403 POLICY_DENIED가 반환된다"
    - "sessionAuth 없이 POST /v1/transactions/sign 호출하면 401이 반환된다"
    - "OpenAPI 문서에 TxSignRequest, TxSignResponse 스키마가 포함된다"
  artifacts:
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "TxSignRequestSchema, TxSignResponseSchema Zod 스키마"
      contains: "TxSignRequest"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "signTransactionRoute createRoute + router.openapi handler"
      contains: "signTransactionRoute"
    - path: "packages/daemon/src/__tests__/sign-only-api.test.ts"
      provides: "POST /v1/transactions/sign 통합 테스트"
      min_lines: 200
  key_links:
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/pipeline/sign-only.ts"
      via: "executeSignOnly() 호출"
      pattern: "executeSignOnly"
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/api/routes/openapi-schemas.ts"
      via: "TxSignRequestSchema, TxSignResponseSchema import"
      pattern: "TxSignRequestSchema|TxSignResponseSchema"
    - from: "packages/daemon/src/api/routes/transactions.ts"
      to: "packages/daemon/src/pipeline/network-resolver.ts"
      via: "resolveNetwork() 호출"
      pattern: "resolveNetwork"
---

<objective>
POST /v1/transactions/sign REST API 라우트와 OpenAPI 스키마를 추가하고, 통합 테스트로 end-to-end 동작을 검증한다.

Purpose: sign-only 파이프라인(Plan 01)을 HTTP API로 노출하여 외부 dApp/SDK가 unsigned tx 서명을 요청할 수 있게 한다.
Output: transactions.ts에 sign 라우트 추가, openapi-schemas.ts에 요청/응답 스키마, 통합 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/117-sign-only-pipeline-rest-api/117-RESEARCH.md
@.planning/phases/117-sign-only-pipeline-rest-api/117-01-SUMMARY.md

@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/pipeline/sign-only.ts
@packages/daemon/src/pipeline/network-resolver.ts
@packages/daemon/src/__tests__/api-transactions.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: OpenAPI 스키마 + signTransactionRoute 라우트 정의 + 핸들러 구현</name>
  <files>
    packages/daemon/src/api/routes/openapi-schemas.ts
    packages/daemon/src/api/routes/transactions.ts
  </files>
  <action>
**1. `packages/daemon/src/api/routes/openapi-schemas.ts` 수정**

파일 하단 (McpTokenCreateResponseSchema 뒤)에 sign-only 스키마 2개 추가:

```typescript
// Sign-Only Transaction Schemas (POST /v1/transactions/sign)

export const TxSignRequestSchema = z
  .object({
    transaction: z.string().min(1).openapi({
      description: 'Unsigned transaction (base64 for Solana, 0x-hex for EVM)',
    }),
    chain: z.string().optional().openapi({
      description: 'Chain type (optional -- inferred from wallet)',
    }),
    network: z.string().optional().openapi({
      description: 'Network (optional -- resolved from wallet defaults)',
    }),
  })
  .openapi('TxSignRequest');

export const TxSignResponseSchema = z
  .object({
    id: z.string().uuid(),
    signedTransaction: z.string(),
    txHash: z.string().nullable(),
    operations: z.array(
      z.object({
        type: z.string(),
        to: z.string().nullable().optional(),
        amount: z.string().nullable().optional(),
        token: z.string().nullable().optional(),
        programId: z.string().nullable().optional(),
        method: z.string().nullable().optional(),
      }),
    ),
    policyResult: z.object({
      tier: z.string(),
    }),
  })
  .openapi('TxSignResponse');
```

**2. `packages/daemon/src/api/routes/transactions.ts` 수정**

2a. Import 추가:
- openapi-schemas.ts에서: `TxSignRequestSchema`, `TxSignResponseSchema`
- sign-only.ts에서: `executeSignOnly` (+ SignOnlyDeps 타입은 인라인 구성)

2b. 라우트 정의 (sendTransactionRoute 뒤, getTransactionRoute **앞**에 배치 -- Pitfall 6: route ordering):

```typescript
const signTransactionRoute = createRoute({
  method: 'post',
  path: '/transactions/sign',
  tags: ['Transactions'],
  summary: 'Sign an external unsigned transaction',
  description: 'Parse, evaluate against policies, and sign an unsigned transaction built by an external dApp. Returns the signed transaction synchronously. DELAY/APPROVAL tier requests are immediately rejected.',
  request: {
    body: {
      content: {
        'application/json': { schema: TxSignRequestSchema },
      },
    },
  },
  responses: {
    200: {
      description: 'Transaction signed successfully',
      content: { 'application/json': { schema: TxSignResponseSchema } },
    },
    ...buildErrorResponses(['INVALID_TRANSACTION', 'WALLET_NOT_SIGNER', 'POLICY_DENIED', 'WALLET_NOT_FOUND']),
  },
});
```

2c. 핸들러 등록 (transactionRoutes 함수 내부, `router.openapi(sendTransactionRoute, ...)` 블록 직후, GET /transactions/:id 블록 **앞**에 배치):

```typescript
// POST /transactions/sign (sessionAuth -- sign external unsigned tx)
router.openapi(signTransactionRoute, async (c) => {
  const walletId = c.get('walletId' as never) as string;
  const sessionId = c.get('sessionId' as never) as string | undefined;
  const body = c.req.valid('json');

  // Look up wallet
  const wallet = await deps.db.select().from(wallets).where(eq(wallets.id, walletId)).get();
  if (!wallet) {
    throw new WAIaaSError('WALLET_NOT_FOUND', { message: `Wallet '${walletId}' not found` });
  }

  // Resolve network (same pattern as POST /transactions/send)
  const resolvedNetwork = resolveNetwork(
    body.network as NetworkType | undefined,
    wallet.defaultNetwork as NetworkType | null,
    wallet.environment as EnvironmentType,
    wallet.chain as ChainType,
  );

  // Resolve adapter
  const rpcUrl = resolveRpcUrl(
    deps.config.rpc as unknown as Record<string, string>,
    wallet.chain,
    resolvedNetwork,
  );
  const adapter = await deps.adapterPool.resolve(
    wallet.chain as ChainType,
    resolvedNetwork as NetworkType,
    rpcUrl,
  );

  // Execute sign-only pipeline (fully synchronous within request)
  const result = await executeSignOnly(
    {
      db: deps.db,
      sqlite: deps.sqlite,
      adapter,
      keyStore: deps.keyStore,
      policyEngine: deps.policyEngine,
      masterPassword: deps.masterPassword,
      notificationService: deps.notificationService,
    },
    walletId,
    { transaction: body.transaction, chain: wallet.chain, network: resolvedNetwork },
    sessionId,
  );

  return c.json(result, 200);
});
```

2d. TransactionRouteDeps에 `notificationService?: NotificationService`가 이미 존재하는지 확인. 이미 있으면 변경 없음. (Research에서 확인: 기존에 존재함)

**핵심 주의:**
- signTransactionRoute를 getTransactionRoute(`/transactions/{id}`)보다 **앞에** 등록. `/transactions/pending` 패턴과 동일 (Pitfall 6).
- sessionAuth는 server.ts에서 `/v1/transactions/*`에 이미 적용됨 (server.ts 변경 불필요).
- body validation은 `c.req.valid('json')`으로 Zod가 자동 처리 (send의 z.any() 패턴과 다름 -- sign은 간단한 3-field 스키마).
  </action>
  <verify>
`npx turbo run build --filter=@waiaas/daemon` 빌드 성공. `GET http://localhost:3000/doc`에서 TxSignRequest, TxSignResponse 스키마 노출 확인 (빌드만 검증, 실행은 통합 테스트에서).
  </verify>
  <done>
POST /v1/transactions/sign 라우트가 transactions.ts에 등록되고, OpenAPI 스키마가 openapi-schemas.ts에 정의된다. sessionAuth가 자동 적용되고, executeSignOnly() 파이프라인을 호출한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: POST /v1/transactions/sign 통합 테스트</name>
  <files>
    packages/daemon/src/__tests__/sign-only-api.test.ts
  </files>
  <action>
`packages/daemon/src/__tests__/sign-only-api.test.ts` 신규 생성.

기존 `api-transactions.test.ts` 패턴을 따라 in-memory SQLite + createApp + app.request()로 통합 테스트 구성.

**셋업:**
- createDatabase + pushSchema in-memory
- mockConfig (DaemonConfig)
- MockAdapter: parseTransaction -> { operations: [{ type: 'NATIVE_TRANSFER', to: '...', amount: 1_000_000_000n }] }, signExternalTransaction -> { signedTransaction: 'base64-signed', txHash: undefined }
- MockKeyStore: decryptPrivateKey -> 32-byte buffer, releaseKey -> vi.fn()
- MockAdapterPool: resolve -> MockAdapter
- DatabasePolicyEngine 실제 인스턴스 (sqlite 전달)
- JwtSecretManager -> createToken으로 valid session JWT 생성
- wallet INSERT via DB (chain='solana', environment='testnet')
- session INSERT via DB

**테스트 케이스 (8개 이상):**

1. **200 성공: valid Solana tx** - POST /v1/transactions/sign with valid body + sessionAuth header -> 200, body에 id, signedTransaction, operations, policyResult.tier 포함
2. **200 성공: operations 배열 반환** - 응답의 operations[0].type === 'NATIVE_TRANSFER', to/amount 확인
3. **DB 기록 확인** - 성공 후 transactions SELECT: type='SIGN', status='SIGNED', reserved_amount 설정됨
4. **401 인증 없음** - Authorization 헤더 없이 요청 -> 401
5. **400 invalid transaction** - adapter.parseTransaction throws -> 400 INVALID_TRANSACTION
6. **403 policy denied (DELAY tier)** - SPENDING_LIMIT 정책 설정 + delay 범위 금액 -> 403 POLICY_DENIED, message에 'DELAY' 포함
7. **403 policy denied (WHITELIST)** - WHITELIST 정책 + 허용되지 않은 주소 -> 403 POLICY_DENIED
8. **reserved_amount 누적 검증** - 첫 번째 sign 성공 -> 두 번째 sign -> DB에서 두 트랜잭션의 reserved_amount 합이 evaluateAndReserve에 반영됨 확인
9. **404 wallet not found** - 존재하지 않는 walletId session으로 요청 -> 404

**요청 패턴:**
```typescript
const res = await app.request(
  'http://127.0.0.1:3100/v1/transactions/sign',
  {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${sessionToken}`,
    },
    body: JSON.stringify({ transaction: 'base64-unsigned-tx' }),
  },
);
```

**검증 패턴:**
- `expect(res.status).toBe(200/400/401/403/404)`
- `const body = await res.json()` -> body 필드 검증
- DB SELECT -> transaction row 필드 검증
  </action>
  <verify>
`npx vitest run packages/daemon/src/__tests__/sign-only-api.test.ts` 전체 통과. `npx turbo run test --filter=@waiaas/daemon` 기존 테스트 회귀 없음.
  </verify>
  <done>
POST /v1/transactions/sign 엔드포인트의 8개 이상 통합 테스트가 통과하고, 인증/파싱/정책/서명/DB기록/에러 응답이 end-to-end로 검증된다.
  </done>
</task>

</tasks>

<verification>
1. `npx turbo run build --filter=@waiaas/daemon` 빌드 성공
2. `npx vitest run packages/daemon/src/__tests__/sign-only-api.test.ts` 전체 통과
3. `npx turbo run test --filter=@waiaas/daemon` 기존 테스트 회귀 없음
4. openapi-schemas.ts에 TxSignRequest, TxSignResponse 스키마 존재 확인
5. transactions.ts에 signTransactionRoute가 getTransactionRoute 앞에 등록됨 확인
</verification>

<success_criteria>
- POST /v1/transactions/sign 엔드포인트가 sessionAuth로 보호되고 정상 동작한다
- 유효한 unsigned tx 제출 시 200 + signedTransaction 반환
- 잘못된 tx, 인증 없음, 정책 거부 시 적절한 HTTP 에러 코드 반환
- OpenAPI 문서에 TxSignRequest/TxSignResponse 스키마 포함
- 통합 테스트 8개 이상 통과
</success_criteria>

<output>
After completion, create `.planning/phases/117-sign-only-pipeline-rest-api/117-02-SUMMARY.md`
</output>
