---
phase: 225-chain-subscriber-implementations
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/adapters/evm/src/evm-incoming-subscriber.ts
  - packages/adapters/evm/src/index.ts
  - packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts
autonomous: true
requirements: [SUB-03]

must_haves:
  truths:
    - "EvmIncomingSubscriber.pollAll() detects ERC-20 Transfer events via getLogs with parseAbiItem filter"
    - "EvmIncomingSubscriber.pollAll() detects native ETH transfers via getBlock(includeTransactions:true) scanning tx.to"
    - "Polling caps at 10 blocks per cycle to stay within RPC provider limits"
    - "subscribe() stores currentBlock as lastBlock cursor for each wallet"
    - "connect() is a no-op (EVM uses polling-first strategy per D-06)"
    - "waitForDisconnect() returns a never-resolving Promise (prevents reconnectLoop triggering for EVM)"
    - "Per-wallet error isolation in pollAll() -- one wallet failure does not affect others"
  artifacts:
    - path: "packages/adapters/evm/src/evm-incoming-subscriber.ts"
      provides: "EvmIncomingSubscriber class implementing IChainSubscriber 6-method interface + pollAll()"
      exports: ["EvmIncomingSubscriber"]
    - path: "packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts"
      provides: "Unit tests with mock viem client for all subscriber methods"
      min_lines: 150
  key_links:
    - from: "packages/adapters/evm/src/evm-incoming-subscriber.ts"
      to: "@waiaas/core IChainSubscriber"
      via: "implements IChainSubscriber"
      pattern: "implements IChainSubscriber"
    - from: "packages/adapters/evm/src/evm-incoming-subscriber.ts"
      to: "viem"
      via: "createPublicClient, http, parseAbiItem for getLogs/getBlock"
      pattern: "import.*from 'viem'"
    - from: "packages/adapters/evm/src/index.ts"
      to: "packages/adapters/evm/src/evm-incoming-subscriber.ts"
      via: "barrel re-export"
      pattern: "export.*EvmIncomingSubscriber"
---

<objective>
Implement EvmIncomingSubscriber that detects ERC-20 Transfer events via getLogs polling and native ETH transfers via getBlock scanning, following the polling-first strategy for EVM chains.

Purpose: Enable periodic detection of incoming EVM transfers -- ERC-20 tokens via Transfer event log filtering and native ETH via block transaction scanning. This is the EVM-side implementation of the IChainSubscriber interface from Phase 224, complementing the Solana subscriber in Plan 225-01.

Output: EvmIncomingSubscriber class with pollAll() method, barrel re-export, and comprehensive unit tests with mock viem client.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/224-core-types-db-foundation/224-01-SUMMARY.md

# Key source references
@packages/core/src/interfaces/IChainSubscriber.ts
@packages/core/src/interfaces/chain-subscriber.types.ts
@packages/core/src/enums/incoming-tx.ts
@packages/core/src/enums/chain.ts
@packages/adapters/evm/src/adapter.ts
@packages/adapters/evm/src/abi/erc20.ts
@packages/adapters/evm/src/index.ts
@packages/adapters/evm/src/__tests__/evm-adapter.test.ts

# Design reference
@internal/design/76-incoming-transaction-monitoring.md (sections 4.1-4.7)
@.planning/phases/225-chain-subscriber-implementations/225-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EvmIncomingSubscriber class with ERC-20 and native ETH detection</name>
  <files>
    packages/adapters/evm/src/evm-incoming-subscriber.ts
    packages/adapters/evm/src/index.ts
  </files>
  <action>
**File 1: `packages/adapters/evm/src/evm-incoming-subscriber.ts`**

Create the `EvmIncomingSubscriber` class implementing `IChainSubscriber` from `@waiaas/core`.

**Imports:**
- `createPublicClient, http, parseAbiItem, type PublicClient, type Address` from `'viem'`.
- `IChainSubscriber, IncomingTransaction, type ChainType` from `'@waiaas/core'`.

**Constants:**
- `TRANSFER_EVENT = parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)')` -- ERC-20 Transfer event signature.
- `MAX_BLOCK_RANGE = 10n` -- Maximum blocks per poll cycle (pitfall 4 from research: RPC provider limits).

**Constructor:**
- Takes `config: { rpcUrl: string; generateId?: () => string }`.
- Creates `this.client = createPublicClient({ transport: http(config.rpcUrl) })`.
- `this.generateId = config.generateId ?? (() => crypto.randomUUID())`.

**Class state:**
- `readonly chain = 'ethereum' as const` (satisfies ChainType).
- `private subscriptions = new Map<string, { address: string; network: string; onTransaction: (tx: IncomingTransaction) => void; lastBlock: bigint }>()`.

**IChainSubscriber methods:**

`subscribe(walletId, address, network, onTransaction)`:
- If `this.subscriptions.has(walletId)`, return (idempotent).
- Get `currentBlock = await this.client.getBlockNumber()`.
- Store `{ address, network, onTransaction, lastBlock: currentBlock }` in subscriptions Map.

`unsubscribe(walletId)`:
- `this.subscriptions.delete(walletId)` -- no-op if not found.

`subscribedWallets()`:
- Return `Array.from(this.subscriptions.keys())`.

`connect()`:
- No-op -- EVM uses polling-first strategy (design decision D-06). Just `return`.

`waitForDisconnect()`:
- Return `new Promise(() => {})` -- never-resolving Promise. This is correct: EVM polling mode has no WebSocket to disconnect. The reconnectLoop in Phase 226 will call `connect()` (succeeds instantly) then `waitForDisconnect()` (blocks forever), meaning EVM stays in WS_ACTIVE state permanently and polling workers handle the actual work.

`destroy()`:
- `this.subscriptions.clear()`.

**Public `pollAll()` method** (called by BackgroundWorkers in Phase 226):
- `const currentBlock = await this.client.getBlockNumber()`.
- For each `[walletId, sub]` in subscriptions:
  - Wrap in try/catch for per-wallet error isolation.
  - If `sub.lastBlock >= currentBlock`, skip (no new blocks).
  - Calculate `toBlock = min(sub.lastBlock + MAX_BLOCK_RANGE, currentBlock)`.
  - Call `this.pollERC20(sub.address as Address, sub.lastBlock + 1n, toBlock, walletId, sub.network)`.
  - Call `this.pollNativeETH(sub.address as Address, sub.lastBlock + 1n, toBlock, walletId, sub.network)`.
  - Concatenate results and call `sub.onTransaction(tx)` for each.
  - Update `sub.lastBlock = toBlock`.
  - Catch errors: `console.warn(\`EVM poll failed for wallet ${walletId}:\`, err)`.

**Private `pollERC20(walletAddress, fromBlock, toBlock, walletId, network)`:**
- Call `this.client.getLogs({ event: TRANSFER_EVENT, args: { to: walletAddress }, fromBlock, toBlock })`.
- Map each log to `IncomingTransaction`:
  - `id: this.generateId()`, `txHash: log.transactionHash!`, `walletId`, `fromAddress: log.args.from!`, `amount: log.args.value!.toString()`, `tokenAddress: log.address`, `chain: 'ethereum'`, `network`, `status: 'DETECTED'`, `blockNumber: Number(log.blockNumber)`, `detectedAt: Math.floor(Date.now() / 1000)`, `confirmedAt: null`.
- Return the array.

**Private `pollNativeETH(walletAddress, fromBlock, toBlock, walletId, network)`:**
- Iterate from `fromBlock` to `toBlock`:
  - `const block = await this.client.getBlock({ blockNumber: blockNum, includeTransactions: true })`.
  - For each `tx` in `block.transactions`:
    - Guard: `if (typeof tx === 'string') continue` (pitfall 2: hash-only without includeTransactions).
    - Guard: `if (typeof tx !== 'object' || !tx.to) continue`.
    - Check: `tx.to.toLowerCase() === walletAddress.toLowerCase() && tx.value > 0n`.
    - Create `IncomingTransaction` with `tokenAddress: null` (native ETH), `fromAddress: tx.from`.
- Return accumulated results array.

**File 2: `packages/adapters/evm/src/index.ts`**

Add export: `export { EvmIncomingSubscriber } from './evm-incoming-subscriber.js';`
  </action>
  <verify>
`pnpm turbo run typecheck --filter=@waiaas/adapter-evm` passes with 0 errors.
  </verify>
  <done>
EvmIncomingSubscriber implements IChainSubscriber with polling-first strategy. connect() is no-op, waitForDisconnect() is never-resolving. pollAll() detects ERC-20 via getLogs and native ETH via getBlock with 10-block cap. Barrel exports the class.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for EvmIncomingSubscriber with mock viem client</name>
  <files>
    packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts
  </files>
  <action>
Create `packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts` following the existing `evm-adapter.test.ts` vi.mock pattern.

**Mock setup:**
- Create `mockClient` object with `getBlockNumber`, `getLogs`, `getBlock` methods as `vi.fn()`.
- `vi.mock('viem', ...)` returning `{ ...actual, createPublicClient: vi.fn(() => mockClient), parseAbiItem: actual.parseAbiItem }` -- keep `parseAbiItem` real since it's a pure function.
- Import `EvmIncomingSubscriber` after the mock.

**Test fixtures:**
- `TEST_RPC_URL = 'https://rpc.test.com'`.
- `TEST_WALLET_ADDRESS = '0x742d35Cc6634C0532925a3b844Bc9e7595f2bD28'`.
- `TEST_SENDER_ADDRESS = '0x1234567890abcdef1234567890abcdef12345678'`.
- `TEST_TOKEN_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'` (USDC-like).
- Mock `generateId` that returns predictable IDs: `let idCounter = 0; const mockGenerateId = () => \`test-id-${++idCounter}\``.

**Test suites (minimum 15 tests):**

`describe('EvmIncomingSubscriber - IChainSubscriber interface')`:
- `chain` property is `'ethereum'`.
- `subscribe()` adds wallet to subscriptions and fetches current block number.
- `subscribe()` is idempotent (second call with same walletId is no-op, getBlockNumber called only once).
- `unsubscribe()` removes wallet from subscriptions.
- `unsubscribe()` is no-op for unknown walletId.
- `subscribedWallets()` returns current subscription IDs.
- `connect()` resolves immediately (no-op).
- `waitForDisconnect()` returns a Promise that never resolves (verify it's pending after 100ms with `Promise.race`).
- `destroy()` clears all subscriptions.

`describe('EvmIncomingSubscriber - pollAll ERC-20')`:
- Detects ERC-20 Transfer event and calls onTransaction with correct IncomingTransaction (tokenAddress = log.address, fromAddress = log.args.from).
- Mock `getLogs` to return a log array with `{ transactionHash, args: { from, to, value }, address, blockNumber }`.
- Updates lastBlock cursor after successful poll.
- Skips polling when no new blocks (lastBlock >= currentBlock).

`describe('EvmIncomingSubscriber - pollAll native ETH')`:
- Detects native ETH transfer (tx.to matches wallet, value > 0n) and calls onTransaction with `tokenAddress: null`.
- Mock `getBlock` to return `{ transactions: [{ hash, from, to, value }] }`.
- Skips string-only transactions (`typeof tx === 'string'`).
- Skips transactions with `value === 0n`.
- Skips transactions where `tx.to` does not match wallet address.

`describe('EvmIncomingSubscriber - pollAll resilience')`:
- Caps block range at 10 blocks per poll cycle (if 20 blocks behind, only polls 10).
- Per-wallet error isolation: mock getLogs to throw for one wallet, verify second wallet still gets polled and onTransaction called.
- Handles getLogs returning empty array gracefully.

Each test should call `beforeEach` to reset mock functions and create a fresh subscriber with `mockGenerateId`.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --reporter=verbose packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts`. All tests pass.
  </verify>
  <done>
15+ tests pass covering IChainSubscriber interface compliance, ERC-20 Transfer detection via getLogs, native ETH detection via getBlock(includeTransactions:true), 10-block cap, per-wallet error isolation, and cursor management. All with mock viem client (no real network calls).
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/adapter-evm` -- 0 errors
2. `pnpm vitest run --reporter=verbose packages/adapters/evm/src/__tests__/evm-incoming-subscriber.test.ts` -- all tests pass
3. `EvmIncomingSubscriber` is importable from `@waiaas/adapter-evm`
4. ERC-20 Transfer detection uses parseAbiItem for event filtering
5. Native ETH detection uses getBlock with includeTransactions:true and typeof guard
6. Block range is capped at 10 per poll cycle
7. connect() is no-op, waitForDisconnect() never resolves
</verification>

<success_criteria>
- EvmIncomingSubscriber class implements all 6 IChainSubscriber methods + pollAll()
- ERC-20 Transfer event detection via getLogs with parseAbiItem filter works correctly
- Native ETH transfer detection via getBlock(includeTransactions:true) with tx.to comparison works correctly
- 10-block cap per poll cycle prevents RPC provider limits
- connect() is no-op, waitForDisconnect() returns never-resolving Promise (polling-first strategy)
- Per-wallet error isolation ensures one failure doesn't break all wallets
- All tests pass with mock viem client (no real network calls)
- Package barrel re-exports EvmIncomingSubscriber
</success_criteria>

<output>
After completion, create `.planning/phases/225-chain-subscriber-implementations/225-02-SUMMARY.md`
</output>
