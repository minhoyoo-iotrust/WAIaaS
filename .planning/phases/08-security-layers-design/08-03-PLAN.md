---
phase: 08-security-layers-design
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - .planning/deliverables/35-notification-architecture.md
autonomous: true

must_haves:
  truths:
    - "INotificationChannel 인터페이스가 type/send/healthCheck 메서드로 정의되고, 3개 채널(Telegram/Discord/ntfy.sh) 구현이 코드 수준으로 설계됨"
    - "NotificationService 오케스트레이터가 우선순위 기반 전송 + 폴백 체인 로직으로 설계됨"
    - "알림 이벤트 타입(NOTIFY_TX, DELAY_TX, APPROVAL_REQUEST, KILL_SWITCH, AUTO_STOP 등)이 열거형으로 정의됨"
    - "notification_channels 테이블 스키마가 채널 설정 저장 구조로 정의됨"
    - "전달 추적(notification_log)이 성공/실패/폴백 기록 구조로 설계됨"
    - "채널별 rate limit 준수 전략(Telegram 30/s, Discord 5/5s)이 정의됨"
    - "최소 2개 채널 설정 필수 검증 로직이 정의됨"
  artifacts:
    - path: ".planning/deliverables/35-notification-architecture.md"
      provides: "멀티 채널 알림 아키텍처 전체 설계 -- 채널 추상화, 3개 어댑터, 전달 추적, 폴백, rate limit"
      contains: "INotificationChannel"
  key_links:
    - from: "35-notification-architecture.md"
      to: "33-time-lock-approval-mechanism.md"
      via: "NOTIFY 티어 알림 + DELAY 큐잉 알림 + APPROVAL 승인 요청 알림에서 NotificationService 사용"
      pattern: "NotificationService.*notify"
    - from: "35-notification-architecture.md"
      to: "24-monorepo-data-directory.md"
      via: "config.toml [notifications] 섹션에 채널 설정 저장"
      pattern: "\\[notifications\\]"
    - from: "35-notification-architecture.md"
      to: "25-sqlite-schema.md"
      via: "notification_channels + notification_log 테이블 스키마 추가"
      pattern: "notification_channels"
---

<objective>
멀티 채널 알림 아키텍처를 완전히 설계한다 -- INotificationChannel 인터페이스 + Telegram/Discord/ntfy.sh 3개 어댑터, NotificationService 오케스트레이터(우선순위, 폴백, 중복 방지), 알림 이벤트 타입 체계, notification_channels/notification_log 테이블, 채널별 rate limit 준수, 전달 추적을 구현 가능한 수준으로 정의한다.

Purpose: 알림은 WAIaaS 3계층 보안의 핵심 요소이다. NOTIFY 티어 거래 알림, DELAY 큐잉 알림, APPROVAL 승인 요청, Kill Switch 긴급 알림, 자동 정지 경고 등 모든 보안 이벤트가 Owner에게 전달되어야 한다. 최소 2개 채널 설정 필수 정책으로 단일 장애점을 방지한다.
Output: 설계 문서 1개 -- 35-notification-architecture.md (NOTI-01, NOTI-02 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-security-layers-design/08-RESEARCH.md

# 08-01 SUMMARY 참조 (직접 의존)
@.planning/phases/08-security-layers-design/08-01-SUMMARY.md

# Phase 6 참조
@.planning/deliverables/24-monorepo-data-directory.md (CORE-01: config.toml 구조)
@.planning/deliverables/25-sqlite-schema.md (CORE-02: 테이블 스키마 패턴)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 알림 채널 추상화 + 3개 어댑터 + NotificationService 설계</name>
  <files>.planning/deliverables/35-notification-architecture.md</files>
  <action>
  설계 문서 `35-notification-architecture.md`를 작성한다. 문서 ID는 `NOTI-ARCH`.

  **섹션 1: 문서 개요 + 요구사항 매핑**
  - 문서 ID, 작성일, 상태, 참조 문서 (LOCK-MECH, CORE-01, CORE-02)
  - 요구사항 매핑: NOTI-01 (멀티 채널 알림), NOTI-02 (최소 2채널 + 폴백)
  - 설계 원칙: native fetch만 사용 (외부 HTTP 라이브러리/Bot 프레임워크 불필요), 채널 추상화로 확장성 확보

  **섹션 2: INotificationChannel 인터페이스**
  - TypeScript 인터페이스 정의:
    ```
    interface INotificationChannel {
      readonly type: 'TELEGRAM' | 'DISCORD' | 'NTFY'
      readonly name: string  // 사용자 지정 이름 (예: "내 텔레그램")
      send(message: NotificationMessage): Promise<NotificationResult>
      healthCheck(): Promise<boolean>
    }
    ```
  - NotificationMessage 타입:
    - level: 'INFO' | 'WARNING' | 'CRITICAL'
    - event: NotificationEventType (열거형)
    - title: string
    - body: string
    - metadata?: Record<string, unknown> (txId, agentId 등)
  - NotificationResult 타입:
    - success: boolean
    - channelId: string
    - error?: string
    - retryAfter?: number (rate limit 시)
  - NotificationEventType 열거형:
    - TX_NOTIFY: NOTIFY 티어 거래 알림 (실행 후)
    - TX_DELAY_QUEUED: DELAY 티어 큐잉 알림 (취소 가능)
    - TX_DELAY_EXECUTED: DELAY 거래 자동 실행 알림
    - TX_APPROVAL_REQUEST: APPROVAL 티어 승인 요청 (긴급)
    - TX_APPROVAL_EXPIRED: APPROVAL 타임아웃 만료
    - TX_CONFIRMED: 거래 확정 알림
    - TX_FAILED: 거래 실패 알림
    - KILL_SWITCH_ACTIVATED: Kill Switch 발동 (모든 채널 동시)
    - KILL_SWITCH_RECOVERED: Kill Switch 복구
    - AUTO_STOP_TRIGGERED: 자동 정지 규칙 발동
    - SESSION_CREATED: 새 세션 생성 알림
    - SESSION_REVOKED: 세션 폐기 알림
    - DAILY_SUMMARY: 일일 요약 (선택)

  **섹션 3: Telegram Bot API 어댑터**
  - TelegramChannel 클래스 설계 (코드 수준):
    - 생성자: botToken, chatId
    - send(): POST https://api.telegram.org/bot{token}/sendMessage
      - parse_mode: 'MarkdownV2' (서식 지원)
      - 메시지 포맷팅: level별 이모지, 거래 상세 (금액, 주소, 상태)
      - AbortSignal.timeout(10_000) 타임아웃
    - healthCheck(): GET /bot{token}/getMe
    - 에러 핸들링: HTTP 429 -> retryAfter 추출, 기타 에러 -> NotificationResult.error
  - Telegram 설정 값:
    - botToken: Bot API 토큰 (BotFather에서 발급)
    - chatId: 수신 채팅 ID (개인 DM 또는 그룹)
  - 메시지 템플릿 예시 (APPROVAL_REQUEST, KILL_SWITCH 등)

  **섹션 4: Discord Webhook 어댑터**
  - DiscordChannel 클래스 설계 (코드 수준):
    - 생성자: webhookUrl
    - send(): POST {webhookUrl}
      - Content-Type: application/json
      - username: 'WAIaaS Security'
      - content 또는 embeds (rich message)
      - embed 구조: color (severity별), title, description, fields, timestamp
    - healthCheck(): GET {webhookUrl} -> 200 확인
    - 에러 핸들링: HTTP 429 -> Retry-After 헤더, 204/200 = 성공
  - Discord Rate Limit 준수:
    - 5 요청 / 5초 per webhook
    - 429 응답 시 Retry-After 값만큼 대기 후 재시도

  **섹션 5: ntfy.sh Push 어댑터**
  - NtfyChannel 클래스 설계 (코드 수준):
    - 생성자: serverUrl (기본 'https://ntfy.sh' 또는 self-hosted), topic
    - send(): POST {serverUrl}/{topic}
      - headers: Title, Priority(1-5), Tags(이모지 태그)
      - body: 메시지 텍스트
      - Click 헤더: 승인 URL 포함 가능 (APPROVAL_REQUEST 시)
      - Actions 헤더: 인라인 버튼 (view, http 액션)
    - healthCheck(): GET {serverUrl}/{topic}/json?poll=1&since=0 (빈 응답 확인)
    - Priority 매핑: CRITICAL=5, WARNING=4, INFO=3
  - ntfy.sh 장점: self-hosted 가능, 인증 선택적, iOS/Android 앱 제공

  **섹션 6: NotificationService 오케스트레이터**
  - 설계 (코드 수준):
    - channels: INotificationChannel[] (priority 순 정렬)
    - notify(message): 표준 알림 전송 (첫 성공 시 중단 + 폴백)
    - broadcast(message): 모든 채널에 전송 (Kill Switch 등 critical)
  - 표준 알림 플로우:
    1. 활성 채널을 priority 순으로 순회
    2. 첫 채널에 send() 시도
    3. 성공 -> notification_log INSERT (status=DELIVERED) -> 종료
    4. 실패 -> notification_log INSERT (status=FAILED, error) -> 다음 채널 폴백
    5. 모든 채널 실패 -> notification_log INSERT (status=ALL_FAILED) -> audit_log CRITICAL
  - broadcast 알림 플로우 (KILL_SWITCH, AUTO_STOP):
    1. 모든 활성 채널에 병렬 전송 (Promise.allSettled)
    2. 각 결과 notification_log INSERT
    3. 1개라도 성공하면 전체 성공
  - 중복 방지: 동일 event+txId 조합 5분 내 재전송 방지 (LRU deduplication)

  </action>
  <verify>
  - 35-notification-architecture.md 파일이 존재하고 문서 ID가 NOTI-ARCH
  - INotificationChannel 인터페이스가 type/name/send/healthCheck로 정의됨
  - 3개 채널 어댑터가 각각 코드 수준으로 설계됨
  - NotificationEventType 열거형에 13개 이벤트가 정의됨
  - NotificationService의 notify/broadcast 플로우가 단계별로 기술됨
  </verify>
  <done>알림 채널 추상화, 3개 어댑터, NotificationService 오케스트레이터가 구현 가능한 수준으로 설계됨</done>
</task>

<task type="auto">
  <name>Task 2: 알림 DB 스키마 + 채널 설정 + 전달 추적 + rate limit 설계</name>
  <files>.planning/deliverables/35-notification-architecture.md</files>
  <action>
  35-notification-architecture.md에 다음 섹션을 추가한다.

  **섹션 7: notification_channels 테이블 스키마**
  - 채널 설정 저장 테이블:
    - id: UUID v7 PK
    - type: TEXT NOT NULL ('TELEGRAM' | 'DISCORD' | 'NTFY')
    - name: TEXT NOT NULL -- 사용자 지정 이름
    - config: TEXT NOT NULL -- JSON (채널별 설정)
      - TELEGRAM: { botToken, chatId }
      - DISCORD: { webhookUrl }
      - NTFY: { serverUrl, topic, authToken? }
    - priority: INTEGER NOT NULL DEFAULT 0 -- 전송 우선순위 (높을수록 먼저)
    - enabled: INTEGER NOT NULL DEFAULT 1
    - lastHealthCheck: TEXT -- ISO 8601
    - lastHealthStatus: INTEGER -- 0/1
    - createdAt: TEXT NOT NULL
    - updatedAt: TEXT NOT NULL
  - 인덱스: idx_notification_channels_enabled (enabled, priority DESC)
  - config JSON 보안:
    - v0.2: 평문 저장 + 데이터 디렉토리 파일 권한 600 (SQLite 파일)
    - v0.3: AES-256-GCM 암호화 저장 마이그레이션 경로 문서화
    - botToken, webhookUrl은 시크릿 -> 로그/API 응답에서 마스킹 (마지막 4자만 표시)

  **섹션 8: notification_log 테이블 스키마**
  - 전달 추적 테이블:
    - id: UUID v7 PK
    - channelId: UUID FK -> notification_channels.id (SET NULL on delete)
    - event: TEXT NOT NULL -- NotificationEventType
    - level: TEXT NOT NULL -- 'INFO' | 'WARNING' | 'CRITICAL'
    - referenceId: TEXT -- 관련 엔티티 ID (txId, sessionId 등)
    - status: TEXT NOT NULL -- 'DELIVERED' | 'FAILED' | 'RATE_LIMITED' | 'ALL_FAILED'
    - error: TEXT -- 실패 시 에러 메시지
    - retryCount: INTEGER DEFAULT 0
    - sentAt: TEXT NOT NULL -- ISO 8601
  - 인덱스: idx_notification_log_event (event, sentAt DESC)
  - 보존 정책: 30일 이상 된 로그 자동 삭제 (만료 세션 정리 워커와 유사)
  - audit_log와의 관계: notification_log는 전달 상세, audit_log는 보안 이벤트. ALL_FAILED만 audit_log에 기록.

  **섹션 9: 채널 설정 검증 + 최소 2채널 정책**
  - waiaas init 시 알림 채널 설정 가이드 출력
  - 채널 추가 API (Phase 9에서 REST 상세화, 여기서는 구조만):
    - POST /v1/owner/notification-channels
    - PUT /v1/owner/notification-channels/:id
    - DELETE /v1/owner/notification-channels/:id
    - POST /v1/owner/notification-channels/:id/test (테스트 메시지 전송)
  - 최소 2채널 검증:
    - 채널 삭제 시 활성 채널 수 < 2이면 거부 (MIN_CHANNELS_REQUIRED 에러)
    - 데몬 시작 시 활성 채널 수 확인 -> 2개 미만이면 경고 로그 + 제한 모드 (INSTANT 티어만 허용)
  - 채널 healthCheck 주기:
    - 5분 주기 백그라운드 워커
    - 실패 시 enabled 유지하되 lastHealthStatus=0 기록
    - 3회 연속 실패 -> Owner에게 다른 채널로 경고 알림

  **섹션 10: 채널별 Rate Limit 준수**
  - 내장 rate limiter (채널별):
    - TELEGRAM: 토큰 버킷 30 req/s (Telegram Bot API 제한)
    - DISCORD: 토큰 버킷 5 req/5s (Discord Webhook 제한)
    - NTFY: 제한 없음 (self-hosted) 또는 서버 설정 따름
  - Rate limit 초과 시:
    - 429 응답의 retryAfter 대기 후 1회 재시도
    - 재시도 실패 -> notification_log (status=RATE_LIMITED) + 폴백 채널
  - Kill Switch/AUTO_STOP critical 알림:
    - rate limit 무시하지 않음 (API 차단 방지)
    - 대신 모든 채널에 전송하여 하나라도 도달 보장

  **섹션 11: 메시지 포맷 템플릿**
  - 채널별 메시지 포맷 (Telegram MarkdownV2, Discord Embed, ntfy.sh plain text):
    - APPROVAL_REQUEST: "[URGENT] Agent {name} requests {amount} SOL transfer to {address}. Approve/Reject within {timeout}."
    - DELAY_QUEUED: "[NOTICE] Agent {name} queued {amount} SOL transfer. Auto-executes in {delay}s. Cancel: {url}"
    - KILL_SWITCH: "[CRITICAL] Kill Switch activated. Reason: {reason}. All sessions revoked, pending txs cancelled."
  - 포맷터 패턴: IMessageFormatter 인터페이스 (formatForTelegram, formatForDiscord, formatForNtfy)
  - 메시지 길이 제한: Telegram 4096 chars, Discord 2000 chars, ntfy.sh 4096 chars

  **섹션 12: 보안 고려사항**
  - 알림 내용에 개인키/시크릿 절대 포함 금지
  - 주소는 축약 표시 (첫 4자...마지막 4자)
  - 알림이 거래 파이프라인을 블로킹하지 않도록 비동기 전송 (NOTIFY 티어)
  - APPROVAL_REQUEST 알림에 승인 직접 링크 포함 시 CSRF 방지 (nonce 바인딩)

  </action>
  <verify>
  - notification_channels 테이블 스키마가 type/config/priority와 함께 정의됨
  - notification_log 테이블 스키마가 status/error/retryCount와 함께 정의됨
  - 최소 2채널 검증 로직이 삭제 거부 + 제한 모드로 정의됨
  - 채널별 rate limit가 토큰 버킷 파라미터로 정의됨
  - 3개 이벤트 타입의 메시지 포맷 템플릿이 포함됨
  </verify>
  <done>알림 DB 스키마, 채널 설정 검증, 전달 추적, rate limit, 메시지 포맷이 구현 가능한 수준으로 설계됨. NOTI-01, NOTI-02 요구사항 모두 충족.</done>
</task>

</tasks>

<verification>
1. 35-notification-architecture.md가 .planning/deliverables/에 존재
2. NOTI-01 (멀티 채널): Telegram/Discord/ntfy.sh 3채널 어댑터 + INotificationChannel 인터페이스 정의됨
3. NOTI-02 (최소 2채널 + 폴백): 삭제 거부 정책 + 폴백 체인 + healthCheck 모니터링 설계됨
4. 13개 알림 이벤트 타입이 열거형으로 정의됨
5. notification_channels + notification_log 테이블 스키마가 정의됨
6. 채널별 rate limit 준수 전략이 토큰 버킷으로 설계됨
7. 메시지 포맷 템플릿이 채널별로 설계됨
</verification>

<success_criteria>
- 알림 아키텍처 문서가 12개 섹션으로 구성되어 Phase 8 Success Criteria #3을 충족
- INotificationChannel 추상화 + 3개 어댑터가 코드 수준으로 설계됨
- NotificationService의 표준/broadcast 플로우가 완전히 문서화됨
- 전달 추적(notification_log)과 채널 관리(notification_channels) 스키마가 확정됨
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-layers-design/08-03-SUMMARY.md`
</output>
