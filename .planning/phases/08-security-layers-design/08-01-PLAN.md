---
phase: 08-security-layers-design
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/33-time-lock-approval-mechanism.md
autonomous: true

must_haves:
  truths:
    - "DatabasePolicyEngine이 IPolicyEngine 인터페이스를 구현하며, policies 테이블에서 규칙을 로드하여 우선순위 순으로 평가하는 전체 로직이 코드 수준으로 설계됨"
    - "4-티어(INSTANT/NOTIFY/DELAY/APPROVAL) 보안 분류가 상태 머신 다이어그램으로 정의되고, 각 티어의 진입 조건/금액 기준/동작이 명시됨"
    - "DELAY 티어의 쿨다운 대기 -> 자동 실행 플로우가 시퀀스 다이어그램으로 문서화됨 (큐잉, 타이머, 취소 가능 기간, 실행 시점 tx 빌드)"
    - "APPROVAL 티어의 Owner 승인 대기 -> 승인/거절/만료 플로우가 시퀀스 다이어그램으로 문서화됨"
    - "TOCTOU 방지가 BEGIN IMMEDIATE + reserved amount 패턴으로 정의됨 (예약량 기록 -> 실행 -> 확정/롤백)"
    - "policies 테이블 스키마와 PolicyRule JSON 구조가 Zod 스키마 수준으로 정의됨"
    - "spending_limits 규칙 타입의 4-티어 금액 기준 설정 구조가 정의됨 (instant_max, notify_max, delay_max, approval 이상)"
  artifacts:
    - path: ".planning/deliverables/33-time-lock-approval-mechanism.md"
      provides: "시간 지연 + 승인 메커니즘 전체 설계 -- DatabasePolicyEngine, 4-티어 상태 머신, DELAY/APPROVAL 플로우, TOCTOU 방지"
      contains: "DatabasePolicyEngine"
  key_links:
    - from: "33-time-lock-approval-mechanism.md"
      to: "32-transaction-pipeline-api.md"
      via: "파이프라인 Stage 3 (Policy Check) + Stage 4 (Tier Classify)의 Phase 8 확장점을 구현"
      pattern: "IPolicyEngine.*evaluate"
    - from: "33-time-lock-approval-mechanism.md"
      to: "25-sqlite-schema.md"
      via: "policies 테이블 스키마 확정 + transactions 상태 전이 DELAY/APPROVAL 경로 상세화"
      pattern: "policies.*rules"
    - from: "33-time-lock-approval-mechanism.md"
      to: "30-session-token-protocol.md"
      via: "usageStats reserved amount 패턴이 세션 제약 검증과 연계"
      pattern: "reservedAmount"
---

<objective>
시간 지연 + 승인 메커니즘을 완전히 설계한다 -- Phase 7에서 정의한 IPolicyEngine 인터페이스를 구현하는 DatabasePolicyEngine, 4-티어(INSTANT/NOTIFY/DELAY/APPROVAL) 보안 분류 상태 머신, DELAY 티어의 쿨다운 큐잉 플로우, APPROVAL 티어의 Owner 승인 대기 플로우, TOCTOU 방지를 위한 BEGIN IMMEDIATE + reserved amount 패턴, policies 테이블 스키마와 규칙 JSON 구조를 구현 가능한 수준으로 정의한다.

Purpose: 이 문서는 WAIaaS 3계층 보안의 2계층(시간 지연 + 승인)의 핵심이다. Phase 7 파이프라인의 Stage 3 (Policy Check)과 Stage 4 (Tier Classify)가 참조하는 DefaultPolicyEngine을 실제 DB-backed 정책 엔진으로 대체하는 설계를 제공한다.
Output: 설계 문서 1개 -- 33-time-lock-approval-mechanism.md (LOCK-01, LOCK-02, LOCK-03, LOCK-04 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-security-layers-design/08-RESEARCH.md

# Phase 7 참조 (직접 의존)
@.planning/deliverables/32-transaction-pipeline-api.md (TX-PIPE: 파이프라인 6단계, Stage 3/4 확장점, 8-state machine)
@.planning/deliverables/30-session-token-protocol.md (SESS-PROTO: 세션 제약 모델, usageStats 원자적 갱신)

# Phase 6 참조
@.planning/deliverables/25-sqlite-schema.md (CORE-02: policies 테이블, transactions 테이블)
@.planning/deliverables/27-chain-adapter-interface.md (CORE-04: IPolicyEngine 인터페이스)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DatabasePolicyEngine + 4-티어 상태 머신 + policies 스키마 설계</name>
  <files>.planning/deliverables/33-time-lock-approval-mechanism.md</files>
  <action>
  설계 문서 `33-time-lock-approval-mechanism.md`를 작성한다. 문서 ID는 `LOCK-MECH`.

  **섹션 1: 문서 개요 + 요구사항 매핑**
  - 문서 ID, 작성일, 상태, 참조 문서 (TX-PIPE, SESS-PROTO, CORE-02, CORE-04)
  - 요구사항 매핑: LOCK-01 (4단계 분류), LOCK-02 (Delay 큐잉), LOCK-03 (Approval 승인), LOCK-04 (미승인 만료)
  - v0.1 -> v0.2 변경 요약 (Squads 온체인 정책 -> 로컬 DB 정책 엔진)
  - Phase 7 DefaultPolicyEngine (passthrough) -> Phase 8 DatabasePolicyEngine (DB-backed) 전환 맥락

  **섹션 2: policies 테이블 스키마 확정**
  - CORE-02에서 정의된 policies 테이블의 상세 구조 확정:
    - id: UUID v7 PK
    - agentId: UUID FK (nullable -- NULL이면 글로벌 정책)
    - type: TEXT (SPENDING_LIMIT, WHITELIST, TIME_RESTRICTION, RATE_LIMIT)
    - rules: TEXT (JSON -- 정책 규칙 상세)
    - priority: INTEGER (높을수록 먼저 평가, 기본 0)
    - enabled: INTEGER (0/1, 기본 1)
    - createdAt, updatedAt: TEXT (ISO 8601)
  - PolicyRuleSchema (Zod): 각 type별 rules JSON 구조 정의
    - SPENDING_LIMIT: { instant_max: string, notify_max: string, delay_max: string, delay_seconds: number, approval_timeout: number }
    - WHITELIST: { allowed_addresses: string[] }
    - TIME_RESTRICTION: { allowed_hours: { start: number, end: number }, timezone: string, allowed_days: number[] }
    - RATE_LIMIT: { max_tx_per_hour: number, max_tx_per_day: number }
  - 기본 정책 세트 (waiaas init 시 생성):
    - 글로벌 SPENDING_LIMIT: instant_max=1_000_000_000 (1 SOL), notify_max=10_000_000_000 (10 SOL), delay_max=50_000_000_000 (50 SOL), delay_seconds=300, approval_timeout=3600
  - 인덱스: idx_policies_agent_enabled (agentId, enabled)

  **섹션 3: DatabasePolicyEngine 설계**
  - IPolicyEngine 인터페이스 (Phase 7 TX-PIPE에서 정의):
    ```
    interface IPolicyEngine {
      evaluate(agentId: string, request: TxRequest): Promise<PolicyDecision>
    }
    ```
  - PolicyDecision 타입 확장:
    - allowed: boolean
    - tier: 'INSTANT' | 'NOTIFY' | 'DELAY' | 'APPROVAL'
    - reason?: string (거부 시)
    - delaySeconds?: number (DELAY 티어)
    - approvalTimeoutSeconds?: number (APPROVAL 티어)
  - DatabasePolicyEngine.evaluate() 알고리즘:
    1. 에이전트별 + 글로벌(agentId=NULL) 활성 정책 로드 (priority DESC)
    2. DENY 우선 평가 (WHITELIST 미포함 주소 -> 즉시 DENY)
    3. TIME_RESTRICTION 평가 (허용 시간대 외 -> DENY)
    4. RATE_LIMIT 평가 (시간당/일일 초과 -> DENY)
    5. SPENDING_LIMIT 평가 -> 4-티어 분류 결정
    6. 첫 DENY 즉시 반환, 모든 통과 시 티어 결정 반환
  - 에이전트별 정책이 글로벌 정책보다 우선 (같은 type이면 에이전트별이 override)

  **섹션 4: 4-티어 보안 분류 상태 머신**
  - Mermaid stateDiagram으로 4-티어 상태 전이 정의:
    - 파이프라인 Stage 3 출력 -> Stage 4 입력으로의 연결
    - INSTANT: amount <= instant_max -> Stage 5 즉시 실행
    - NOTIFY: instant_max < amount <= notify_max -> Stage 5 실행 + 알림(08-03)
    - DELAY: notify_max < amount <= delay_max -> QUEUED + 쿨다운 타이머
    - APPROVAL: amount > delay_max -> QUEUED + Owner 승인 대기
  - 각 티어의 트랜잭션 상태 전이 경로 (TX-PIPE 8-state machine과 통합):
    - INSTANT: PENDING -> QUEUED -> EXECUTING -> SUBMITTED -> CONFIRMED
    - NOTIFY: PENDING -> QUEUED -> EXECUTING -> SUBMITTED -> CONFIRMED (+ 비동기 알림)
    - DELAY: PENDING -> QUEUED (delaySeconds 대기) -> EXECUTING -> SUBMITTED -> CONFIRMED
    - APPROVAL: PENDING -> QUEUED (Owner 승인 대기) -> EXECUTING -> SUBMITTED -> CONFIRMED
  - 티어 분류 시점의 DB UPDATE:
    - transactions UPDATE (tier=결과, status=QUEUED, queuedAt=now)
    - DELAY: expiresAt = now + delaySeconds
    - APPROVAL: expiresAt = now + approvalTimeoutSeconds

  **섹션 5: TOCTOU 방지 -- Reserved Amount 패턴**
  - 문제: 정책 평가(Stage 3) -> usageStats 확정(Stage 6 CONFIRMED) 사이 gap에서 동시 요청이 한도 초과 가능
  - 해결: BEGIN IMMEDIATE 트랜잭션 내에서 "예약량(reserved)" 즉시 기록
  - 패턴:
    1. Stage 3 시작: BEGIN IMMEDIATE
    2. 현재 usageStats + 활성 reserved 합계 읽기
    3. 합산 금액으로 정책 평가
    4. 통과 시: transactions INSERT (reserved_amount = request.amount)
    5. COMMIT
    6. Stage 6 CONFIRMED: reserved_amount -> 실제 usageStats 전환
    7. FAILED/CANCELLED: reserved_amount 롤백 (reserved_amount = NULL)
  - transactions 테이블에 reserved_amount TEXT 컬럼 추가 설계
  - 동시 요청 시나리오 시퀀스 다이어그램 (2개 세션의 동시 거래)

  </action>
  <verify>
  - 33-time-lock-approval-mechanism.md 파일이 존재하고 문서 ID가 LOCK-MECH
  - policies 테이블 스키마가 type/rules/priority와 함께 정의됨
  - PolicyRuleSchema가 4개 정책 타입별 Zod 스키마로 정의됨
  - DatabasePolicyEngine.evaluate() 알고리즘이 6단계로 기술됨
  - 4-티어 상태 머신이 Mermaid stateDiagram으로 포함됨
  - TOCTOU 방지 패턴이 reserved_amount + BEGIN IMMEDIATE로 정의됨
  </verify>
  <done>DatabasePolicyEngine, 4-티어 상태 머신, policies 스키마, TOCTOU 방지 패턴이 구현 가능한 수준으로 설계됨</done>
</task>

<task type="auto">
  <name>Task 2: DELAY 쿨다운 큐잉 + APPROVAL 승인 플로우 상세 설계</name>
  <files>.planning/deliverables/33-time-lock-approval-mechanism.md</files>
  <action>
  33-time-lock-approval-mechanism.md에 다음 섹션을 추가한다.

  **섹션 6: DELAY 티어 -- 쿨다운 큐잉 플로우**
  - DELAY 플로우 시퀀스 다이어그램 (Mermaid sequenceDiagram):
    1. 파이프라인 Stage 4에서 DELAY 분류 -> transactions (status=QUEUED, tier=DELAY, queuedAt=now, expiresAt=now+delaySeconds)
    2. 즉시 202 Accepted 응답 반환 (transactionId, status=QUEUED, tier=DELAY, expiresAt)
    3. Owner에게 알림 전송 (08-03 NotificationService): "에이전트 X가 N SOL 전송 요청. {delaySeconds}초 후 자동 실행. 취소하려면 [링크]"
    4. 쿨다운 대기 워커 (DelayQueueWorker):
       - setInterval 10초 주기로 만료된 DELAY 거래 폴링
       - SELECT * FROM transactions WHERE tier='DELAY' AND status='QUEUED' AND expiresAt <= now()
       - 각 거래에 대해 Stage 5a (buildTransaction)부터 재실행
       - 핵심: tx를 큐잉 시점이 아닌 실행 시점에 빌드 (blockhash 만료 방지 -- 07-02 결정)
    5. Owner 취소: DELETE /v1/owner/reject/:txId -> transactions (status=CANCELLED, error='OWNER_REJECTED')
    6. 쿨다운 미만료 + 미취소 -> 자동 실행
  - DelayQueueWorker 설계:
    - 폴링 주기: 10초 (delaySeconds 최소 60초이므로 충분한 정밀도)
    - 동시 실행 방지: BEGIN IMMEDIATE 내에서 status=QUEUED -> EXECUTING 원자적 전이
    - 실행 실패 시: status=FAILED (재시도 없음 -- 새 요청 필요)
    - 워커 종료: 데몬 shutdown 시 clearInterval + 진행 중 거래 완료 대기

  **섹션 7: APPROVAL 티어 -- Owner 승인 대기 플로우**
  - APPROVAL 플로우 시퀀스 다이어그램 (Mermaid sequenceDiagram):
    1. 파이프라인 Stage 4에서 APPROVAL 분류 -> transactions (status=QUEUED, tier=APPROVAL, queuedAt=now, expiresAt=now+approvalTimeoutSeconds)
    2. 즉시 202 Accepted 응답 반환 (transactionId, status=QUEUED, tier=APPROVAL)
    3. Owner에게 긴급 알림 (모든 채널): "에이전트 X가 N SOL 전송 요청. 승인이 필요합니다. {approvalTimeoutSeconds}초 내 미승인 시 자동 만료."
    4. Owner 승인: POST /v1/owner/approve/:txId (SIWS/SIWE 서명 + ownerAuth)
       - transactions (status=QUEUED -> EXECUTING) 원자적 전이
       - Stage 5a (buildTransaction)부터 실행
       - 승인 시점에 tx 빌드 (DELAY와 동일 -- blockhash 신선도)
    5. Owner 거절: POST /v1/owner/reject/:txId (ownerAuth)
       - transactions (status=CANCELLED, error='OWNER_REJECTED')
    6. 타임아웃 만료: ApprovalTimeoutWorker
       - 폴링 주기: 30초
       - SELECT * FROM transactions WHERE tier='APPROVAL' AND status='QUEUED' AND expiresAt <= now()
       - transactions (status=EXPIRED, error='APPROVAL_TIMEOUT')
       - Owner에게 만료 알림
  - Owner 승인 API 엔드포인트 스펙:
    - POST /v1/owner/approve/:txId:
      - 인증: ownerAuth (SIWS/SIWE)
      - 응답: { transactionId, status: 'EXECUTING', approvedAt }
      - 에러: TX_NOT_FOUND (404), TX_NOT_PENDING_APPROVAL (409), TX_EXPIRED (410)
    - POST /v1/owner/reject/:txId:
      - 인증: ownerAuth (SIWS/SIWE)
      - 응답: { transactionId, status: 'CANCELLED', rejectedAt }
      - 에러: TX_NOT_FOUND (404), TX_NOT_PENDING (409)

  **섹션 8: 기본 정책 설정 가이드**
  - waiaas init 기본 정책 세트 (보수적):
    - SOL: INSTANT <= 1 SOL, NOTIFY <= 10 SOL, DELAY <= 50 SOL (5분), APPROVAL > 50 SOL (1시간)
    - EVM (v0.3): INSTANT <= 0.1 ETH, NOTIFY <= 1 ETH, DELAY <= 5 ETH, APPROVAL > 5 ETH
  - 에이전트별 커스텀 정책 설정 API (Phase 9에서 REST API 상세화, 여기서는 구조만)
  - 정책 변경 시 감사 로그 기록 (POLICY_CREATED, POLICY_UPDATED, POLICY_DELETED)

  **섹션 9: Phase 7 파이프라인과의 통합 포인트**
  - Stage 3 (Policy Check): DefaultPolicyEngine -> DatabasePolicyEngine 교체 지점
  - Stage 4 (Tier Classify): PolicyDecision.tier에 따른 분기 로직 상세화
  - Stage 5 (Execute): DELAY/APPROVAL 티어는 승인 후 Stage 5a부터 재실행 경로
  - 지연 실행 워커 (DelayQueueWorker, ApprovalTimeoutWorker)의 데몬 라이프사이클 통합 (CORE-05)

  **섹션 10: 보안 고려사항**
  - DELAY 티어 최소 쿨다운: 60초 (너무 짧으면 Owner가 알림 확인 전 실행)
  - APPROVAL 티어 최소 타임아웃: 300초 (5분), 최대: 86400초 (24시간), 기본: 3600초 (1시간)
  - 정책 변경 즉시 적용 (캐시 없음 -- DB 직접 조회)
  - reserved amount 정리: 15분 이상 PENDING 상태인 예약량 자동 롤백 (좀비 방지)

  </action>
  <verify>
  - DELAY 쿨다운 플로우가 시퀀스 다이어그램으로 문서화됨
  - APPROVAL 승인 플로우가 시퀀스 다이어그램으로 문서화됨
  - DelayQueueWorker와 ApprovalTimeoutWorker 설계가 포함됨
  - Owner approve/reject API 엔드포인트 스펙이 정의됨
  - 기본 정책 세트가 SOL 금액 기준으로 정의됨
  - Phase 7 파이프라인 통합 포인트 4개가 명시됨
  </verify>
  <done>DELAY 쿨다운 큐잉, APPROVAL 승인 플로우, 기본 정책 세트, 파이프라인 통합이 구현 가능한 수준으로 설계됨. LOCK-01~04 요구사항 모두 충족.</done>
</task>

</tasks>

<verification>
1. 33-time-lock-approval-mechanism.md가 .planning/deliverables/에 존재
2. LOCK-01 (4단계 분류): 4-티어 상태 머신 + 금액 기준 설정이 정의됨
3. LOCK-02 (Delay 큐잉): 쿨다운 대기 -> 미취소 시 자동 실행 플로우가 정의됨
4. LOCK-03 (Approval 승인): Owner 서명 승인 플로우 + API 엔드포인트가 정의됨
5. LOCK-04 (미승인 만료): 타임아웃 후 자동 EXPIRED 전이가 정의됨
6. DatabasePolicyEngine이 IPolicyEngine 인터페이스를 구현하는 설계가 코드 수준으로 포함됨
7. TOCTOU 방지가 reserved amount + BEGIN IMMEDIATE 패턴으로 정의됨
</verification>

<success_criteria>
- 시간 지연 + 승인 메커니즘 문서가 10개 섹션으로 구성되어 Phase 8 Success Criteria #1을 충족
- DatabasePolicyEngine, 4-티어 상태 머신, DELAY/APPROVAL 플로우가 다이어그램 + 코드 수준으로 설계됨
- Phase 7 파이프라인 Stage 3/4 확장점이 실제 구현으로 대체되는 경로가 명시됨
- TOCTOU 방지 패턴이 동시성 시나리오와 함께 설계됨
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-layers-design/08-01-SUMMARY.md`
</output>
