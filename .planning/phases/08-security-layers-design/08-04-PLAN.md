---
phase: 08-security-layers-design
plan: 04
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - .planning/deliverables/36-killswitch-autostop-evm.md
autonomous: true

must_haves:
  truths:
    - "Kill Switch 캐스케이드 프로토콜이 6단계 순서로 정의됨 (세션 폐기 -> 거래 취소 -> 에이전트 정지 -> 키스토어 잠금 -> 알림 -> 감사)"
    - "Kill Switch 복구 절차가 이중 인증(Owner 서명 + 마스터 패스워드)으로 정의됨"
    - "자동 정지 규칙 엔진(AutoStopEngine)이 규칙 타입별 평가 로직과 기본 규칙 세트로 설계됨"
    - "자동 정지 규칙 5개 타입이 정의됨 (연속 실패, 시간대, 일일 한도, 시간당 빈도, 이상 패턴)"
    - "EVM Adapter stub이 IChainAdapter 13개 메서드를 'not yet implemented' 에러로 구현하는 설계됨"
    - "Kill Switch 상태 머신(NORMAL -> ACTIVATED -> RECOVERING -> NORMAL)이 다이어그램으로 정의됨"
  artifacts:
    - path: ".planning/deliverables/36-killswitch-autostop-evm.md"
      provides: "Kill Switch 프로토콜, 자동 정지 규칙 엔진, EVM Adapter stub 전체 설계"
      contains: "AutoStopEngine"
  key_links:
    - from: "36-killswitch-autostop-evm.md"
      to: "35-notification-architecture.md"
      via: "Kill Switch 발동 시 NotificationService.broadcast() 호출 (모든 채널 동시 알림)"
      pattern: "broadcast.*KILL_SWITCH"
    - from: "36-killswitch-autostop-evm.md"
      to: "33-time-lock-approval-mechanism.md"
      via: "Kill Switch가 모든 QUEUED 거래를 CANCELLED로 전이 (DELAY/APPROVAL 포함)"
      pattern: "CANCELLED.*KILL_SWITCH"
    - from: "36-killswitch-autostop-evm.md"
      to: "34-owner-wallet-connection.md"
      via: "Kill Switch 발동: POST /v1/owner/kill-switch (ownerAuth) + 복구: POST /v1/owner/recover"
      pattern: "kill-switch.*ownerAuth"
    - from: "36-killswitch-autostop-evm.md"
      to: "27-chain-adapter-interface.md"
      via: "EVM Adapter stub이 IChainAdapter 인터페이스를 구현"
      pattern: "EvmAdapterStub.*IChainAdapter"
---

<objective>
Kill Switch 캐스케이드 프로토콜, 자동 정지 규칙 엔진, Kill Switch 복구 절차, EVM Adapter stub을 완전히 설계한다 -- Kill Switch 6단계 캐스케이드, 복구 이중 인증, AutoStopEngine 규칙 평가 로직, 기본 규칙 세트, EVM Adapter의 IChainAdapter 13개 메서드 stub을 구현 가능한 수준으로 정의한다.

Purpose: Kill Switch는 WAIaaS 3계층 보안의 최후 방어선이다. 자동 정지 규칙 엔진은 Owner가 부재중일 때도 이상 패턴을 감지하여 시스템을 보호한다. EVM Adapter stub은 CHAIN-03 요구사항을 충족하며 v0.3 EVM 본구현의 기반을 제공한다.
Output: 설계 문서 1개 -- 36-killswitch-autostop-evm.md (NOTI-03, NOTI-04, NOTI-05, CHAIN-03 충족)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-security-layers-design/08-RESEARCH.md

# 08-01~03 SUMMARY 참조 (직접 의존)
@.planning/phases/08-security-layers-design/08-01-SUMMARY.md
@.planning/phases/08-security-layers-design/08-02-SUMMARY.md
@.planning/phases/08-security-layers-design/08-03-SUMMARY.md

# Phase 6 참조
@.planning/deliverables/27-chain-adapter-interface.md (CORE-04: IChainAdapter 13 메서드, AdapterRegistry)
@.planning/deliverables/28-daemon-lifecycle-cli.md (CORE-05: 10-step shutdown cascade)
@.planning/deliverables/26-keystore-spec.md (CORE-03: 키스토어 잠금/해제)
@.planning/deliverables/25-sqlite-schema.md (CORE-02: agents 테이블 status, sessions, transactions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kill Switch 캐스케이드 프로토콜 + 상태 머신 + 복구 절차 설계</name>
  <files>.planning/deliverables/36-killswitch-autostop-evm.md</files>
  <action>
  설계 문서 `36-killswitch-autostop-evm.md`를 작성한다. 문서 ID는 `KILL-AUTO-EVM`.

  **섹션 1: 문서 개요 + 요구사항 매핑**
  - 문서 ID, 작성일, 상태, 참조 문서 (LOCK-MECH, OWNR-CONN, NOTI-ARCH, CORE-04, CORE-05, CORE-03)
  - 요구사항 매핑: NOTI-03 (Kill Switch), NOTI-04 (자동 정지 규칙), NOTI-05 (복구 절차), CHAIN-03 (EVM Adapter stub)
  - Kill Switch의 위치: 3계층 보안의 Layer 3 (모니터링 + Kill Switch)

  **섹션 2: Kill Switch 상태 머신**
  - 3개 상태: NORMAL, ACTIVATED, RECOVERING
  - Mermaid stateDiagram:
    - NORMAL -> ACTIVATED: Owner 수동 발동 (POST /v1/owner/kill-switch) 또는 AutoStopEngine 트리거
    - ACTIVATED -> RECOVERING: Owner 복구 시작 (POST /v1/owner/recover)
    - RECOVERING -> NORMAL: 복구 완료 (키스토어 잠금 해제 + 에이전트 재활성화)
    - RECOVERING -> ACTIVATED: 복구 실패 (인증 오류)
  - 시스템 상태 저장: system_state 테이블 또는 config.toml [system] 섹션
    - kill_switch_status: 'NORMAL' | 'ACTIVATED' | 'RECOVERING'
    - kill_switch_activated_at: ISO 8601
    - kill_switch_reason: string
  - ACTIVATED 상태에서의 API 동작:
    - 모든 세션 인증 요청 거부 (401 SYSTEM_LOCKED)
    - Owner 인증은 복구 관련 엔드포인트만 허용
    - /health 엔드포인트에 kill_switch: true 표시

  **섹션 3: Kill Switch 캐스케이드 프로토콜 (6단계)**
  - 시퀀스 다이어그램 (Mermaid sequenceDiagram):
    참여자: Trigger(Owner/AutoStop), KillSwitchService, SessionService, TransactionService, AgentService, KeyStore, NotificationService, AuditLog

  Step 1 -- 모든 활성 세션 즉시 폐기:
    - sessions UPDATE SET revokedAt=now WHERE revokedAt IS NULL
    - 영향: 모든 에이전트의 API 접근 즉시 차단
    - audit_log: KILL_SWITCH_SESSIONS_REVOKED (폐기 건수)

  Step 2 -- 모든 대기 거래 취소:
    - BEGIN IMMEDIATE 트랜잭션 내에서:
    - transactions UPDATE SET status='CANCELLED', error='KILL_SWITCH' WHERE status IN ('PENDING', 'QUEUED')
    - reserved_amount 일괄 롤백 (NULL 처리)
    - audit_log: KILL_SWITCH_TX_CANCELLED (취소 건수)

  Step 3 -- 모든 에이전트 정지:
    - agents UPDATE SET status='SUSPENDED', suspendedAt=now, suspensionReason=reason WHERE status NOT IN ('TERMINATED', 'SUSPENDED')
    - audit_log: KILL_SWITCH_AGENTS_SUSPENDED (정지 건수)

  Step 4 -- 키스토어 잠금:
    - keyStore.lock(): sodium_memzero로 메모리 내 모든 복호화된 키 제거
    - 이후 signTransaction 호출 시 KEYSTORE_LOCKED 에러
    - 데몬 프로세스는 종료하지 않음 (복구를 위해 API 서버 유지)

  Step 5 -- 모든 채널 긴급 알림:
    - NotificationService.broadcast({ level: 'CRITICAL', event: 'KILL_SWITCH_ACTIVATED', ... })
    - 모든 활성 채널에 병렬 전송 (08-03 broadcast 플로우)
    - 알림 내용: 발동 사유, 영향 범위 (세션/거래/에이전트 건수)

  Step 6 -- 감사 기록:
    - audit_log INSERT: eventType='KILL_SWITCH_ACTIVATED', actor='owner' 또는 'auto_stop', severity='critical'
    - 전체 캐스케이드 실행 시간 기록

  - 캐스케이드 원자성: Step 1-3은 단일 SQLite 트랜잭션 (원자적), Step 4-6은 순차 실행
  - 부분 실패 처리: Step N 실패 시 Step N+1 계속 진행 (best-effort), 실패 항목만 audit_log에 기록

  **섹션 4: Kill Switch 복구 절차 (NOTI-05)**
  - 이중 인증 요구:
    1. Owner 지갑 서명 (SIWS/SIWE) -- ownerAuth
    2. 마스터 패스워드 -- 키스토어 잠금 해제 (Argon2id 검증)
  - 복구 시퀀스 다이어그램 (Mermaid sequenceDiagram):
    1. Owner -> POST /v1/owner/recover { masterPassword, signature, message }
    2. ownerAuth 검증 (Owner 서명)
    3. 마스터 패스워드로 키스토어 잠금 해제 시도 (Argon2id 검증 -> AES-256-GCM 복호화)
    4. 성공 시: system_state -> RECOVERING
    5. 에이전트 상태 복원: SUSPENDED -> ACTIVE (suspensionReason='KILL_SWITCH'인 것만)
    6. system_state -> NORMAL
    7. 기존 세션은 복원하지 않음 (새 세션 생성 필요)
    8. NotificationService.broadcast({ event: 'KILL_SWITCH_RECOVERED' })
    9. audit_log: KILL_SWITCH_RECOVERED (severity='critical')
  - 복구 후 상태:
    - 세션: 모두 폐기 유지 -> 에이전트가 새 세션 요청 필요
    - 거래: CANCELLED 유지 (복원 불가)
    - 에이전트: ACTIVE 복원 (KILL_SWITCH로 정지된 것만)
    - 키스토어: 잠금 해제 (복구 과정에서 마스터 패스워드로 해제됨)
  - POST /v1/owner/recover 엔드포인트 스펙:
    - 인증: ownerAuth (action='kill_switch')
    - 요청: { masterPassword: z.string().min(8) }
    - 응답: { recovered: true, timestamp, agentsReactivated }
    - 에러: KILL_SWITCH_NOT_ACTIVE (409), INVALID_MASTER_PASSWORD (401), INVALID_SIGNATURE (401)
  - CLI 복구 대안: waiaas recover --master-password <pw> --signature <sig>
    - WalletConnect 불필요 (서명을 CLI 인자로 직접 전달)

  **섹션 5: Kill Switch 트리거 소스**
  - Owner 수동: POST /v1/owner/kill-switch (ownerAuth)
  - CLI 수동: waiaas kill-switch --reason "emergency" (마스터 패스워드 인증)
  - AutoStopEngine 자동: 규칙 엔진이 트리거 조건 감지 시
  - 데몬 자체 감지: 키스토어 무결성 검증 실패 시 자동 발동 (선택적)

  </action>
  <verify>
  - 36-killswitch-autostop-evm.md 파일이 존재하고 문서 ID가 KILL-AUTO-EVM
  - Kill Switch 상태 머신이 3개 상태로 Mermaid stateDiagram으로 정의됨
  - 캐스케이드 6단계가 시퀀스 다이어그램으로 문서화됨
  - 복구 절차가 이중 인증 + 시퀀스 다이어그램으로 정의됨
  - POST /v1/owner/recover 엔드포인트 스펙이 정의됨
  </verify>
  <done>Kill Switch 캐스케이드 프로토콜, 상태 머신, 복구 절차가 구현 가능한 수준으로 설계됨</done>
</task>

<task type="auto">
  <name>Task 2: 자동 정지 규칙 엔진 + EVM Adapter stub 설계</name>
  <files>.planning/deliverables/36-killswitch-autostop-evm.md</files>
  <action>
  36-killswitch-autostop-evm.md에 다음 섹션을 추가한다.

  **섹션 6: 자동 정지 규칙 엔진 (AutoStopEngine)**
  - 목적: Owner가 부재 시에도 이상 패턴을 감지하여 자동으로 Kill Switch 또는 에이전트 정지 발동
  - AutoStopEngine 인터페이스:
    ```
    interface IAutoStopEngine {
      evaluate(event: SecurityEvent): Promise<AutoStopDecision>
      loadRules(): Promise<void>
    }
    ```
  - SecurityEvent 타입:
    - type: 'TX_COMPLETED' | 'TX_FAILED' | 'SESSION_CREATED' | 'POLICY_VIOLATION'
    - agentId: string
    - timestamp: string (ISO 8601)
    - details: Record<string, unknown>
  - AutoStopDecision 타입:
    - action: 'NONE' | 'WARN' | 'SUSPEND_AGENT' | 'KILL_SWITCH'
    - ruleId: string (트리거된 규칙)
    - reason: string

  **섹션 7: 자동 정지 규칙 5개 타입**

  Rule 1 -- CONSECUTIVE_FAILURES (연속 거래 실패):
  - 조건: 동일 에이전트의 연속 N회 거래 실패 (status=FAILED)
  - 기본 threshold: 3회
  - 동작: SUSPEND_AGENT (에이전트만 정지, 시스템 전체 아님)
  - 카운터 리셋: 성공 거래 시 0으로 리셋
  - DB 쿼리: SELECT COUNT(*) FROM transactions WHERE agentId=? AND status='FAILED' AND id > (가장 최근 CONFIRMED id)

  Rule 2 -- TIME_RESTRICTION (비정상 시간대 거래):
  - 조건: auto_stop_rules 테이블에 정의된 허용 시간대 외 거래 시도
  - 기본: OFF (기본 비활성, 사용자가 시간대 설정 시 활성)
  - 동작: WARN (Owner 알림) 또는 SUSPEND_AGENT (설정에 따라)
  - 시간대: policies 테이블의 TIME_RESTRICTION 규칙 재사용

  Rule 3 -- DAILY_LIMIT_THRESHOLD (일일 한도 임계):
  - 조건: 에이전트의 일일 누적 거래 금액이 설정된 한도의 N%에 도달
  - 기본: 80% -> WARN (Owner 알림), 100% -> SUSPEND_AGENT
  - 일일 한도: policies 테이블의 SPENDING_LIMIT에서 daily_max 필드 (추가)
  - DB 쿼리: SUM(amount) FROM transactions WHERE agentId=? AND status='CONFIRMED' AND createdAt >= today_start

  Rule 4 -- HOURLY_RATE (시간당 거래 빈도 이상):
  - 조건: 동일 에이전트의 시간당 거래 횟수가 threshold 초과
  - 기본: 50 tx/hour
  - 동작: SUSPEND_AGENT
  - DB 쿼리: COUNT(*) FROM transactions WHERE agentId=? AND createdAt >= now-1h

  Rule 5 -- ANOMALY_PATTERN (이상 패턴 감지):
  - 조건: 동일 주소로 반복 전송, 금액 증가 패턴, 새 주소 집중 전송
  - 기본: 동일 주소 10회/시간 -> WARN, 20회/시간 -> SUSPEND_AGENT
  - v0.2는 단순 패턴만 (ML 기반 이상 탐지는 v0.4 이연)

  **섹션 8: auto_stop_rules 테이블 스키마**
  - auto_stop_rules는 policies 테이블과 별도 (auto-stop 전용):
    - id: UUID v7 PK
    - agentId: UUID FK (nullable -- NULL이면 글로벌)
    - type: TEXT NOT NULL -- 'CONSECUTIVE_FAILURES' | 'TIME_RESTRICTION' | 'DAILY_LIMIT_THRESHOLD' | 'HOURLY_RATE' | 'ANOMALY_PATTERN'
    - config: TEXT NOT NULL -- JSON (type별 설정)
    - action: TEXT NOT NULL -- 'WARN' | 'SUSPEND_AGENT' | 'KILL_SWITCH'
    - enabled: INTEGER NOT NULL DEFAULT 1
    - createdAt, updatedAt: TEXT
  - 기본 규칙 세트 (waiaas init 시 생성):
    - CONSECUTIVE_FAILURES: threshold=3, action=SUSPEND_AGENT (글로벌)
    - DAILY_LIMIT_THRESHOLD: warn_percent=80, stop_percent=100, action=SUSPEND_AGENT (글로벌)
    - HOURLY_RATE: max_tx=50, action=SUSPEND_AGENT (글로벌)
  - 인덱스: idx_auto_stop_rules_agent (agentId, enabled)

  **섹션 9: AutoStopEngine 평가 흐름**
  - 호출 시점: 파이프라인 Stage 6 (CONFIRM) 완료 후, 거래 실패 감지 후
  - 평가 플로우:
    1. 활성 규칙 로드 (에이전트별 + 글로벌)
    2. 각 규칙 evaluate (SecurityEvent 기반)
    3. 가장 심각한 action 결정 (KILL_SWITCH > SUSPEND_AGENT > WARN > NONE)
    4. action 실행:
       - WARN: NotificationService.notify({ level: 'WARNING', event: 'AUTO_STOP_TRIGGERED' })
       - SUSPEND_AGENT: agents UPDATE (status='SUSPENDED', suspensionReason=reason) + 해당 에이전트 세션 폐기 + 알림
       - KILL_SWITCH: KillSwitchService.activate(reason='auto_stop: {ruleType}')
    5. audit_log: AUTO_STOP_EVALUATED (결과 기록)
  - 성능: 규칙 평가는 파이프라인 이후 비동기 실행 (거래 응답을 블로킹하지 않음)

  **섹션 10: EVM Adapter Stub (CHAIN-03)**
  - IChainAdapter 인터페이스 준수 (CORE-04 27-chain-adapter-interface.md):
  - EvmAdapterStub 클래스 설계:
    - chain = 'ethereum'
    - 13개 메서드 모두 `throw new Error('EVM adapter not yet implemented (v0.3)')`:
      1. connect(config): 연결 초기화
      2. disconnect(): 연결 해제
      3. isConnected(): boolean (항상 false)
      4. getBalance(address): 잔액 조회
      5. getTransaction(hash): 거래 조회
      6. buildTransaction(params): 거래 빌드
      7. simulateTransaction(tx): 시뮬레이션
      8. signTransaction(tx, privateKey): 서명
      9. submitTransaction(signedTx): 제출
      10. waitForConfirmation(hash, timeout): 확정 대기
      11. estimateFee(params): 수수료 추정
      12. validateAddress(address): 주소 검증
      13. getRecentBlockhash(): 최근 블록 정보
  - viem v2.45.x 기반 설계 노트:
    - createPublicClient + http transport (RPC URL)
    - createWalletClient (서명용)
    - privateKeyToAccount (viem/accounts)
    - chain definitions: mainnet, sepolia (viem/chains)
  - AdapterRegistry 등록: { chain: 'ethereum', factory: () => new EvmAdapterStub() }
  - v0.3 구현 시 교체 경로: EvmAdapterStub -> EvmAdapter (동일 인터페이스)

  **섹션 11: 데몬 라이프사이클 통합**
  - Kill Switch 관련 워커:
    - ApprovalTimeoutWorker: 30초 주기 (08-01에서 정의)
    - DelayQueueWorker: 10초 주기 (08-01에서 정의)
    - AutoStopEvaluator: 이벤트 기반 (파이프라인 완료 후 호출)
    - ChannelHealthChecker: 5분 주기 (08-03에서 정의)
  - 데몬 시작 시: system_state 확인 -> ACTIVATED이면 제한 모드 시작
  - 데몬 shutdown 시: ACTIVATED 상태 유지 (다음 시작 시 복구 필요)

  **섹션 12: 보안 고려사항**
  - AutoStopEngine 자체가 공격 벡터: 의도적 실패 유발로 Kill Switch 트리거 방지
    - CONSECUTIVE_FAILURES는 에이전트 단위 정지 (시스템 전체 Kill Switch 아님)
    - Kill Switch 자동 트리거는 DAILY_LIMIT 100% 초과 등 명백한 위반에만 적용
  - 복구 brute-force 방지: 마스터 패스워드 검증 실패 5회 -> 30분 lockout
  - Kill Switch 발동 로그는 변경/삭제 불가 (audit_log FK 없음, append-only)
  - EVM Adapter stub: 실수로 활성화되어도 모든 메서드가 에러 -> 자금 위험 없음

  </action>
  <verify>
  - AutoStopEngine 인터페이스가 evaluate/loadRules 메서드로 정의됨
  - 5개 규칙 타입이 조건/기본값/동작과 함께 정의됨
  - auto_stop_rules 테이블 스키마가 정의됨
  - 기본 규칙 세트 3개가 waiaas init 용으로 정의됨
  - EVM Adapter stub이 13개 메서드와 함께 설계됨
  - viem 기반 v0.3 구현 노트가 포함됨
  </verify>
  <done>자동 정지 규칙 엔진, EVM Adapter stub이 구현 가능한 수준으로 설계됨. NOTI-03~05, CHAIN-03 요구사항 모두 충족.</done>
</task>

</tasks>

<verification>
1. 36-killswitch-autostop-evm.md가 .planning/deliverables/에 존재
2. NOTI-03 (Kill Switch): 6단계 캐스케이드 + 모든 세션/거래/에이전트 정지가 정의됨
3. NOTI-04 (자동 정지 규칙): AutoStopEngine + 5개 규칙 타입 + 기본 규칙 세트가 정의됨
4. NOTI-05 (복구 절차): 이중 인증 복구 + 시퀀스 다이어그램이 정의됨
5. CHAIN-03 (EVM Adapter stub): IChainAdapter 13개 메서드 stub + viem 기반 설계 노트가 정의됨
6. Kill Switch 상태 머신(NORMAL/ACTIVATED/RECOVERING)이 다이어그램으로 정의됨
7. 데몬 라이프사이클과의 통합 포인트가 명시됨
</verification>

<success_criteria>
- Kill Switch + 자동 정지 + EVM 문서가 12개 섹션으로 구성되어 Phase 8 Success Criteria #4, #5를 충족
- Kill Switch 캐스케이드가 시퀀스 다이어그램으로 완전히 문서화됨
- AutoStopEngine이 5개 규칙 타입 + 평가 흐름으로 설계됨
- EVM Adapter stub이 IChainAdapter 준수로 설계됨
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-layers-design/08-04-SUMMARY.md`
</output>
