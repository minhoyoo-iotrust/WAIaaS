---
phase: 87-owner-auth-siwe
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/api/middleware/siwe-verify.ts
  - packages/daemon/src/api/middleware/address-validation.ts
  - packages/daemon/src/__tests__/siwe-verify.test.ts
  - packages/daemon/src/__tests__/address-validation.test.ts
autonomous: true

must_haves:
  truths:
    - "verifySIWE rejects expired SIWE messages"
    - "verifySIWE rejects messages where recovered address does not match X-Owner-Address"
    - "verifySIWE accepts valid SIWE message with correct EIP-191 signature"
    - "validateOwnerAddress accepts valid Solana base58 32-byte public key"
    - "validateOwnerAddress accepts valid EIP-55 checksum Ethereum address"
    - "validateOwnerAddress rejects malformed addresses for each chain type"
  artifacts:
    - path: "packages/daemon/src/api/middleware/siwe-verify.ts"
      provides: "verifySIWE pure function"
      exports: ["verifySIWE"]
    - path: "packages/daemon/src/api/middleware/address-validation.ts"
      provides: "validateOwnerAddress utility"
      exports: ["validateOwnerAddress"]
    - path: "packages/daemon/src/__tests__/siwe-verify.test.ts"
      provides: "SIWE verification tests"
    - path: "packages/daemon/src/__tests__/address-validation.test.ts"
      provides: "Address validation tests"
  key_links:
    - from: "packages/daemon/src/api/middleware/siwe-verify.ts"
      to: "viem/siwe"
      via: "parseSiweMessage + validateSiweMessage"
      pattern: "parseSiweMessage|validateSiweMessage"
    - from: "packages/daemon/src/api/middleware/siwe-verify.ts"
      to: "viem"
      via: "verifyMessage for EIP-191 signature recovery"
      pattern: "verifyMessage"
    - from: "packages/daemon/src/api/middleware/address-validation.ts"
      to: "viem"
      via: "isAddress + getAddress for EIP-55 checksum validation"
      pattern: "isAddress|getAddress"
---

<objective>
Implement `verifySIWE` pure function and `validateOwnerAddress` utility as standalone modules with full test coverage, using TDD.

Purpose: Provide the cryptographic verification and address validation building blocks that the owner-auth middleware (Plan 87-02) will consume. Separating these as pure functions enables thorough unit testing without middleware wiring complexity.

Output: Two tested modules -- `siwe-verify.ts` (SIWE-01) and `address-validation.ts` (SIWE-03 address validation logic).
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/daemon/src/api/middleware/owner-auth.ts
@packages/daemon/src/__tests__/owner-auth.test.ts
@packages/daemon/src/infrastructure/keystore/keystore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: verifySIWE function with TDD (SIWE-01)</name>
  <files>
    packages/daemon/src/api/middleware/siwe-verify.ts
    packages/daemon/src/__tests__/siwe-verify.test.ts
  </files>
  <action>
Create `siwe-verify.ts` exporting a single async pure function:

```typescript
export interface VerifySIWEParams {
  message: string;      // EIP-4361 formatted message string
  signature: string;    // hex-encoded 0x-prefixed EIP-191 signature
  expectedAddress: string; // 0x EIP-55 checksum address to match
}

export interface VerifySIWEResult {
  valid: boolean;
  address?: string;     // recovered address on success
  error?: string;       // reason on failure
}

export async function verifySIWE(params: VerifySIWEParams): Promise<VerifySIWEResult>
```

Implementation steps:
1. Import `parseSiweMessage`, `validateSiweMessage` from `viem/siwe`
2. Import `verifyMessage` from `viem` (the utility version, NOT the client action)
3. Parse the SIWE message via `parseSiweMessage(params.message)` -- returns SiweMessage fields
4. Validate the SIWE message via `validateSiweMessage({ message: parsed })` -- checks expirationTime, notBefore etc.
   - Per decision [v1.4.1]: skip nonce validation (consistency with Solana owner-auth which has no server-side nonce check). Do NOT pass `nonce` parameter to validateSiweMessage.
5. Verify EIP-191 personal_sign via `verifyMessage({ address: params.expectedAddress, message: params.message, signature: params.signature as \`0x${string}\` })`
6. If verifyMessage returns true, return `{ valid: true, address: params.expectedAddress }`
7. Wrap all failures in try/catch and return `{ valid: false, error: "description" }`

**Test file** `siwe-verify.test.ts`:

Use `viem/accounts` `privateKeyToAccount` to create test wallets and `createSiweMessage` from `viem/siwe` to construct valid SIWE messages. Use `account.signMessage` to produce real EIP-191 signatures.

Test cases (RED first, then GREEN):
1. Returns `{ valid: true }` for valid SIWE message + correct signature
2. Returns `{ valid: false, error containing "expired" }` for expired SIWE message (set expirationTime in past)
3. Returns `{ valid: false }` when signature is from different account than expectedAddress
4. Returns `{ valid: false }` when message is malformed (not EIP-4361 format)
5. Returns `{ valid: false }` when signature is corrupted (invalid hex)

For test SIWE message construction, use:
```typescript
import { privateKeyToAccount } from 'viem/accounts';
import { createSiweMessage } from 'viem/siwe';

const testAccount = privateKeyToAccount('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'); // hardhat account #0
const message = createSiweMessage({
  address: testAccount.address,
  chainId: 1,
  domain: 'localhost',
  nonce: 'testnonce123',
  uri: 'http://localhost:3000',
  version: '1',
  expirationTime: new Date(Date.now() + 300_000), // 5 min from now
});
const signature = await testAccount.signMessage({ message });
```
  </action>
  <verify>
Run `pnpm vitest run packages/daemon/src/__tests__/siwe-verify.test.ts` -- all 5+ tests pass.
  </verify>
  <done>
verifySIWE correctly validates EIP-4361 SIWE messages: accepts valid, rejects expired/wrong-signer/malformed/corrupted. No server-side nonce validation per design decision.
  </done>
</task>

<task type="auto">
  <name>Task 2: validateOwnerAddress utility with TDD (SIWE-03 partial)</name>
  <files>
    packages/daemon/src/api/middleware/address-validation.ts
    packages/daemon/src/__tests__/address-validation.test.ts
  </files>
  <action>
Create `address-validation.ts` exporting:

```typescript
import type { ChainType } from '@waiaas/core';

export interface AddressValidationResult {
  valid: boolean;
  normalized?: string;  // normalized address (EIP-55 checksum for ethereum)
  error?: string;
}

export function validateOwnerAddress(chain: ChainType, address: string): AddressValidationResult
```

Implementation:
1. For `chain === 'solana'`:
   - Reuse the Base58 decode logic from existing `owner-auth.ts` (the `decodeBase58` function)
   - Extract `decodeBase58` into this module and export it (owner-auth.ts will import from here in Plan 02)
   - Validate: decoded bytes length === 32 (Ed25519 public key)
   - Return `{ valid: true, normalized: address }` (Solana addresses are already canonical base58)

2. For `chain === 'ethereum'`:
   - Import `isAddress`, `getAddress` from `viem`
   - Check `isAddress(address, { strict: true })` -- this validates 0x prefix + EIP-55 checksum
   - If valid, normalize via `getAddress(address)` and return `{ valid: true, normalized }`
   - If the address is valid hex but wrong checksum: return `{ valid: false, error: 'Invalid EIP-55 checksum' }`
   - If not a valid address format at all: return `{ valid: false, error: 'Invalid Ethereum address format' }`

3. For unknown chain: return `{ valid: false, error: 'Unsupported chain: ...' }`

**Test file** `address-validation.test.ts`:

Test cases:
1. Solana: accepts valid base58 32-byte public key (use a known Solana address like `11111111111111111111111111111112`)
2. Solana: rejects string that decodes to != 32 bytes
3. Solana: rejects string with invalid base58 characters (0, O, I, l)
4. Ethereum: accepts valid EIP-55 checksum address (`0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed`)
5. Ethereum: accepts all-lowercase 0x address and normalizes to EIP-55 (since `isAddress` with strict=false would pass, but we use strict=true, so all-lowercase is rejected -- test this explicitly)
6. Ethereum: rejects address without 0x prefix
7. Ethereum: rejects address with wrong checksum
8. Ethereum: rejects too-short address
9. Unknown chain: returns error

Note on Ethereum strict mode: `isAddress(addr, { strict: true })` rejects all-lowercase and all-uppercase addresses. This is by design -- we require EIP-55 checksum format for security. Document this in a JSDoc comment.
  </action>
  <verify>
Run `pnpm vitest run packages/daemon/src/__tests__/address-validation.test.ts` -- all 9 tests pass.
  </verify>
  <done>
validateOwnerAddress correctly validates and normalizes addresses for both chains. Solana requires base58 32-byte, Ethereum requires 0x + EIP-55 checksum. Unknown chains are rejected.
  </done>
</task>

</tasks>

<verification>
1. `pnpm vitest run packages/daemon/src/__tests__/siwe-verify.test.ts` -- all pass
2. `pnpm vitest run packages/daemon/src/__tests__/address-validation.test.ts` -- all pass
3. `pnpm tsc -p packages/daemon/tsconfig.json --noEmit` -- no type errors
4. Both modules have zero side effects (pure functions, no DB, no middleware)
</verification>

<success_criteria>
- verifySIWE accepts valid EIP-4361 + EIP-191 signatures
- verifySIWE rejects expired, wrong-signer, malformed, corrupted inputs
- validateOwnerAddress validates Solana base58 32B and Ethereum 0x EIP-55
- All new tests pass, TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/87-owner-auth-siwe/87-01-SUMMARY.md`
</output>
