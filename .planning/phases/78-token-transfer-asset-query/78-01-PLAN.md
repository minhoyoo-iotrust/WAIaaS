---
phase: 78-token-transfer-asset-query
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/adapters/solana/src/adapter.ts
  - packages/adapters/solana/src/__tests__/solana-token-transfer.test.ts
  - packages/adapters/solana/package.json
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
  - packages/daemon/src/__tests__/pipeline-integration.test.ts
  - packages/daemon/src/__tests__/pipeline.test.ts
  - packages/daemon/src/__tests__/api-transactions.test.ts
  - packages/daemon/src/__tests__/api-new-endpoints.test.ts
  - packages/daemon/src/__tests__/api-agents.test.ts
  - packages/daemon/src/__tests__/api-hint-field.test.ts
  - packages/daemon/src/__tests__/api-admin-endpoints.test.ts
  - packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts
  - packages/daemon/src/__tests__/workflow-owner-e2e.test.ts
  - packages/daemon/src/__tests__/pipeline-notification.test.ts
  - packages/daemon/src/__tests__/pipeline-stage4.test.ts
autonomous: true

must_haves:
  truths:
    - "Agent can send SPL tokens to recipients without existing token accounts (ATA auto-created)"
    - "Agent can send both Token Program and Token-2022 tokens without specifying program ID"
    - "Fee estimates for token transfers include ATA creation costs when applicable"
    - "Estimated fees match actual transaction fees (getTransactionFee returns estimatedFee)"
    - "Agent's asset portfolio includes Token-2022 tokens alongside standard SPL tokens"
    - "Token transfers are denied by default when no ALLOWED_TOKENS policy is configured"
    - "Only whitelisted token addresses are permitted for transfer when ALLOWED_TOKENS policy exists"
  artifacts:
    - path: "packages/adapters/solana/src/adapter.ts"
      provides: "SolanaAdapter buildTokenTransfer, getTokenInfo, estimateFee, getTransactionFee, getAssets Token-2022 real implementations"
    - path: "packages/adapters/solana/src/__tests__/solana-token-transfer.test.ts"
      provides: "Tests for SPL token transfer, Token-2022 branching, ATA creation, getTokenInfo, estimateFee"
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "ALLOWED_TOKENS policy evaluation in DatabasePolicyEngine"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "Tests for ALLOWED_TOKENS policy deny/allow logic"
  key_links:
    - from: "packages/adapters/solana/src/adapter.ts"
      to: "@solana-program/token"
      via: "getTransferCheckedInstruction import"
      pattern: "getTransferCheckedInstruction"
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "ALLOWED_TOKENS policy"
      via: "evaluateAllowedTokens method"
      pattern: "ALLOWED_TOKENS"
    - from: "pipeline Stage 3 (Phase 81)"
      to: "DatabasePolicyEngine.evaluate()"
      via: "tokenAddress field passed from pipeline to evaluate() -- wiring deferred to Phase 81"
      pattern: "tokenAddress"
      note: "Phase 78 adds tokenAddress? to evaluate() signature. Phase 81 wires Stage 3 to pass tokenAddress from TokenTransferParams into evaluate()."
---

<objective>
Implement SolanaAdapter SPL token transfer (buildTokenTransfer with Token-2022 auto-branching), getTokenInfo, estimateFee, getTransactionFee, expand getAssets to include Token-2022 accounts, and add ALLOWED_TOKENS policy evaluation to DatabasePolicyEngine.

Purpose: Enable agents to send SPL tokens on Solana with automatic Token Program/Token-2022 detection, ATA creation, and enforce ALLOWED_TOKENS whitelist policy (deny by default when no policy set).

Output: Working SolanaAdapter token methods + ALLOWED_TOKENS policy engine + comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/76-infra-pipeline-foundation/76-03-SUMMARY.md
@.planning/phases/77-evm-adapter/77-02-SUMMARY.md
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/adapters/solana/src/adapter.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/core/src/schemas/policy.schema.ts
@docs/56-token-transfer-extension-spec.md
@docs/57-asset-query-fee-estimation-spec.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SolanaAdapter buildTokenTransfer + getTokenInfo + estimateFee + getTransactionFee + getAssets Token-2022</name>
  <files>
    packages/adapters/solana/src/adapter.ts
    packages/adapters/solana/package.json
    packages/adapters/solana/src/__tests__/solana-token-transfer.test.ts
  </files>
  <action>
Replace the 4 SolanaAdapter stub methods (buildTokenTransfer, getTokenInfo, estimateFee, getTransactionFee) with real implementations, and expand getAssets to also query Token-2022 program accounts.

**1. Add dependency**: Add `@solana-program/token` to package.json dependencies (for `getTransferCheckedInstruction`). Also add `@solana-program/associated-token-account` if needed for `findAssociatedTokenPda` and `getCreateAssociatedTokenAccountInstruction`. Check whether these functions are available from `@solana/kit` first -- if they are, no separate package needed. If not, add the packages.

**2. Define constants**:
- `TOKEN_2022_PROGRAM_ID = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'` (existing SPL_TOKEN_PROGRAM_ID already defined)
- `ATA_RENT_LAMPORTS = 2_039_280n` (rent-exempt minimum for ATA, ~0.00204 SOL)

**3. buildTokenTransfer(request: TokenTransferParams) -> UnsignedTransaction**:
Implementation per design doc 56 section 3.2:
- Step 1: Query mint account via `rpc.getAccountInfo(address(request.token.address)).send()` with `{ encoding: 'base64' }`. Determine token program from `mintAccountInfo.value.owner`:
  - If owner === SPL_TOKEN_PROGRAM_ID -> tokenProgramId = SPL_TOKEN_PROGRAM_ID
  - If owner === TOKEN_2022_PROGRAM_ID -> tokenProgramId = TOKEN_2022_PROGRAM_ID
  - Else -> throw ChainError('INVALID_INSTRUCTION', 'solana', { message: 'Invalid token mint: owner is not a token program' })
  - If account not found -> throw ChainError('TOKEN_ACCOUNT_NOT_FOUND', 'solana', { message: ... })
- Step 2: Compute source and destination ATA addresses. Use the deterministic PDA derivation: `[owner, tokenProgramId, mint]`. Use `@solana-program/associated-token-account` findAssociatedTokenPda or derive manually.
- Step 3: Check if destination ATA exists via `rpc.getAccountInfo(destinationAta).send()`. If null, set `needCreateAta = true`.
- Step 4: Build transaction message using pipe pattern (same as buildTransaction):
  - createTransactionMessage({ version: 0 })
  - setTransactionMessageFeePayer(from)
  - setTransactionMessageLifetimeUsingBlockhash(blockhash)
  - If needCreateAta: appendTransactionMessageInstruction(getCreateAssociatedTokenAccountInstruction({payer: from, owner: to, mint: mintAddress, tokenProgram: tokenProgramId}))
  - appendTransactionMessageInstruction(getTransferCheckedInstruction({source: sourceAta, mint: mintAddress, destination: destinationAta, authority: from, amount: request.amount, decimals: request.token.decimals, tokenProgram: tokenProgramId}))
- Step 5: compileTransaction + txEncoder.encode
- Step 6: Return UnsignedTransaction with:
  - chain: 'solana'
  - serialized: encoded bytes
  - estimatedFee: DEFAULT_SOL_TRANSFER_FEE + (needCreateAta ? ATA_RENT_LAMPORTS : 0n)
  - expiresAt: new Date(Date.now() + 60_000)
  - metadata: { blockhash, lastValidBlockHeight, version: 0, tokenProgram: tokenProgramId, needCreateAta, token: request.token }
- Error handling: Wrap in try/catch, re-throw ChainError/WAIaaSError, map other errors with WAIaaSError('CHAIN_ERROR').

**4. getTokenInfo(tokenAddress: string) -> TokenInfo**:
- Query mint account via `rpc.getAccountInfo(address(tokenAddress), { encoding: 'base64' }).send()`
- If not found -> throw ChainError('TOKEN_ACCOUNT_NOT_FOUND', 'solana')
- Extract decimals from raw data at offset 44 (1 byte uint8) per SPL Token mint layout
- Determine programId from account owner field
- symbol and name: return empty strings (Metaplex metadata lookup deferred; symbol/name are cosmetic, not used in transfer logic). Return { address: tokenAddress, symbol: '', name: '', decimals, programId }
- Wrap errors in WAIaaSError('CHAIN_ERROR')

**5. estimateFee(request: TransferRequest | TokenTransferParams) -> FeeEstimate**:
- If request is TransferRequest (no 'token' field): return `{ fee: DEFAULT_SOL_TRANSFER_FEE }` (simple SOL transfer)
- If request is TokenTransferParams (has 'token' field):
  - Check if destination ATA exists (same logic as buildTokenTransfer Step 3)
  - fee = DEFAULT_SOL_TRANSFER_FEE + (needCreateAta ? ATA_RENT_LAMPORTS : 0n)
  - Return `{ fee, needsAtaCreation: needCreateAta, ataRentCost: needCreateAta ? ATA_RENT_LAMPORTS : undefined }`
- Error handling: wrap in ChainError/WAIaaSError

**6. getTransactionFee(tx: UnsignedTransaction) -> bigint**:
- Return tx.estimatedFee (Solana fees are known at build time)

**7. Expand getAssets**: After querying Token Program accounts (already implemented), also query Token-2022 accounts:
```typescript
const token2022Result = await rpc
  .getTokenAccountsByOwner(
    address(addr),
    { programId: address(TOKEN_2022_PROGRAM_ID) },
    { encoding: 'jsonParsed' },
  )
  .send();
```
Merge non-zero Token-2022 accounts into the assets array alongside existing SPL accounts. Sort: native first, then by balance descending.

**8. Write tests** in `packages/adapters/solana/src/__tests__/solana-token-transfer.test.ts`:
Mock `@solana/kit` RPC methods. Test cases:
- buildTokenTransfer: SPL Token Program transfer (mint owner = TOKEN_PROGRAM_ID)
- buildTokenTransfer: Token-2022 transfer (mint owner = TOKEN_2022_PROGRAM_ID)
- buildTokenTransfer: ATA creation when destination ATA doesn't exist
- buildTokenTransfer: Skip ATA creation when destination ATA exists
- buildTokenTransfer: Invalid mint (account not found) -> ChainError
- buildTokenTransfer: Invalid mint owner -> ChainError
- getTokenInfo: Successful mint account query with correct decimals extraction
- getTokenInfo: Account not found -> ChainError
- estimateFee: Native transfer returns DEFAULT_SOL_TRANSFER_FEE
- estimateFee: Token transfer with ATA creation returns fee + ATA_RENT_LAMPORTS
- estimateFee: Token transfer without ATA creation returns fee only
- getTransactionFee: Returns tx.estimatedFee
- getAssets: Includes Token-2022 accounts alongside Token Program accounts

Target: ~15-20 tests.

**Important**: The `@solana-program/token` and `@solana-program/associated-token-account` packages use the `@solana/kit` ecosystem. Import `getTransferCheckedInstruction` from `@solana-program/token`. If `findAssociatedTokenPda` and `getCreateAssociatedTokenAccountInstruction` are not available in any already-installed package, compute the ATA address deterministically using the standard PDA derivation or add the package.

For test mocking, follow the established pattern from existing solana-adapter.test.ts -- mock `@solana/kit` module and provide mock RPC responses.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS
pnpm --filter @waiaas/adapter-solana build
pnpm --filter @waiaas/adapter-solana test 2>&1 | tail -5
# Verify test count: expect 15-20 new tests in solana-token-transfer.test.ts
pnpm --filter @waiaas/adapter-solana test -- --reporter=verbose 2>&1 | grep -c 'PASS\|✓\|✔' || echo "Check test count manually"
```
All tests pass (existing + new). Build succeeds with no TypeScript errors. Confirm at least 15 new tests in solana-token-transfer.test.ts.
  </verify>
  <done>
SolanaAdapter has real implementations for buildTokenTransfer (with Token-2022 auto-branching and ATA creation), getTokenInfo, estimateFee (with ATA cost), getTransactionFee, and getAssets Token-2022 expansion. All tests pass including ~15-20 new token-specific tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: ALLOWED_TOKENS policy evaluation in DatabasePolicyEngine + daemon mock adapter updates</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
    packages/daemon/src/__tests__/database-policy-engine.test.ts
    packages/daemon/src/__tests__/pipeline-integration.test.ts
    packages/daemon/src/__tests__/pipeline.test.ts
    packages/daemon/src/__tests__/api-transactions.test.ts
    packages/daemon/src/__tests__/api-new-endpoints.test.ts
    packages/daemon/src/__tests__/api-agents.test.ts
    packages/daemon/src/__tests__/api-hint-field.test.ts
    packages/daemon/src/__tests__/api-admin-endpoints.test.ts
    packages/daemon/src/__tests__/session-lifecycle-e2e.test.ts
    packages/daemon/src/__tests__/workflow-owner-e2e.test.ts
    packages/daemon/src/__tests__/pipeline-notification.test.ts
    packages/daemon/src/__tests__/pipeline-stage4.test.ts
  </files>
  <action>
Add ALLOWED_TOKENS policy evaluation to DatabasePolicyEngine and update daemon test mock adapters.

**1. DatabasePolicyEngine.evaluate() -- Add ALLOWED_TOKENS evaluation**:

After the existing WHITELIST evaluation (Step 4) and before SPENDING_LIMIT evaluation (Step 5), add a new step:

```typescript
// Step 4b: Evaluate ALLOWED_TOKENS (token transfer whitelist)
const allowedTokensResult = this.evaluateAllowedTokens(resolved, transaction);
if (allowedTokensResult !== null) {
  return allowedTokensResult;
}
```

**2. Add evaluateAllowedTokens private method**:

```typescript
/**
 * ALLOWED_TOKENS policy evaluation.
 *
 * Logic:
 * - Only applies to TOKEN_TRANSFER transaction type
 * - If transaction type is TOKEN_TRANSFER and no ALLOWED_TOKENS policy exists:
 *   -> deny with reason 'Token transfer not allowed: no ALLOWED_TOKENS policy configured'
 * - If ALLOWED_TOKENS policy exists, check if transaction's token address is in rules.tokens[].address:
 *   -> If found: return null (continue to next evaluation)
 *   -> If not found: deny with reason 'Token not in allowed list: {tokenAddress}'
 * - For non-TOKEN_TRANSFER types: return null (not applicable)
 *
 * The token address is extracted from transaction metadata. The transaction
 * object passed to evaluate() needs to carry token info. Use the `metadata`
 * field or add a `tokenAddress` optional field to the transaction parameter.
 */
private evaluateAllowedTokens(
  policies: PolicyRow[],
  transaction: { type: string; amount: string; toAddress: string; chain: string; tokenAddress?: string },
): PolicyEvaluation | null {
  // Only evaluate for TOKEN_TRANSFER transactions
  if (transaction.type !== 'TOKEN_TRANSFER') return null;

  const allowedTokensPolicy = policies.find(p => p.type === 'ALLOWED_TOKENS');

  // No ALLOWED_TOKENS policy -> deny token transfers (default deny)
  if (!allowedTokensPolicy) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: 'Token transfer not allowed: no ALLOWED_TOKENS policy configured',
    };
  }

  // Parse rules.tokens array
  const rules = JSON.parse(allowedTokensPolicy.rules) as { tokens: Array<{ address: string }> };
  const tokenAddress = transaction.tokenAddress;

  if (!tokenAddress) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: 'Token transfer missing token address',
    };
  }

  // Check if token is in allowed list (case-insensitive comparison for EVM addresses)
  const isAllowed = rules.tokens.some(
    t => t.address.toLowerCase() === tokenAddress.toLowerCase()
  );

  if (!isAllowed) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: `Token not in allowed list: ${tokenAddress}`,
    };
  }

  return null; // Token is allowed, continue evaluation
}
```

**3. Update evaluate() method signature**: The `transaction` parameter needs a `tokenAddress?: string` optional field. Update the type definition:
```typescript
transaction: {
  type: string;
  amount: string;
  toAddress: string;
  chain: string;
  tokenAddress?: string;  // NEW: for ALLOWED_TOKENS evaluation
}
```
This is backward compatible -- existing callers don't pass tokenAddress, and the field is optional.

**4. Also update evaluateAndReserve()**: The same `tokenAddress` field needs to be added to the transaction parameter in evaluateAndReserve, and the ALLOWED_TOKENS evaluation needs to run there too (between WHITELIST and SPENDING_LIMIT).

**5. Write tests in database-policy-engine.test.ts**:
Add a new describe block 'ALLOWED_TOKENS policy' with these test cases:
- TOKEN_TRANSFER without ALLOWED_TOKENS policy -> denied
- TOKEN_TRANSFER with ALLOWED_TOKENS policy, token in list -> allowed (continues to SPENDING_LIMIT)
- TOKEN_TRANSFER with ALLOWED_TOKENS policy, token NOT in list -> denied
- TOKEN_TRANSFER with ALLOWED_TOKENS policy, case-insensitive address match (EVM hex) -> allowed
- TRANSFER (native) type -> ALLOWED_TOKENS not evaluated (passthrough)
- TOKEN_TRANSFER without tokenAddress -> denied with 'missing token address'

Target: ~6-8 new tests.

**6. Update daemon test mock adapters**: The `tokenAddress?: string` field is OPTIONAL, so existing callers that pass `{ type, amount, toAddress, chain }` without tokenAddress will continue to work without any changes. Verify this by running the full daemon test suite BEFORE touching any test files. If (and ONLY if) TypeScript strict mode or runtime errors occur, update the affected mock adapter transaction objects. The mock adapters already have the v1.4 stub methods from Phase 76, so no IChainAdapter changes needed. Expectation: zero or near-zero existing test files need changes because the field is optional.

**Phase 81 dependency note**: The pipeline wiring that passes tokenAddress from Stage 3 (TokenTransferParams) into DatabasePolicyEngine.evaluate() is intentionally deferred to Phase 81 ("파이프라인 통합 + Stage 5"). Phase 78 only adds the evaluate() capability and the optional tokenAddress field. Phase 81 connects the plumbing.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS
pnpm --filter @waiaas/daemon build
pnpm --filter @waiaas/daemon test
```
All daemon tests pass (existing + new ALLOWED_TOKENS tests). Build succeeds.
  </verify>
  <done>
DatabasePolicyEngine evaluates ALLOWED_TOKENS policy for TOKEN_TRANSFER transactions: denies when no policy exists (default deny), denies when token not in whitelist, allows when token is whitelisted. Case-insensitive address matching for EVM compatibility. 6-8 new tests pass. All existing daemon tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS

# 1. Build all affected packages
pnpm turbo build

# 2. Run all tests
pnpm --filter @waiaas/adapter-solana test
pnpm --filter @waiaas/daemon test

# 3. Verify no TypeScript errors
pnpm --filter @waiaas/adapter-solana typecheck
pnpm --filter @waiaas/daemon typecheck
```

All builds succeed. All tests pass. No TypeScript errors.
</verification>

<success_criteria>
1. SolanaAdapter.buildTokenTransfer builds SPL transferChecked transactions with automatic Token/Token-2022 branching and ATA creation
2. SolanaAdapter.getTokenInfo extracts decimals from Solana mint account data
3. SolanaAdapter.estimateFee includes ATA rent cost for token transfers when needed
4. SolanaAdapter.getTransactionFee returns estimatedFee from built transactions
5. SolanaAdapter.getAssets queries both Token Program and Token-2022 program accounts
6. DatabasePolicyEngine denies TOKEN_TRANSFER when no ALLOWED_TOKENS policy exists
7. DatabasePolicyEngine allows TOKEN_TRANSFER only for whitelisted token addresses
8. All existing tests continue to pass (no regressions)
9. 20+ new tests across adapter-solana and daemon packages
</success_criteria>

<output>
After completion, create `.planning/phases/78-token-transfer-asset-query/78-01-SUMMARY.md`
</output>
