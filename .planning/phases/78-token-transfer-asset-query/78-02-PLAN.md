---
phase: 78-token-transfer-asset-query
plan: 02
type: tdd
wave: 2
depends_on: ["78-01"]
files_modified:
  - packages/adapters/evm/src/adapter.ts
  - packages/adapters/evm/src/__tests__/evm-adapter.test.ts
  - packages/adapters/evm/src/__tests__/evm-token-transfer.test.ts
autonomous: true

must_haves:
  truths:
    - "EvmAdapter.buildTokenTransfer builds ERC-20 transfer calldata using encodeFunctionData with ERC20_ABI"
    - "EvmAdapter.buildTokenTransfer returns EIP-1559 transaction targeting the token contract address with 1.2x gas margin"
    - "EvmAdapter.getAssets returns native ETH balance when no allowedTokens configured (backward compatible)"
    - "EvmAdapter.getAssets returns native ETH + ERC-20 token balances via multicall when allowedTokens are set via setAllowedTokens()"
    - "setAllowedTokens() configures the token list used by getAssets -- daemon integration (loading ALLOWED_TOKENS policy and calling setAllowedTokens) deferred to Phase 81"
  artifacts:
    - path: "packages/adapters/evm/src/adapter.ts"
      provides: "EvmAdapter buildTokenTransfer real implementation + getAssets ERC-20 multicall expansion"
    - path: "packages/adapters/evm/src/__tests__/evm-token-transfer.test.ts"
      provides: "Tests for ERC-20 transfer build, getAssets multicall, token balance integration"
  key_links:
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "ERC20_ABI"
      via: "encodeFunctionData for transfer(address,uint256)"
      pattern: "encodeFunctionData.*transfer"
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "viem multicall"
      via: "client.multicall for ERC-20 balanceOf"
      pattern: "multicall.*balanceOf"
    - from: "daemon service layer (Phase 81)"
      to: "EvmAdapter.setAllowedTokens()"
      via: "daemon loads ALLOWED_TOKENS policy -> calls setAllowedTokens() -> calls getAssets() -- deferred to Phase 81"
      pattern: "setAllowedTokens"
      note: "Phase 78 implements setAllowedTokens() and getAssets() multicall. Phase 81 wires daemon to load policy and call setAllowedTokens before getAssets."
---

<objective>
Implement EvmAdapter ERC-20 token transfer (buildTokenTransfer) and expand getAssets to include ERC-20 token balances via multicall using ALLOWED_TOKENS addresses.

Purpose: Enable agents to send ERC-20 tokens on EVM chains and view their complete asset portfolio including token balances, completing the EVM side of Phase 78 token transfer requirements.

Output: Working EvmAdapter buildTokenTransfer + getAssets ERC-20 expansion + comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-token-transfer-asset-query/78-01-SUMMARY.md
@.planning/phases/77-evm-adapter/77-02-SUMMARY.md
@packages/adapters/evm/src/adapter.ts
@packages/adapters/evm/src/abi/erc20.ts
@packages/adapters/evm/src/__tests__/evm-adapter.test.ts
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/core/src/interfaces/IChainAdapter.ts
@docs/56-token-transfer-extension-spec.md
@docs/57-asset-query-fee-estimation-spec.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: EvmAdapter buildTokenTransfer ERC-20 implementation</name>
  <files>
    packages/adapters/evm/src/adapter.ts
    packages/adapters/evm/src/__tests__/evm-token-transfer.test.ts
  </files>
  <action>
Replace the EvmAdapter.buildTokenTransfer stub with a real ERC-20 transfer implementation.

**1. Implement buildTokenTransfer(request: TokenTransferParams) -> UnsignedTransaction**:

Follow the established EvmAdapter EIP-1559 pattern from buildTransaction and buildApprove. The logic is identical to buildApprove but with `transfer` instead of `approve`:

```typescript
async buildTokenTransfer(request: TokenTransferParams): Promise<UnsignedTransaction> {
  const client = this.getClient();
  try {
    const fromAddr = request.from as `0x${string}`;
    const tokenAddr = request.token.address as `0x${string}`;
    const toAddr = request.to as `0x${string}`;

    // 1. Encode ERC-20 transfer(address,uint256) calldata
    const transferData = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'transfer',
      args: [toAddr, request.amount],
    });

    // 2. Get nonce
    const nonce = await client.getTransactionCount({ address: fromAddr });

    // 3. Get EIP-1559 fee data
    const fees = await client.estimateFeesPerGas();

    // 4. Estimate gas with 1.2x safety margin
    const estimatedGas = await client.estimateGas({
      account: fromAddr,
      to: tokenAddr,  // tx target is the TOKEN CONTRACT, not the recipient
      data: transferData,
    });
    const gasLimit = (estimatedGas * GAS_SAFETY_NUMERATOR) / GAS_SAFETY_DENOMINATOR;

    const maxFeePerGas = fees.maxFeePerGas!;
    const maxPriorityFeePerGas = fees.maxPriorityFeePerGas!;
    const chainId = client.chain?.id ?? 1;

    // 5. Build EIP-1559 tx to token contract with transfer calldata, value=0
    const txRequest = {
      type: 'eip1559' as const,
      to: tokenAddr,  // target is token contract
      value: 0n,      // no ETH value for ERC-20 transfer
      nonce,
      gas: gasLimit,
      maxFeePerGas,
      maxPriorityFeePerGas,
      chainId,
      data: transferData,
    };

    // 6. Serialize
    const serializedHex = serializeTransaction(txRequest);
    const serializedBytes = hexToBytes(serializedHex);

    const estimatedFee = gasLimit * maxFeePerGas;

    return {
      chain: 'ethereum',
      serialized: serializedBytes,
      estimatedFee,
      expiresAt: undefined,  // EVM uses nonce, no expiry
      metadata: {
        nonce,
        chainId,
        maxFeePerGas,
        maxPriorityFeePerGas,
        gasLimit,
        type: 'eip1559',
        tokenAddress: request.token.address,
        recipient: request.to,
        tokenAmount: request.amount,
      },
      nonce,
    };
  } catch (error) {
    if (error instanceof ChainError || error instanceof WAIaaSError) throw error;
    throw this.mapError(error, 'Failed to build token transfer');
  }
}
```

Key differences from native buildTransaction:
- `to` field is the TOKEN CONTRACT address, not the recipient
- `value` is 0n (no ETH sent)
- `data` contains the encoded `transfer(address,uint256)` calldata
- metadata includes tokenAddress, recipient, tokenAmount for audit

**2. Write tests in evm-token-transfer.test.ts**:

Follow the established vi.mock('viem') pattern from evm-adapter.test.ts. Create a new test file to keep tests organized:

Test cases:
- buildTokenTransfer: Returns UnsignedTransaction with correct chain, serialized bytes, and metadata
- buildTokenTransfer: Transaction targets token contract address (not recipient)
- buildTokenTransfer: Value is 0n (ERC-20 transfer carries no ETH)
- buildTokenTransfer: Gas estimation uses 1.2x safety margin
- buildTokenTransfer: Metadata includes tokenAddress, recipient, tokenAmount
- buildTokenTransfer: Calls encodeFunctionData with ERC20_ABI transfer function
- buildTokenTransfer: Insufficient funds -> ChainError INSUFFICIENT_BALANCE
- buildTokenTransfer: Nonce too low -> ChainError NONCE_TOO_LOW
- buildTokenTransfer: RPC error -> mapError fallback

Target: ~8-10 tests.

Mock setup: Same as evm-adapter.test.ts -- vi.mock('viem') returning mockClient with getTransactionCount, estimateFeesPerGas, estimateGas, getBalance. Mock encodeFunctionData, serializeTransaction, hexToBytes, toHex.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS
pnpm --filter @waiaas/adapter-evm build
pnpm --filter @waiaas/adapter-evm test
```
All tests pass (existing 34 + new ~8-10). Build succeeds with no TypeScript errors.
  </verify>
  <done>
EvmAdapter.buildTokenTransfer builds EIP-1559 transaction with ERC-20 transfer calldata, targeting token contract with value=0n, 1.2x gas margin, and audit metadata. 8-10 new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: EvmAdapter getAssets ERC-20 multicall expansion + sorting</name>
  <files>
    packages/adapters/evm/src/adapter.ts
    packages/adapters/evm/src/__tests__/evm-token-transfer.test.ts
  </files>
  <action>
Expand EvmAdapter.getAssets to include ERC-20 token balances via multicall. Per design doc 57, EVM uses a "conservative query" approach: only query tokens from an explicit token list (from ALLOWED_TOKENS policy), not scanning all possible tokens.

**1. Update getAssets method signature and implementation**:

The IChainAdapter interface defines `getAssets(address: string): Promise<AssetInfo[]>`. Since the interface doesn't accept a token list parameter, we need a way to pass the ALLOWED_TOKENS list. Two approaches:

**Approach A (preferred)**: Add an optional `allowedTokens` field to the EvmAdapter class that can be set before calling getAssets. The daemon's service layer sets this before querying:
```typescript
// In EvmAdapter class
private _allowedTokens: Array<{ address: string; symbol?: string; name?: string; decimals?: number }> = [];

/** Set the allowed tokens list for getAssets ERC-20 queries. */
setAllowedTokens(tokens: Array<{ address: string; symbol?: string; name?: string; decimals?: number }>): void {
  this._allowedTokens = tokens;
}
```

**Approach B**: The getAssets method only returns native ETH if no allowed tokens are set (current behavior = fallback). When _allowedTokens is populated, it queries those token balances via multicall.

**2. Implement ERC-20 balance query via multicall**:

```typescript
async getAssets(addr: string): Promise<AssetInfo[]> {
  const client = this.getClient();
  try {
    // 1. Get native ETH balance
    const ethBalance = await client.getBalance({ address: addr as `0x${string}` });
    const assets: AssetInfo[] = [
      {
        mint: 'native',
        symbol: 'ETH',
        name: 'Ethereum',
        balance: ethBalance,
        decimals: 18,
        isNative: true,
      },
    ];

    // 2. Query ERC-20 balances if allowedTokens configured
    if (this._allowedTokens.length > 0) {
      // Build multicall contracts array for balanceOf queries
      const balanceContracts = this._allowedTokens.map(token => ({
        address: token.address as `0x${string}`,
        abi: ERC20_ABI,
        functionName: 'balanceOf' as const,
        args: [addr as `0x${string}`],
      }));

      const results = await client.multicall({ contracts: balanceContracts });

      // 3. Process results, skip failed calls and zero balances
      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const tokenDef = this._allowedTokens[i];

        if (result.status === 'success') {
          const balance = result.result as bigint;
          if (balance > 0n) {
            assets.push({
              mint: tokenDef.address,
              symbol: tokenDef.symbol ?? '',
              name: tokenDef.name ?? '',
              balance,
              decimals: tokenDef.decimals ?? 18,
              isNative: false,
            });
          }
        }
        // Skip failed multicall results silently (token may not exist or revert)
      }

      // 4. Sort: native first (already first), then by balance descending
      // Keep native at index 0, sort the rest by balance descending
      if (assets.length > 1) {
        const native = assets[0];
        const tokens = assets.slice(1).sort((a, b) => {
          if (b.balance > a.balance) return 1;
          if (b.balance < a.balance) return -1;
          return a.symbol.localeCompare(b.symbol); // tie-break: alphabetical
        });
        return [native, ...tokens];
      }
    }

    return assets;
  } catch (error) {
    throw this.mapError(error, 'Failed to get assets');
  }
}
```

**3. Add tests for getAssets ERC-20 expansion**:

Append to evm-token-transfer.test.ts:
- getAssets: Returns only native ETH when no allowedTokens set (backward compatible)
- getAssets: Returns native ETH + ERC-20 balances when allowedTokens set
- getAssets: Skips zero-balance tokens
- getAssets: Skips failed multicall results (graceful handling)
- getAssets: Sorts tokens by balance descending, native first
- getAssets: Multiple tokens sorted correctly (highest balance first)
- setAllowedTokens: Updates the internal token list

Target: ~6-8 additional tests.

**4. Important considerations**:
- The `setAllowedTokens()` approach keeps IChainAdapter interface unchanged (no breaking changes)
- **Phase 81 integration boundary**: The daemon service layer will load ALLOWED_TOKENS from the policy DB and call `setAllowedTokens()` before `getAssets()` -- that wiring is explicitly deferred to Phase 81 ("파이프라인 통합 + Stage 5"). Phase 78 only builds the EvmAdapter capability (setAllowedTokens + getAssets multicall). Tests in Phase 78 verify the adapter works when setAllowedTokens is called directly, not via daemon integration.
- balanceOf multicall is a single RPC call regardless of number of tokens, which is efficient
- Failed multicall results are silently skipped (token contract may not exist or may revert)

**5. TOKEN-05 (getTokenInfo) note**: EvmAdapter.getTokenInfo was already fully implemented in Phase 77-02 using viem multicall for decimals/symbol/name. No additional work needed in this plan for TOKEN-05.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS
pnpm --filter @waiaas/adapter-evm build
pnpm --filter @waiaas/adapter-evm test
pnpm turbo build  # Verify full monorepo build
```
All tests pass (existing 34 + new ~14-18 from both tasks). Build succeeds. Full monorepo build clean.
  </verify>
  <done>
EvmAdapter.getAssets returns native ETH + ERC-20 token balances via multicall when allowedTokens are set. Tokens are sorted by balance descending with native first. Zero balances and failed multicall results are filtered. setAllowedTokens() allows the daemon to configure the query without changing IChainAdapter interface. 6-8 new tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS

# 1. Build all packages
pnpm turbo build

# 2. Run EVM adapter tests
pnpm --filter @waiaas/adapter-evm test

# 3. Run full test suite
pnpm --filter @waiaas/adapter-solana test
pnpm --filter @waiaas/daemon test
pnpm --filter @waiaas/core test

# 4. TypeScript verification
pnpm --filter @waiaas/adapter-evm typecheck
```

All builds succeed. All tests pass. No TypeScript errors across the monorepo.
</verification>

<success_criteria>
1. EvmAdapter.buildTokenTransfer builds EIP-1559 transaction with ERC-20 transfer calldata targeting token contract
2. EvmAdapter.getAssets returns native ETH + ERC-20 token balances via multicall when allowedTokens configured
3. EvmAdapter.getAssets returns only native ETH when no allowedTokens set (backward compatible)
4. Token balances are sorted: native first, then balance descending
5. Zero balances and failed multicall results are gracefully handled
6. All existing 34 EVM adapter tests continue to pass
7. 14-18 new tests pass across both tasks
8. Full monorepo build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/78-token-transfer-asset-query/78-02-SUMMARY.md`
</output>
