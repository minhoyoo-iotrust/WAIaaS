---
phase: 228-rest-api-sdk-mcp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/api/routes/incoming.ts
  - packages/daemon/src/api/routes/wallets.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/api/server.ts
autonomous: true
requirements:
  - API-01
  - API-02
  - API-03

must_haves:
  truths:
    - "GET /v1/wallet/incoming returns paginated incoming transactions with composite (detectedAt, id) cursor and chain/network/status/token filters, defaulting to status=CONFIRMED"
    - "GET /v1/wallet/incoming/summary returns period-based (daily/weekly/monthly) incoming totals with USD conversion using application-layer BigInt summation"
    - "PATCH /v1/wallets/:id with monitorIncoming field updates the wallet DB column and calls syncSubscriptions() asynchronously"
  artifacts:
    - path: "packages/daemon/src/api/routes/incoming.ts"
      provides: "Incoming transaction list and summary endpoints"
      exports: ["incomingRoutes"]
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "Zod schemas for incoming TX API responses"
      contains: "IncomingTxListResponseSchema"
    - path: "packages/daemon/src/api/routes/wallets.ts"
      provides: "PATCH /v1/wallets/:id route for monitorIncoming toggle"
      contains: "patchWalletRoute"
    - path: "packages/daemon/src/api/server.ts"
      provides: "Route mounting and auth middleware for incoming routes"
      contains: "incomingRoutes"
  key_links:
    - from: "packages/daemon/src/api/routes/incoming.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle query on incomingTransactions table"
      pattern: "incomingTransactions"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/api/routes/incoming.ts"
      via: "app.route('/v1', incomingRoutes(...))"
      pattern: "incomingRoutes"
    - from: "packages/daemon/src/api/routes/wallets.ts"
      to: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      via: "syncSubscriptions() fire-and-forget after monitorIncoming update"
      pattern: "syncSubscriptions"
---

<objective>
Create the three REST API endpoints for incoming transaction monitoring: GET /v1/wallet/incoming (paginated list with filters), GET /v1/wallet/incoming/summary (period aggregation), and PATCH /v1/wallets/:id (monitorIncoming toggle).

Purpose: Expose the incoming transaction infrastructure (Phases 224-227) through the REST API so agents and admin tools can query received transactions and toggle per-wallet monitoring.
Output: New incoming.ts route file, updated wallets.ts with PATCH, OpenAPI schemas, server.ts mounting.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/228-rest-api-sdk-mcp/228-RESEARCH.md

# Key source files to reference
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/api/routes/wallets.ts
@packages/daemon/src/api/routes/wallet.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/helpers/resolve-wallet-id.ts
@packages/daemon/src/infrastructure/database/schema.ts
@packages/core/src/schemas/incoming-transaction.schema.ts
@packages/core/src/enums/incoming-tx.ts
@packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create incoming.ts route file with list + summary endpoints and OpenAPI schemas</name>
  <files>
    packages/daemon/src/api/routes/incoming.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
  </files>
  <action>
1. **Add OpenAPI schemas to openapi-schemas.ts** (append at end, before closing):

   a. `IncomingTxItemSchema` — Zod object matching IncomingTransaction interface (13 fields):
      id (string.uuid), txHash (string), walletId (string.uuid), fromAddress (string),
      amount (string), tokenAddress (string.nullable), chain (string), network (string),
      status (string — 'DETECTED' | 'CONFIRMED'), blockNumber (number.int.nullable),
      detectedAt (number.int), confirmedAt (number.int.nullable),
      suspicious (boolean).
      Call `.openapi('IncomingTxItem')`.

   b. `IncomingTxListResponseSchema` — Zod object with:
      `data: z.array(IncomingTxItemSchema)`, `nextCursor: z.string().nullable()`, `hasMore: z.boolean()`.
      Call `.openapi('IncomingTxListResponse')`.

   c. `IncomingTxSummaryEntrySchema` — Zod object:
      `date: z.string()`, `totalCount: z.number().int()`, `totalAmountNative: z.string()`,
      `totalAmountUsd: z.number().nullable()`, `suspiciousCount: z.number().int()`.
      Call `.openapi('IncomingTxSummaryEntry')`.

   d. `IncomingTxSummaryResponseSchema` — Zod object:
      `period: z.string()`, `entries: z.array(IncomingTxSummaryEntrySchema)`.
      Call `.openapi('IncomingTxSummaryResponse')`.

   e. `PatchWalletRequestSchema` — Zod object:
      `monitorIncoming: z.boolean().optional()`.
      Call `.openapi('PatchWalletRequest')`.

   f. `PatchWalletResponseSchema` — Zod object:
      `id: z.string().uuid()`, `monitorIncoming: z.boolean()`.
      Call `.openapi('PatchWalletResponse')`.

   Export all six schemas.

2. **Create packages/daemon/src/api/routes/incoming.ts**:

   a. Define `IncomingRouteDeps` interface:
      ```
      db: BetterSQLite3Database<typeof schema>
      sqlite?: SQLiteDatabase
      priceOracle?: IPriceOracle
      forexRateService?: IForexRateService
      settingsService?: SettingsService
      ```

   b. Create cursor helper functions:
      - `encodeCursor(detectedAt: number, id: string): string` — `Buffer.from(JSON.stringify({ d: detectedAt, i: id })).toString('base64url')`
      - `decodeCursor(cursor: string): { detectedAt: number; id: string } | null` — try/catch parse from base64url, return null on failure.

   c. Define `listIncomingRoute` via `createRoute()`:
      - method: 'get', path: '/wallet/incoming', tags: ['Wallet']
      - query schema: `limit` (coerce number, int, min 1, max 100, default 20, optional), `cursor` (string optional), `chain` (string optional), `network` (string optional), `status` (string optional, description mentions default CONFIRMED), `token` (string optional — tokenAddress filter), `from_address` (string optional), `since` (coerce number optional — epoch seconds), `until` (coerce number optional), `wallet_id` (string.uuid optional)
      - response 200: IncomingTxListResponseSchema

   d. Define `incomingSummaryRoute` via `createRoute()`:
      - method: 'get', path: '/wallet/incoming/summary', tags: ['Wallet']
      - query: `period` (enum 'daily' | 'weekly' | 'monthly', default 'daily'), `chain` (string optional), `network` (string optional), `since` (coerce number optional), `until` (coerce number optional), `wallet_id` (string.uuid optional)
      - response 200: IncomingTxSummaryResponseSchema

   e. Export `incomingRoutes(deps: IncomingRouteDeps): OpenAPIHono` factory function:

   **GET /wallet/incoming handler:**
   - Call `resolveWalletId(c, deps.db)` to get walletId from session
   - If query has `wallet_id`, override with that value (pass as 3rd arg to resolveWalletId)
   - Read query params (limit default 20, cursor, chain, network, status, token, from_address, since, until)
   - **CRITICAL: Default status to 'CONFIRMED' when no status param provided** (per success criteria #1)
   - Build Drizzle WHERE conditions:
     - Always: `eq(incomingTransactions.walletId, walletId)`
     - If status: `eq(incomingTransactions.status, status)` (default: 'CONFIRMED')
     - If chain: `eq(incomingTransactions.chain, chain)`
     - If network: `eq(incomingTransactions.network, network)`
     - If token: `eq(incomingTransactions.tokenAddress, token)`
     - If from_address: `eq(incomingTransactions.fromAddress, from_address)`
     - If since: `gte(incomingTransactions.detectedAt, since)` (use `>=` via `sql` template or `gte` from drizzle-orm)
     - If until: `lte(incomingTransactions.detectedAt, until)` (use `<=`)
     - If cursor: decode it, then add `(detectedAt < cursor.detectedAt) OR (detectedAt = cursor.detectedAt AND id < cursor.id)` using Drizzle `sql` template or `or(lt(...), and(eq(...), lt(...)))`.
   - Query: `.orderBy(desc(incomingTransactions.detectedAt), desc(incomingTransactions.id)).limit(limit + 1)`
   - Slice results, determine hasMore, compute nextCursor from last item
   - **CRITICAL: Date-to-epoch conversion.** Drizzle `mode: 'timestamp'` returns `Date` objects, but the response schema expects `z.number().int()` (epoch seconds). Map each row before returning:
     ```typescript
     const mapped = items.map(row => ({
       ...row,
       detectedAt: Math.floor(row.detectedAt.getTime() / 1000),
       confirmedAt: row.confirmedAt ? Math.floor(row.confirmedAt.getTime() / 1000) : null,
       suspicious: row.isSuspicious,  // DB column is is_suspicious, Drizzle field is isSuspicious
     }));
     ```
     Follow the same pattern used in `transactions.ts` (line ~540: `createdAt: tx.createdAt ? Math.floor(tx.createdAt.getTime() / 1000) : null`).
   - **Cursor encoding** must also use the epoch-converted value: `encodeCursor(Math.floor(lastItem.detectedAt.getTime() / 1000), lastItem.id)` (NOT the raw Date object).
   - Return JSON with `data: mapped`, `nextCursor`, `hasMore`

   **GET /wallet/incoming/summary handler:**
   - Call `resolveWalletId(c, deps.db)` for walletId
   - Read query params (period default 'daily', chain, network, since, until)
   - **Use raw SQL via deps.sqlite** (not Drizzle ORM) because we need GROUP BY with date formatting:
     - For 'daily': `strftime('%Y-%m-%d', detected_at, 'unixepoch')` as date column
     - For 'weekly': `strftime('%Y-W%W', detected_at, 'unixepoch')`
     - For 'monthly': `strftime('%Y-%m', detected_at, 'unixepoch')`
   - SQL query: `SELECT date_col, COUNT(*) as total_count, SUM(CASE WHEN is_suspicious = 1 THEN 1 ELSE 0 END) as suspicious_count FROM incoming_transactions WHERE wallet_id = ? AND status = 'CONFIRMED' [AND chain = ? AND network = ?] [AND detected_at >= ? AND detected_at <= ?] GROUP BY date_col ORDER BY date_col DESC`
   - **For totalAmountNative:** SQL does NOT SUM amounts. Instead, for each date period, fetch all `amount` values and sum using JavaScript BigInt in app layer to avoid overflow.
     - Either: separate query `SELECT amount FROM incoming_transactions WHERE wallet_id = ? AND date_col = ?` per period entry, OR fetch all amounts in the initial query and group in JS.
     - Recommended: single query with `GROUP_CONCAT(amount, ',')` per period, then parse in JS and BigInt sum. Or simply add `amount` to the SELECT and do the grouping in JS.
     - Simplest approach: run the COUNT/GROUP BY query first to get date buckets and counts, then for each bucket run a second query to fetch amounts and BigInt-sum. This avoids GROUP_CONCAT limitations.
     - Actually, most efficient: single raw SQL query fetching `date_col, amount, is_suspicious` for all matching rows (no GROUP BY), then aggregate entirely in JS. This is cleanest for BigInt handling.
   - For USD conversion: if `deps.priceOracle` is available, get native token price and multiply by totalAmountNative (converted from BigInt to human-readable with decimals). If unavailable, set `totalAmountUsd` to null.
   - Return JSON with `period` and `entries` array

   f. Import `incomingTransactions` from database schema, `resolveWalletId` from helpers, `IPriceOracle`, `IForexRateService` from @waiaas/core.
   Note: Use `import { gte, lte, or } from 'drizzle-orm'` for comparison operators if needed, alongside existing `eq, and, lt, desc`.
  </action>
  <verify>
    - `pnpm turbo run typecheck --filter=@waiaas/daemon` passes without errors
    - `pnpm turbo run lint --filter=@waiaas/daemon` passes without errors
    - The `incoming.ts` file exports `incomingRoutes` function
    - The `openapi-schemas.ts` file exports all 6 new schemas
  </verify>
  <done>
    GET /v1/wallet/incoming route defined with composite cursor pagination, 8 filter params, and default status=CONFIRMED.
    GET /v1/wallet/incoming/summary route defined with daily/weekly/monthly period aggregation using BigInt app-layer summation.
    All OpenAPI schemas defined and registered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PATCH /v1/wallets/:id to wallets.ts and mount incoming routes in server.ts</name>
  <files>
    packages/daemon/src/api/routes/wallets.ts
    packages/daemon/src/api/server.ts
  </files>
  <action>
1. **Update wallets.ts:**

   a. Add `incomingTxMonitorService` optional field to `WalletCrudRouteDeps`:
      ```typescript
      incomingTxMonitorService?: { syncSubscriptions(): void | Promise<void> };
      ```
      Use duck-typed interface (not importing IncomingTxMonitorService directly) to avoid circular dependencies, consistent with the pattern from Phase 226-04 decisions.

   b. Import `PatchWalletRequestSchema` and `PatchWalletResponseSchema` from `./openapi-schemas.js`.

   c. Define `patchWalletRoute` via `createRoute()`:
      - method: 'patch', path: '/wallets/{id}', tags: ['Wallets']
      - summary: 'Update wallet monitoring settings'
      - request: params `z.object({ id: z.string().uuid() })`, body `PatchWalletRequestSchema`
      - response 200: `PatchWalletResponseSchema`
      - error responses: `['WALLET_NOT_FOUND']`

   d. Add handler inside `walletCrudRoutes()` function (after the existing updateWalletRoute handler, before deleteWalletRoute):
      - Validate params, get walletId
      - Look up wallet, throw WALLET_NOT_FOUND if missing
      - Read body `monitorIncoming`
      - If `monitorIncoming !== undefined`:
        - `UPDATE wallets SET monitor_incoming = ? WHERE id = ?` via `deps.db.update(wallets).set({ monitorIncoming: body.monitorIncoming }).where(eq(wallets.id, walletId)).run()`
        - Note: The column name in Drizzle schema is `monitorIncoming` (camelCase), which maps to `monitor_incoming` in SQLite.
        - **Fire-and-forget** call to syncSubscriptions: `void deps.incomingTxMonitorService?.syncSubscriptions();`
      - Re-fetch wallet to get updated state
      - Return JSON: `{ id: walletId, monitorIncoming: updated.monitorIncoming ?? false }`

2. **Update server.ts:**

   a. Import `incomingRoutes` from `'./routes/incoming.js'`.

   b. **Auth middleware:** The existing `app.use('/v1/wallet/*', sessionAuth)` on line 209 already covers `/v1/wallet/incoming` and `/v1/wallet/incoming/summary` because the wildcard matches sub-paths. No additional auth registration needed for incoming routes.

   c. **PATCH /v1/wallets/:id auth:** The existing masterAuth middleware on `/v1/wallets/:id` (lines 181-188) skips sub-paths (`/owner`, `/default-network`, `/networks`, `/wc/`). For PATCH on the base path, it DOES apply masterAuth. However, the current skip logic checks `c.req.path.includes('/owner')` etc. The PATCH on `/v1/wallets/:id` (no sub-path) will pass through to masterAuth correctly. Verify no changes needed.

   d. **Mount incoming routes:** After the walletRoutes block (around line 361), add:
      ```typescript
      if (deps.db) {
        app.route(
          '/v1',
          incomingRoutes({
            db: deps.db,
            sqlite: deps.sqlite,
            priceOracle: deps.priceOracle,
            forexRateService: deps.forexRateService,
            settingsService: deps.settingsService,
          }),
        );
      }
      ```

   e. **Pass incomingTxMonitorService to walletCrudRoutes:** In the `CreateAppDeps` interface, add:
      ```typescript
      incomingTxMonitorService?: { syncSubscriptions(): void | Promise<void> };
      ```
      Then in the walletCrudRoutes call, add the new field:
      ```typescript
      incomingTxMonitorService: deps.incomingTxMonitorService,
      ```
  </action>
  <verify>
    - `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
    - `pnpm turbo run lint --filter=@waiaas/daemon` passes
    - In server.ts, incoming routes are mounted after wallet routes
    - PATCH /v1/wallets/:id is covered by existing masterAuth middleware
  </verify>
  <done>
    PATCH /v1/wallets/:id accepts monitorIncoming boolean, updates DB, and calls syncSubscriptions() asynchronously.
    Incoming routes mounted at /v1/wallet/incoming and /v1/wallet/incoming/summary with sessionAuth via existing wildcard.
    CreateAppDeps extended with incomingTxMonitorService for DI.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` — zero type errors
2. `pnpm turbo run lint --filter=@waiaas/daemon` — zero lint warnings/errors
3. Verify openapi-schemas.ts exports 6 new schemas: IncomingTxItemSchema, IncomingTxListResponseSchema, IncomingTxSummaryEntrySchema, IncomingTxSummaryResponseSchema, PatchWalletRequestSchema, PatchWalletResponseSchema
4. Verify incoming.ts exports incomingRoutes function
5. Verify server.ts imports and mounts incomingRoutes
6. Verify PATCH route is registered in walletCrudRoutes
</verification>

<success_criteria>
- GET /v1/wallet/incoming route handler exists with composite cursor pagination, 8 filter params, and status=CONFIRMED default
- GET /v1/wallet/incoming/summary route handler exists with period aggregation and BigInt app-layer amount summation
- PATCH /v1/wallets/:id route handler exists with monitorIncoming field and syncSubscriptions() async call
- All routes have proper OpenAPI schemas and are mounted in server.ts with correct auth middleware
- TypeScript compilation succeeds across the daemon package
</success_criteria>

<output>
After completion, create `.planning/phases/228-rest-api-sdk-mcp/228-01-SUMMARY.md`
</output>
