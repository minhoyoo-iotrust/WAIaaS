---
phase: 43-concurrency-execution-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/53-session-renewal-protocol.md
autonomous: true

must_haves:
  truths:
    - "53-session-renewal SS5에 token_hash = :currentTokenHash 낙관적 잠금 패턴이 SQL 수준으로 정의되어 있다"
    - "UPDATE의 WHERE 절에 token_hash 조건이 포함되어 있고, changes === 0일 때 RENEWAL_CONFLICT(409) 에러를 반환한다"
    - "RENEWAL_CONFLICT 에러 코드의 HTTP 상태(409), retryable(false), 에러 메시지가 정의되어 있다"
    - "BEGIN IMMEDIATE + 낙관적 잠금이 결합된 완전한 세션 갱신 트랜잭션 의사코드가 존재한다"
  artifacts:
    - path: ".planning/deliverables/53-session-renewal-protocol.md"
      provides: "낙관적 잠금 세션 갱신 패턴 + RENEWAL_CONFLICT 에러 정의"
      contains: "token_hash.*:currentTokenHash"
  key_links:
    - from: "53-session-renewal SS5 UPDATE WHERE token_hash"
      to: "34-owner-wallet markOwnerVerified() CAS 선례"
      via: "동일 패턴: WHERE + changes === 0 검사"
      pattern: "changes === 0"
    - from: "53-session-renewal RENEWAL_CONFLICT"
      to: "37-rest-api SS10.12 통합 매트릭스"
      via: "SESSION 도메인 에러 코드 등록"
      pattern: "RENEWAL_CONFLICT.*409"
---

<objective>
53-session-renewal-protocol.md SS5에 낙관적 잠금(token_hash WHERE 조건) + RENEWAL_CONFLICT(409) 에러를 추가한다.

Purpose: 세션 갱신 시 동시 요청이 발생하면 첫 번째 요청만 성공하고 두 번째 요청은 명확한 409 에러를 받도록, 기존 `WHERE id = ?` 패턴을 `WHERE id = ? AND token_hash = ?` 낙관적 잠금으로 강화한다. 이 패턴은 34-owner-wallet의 markOwnerVerified() CAS와 동일한 프로젝트 내 선례를 따른다.
Output: 53-session-renewal SS5에 낙관적 잠금 SQL + RENEWAL_CONFLICT 에러 정의 + 갱신 서비스 의사코드 업데이트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/deliverables/53-session-renewal-protocol.md
@.planning/deliverables/34-owner-wallet-connection.md
@.planning/phases/43-concurrency-execution-completion/43-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 세션 갱신 낙관적 잠금 패턴 + RENEWAL_CONFLICT 에러 추가</name>
  <files>.planning/deliverables/53-session-renewal-protocol.md</files>
  <action>
53-session-renewal-protocol.md의 SS5를 다음과 같이 수정한다:

**1) SS5.4 "동시 갱신 방어" 서브섹션 강화:**

기존 SS5.4는 "BEGIN IMMEDIATE가 자연스럽게 직렬화"한다고 설명한다. 이 설명은 유지하되, 그 한계와 낙관적 잠금의 필요성을 추가한다:

```markdown
[v0.10] **낙관적 잠금 강화:**

BEGIN IMMEDIATE는 동시 WRITE 충돌(SQLITE_BUSY)을 방지하지만, 다음 시나리오를 해결하지 못한다:
1. 요청 A가 세션을 SELECT로 읽고 token_hash_A를 확인
2. 요청 B가 같은 세션을 SELECT로 읽고 동일한 token_hash_A를 확인
3. 요청 A가 UPDATE 실행 → token_hash를 hash_B로 변경 → 성공
4. 요청 B가 UPDATE 실행 → token_hash를 hash_C로 변경 → 성공 (hash_B를 덮어씀!)

요청 A가 발급한 토큰(hash_B)이 무효화되는데, 요청 A의 클라이언트는 이를 모른다.

**해결:** UPDATE의 WHERE 절에 `token_hash = :currentTokenHash`를 추가하여, 조회 시점과 갱신 시점의 token_hash가 동일할 때만 UPDATE가 성공한다. changes === 0이면 다른 요청이 먼저 갱신한 것이므로 RENEWAL_CONFLICT(409)를 반환한다.

이 패턴은 34-owner-wallet-connection의 markOwnerVerified() CAS와 동일한 프로젝트 내 선례를 따른다.
```

**2) SS5.5 갱신 서비스 코드의 UPDATE SQL 수정:**

기존:
```sql
UPDATE sessions SET
  token_hash = ?,
  expires_at = ?,
  renewal_count = ?,
  last_renewed_at = ?
WHERE id = ?
```

변경 후:
```sql
UPDATE sessions SET
  token_hash = :newTokenHash,
  expires_at = :newExpiresAt,
  renewal_count = renewal_count + 1,
  last_renewed_at = :now
WHERE id = :id AND token_hash = :currentTokenHash
```

핵심 변경:
- `WHERE id = ?` → `WHERE id = :id AND token_hash = :currentTokenHash` (낙관적 잠금)
- `renewal_count = ?` → `renewal_count = renewal_count + 1` (원자적 증가)
- 바인드 파라미터를 named parameter 스타일(`:name`)로 통일 (가독성 향상)

**3) SS5.5 갱신 서비스 코드에 changes 검사 + RENEWAL_CONFLICT 반환 로직 추가:**

UPDATE 실행 직후:
```typescript
if (result.changes === 0) {
  // 다른 요청이 먼저 token_hash를 교체함 → 낙관적 잠금 실패
  throw new RenewalConflictError()
}
```

트랜잭션 외부에서:
```typescript
try {
  renewTx.immediate()  // BEGIN IMMEDIATE
} catch (err) {
  if (err instanceof RenewalConflictError) {
    return {
      success: false,
      error: {
        code: 'RENEWAL_CONFLICT',
        message: '다른 요청이 먼저 세션을 갱신했습니다. 새 토큰으로 재시도하세요.',
        status: 409,
        retryable: false,
      },
    }
  }
  throw err
}
```

**4) SS5 내에 "RENEWAL_CONFLICT 에러 정의" 서브섹션 추가:**

```markdown
[v0.10] **RENEWAL_CONFLICT 에러 코드:**

| 필드 | 값 |
|------|-----|
| code | RENEWAL_CONFLICT |
| HTTP | 409 Conflict |
| domain | SESSION |
| retryable | false |
| message | "다른 요청이 먼저 세션을 갱신했습니다. 새 토큰으로 재시도하세요." |

**클라이언트 처리 가이드:**
- 409를 받은 클라이언트는 구 토큰으로 재시도하면 안 된다 (이미 무효화됨)
- 새 API 호출로 현재 세션 상태를 확인하거나, 다른 세션 생성이 필요
- AI 에이전트의 단일 프로세스 환경에서 동시 갱신은 거의 발생하지 않음 -- 이 패턴은 방어적 설계

**Note:** 이 에러 코드는 37-rest-api SS10.12 통합 매트릭스에도 등록되어야 한다. 구현 시 SS10.12에 SESSION 도메인 행으로 추가.
```

**5) 변경 이력 업데이트:**

문서 상단 변경 이력 또는 메타데이터에 "[v0.10] SS5: 낙관적 잠금(token_hash WHERE 조건) + RENEWAL_CONFLICT(409) 에러 추가 (CONC-02)" 기록.

**주의사항:**
- SS5.5의 기존 전체 구조(트랜잭션 내 감사 로그 INSERT, JWT 생성, 응답 형식 등)는 유지한다. 수정 대상은 UPDATE SQL과 changes 검사 로직에 한정.
- 기존 SS5.4의 BEGIN IMMEDIATE 설명도 유지한다. 낙관적 잠금은 이에 **추가**하는 보강이지 대체가 아니다.
- better-sqlite3의 `.immediate()` 호출 패턴은 기존 코드와 동일하게 유지.
  </action>
  <verify>
검증 명령:
1. `grep -c "currentTokenHash\|:currentTokenHash" .planning/deliverables/53-session-renewal-protocol.md` -- 3회 이상 출현 (SQL + 설명 + 바인딩)
2. `grep -c "RENEWAL_CONFLICT" .planning/deliverables/53-session-renewal-protocol.md` -- 5회 이상 출현 (에러 정의 + throw + catch + 반환 + 설명)
3. `grep "409" .planning/deliverables/53-session-renewal-protocol.md` -- 409 Conflict 존재
4. `grep "changes === 0" .planning/deliverables/53-session-renewal-protocol.md` -- changes 검사 존재
5. `grep "token_hash = :currentTokenHash\|AND token_hash" .planning/deliverables/53-session-renewal-protocol.md` -- WHERE 절 낙관적 잠금 존재
  </verify>
  <done>
53-session-renewal SS5에 `WHERE id = :id AND token_hash = :currentTokenHash` 낙관적 잠금 패턴이 SQL 수준으로 정의되어 있고, changes === 0 시 RENEWAL_CONFLICT(409) 에러를 반환하는 로직이 완전한 의사코드로 존재한다. RENEWAL_CONFLICT 에러 코드(HTTP 409, retryable: false)의 정의와 클라이언트 처리 가이드가 포함되어 있다.
  </done>
</task>

</tasks>

<verification>
Phase 43 Success Criteria #2 충족 확인:
- [ ] 53-session-renewal SS5에 `token_hash = :currentTokenHash` 낙관적 잠금 패턴이 존재한다
- [ ] RENEWAL_CONFLICT(409) 에러 반환 로직이 SQL 수준으로 정의되어 있다
- [ ] changes === 0 검사로 동시 갱신을 감지하는 패턴이 포함되어 있다
- [ ] RENEWAL_CONFLICT 에러 코드(domain, HTTP, retryable)가 정의되어 있다
- [ ] 클라이언트 처리 가이드가 포함되어 있다
</verification>

<success_criteria>
1. 세션 갱신 UPDATE SQL에 `AND token_hash = :currentTokenHash` 조건이 추가되어 있다
2. changes === 0 시 RENEWAL_CONFLICT 에러를 throw하는 로직이 존재한다
3. RENEWAL_CONFLICT 에러 코드(409, retryable: false, SESSION 도메인)가 정의되어 있다
4. SS5.4에 낙관적 잠금의 필요성과 BEGIN IMMEDIATE와의 관계가 설명되어 있다
5. 클라이언트 처리 가이드(구 토큰 재사용 금지)가 포함되어 있다
</success_criteria>

<output>
After completion, create `.planning/phases/43-concurrency-execution-completion/43-02-SUMMARY.md`
</output>
