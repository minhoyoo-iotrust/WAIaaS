---
phase: 43-concurrency-execution-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/36-killswitch-autostop-evm.md
autonomous: true

must_haves:
  truths:
    - "36-killswitch SS3.1의 NORMAL->ACTIVATED 전이에 WHERE value = '\"NORMAL\"' CAS 조건이 포함되어 있다"
    - "36-killswitch의 ACTIVATED->RECOVERING 전이에 WHERE value = '\"ACTIVATED\"' CAS 조건이 포함되어 있다"
    - "36-killswitch의 RECOVERING->NORMAL 전이에 WHERE value = '\"RECOVERING\"' CAS 조건이 포함되어 있다"
    - "36-killswitch의 RECOVERING->ACTIVATED 전이(복구 실패 롤백)에 WHERE value = '\"RECOVERING\"' CAS 조건이 포함되어 있다"
    - "모든 CAS 실패(changes === 0) 시 전이별 409 에러 코드(KILL_SWITCH_ALREADY_ACTIVE, RECOVERY_ALREADY_STARTED 등)가 정의되어 있다"
  artifacts:
    - path: ".planning/deliverables/36-killswitch-autostop-evm.md"
      provides: "Kill Switch CAS 상태 전이 패턴 + 전이별 에러 코드"
      contains: "WHERE.*value.*=.*:expectedState"
  key_links:
    - from: "36-killswitch SS3.1 CAS UPDATE"
      to: "34-owner-wallet markOwnerVerified() CAS 선례"
      via: "동일 패턴: UPDATE WHERE value = :expected + changes === 0"
      pattern: "changes === 0"
    - from: "36-killswitch CAS 에러 코드"
      to: "37-rest-api SS10.12 통합 매트릭스"
      via: "SYSTEM 도메인 에러 코드 등록"
      pattern: "KILL_SWITCH_ALREADY_ACTIVE"
---

<objective>
36-killswitch-autostop-evm.md SS3.1의 모든 상태 전이에 `WHERE value = :expectedState` CAS(Compare-And-Swap) 패턴을 추가한다.

Purpose: Kill Switch의 동시 발동/복구 레이스를 원자적으로 방지하여, 구현자가 각 상태 전이의 ACID 안전성을 추측 없이 구현할 수 있도록 한다. 이 패턴은 34-owner-wallet의 markOwnerVerified() CAS와 동일한 프로젝트 내 선례를 따른다.
Output: 36-killswitch SS3.1에 4개 전이의 CAS SQL + 전이별 에러 코드 + 에러 처리 로직
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/deliverables/36-killswitch-autostop-evm.md
@.planning/deliverables/34-owner-wallet-connection.md
@.planning/phases/43-concurrency-execution-completion/43-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kill Switch 4개 상태 전이 CAS 패턴 + 전이별 에러 코드 추가</name>
  <files>.planning/deliverables/36-killswitch-autostop-evm.md</files>
  <action>
36-killswitch-autostop-evm.md의 SS3.1 (캐스케이드 프로토콜) 및 SS4 (복구 절차)를 다음과 같이 수정한다:

**1) SS3.1 activate() 함수에 CAS 패턴 추가:**

기존 activate() 내의 `UPDATE system_state SET value = '"ACTIVATED"' WHERE key = 'kill_switch_status'` 패턴을 다음으로 교체:

```typescript
// [v0.10] CAS (Compare-And-Swap) 패턴: NORMAL -> ACTIVATED
// 선례: 34-owner-wallet markOwnerVerified() WHERE owner_verified = 0
const activateTx = sqlite.transaction(() => {
  // CAS: 현재 상태가 NORMAL일 때만 ACTIVATED로 전이
  const result = sqlite.prepare(`
    UPDATE system_state
    SET value = '"ACTIVATED"', updated_at = :now
    WHERE key = 'kill_switch_status' AND value = '"NORMAL"'
  `).run({ now: nowEpoch })

  if (result.changes === 0) {
    // 이미 ACTIVATED이거나 RECOVERING 상태
    throw new KillSwitchAlreadyActiveError()
  }

  // Step 1: 모든 활성 세션 폐기
  sqlite.prepare(`
    UPDATE sessions SET revoked_at = :now WHERE revoked_at IS NULL
  `).run({ now: nowEpoch })

  // Step 2: 진행 중 거래 취소 (QUEUED/EXECUTING -> CANCELLED)
  sqlite.prepare(`
    UPDATE transactions SET status = 'CANCELLED', updated_at = :now
    WHERE status IN ('QUEUED', 'EXECUTING')
  `).run({ now: nowEpoch })

  // Step 3: 감사 로그
  sqlite.prepare(`
    INSERT INTO audit_log (id, event_type, actor, severity, details, timestamp)
    VALUES (:id, 'KILL_SWITCH_ACTIVATED', 'system', 'critical',
            :details, :now)
  `).run({ id: generateUuidV7(), details: JSON.stringify({ trigger: reason }), now: nowEpoch })
})

activateTx.immediate()  // BEGIN IMMEDIATE로 직렬화
```

핵심: CAS UPDATE가 트랜잭션의 **첫 번째 문장**이어야 한다. changes === 0이면 즉시 throw하여 이후 캐스케이드(세션 폐기, 거래 취소)가 실행되지 않는다.

**2) SS4 recover Step 1에 CAS 패턴 추가: ACTIVATED -> RECOVERING:**

```typescript
// [v0.10] CAS: ACTIVATED -> RECOVERING
const beginRecoveryTx = sqlite.transaction(() => {
  const result = sqlite.prepare(`
    UPDATE system_state
    SET value = '"RECOVERING"', updated_at = :now
    WHERE key = 'kill_switch_status' AND value = '"ACTIVATED"'
  `).run({ now: nowEpoch })

  if (result.changes === 0) {
    // 현재 상태 조회하여 적절한 에러 반환
    const current = sqlite.prepare(
      'SELECT value FROM system_state WHERE key = ?'
    ).get('kill_switch_status')

    if (current?.value === '"NORMAL"') throw new KillSwitchNotActiveError()
    if (current?.value === '"RECOVERING"') throw new RecoveryAlreadyStartedError()
    throw new InvalidKillSwitchStateError()
  }

  // 감사 로그
  sqlite.prepare(`
    INSERT INTO audit_log (id, event_type, actor, severity, details, timestamp)
    VALUES (:id, 'KILL_SWITCH_RECOVERY_STARTED', 'owner', 'warning', '{}', :now)
  `).run({ id: generateUuidV7(), now: nowEpoch })
})

beginRecoveryTx.immediate()
```

**3) SS4 recover Step 2에 CAS 패턴 추가: RECOVERING -> NORMAL:**

```typescript
// [v0.10] CAS: RECOVERING -> NORMAL
const completeRecoveryTx = sqlite.transaction(() => {
  const result = sqlite.prepare(`
    UPDATE system_state
    SET value = '"NORMAL"', updated_at = :now
    WHERE key = 'kill_switch_status' AND value = '"RECOVERING"'
  `).run({ now: nowEpoch })

  if (result.changes === 0) {
    // 복구 중 다시 Kill Switch가 발동되었을 수 있음
    throw new InvalidRecoveryStateError()
  }

  // kill_switch 관련 카운터 초기화
  // 에이전트 재활성화 등 (기존 복구 절차 로직 유지)

  // 감사 로그
  sqlite.prepare(`
    INSERT INTO audit_log (id, event_type, actor, severity, details, timestamp)
    VALUES (:id, 'KILL_SWITCH_RECOVERY_COMPLETED', 'owner', 'info', '{}', :now)
  `).run({ id: generateUuidV7(), now: nowEpoch })
})

completeRecoveryTx.immediate()
```

**4) SS4에 recover 실패 롤백 CAS 추가: RECOVERING -> ACTIVATED:**

```typescript
// [v0.10] CAS: RECOVERING -> ACTIVATED (복구 실패 시 롤백)
const rollbackRecoveryTx = sqlite.transaction(() => {
  const result = sqlite.prepare(`
    UPDATE system_state
    SET value = '"ACTIVATED"', updated_at = :now
    WHERE key = 'kill_switch_status' AND value = '"RECOVERING"'
  `).run({ now: nowEpoch })

  if (result.changes === 0) {
    throw new InvalidRecoveryStateError()
  }

  // 감사 로그
  sqlite.prepare(`
    INSERT INTO audit_log (id, event_type, actor, severity, details, timestamp)
    VALUES (:id, 'KILL_SWITCH_RECOVERY_FAILED', 'owner', 'critical',
            :details, :now)
  `).run({ id: generateUuidV7(), details: JSON.stringify({ reason: failureReason }), now: nowEpoch })
})

rollbackRecoveryTx.immediate()
```

**5) "Kill Switch CAS 에러 코드" 서브섹션 추가 (SS3.1 또는 SS4 적절한 위치):**

```markdown
[v0.10] **Kill Switch CAS 에러 코드:**

| 전이 시도 | CAS 실패 원인 | 에러 코드 | HTTP |
|----------|-------------|----------|:----:|
| NORMAL -> ACTIVATED | 이미 ACTIVATED 또는 RECOVERING | KILL_SWITCH_ALREADY_ACTIVE | 409 |
| ACTIVATED -> RECOVERING | 이미 NORMAL (비활성) | KILL_SWITCH_NOT_ACTIVE | 409 |
| ACTIVATED -> RECOVERING | 이미 RECOVERING (중복 복구) | RECOVERY_ALREADY_STARTED | 409 |
| RECOVERING -> NORMAL | 복구 중 재발동으로 상태 변경됨 | INVALID_RECOVERY_STATE | 409 |
| RECOVERING -> ACTIVATED | 복구 중 다른 전이로 상태 변경됨 | INVALID_RECOVERY_STATE | 409 |

모든 CAS 실패는 HTTP 409 Conflict로 반환한다. 이는 "클라이언트 요청은 올바르나, 현재 서버 상태와 충돌"을 의미한다.

**Note:** 이 에러 코드들은 37-rest-api SS10.12 통합 매트릭스에도 등록되어야 한다. 구현 시 SYSTEM 도메인 행으로 추가.
```

**6) SS3.1에 "CAS 패턴 설명" 추가:**

```markdown
[v0.10] **CAS (Compare-And-Swap) 패턴 원칙:**

1. CAS UPDATE는 BEGIN IMMEDIATE 트랜잭션의 **첫 번째 문장**이어야 한다
2. `changes === 0`이면 즉시 throw → 이후 캐스케이드 로직이 실행되지 않음
3. 현재 상태가 예상과 다른 경우, SELECT로 실제 상태를 조회하여 적절한 에러 코드를 선택한다
4. CAS 범위는 `kill_switch_status` 전이에만 적용한다. Step 1-3 캐스케이드(세션 폐기, 거래 취소, 에이전트 정지)는 동일 트랜잭션 내에서 원자적으로 실행되므로 별도 CAS 불필요
5. 선례: 34-owner-wallet-connection markOwnerVerified() `WHERE owner_verified = 0` + changes 확인
```

**7) 변경 이력 업데이트:**

문서 상단 변경 이력 또는 메타데이터에 "[v0.10] SS3.1/SS4: 모든 상태 전이에 CAS(Compare-And-Swap) ACID 패턴 추가 (CONC-03)" 기록.

**주의사항:**
- 기존 SS3.1의 캐스케이드 로직(Step 1-6)은 유지한다. CAS는 상태 전이 UPDATE에만 추가하는 것이며, 기존 캐스케이드 로직의 구조를 변경하지 않는다.
- 기존 SS4의 복구 절차 2단계 구조(Step 1: 복구 시작, Step 2: 복구 완료)는 유지한다.
- system_state 테이블의 value 필드가 JSON 문자열(`'"NORMAL"'`)로 저장되는 것은 25-sqlite의 기존 패턴이다. CAS SQL에서도 이 형식을 사용한다.
- 기존 시퀀스 다이어그램이 있다면 CAS 조건을 반영하여 보강하되, 다이어그램 전체를 재작성하지 않는다.
  </action>
  <verify>
검증 명령:
1. `grep -c "WHERE.*key.*=.*kill_switch_status.*AND.*value" .planning/deliverables/36-killswitch-autostop-evm.md` -- 4회 이상 출현 (4개 전이)
2. `grep -c "changes === 0" .planning/deliverables/36-killswitch-autostop-evm.md` -- 4회 이상 출현 (각 전이별 검사)
3. `grep -c "KILL_SWITCH_ALREADY_ACTIVE\|RECOVERY_ALREADY_STARTED\|KILL_SWITCH_NOT_ACTIVE\|INVALID_RECOVERY_STATE" .planning/deliverables/36-killswitch-autostop-evm.md` -- 8회 이상 출현
4. `grep "CAS\|Compare-And-Swap" .planning/deliverables/36-killswitch-autostop-evm.md` -- CAS 패턴 설명 존재
5. `grep ".immediate()" .planning/deliverables/36-killswitch-autostop-evm.md` -- BEGIN IMMEDIATE 패턴 존재
  </verify>
  <done>
36-killswitch SS3.1/SS4의 4개 상태 전이(NORMAL->ACTIVATED, ACTIVATED->RECOVERING, RECOVERING->NORMAL, RECOVERING->ACTIVATED) 모두에 `WHERE value = :expectedState` CAS 조건이 포함된 SQL이 정의되어 있고, 각 CAS 실패 시 적절한 409 에러 코드(KILL_SWITCH_ALREADY_ACTIVE, RECOVERY_ALREADY_STARTED, KILL_SWITCH_NOT_ACTIVE, INVALID_RECOVERY_STATE)가 정의되어 있다. CAS 패턴 원칙 5개 항목과 범위 제한(kill_switch_status 전이에만 적용)이 명시되어 있다.
  </done>
</task>

</tasks>

<verification>
Phase 43 Success Criteria #3 충족 확인:
- [ ] 36-killswitch SS3.1의 NORMAL->ACTIVATED 전이에 `WHERE value = '"NORMAL"'` CAS 조건이 있다
- [ ] ACTIVATED->RECOVERING 전이에 `WHERE value = '"ACTIVATED"'` CAS 조건이 있다
- [ ] RECOVERING->NORMAL 전이에 `WHERE value = '"RECOVERING"'` CAS 조건이 있다
- [ ] RECOVERING->ACTIVATED 전이(복구 실패 롤백)에 CAS 조건이 있다
- [ ] 모든 전이에서 changes === 0 시 적절한 409 에러 코드가 반환된다
- [ ] CAS 패턴 원칙이 문서화되어 있다
</verification>

<success_criteria>
1. 4개 상태 전이 모두에 `WHERE key = 'kill_switch_status' AND value = :expectedState` CAS SQL이 존재한다
2. 각 전이별 changes === 0 처리 로직(throw + 에러 코드)이 정의되어 있다
3. 전이별 에러 코드 테이블(5행)이 존재하고, 모든 에러가 HTTP 409이다
4. CAS 패턴 원칙(5항목)이 설명되어 있다
5. BEGIN IMMEDIATE + CAS가 결합된 완전한 트랜잭션 의사코드가 activate(), beginRecovery(), completeRecovery(), rollbackRecovery() 4개 함수에 존재한다
</success_criteria>

<output>
After completion, create `.planning/phases/43-concurrency-execution-completion/43-03-SUMMARY.md`
</output>
