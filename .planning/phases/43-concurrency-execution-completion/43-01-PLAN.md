---
phase: 43-concurrency-execution-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/deliverables/32-transaction-pipeline-api.md
autonomous: true

must_haves:
  truths:
    - "32-pipeline SS5에 Stage 5 완전 실행 루프 의사코드(build->simulate->sign->submit + 외부 재시도 루프)가 존재한다"
    - "에러 발생 시 ChainError category(PERMANENT/TRANSIENT/STALE)에 따른 분기 로직이 switch문으로 정의되어 있다"
    - "TRANSIENT은 실패한 단계에서 지수 백오프(1s,2s,4s) max 3회 재시도하고, STALE은 Stage 5a로 복귀하여 1회 재빌드 재시도한다"
    - "티어별 타임아웃(INSTANT/NOTIFY=30초, DELAY/APPROVAL=60초)이 AbortController 패턴으로 정의되어 있다"
    - "EVM_GAS_TOO_LOW 특수 처리(TRANSIENT이지만 gas limit 1.2x 상향 후 Stage 5a 재빌드)가 명시되어 있다"
  artifacts:
    - path: ".planning/deliverables/32-transaction-pipeline-api.md"
      provides: "Stage 5 완전 의사코드 + 에러 분기 + 티어별 타임아웃"
      contains: "executeStage5"
  key_links:
    - from: "32-pipeline SS5 Stage 5 의사코드"
      to: "27-chain-adapter SS4.5 ChainError category"
      via: "err.category switch 분기"
      pattern: "err\\.category"
    - from: "32-pipeline 티어별 타임아웃"
      to: "32-pipeline SS4 티어 분류 (INSTANT/NOTIFY/DELAY/APPROVAL)"
      via: "tier 파라미터로 30초/60초 분기"
      pattern: "INSTANT.*NOTIFY.*30.*DELAY.*APPROVAL.*60"
---

<objective>
32-transaction-pipeline-api.md SS5에 Stage 5 완전 실행 의사코드를 추가한다.

Purpose: 구현자가 트랜잭션 실행의 build->simulate->sign->submit 4단계, ChainError category 기반 에러 분기(PERMANENT/TRANSIENT/STALE), 티어별 타임아웃(30초/60초)을 추측 없이 코드로 옮길 수 있도록 완전한 의사코드와 에러 분기 플로우를 정의한다.
Output: 32-pipeline SS5에 executeStage5() 완전 의사코드 + 에러 분기 플로우 + 티어별 타임아웃 테이블
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/deliverables/32-transaction-pipeline-api.md
@.planning/deliverables/27-chain-adapter-interface.md
@.planning/phases/43-concurrency-execution-completion/43-RESEARCH.md
@.planning/phases/42-error-handling-completion/42-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stage 5 완전 실행 루프 의사코드 + 에러 분기 + 티어별 타임아웃 추가</name>
  <files>.planning/deliverables/32-transaction-pipeline-api.md</files>
  <action>
32-transaction-pipeline-api.md의 SS5 (Stage 5: 체인 실행) 섹션을 확장하여 완전한 실행 의사코드를 추가한다. 기존 Stage 5a-5d 개별 단계 설명은 유지하되, 그 아래에 통합 실행 루프를 신설한다.

**1) SS5 섹션 내에 "Stage 5 통합 실행 루프" 서브섹션 추가:**

다음 구조의 완전한 executeStage5() 의사코드를 추가한다:

```typescript
// [v0.10] Stage 5 통합 실행 루프
// SSoT: 27-chain-adapter SS4.5 ChainError category + 복구 전략 테이블

interface Stage5Options {
  txId: string
  request: TransactionRequest  // 5-type discriminatedUnion
  tier: 'INSTANT' | 'NOTIFY' | 'DELAY' | 'APPROVAL'
  adapter: IChainAdapter
  keyStore: ILocalKeyStore
  agentId: string
  sqlite: Database.Database  // better-sqlite3
}

async function executeStage5(opts: Stage5Options): Promise<SubmitResult> {
  const { txId, request, tier, adapter, keyStore, agentId, sqlite } = opts

  // 티어별 타임아웃 (SS5 타임아웃 테이블 참조)
  const timeoutMs = (tier === 'INSTANT' || tier === 'NOTIFY') ? 30_000 : 60_000
  const controller = new AbortController()
  const timer = setTimeout(() => controller.abort(), timeoutMs)

  let retryCount = 0

  try {
    // 외부 재시도 루프 (STALE은 여기로 복귀)
    buildLoop:
    while (!controller.signal.aborted) {
      try {
        // Stage 5a: build
        const unsignedTx = await buildByType(adapter, request, agentId)

        // Stage 5b: simulate
        const simResult = await adapter.simulateTransaction(unsignedTx)
        if (!simResult.success) {
          throw new ChainError({
            code: 'SIMULATION_FAILED',
            chain: request.chain,
            message: simResult.error ?? '시뮬레이션 실패',
            category: 'TRANSIENT',
          })
        }

        // DB 상태 전이: QUEUED -> EXECUTING
        transitionTo(sqlite, txId, 'QUEUED', 'EXECUTING')

        // Stage 5c: sign (guarded memory)
        const privateKey = await keyStore.getPrivateKey(agentId)
        let signedTx: SignedTransaction
        try {
          signedTx = await adapter.signTransaction(unsignedTx, privateKey)
        } finally {
          sodium_memzero(privateKey)  // 서명 후 즉시 키 제거
        }

        // Stage 5d: submit
        const submitResult = await adapter.submitTransaction(signedTx)

        // DB 상태 전이: EXECUTING -> SUBMITTED
        transitionTo(sqlite, txId, 'EXECUTING', 'SUBMITTED', {
          txHash: submitResult.txHash
        })

        return submitResult

      } catch (err) {
        if (controller.signal.aborted) {
          // 타임아웃으로 인한 abort
          transitionTo(sqlite, txId, 'EXECUTING', 'FAILED', {
            error: `STAGE5_TIMEOUT (${timeoutMs}ms)`
          })
          throw new WaiaasError('STAGE5_TIMEOUT', `Stage 5 타임아웃 (${timeoutMs}ms)`, 408)
        }

        if (!(err instanceof ChainError)) throw err

        switch (err.category) {
          case 'PERMANENT':
            // 즉시 실패, 재시도 없음
            transitionTo(sqlite, txId, 'EXECUTING', 'FAILED', {
              error: err.code
            })
            throw err

          case 'TRANSIENT':
            if (retryCount >= 3) {
              transitionTo(sqlite, txId, 'EXECUTING', 'FAILED', {
                error: `${err.code} (max retries exceeded)`
              })
              throw err
            }
            // EVM_GAS_TOO_LOW: gas limit 1.2x 상향 후 Stage 5a 재빌드
            if (err.code === 'EVM_GAS_TOO_LOW') {
              retryCount++
              continue buildLoop  // Stage 5a로 복귀 (재빌드)
            }
            // 일반 TRANSIENT: 지수 백오프 후 실패한 단계에서 재시도
            await sleep(1000 * Math.pow(2, retryCount))  // 1s, 2s, 4s
            retryCount++
            continue  // 실패한 단계에서 재시도

          case 'STALE':
            if (retryCount >= 1) {
              transitionTo(sqlite, txId, 'EXECUTING', 'FAILED', {
                error: `${err.code} (stale retry exhausted)`
              })
              throw err
            }
            retryCount++
            continue buildLoop  // Stage 5a로 복귀 (새 blockhash/nonce로 재빌드)
        }
      }
    }

    // AbortController에 의한 루프 종료
    throw new WaiaasError('STAGE5_TIMEOUT', `Stage 5 타임아웃 (${timeoutMs}ms)`, 408)

  } finally {
    clearTimeout(timer)
  }
}
```

핵심 설명 노트 (의사코드 아래에 추가):
- `buildByType(adapter, request, agentId)`: request.type에 따라 adapter.buildTransferTransaction / buildTokenTransferTransaction / buildContractCallTransaction / buildApproveTransaction 분기. 5-type discriminatedUnion의 type 필드가 결정. [v0.6] 추가 타입(BATCH 등) 포함.
- `transitionTo(sqlite, txId, fromState, toState, metadata?)`: BEGIN IMMEDIATE 트랜잭션 내에서 `UPDATE transactions SET status = :toState WHERE id = :txId AND status = :fromState` 실행. changes === 0이면 상태 불일치 에러. CAS 패턴.
- TRANSIENT 재시도는 **실패한 단계**에서 재시도한다. simulate에서 RPC_ERROR 발생 시 simulate만 재시도. build와 sign은 로컬 연산이므로 TRANSIENT 에러가 발생하지 않는다 (27-chain-adapter SS4.5 참조).
- STALE 재시도는 반드시 **Stage 5a (buildTransaction)**부터 재실행한다. 동일 빌드 결과를 재제출하면 같은 STALE 에러가 반복된다.
- DELAY/APPROVAL 티어의 재진입(승인 후): 동일한 executeStage5()를 호출하되 tier 파라미터로 60초 타임아웃이 적용된다. 재진입 트리거 자체는 Stage 4(APPROVAL 승인 대기)에서 관리한다.
- AbortController signal은 각 단계 시작 전 `controller.signal.aborted` 검사로 타임아웃을 감지한다. IChainAdapter 메서드 시그니처 변경(signal 파라미터 추가)은 구현 단계 검토 사항.

**2) SS5 내에 "티어별 타임아웃 테이블" 추가:**

```markdown
**[v0.10] Stage 5 티어별 타임아웃:**

| 티어 | 타임아웃 | 근거 |
|------|:--------:|------|
| INSTANT | 30초 | Solana blockhash ~60초 수명의 절반. 빠른 실패 원칙 |
| NOTIFY | 30초 | INSTANT과 동일. 알림은 Stage 4에서 발송 |
| DELAY | 60초 | 시간 지연 후 실행이므로 새 blockhash로 빌드. 여유 확보 |
| APPROVAL | 60초 | 승인 후 새 blockhash로 빌드. 여유 확보 |
```

기존 SS5에 "30초"로만 언급된 타임아웃을 이 테이블로 대체/보강한다.

**3) SS5 내에 "에러 분기 플로우" 추가:**

카테고리별 에러 분기를 시각적으로 정리하는 표를 추가:

```markdown
**[v0.10] Stage 5 에러 분기 요약:**

| 에러 발생 단계 | 카테고리 | 재시도 행동 | 재시도 시작 | 최대 횟수 |
|--------------|----------|-----------|:---------:|:--------:|
| 5b simulate | TRANSIENT | 지수 백오프 대기 후 5b 재시도 | 5b | 3 |
| 5d submit | TRANSIENT | 지수 백오프 대기 후 5d 재시도 | 5d | 3 |
| 5d submit | STALE | 즉시 5a로 복귀 (재빌드) | 5a | 1 |
| 어디든 | PERMANENT | 즉시 FAILED, 재시도 없음 | - | 0 |
| 5a build (EVM) | TRANSIENT (GAS_TOO_LOW) | gas 1.2x 상향 후 5a 재빌드 | 5a | 1 |
```

**4) 변경 이력 업데이트:**

문서 상단 변경 이력 또는 메타데이터에 "[v0.10] SS5: Stage 5 통합 실행 루프 의사코드 + 에러 분기 + 티어별 타임아웃 추가 (CONC-01)" 기록.

**주의사항:**
- 기존 SS5의 Stage 5a-5d 개별 설명(buildTransaction, simulateTransaction, signTransaction, submitTransaction)은 유지한다. 신규 추가는 이 개별 설명 뒤에 "통합 실행 루프" 서브섹션으로 추가.
- 27-chain-adapter SS4.5의 카테고리 분류와 복구 전략 테이블을 SSoT로 참조한다. 이 의사코드는 해당 SSoT의 **소비자**이다.
- 상태 전이(QUEUED->EXECUTING->SUBMITTED->FAILED)는 32-pipeline SS3의 8-state machine과 일치해야 한다.
  </action>
  <verify>
검증 명령:
1. `grep -c "executeStage5" .planning/deliverables/32-transaction-pipeline-api.md` -- 5회 이상 출현 (함수 정의 + 참조)
2. `grep -c "err.category\|err\.category" .planning/deliverables/32-transaction-pipeline-api.md` -- 3회 이상 출현 (switch 분기)
3. `grep "INSTANT.*30\|NOTIFY.*30\|DELAY.*60\|APPROVAL.*60" .planning/deliverables/32-transaction-pipeline-api.md` -- 티어별 타임아웃 존재
4. `grep "EVM_GAS_TOO_LOW" .planning/deliverables/32-transaction-pipeline-api.md` -- 특수 처리 존재
5. `grep "통합 실행 루프\|Stage 5 통합" .planning/deliverables/32-transaction-pipeline-api.md` -- 서브섹션 존재
  </verify>
  <done>
32-pipeline SS5에 executeStage5() 완전 의사코드가 존재하고, ChainError category 기반 PERMANENT/TRANSIENT/STALE 에러 분기가 switch문으로 정의되어 있으며, 티어별 타임아웃(INSTANT/NOTIFY=30초, DELAY/APPROVAL=60초) 테이블과 에러 분기 요약 테이블이 포함되어 있다. 구현자가 이 의사코드를 직접 코드로 변환할 수 있는 상태.
  </done>
</task>

</tasks>

<verification>
Phase 43 Success Criteria #1 충족 확인:
- [ ] 32-pipeline SS5에 Stage 5 완전 의사코드(build->simulate->sign->submit + 에러 분기 + STALE/TRANSIENT 재시도 로직)가 존재한다
- [ ] 티어별 타임아웃(INSTANT/NOTIFY=30초, DELAY/APPROVAL=60초)이 명시되어 있다
- [ ] ChainError category 기반 switch 분기가 정의되어 있다
- [ ] TRANSIENT은 실패한 단계에서 max 3회 지수 백오프, STALE은 Stage 5a로 1회 복귀
- [ ] EVM_GAS_TOO_LOW 특수 처리가 명시되어 있다
- [ ] AbortController 타임아웃 패턴이 포함되어 있다
</verification>

<success_criteria>
1. executeStage5() 함수 시그니처와 완전한 실행 루프가 32-pipeline SS5에 존재한다
2. err.category에 따른 PERMANENT/TRANSIENT/STALE 3-분기가 switch문으로 정의되어 있다
3. 티어별 타임아웃 테이블(4행)이 존재하고, INSTANT/NOTIFY=30초, DELAY/APPROVAL=60초가 명시되어 있다
4. 에러 분기 요약 테이블이 존재하고, 각 에러 유형별 재시도 시작 단계와 최대 횟수가 명시되어 있다
5. transitionTo() CAS 패턴이 의사코드 내에서 사용되고, DB 상태 전이가 8-state machine과 일치한다
</success_criteria>

<output>
After completion, create `.planning/phases/43-concurrency-execution-completion/43-01-SUMMARY.md`
</output>
