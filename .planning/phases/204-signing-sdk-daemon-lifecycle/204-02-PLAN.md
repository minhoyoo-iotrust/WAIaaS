---
phase: 204-signing-sdk-daemon-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["204-01"]
files_modified:
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/__tests__/signing-sdk-lifecycle.test.ts
autonomous: true
requirements: [CHAN-04]

must_haves:
  truths:
    - "signResponseHandler가 TelegramBotService에 주입되어 /sign_response 명령어가 'not enabled' 대신 실제 처리를 수행한다"
    - "signing SDK 라이프사이클 통합 테스트가 인스턴스화, 라우팅, shutdown을 검증한다"
  artifacts:
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "signResponseHandler injection into TelegramBotService"
      contains: "signResponseHandler"
    - path: "packages/daemon/src/__tests__/signing-sdk-lifecycle.test.ts"
      provides: "Integration tests for signing SDK lifecycle wiring"
      contains: "signing-sdk lifecycle"
  key_links:
    - from: "daemon.ts Step 4c-8"
      to: "TelegramBotService.signResponseHandler"
      via: "late-binding injection after both are created"
      pattern: "signResponseHandler"
---

<objective>
Inject signResponseHandler into TelegramBotService in daemon.ts and create integration tests for the signing SDK lifecycle wiring.

Purpose: Close GAP-2 (CHAN-04) and verify that the complete signing SDK lifecycle from Plan 204-01 works correctly as a unit. Without signResponseHandler injection, /sign_response Telegram command always returns "not enabled".

Output: daemon.ts with signResponseHandler injection, integration test file verifying lifecycle wiring.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/v2.6.1-MILESTONE-AUDIT.md
@.planning/phases/204-signing-sdk-daemon-lifecycle/204-01-PLAN.md
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts
@packages/daemon/src/services/signing-sdk/sign-response-handler.ts
@packages/daemon/src/services/signing-sdk/approval-channel-router.ts
@packages/daemon/src/__tests__/signing-sdk-e2e.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject signResponseHandler into TelegramBotService in daemon.ts</name>
  <files>packages/daemon/src/lifecycle/daemon.ts</files>
  <action>
  In daemon.ts Step 4c-8 (created by Plan 204-01), after all signing SDK classes are instantiated, inject signResponseHandler into TelegramBotService.

  **TelegramBotService already accepts signResponseHandler in its constructor** (see TelegramBotServiceOptions interface). The issue is that at daemon.ts line 583, TelegramBotService is created in Step 4c-5 BEFORE Step 4c-8 creates signResponseHandler. Two approaches:

  **Approach: Late-binding setter** -- TelegramBotService already stores signResponseHandler as a private field. Add a public setter method OR pass via constructor. Since TelegramBotService constructor already accepts `signResponseHandler?: SignResponseHandler`, the cleanest fix is to set it after creation.

  Check TelegramBotService for an existing setter method. If none exists, add one:

  In `packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts`, add a public method:
  ```typescript
  /** Set the signResponseHandler for /sign_response command (late-binding from signing SDK lifecycle). */
  setSignResponseHandler(handler: SignResponseHandler): void {
    this.signResponseHandler = handler;
  }
  ```
  Add this after the constructor (around line 98). This is the same pattern used by VersionCheckService.setNotificationService() in daemon.ts.

  Then in daemon.ts Step 4c-8, after creating signResponseHandler, add:
  ```typescript
  // Inject signResponseHandler into TelegramBotService for /sign_response command (GAP-2)
  if (this.telegramBotService) {
    this.telegramBotService.setSignResponseHandler(signResponseHandler);
    console.debug('Step 4c-8: signResponseHandler injected into TelegramBotService');
  }
  ```

  **File also modified:** packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts (add setter method).
  </action>
  <verify>
  1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
  2. Grep daemon.ts for "setSignResponseHandler" confirms injection
  3. Grep telegram-bot-service.ts for "setSignResponseHandler" confirms setter method exists
  </verify>
  <done>
  signResponseHandler is injected into TelegramBotService via setSignResponseHandler() in daemon.ts Step 4c-8. /sign_response command now has access to the handler for processing wallet app responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Signing SDK lifecycle integration tests</name>
  <files>packages/daemon/src/__tests__/signing-sdk-lifecycle.test.ts</files>
  <action>
  Create integration tests verifying the signing SDK lifecycle wiring works correctly. These tests verify that the classes are properly instantiated and connected, not full E2E ntfy/Telegram communication (that's covered by existing signing-sdk-e2e.test.ts).

  Create `packages/daemon/src/__tests__/signing-sdk-lifecycle.test.ts` with the following test cases:

  **Test setup:** Use the pattern from existing daemon tests. Create a minimal test environment with:
  - In-memory SQLite database (via better-sqlite3)
  - SettingsService with signing_sdk.enabled = 'true'
  - Mock/stub dependencies

  **Test cases:**

  1. **"SignRequestBuilder is instantiated with SettingsService and WalletLinkRegistry"**
     - Create SettingsService, WalletLinkRegistry, SignRequestBuilder
     - Verify SignRequestBuilder exists (not null)
     - Verify it has buildRequest method

  2. **"SignResponseHandler is instantiated with sqlite"**
     - Create SignResponseHandler with sqlite
     - Verify it exists and has handle/registerRequest methods

  3. **"NtfySigningChannel is instantiated with required dependencies"**
     - Create all deps, then NtfySigningChannel
     - Verify it exists and has sendRequest/shutdown methods

  4. **"TelegramSigningChannel is instantiated with required dependencies"**
     - Create all deps including mock TelegramApi
     - Verify it exists and has sendRequest/shutdown methods

  5. **"ApprovalChannelRouter is instantiated with sqlite, settingsService, and channels"**
     - Create all deps, both channels, then ApprovalChannelRouter
     - Verify it exists and has route/shutdown methods

  6. **"ApprovalChannelRouter.route() dispatches to ntfy channel when owner_approval_method is sdk_ntfy"**
     - Set up wallet in DB with owner_approval_method = 'sdk_ntfy'
     - Mock ntfyChannel.sendRequest to return { requestId: 'test-id', requestTopic: 't', responseTopic: 'r' }
     - Call router.route(walletId, params)
     - Verify ntfyChannel.sendRequest was called
     - Verify result.method === 'sdk_ntfy'

  7. **"ApprovalChannelRouter.route() dispatches to telegram channel when owner_approval_method is sdk_telegram"**
     - Same as above but with sdk_telegram and mock telegramChannel

  8. **"ApprovalChannelRouter.shutdown() calls shutdown on both channels"**
     - Create router with both channels (mock)
     - Call router.shutdown()
     - Verify both channel shutdown() methods were called

  9. **"signing SDK classes are not instantiated when signing_sdk.enabled is false"**
     - Verify that when settings.get('signing_sdk.enabled') returns 'false', the SDK should not be created
     - This tests the conditional logic pattern

  10. **"TelegramBotService.setSignResponseHandler() makes signResponseHandler available"**
      - Create TelegramBotService with mock deps (no signResponseHandler)
      - Call setSignResponseHandler(handler)
      - Verify handler is now set (test via the /sign_response command behavior change)

  **Test file structure:**
  ```typescript
  import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
  import Database from 'better-sqlite3';
  // ... imports
  ```

  Use `vi.fn()` for mocks. Follow the test patterns from existing `approval-channel-router.test.ts` for DB setup (pushSchema, insert wallet rows).

  **Important:** Do NOT test actual ntfy/Telegram network calls. Mock all external I/O. The goal is to verify the wiring (instantiation + method delegation), not the channel implementations (already tested in 202/203).
  </action>
  <verify>
  1. `pnpm turbo run test --filter=@waiaas/daemon` passes including the new test file
  2. New test file has >= 8 test cases covering all signing SDK lifecycle aspects
  3. All tests pass without network calls (fully mocked)
  </verify>
  <done>
  Integration test file covers signing SDK lifecycle: class instantiation, channel routing dispatch, shutdown cleanup, conditional initialization, and TelegramBotService signResponseHandler injection. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` -- no type errors
2. `pnpm turbo run test --filter=@waiaas/daemon` -- all tests pass including new lifecycle tests
3. signResponseHandler is injected into TelegramBotService via setter method
4. Integration tests cover instantiation, routing, shutdown, and conditional initialization
</verification>

<success_criteria>
- signResponseHandler injected into TelegramBotService (GAP-2 closed: CHAN-04)
- TelegramBotService has setSignResponseHandler() public method
- 8+ integration tests verify signing SDK lifecycle wiring
- All daemon tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/204-signing-sdk-daemon-lifecycle/204-02-SUMMARY.md`
</output>
