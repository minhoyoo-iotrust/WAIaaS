---
phase: 80-batch-transactions
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/adapters/solana/src/adapter.ts
  - packages/adapters/solana/src/__tests__/solana-batch.test.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
autonomous: true

must_haves:
  truths:
    - "SolanaAdapter.buildBatch composes 2-20 InstructionRequest items into a single atomic Solana transaction"
    - "buildBatch supports mixed instruction types (TRANSFER + TOKEN_TRANSFER + CONTRACT_CALL + APPROVE) in one batch"
    - "buildBatch automatically creates ATA instructions for TOKEN_TRANSFER recipients that lack an ATA"
    - "DatabasePolicyEngine.evaluateBatch performs 2-stage evaluation: Phase A (per-instruction) + Phase B (aggregate SPENDING_LIMIT)"
    - "Phase A denies entire batch if any single instruction violates its applicable policy (All-or-Nothing)"
    - "Phase B sums native amounts (TRANSFER.amount + CONTRACT_CALL.value) for aggregate SPENDING_LIMIT tier"
    - "APPROVE instructions in batch trigger APPROVE_TIER_OVERRIDE; final tier is max(amount tier, approve tier)"
    - "EVM adapter.buildBatch already throws BATCH_NOT_SUPPORTED (verified in Phase 77)"
    - "DB transactions table already contains parentId and batchIndex columns (from Phase 48 initial schema) — no migration needed. Phase 81 wires Stage 6 to INSERT parent-child rows during pipeline execution (BATCH-03 DB recording is a pipeline integration concern)"
  artifacts:
    - path: "packages/adapters/solana/src/adapter.ts"
      provides: "SolanaAdapter.buildBatch real implementation replacing Phase 76 stub"
      contains: "async buildBatch"
    - path: "packages/adapters/solana/src/__tests__/solana-batch.test.ts"
      provides: "buildBatch unit tests: mixed types, ATA creation, size validation, error cases"
      min_lines: 100
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateBatch method with 2-stage policy evaluation"
      contains: "evaluateBatch"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "evaluateBatch tests: Phase A individual deny, Phase B aggregate, All-or-Nothing"
      min_lines: 50
  key_links:
    - from: "packages/adapters/solana/src/adapter.ts"
      to: "@solana/kit pipe pattern"
      via: "appendTransactionMessageInstruction loop over converted instructions"
      pattern: "appendTransactionMessageInstruction.*txMessage"
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "existing evaluate() method"
      via: "evaluateBatch reuses evaluateWhitelist/evaluateAllowedTokens/evaluateContractWhitelist/evaluateApprovedSpenders/evaluateApproveAmountLimit per instruction"
      pattern: "evaluateBatch"
---

<objective>
SolanaAdapter.buildBatch 실제 구현 + DatabasePolicyEngine.evaluateBatch 2단계 합산 정책 평가

Purpose: 에이전트가 Solana에서 복합 작업(ATA 생성 + approve + transfer 등)을 원자적 단일 트랜잭션으로 실행하면서, 소액 분할 우회를 2단계 합산 정책으로 방지한다.

Output:
- SolanaAdapter.buildBatch: 2-20개 InstructionRequest를 Solana instructions로 변환하고 단일 트랜잭션 조립
- DatabasePolicyEngine.evaluateBatch: Phase A (개별 instruction 정책 평가) + Phase B (합산 SPENDING_LIMIT)
- TDD 테스트: adapter + policy engine 양쪽

Scope boundary (BATCH-03):
- DB의 transactions 테이블에 parentId/batchIndex 컬럼은 Phase 48 초기 스키마에서 이미 생성됨 (ALTER TABLE 불필요)
- buildBatch가 metadata.instructionCount/instructionTypes를 반환하여 Phase 81 파이프라인이 부모-자식 행 생성에 활용
- Stage 6에서 실제 parent-child INSERT 로직은 Phase 81 (파이프라인 통합)에서 구현
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/core/src/interfaces/chain-adapter.types.ts — BatchParams interface (from, instructions[])
@packages/core/src/interfaces/IChainAdapter.ts — buildBatch signature
@packages/core/src/schemas/transaction.schema.ts — BatchRequestSchema (z.union for inner instructions)
@packages/adapters/solana/src/adapter.ts — existing buildTokenTransfer/buildContractCall/buildApprove patterns to reuse
@packages/daemon/src/pipeline/database-policy-engine.ts — existing evaluate/evaluateAndReserve + all private evaluation methods
@docs/60-batch-transaction-spec.md — design spec sections 4-5
</context>

<tasks>

<task type="auto">
  <name>Task 1: SolanaAdapter.buildBatch implementation + tests (TDD)</name>
  <files>
    packages/adapters/solana/src/adapter.ts
    packages/adapters/solana/src/__tests__/solana-batch.test.ts
  </files>
  <action>
**RED phase:** Create `packages/adapters/solana/src/__tests__/solana-batch.test.ts` with tests for buildBatch:

1. **Basic TRANSFER batch** (2 SOL transfers) -- builds single Solana tx with 2 transfer instructions
2. **Mixed instruction batch** (TRANSFER + TOKEN_TRANSFER) -- verify both instruction types in one tx
3. **TOKEN_TRANSFER with ATA creation** -- verify createAssociatedTokenIdempotent instruction auto-inserted before transferChecked when destination ATA doesn't exist
4. **CONTRACT_CALL instruction** -- verify programId/accounts/instructionData mapped correctly
5. **APPROVE instruction** -- verify ApproveChecked instruction added
6. **Instruction count validation** -- reject <2 instructions (BATCH_SIZE_EXCEEDED), reject >20 instructions
7. **Transaction size estimation** -- verify estimatedFee accounts for base fee + ATA creation costs
8. **Metadata includes batch details** -- verify metadata.instructionCount, metadata.instructionTypes

Mock setup: Same mock RPC pattern as solana-token-transfer.test.ts and solana-adapter.test.ts. Mock `getLatestBlockhash`, `getAccountInfo` (for mint/ATA checks), Token program detection.

**GREEN phase:** Replace the stub `buildBatch` in `packages/adapters/solana/src/adapter.ts`:

```typescript
async buildBatch(request: BatchParams): Promise<UnsignedTransaction> {
  const rpc = this.getRpc();
  try {
    const from = address(request.from);
    const fromSigner = createNoopSigner(from);

    // 1. Get latest blockhash
    const { value: blockhashInfo } = await rpc.getLatestBlockhash().send();

    // 2. Build base transaction message
    let txMessage = pipe(
      createTransactionMessage({ version: 0 }),
      (tx) => setTransactionMessageFeePayer(from, tx),
      (tx) => setTransactionMessageLifetimeUsingBlockhash({
        blockhash: blockhashInfo.blockhash,
        lastValidBlockHeight: blockhashInfo.lastValidBlockHeight,
      }, tx),
    );

    // 3. Validate instruction count (2-20)
    if (request.instructions.length < 2) {
      throw new ChainError('BATCH_SIZE_EXCEEDED', 'solana', {
        message: 'Batch requires at least 2 instructions',
      });
    }
    if (request.instructions.length > 20) {
      throw new ChainError('BATCH_SIZE_EXCEEDED', 'solana', {
        message: 'Batch maximum 20 instructions',
      });
    }

    // 4. Convert each instruction and append
    let ataCount = 0;
    const instructionTypes: string[] = [];

    for (const instr of request.instructions) {
      const solanaInstructions = await this.convertBatchInstruction(instr, from, fromSigner, rpc);
      // Count ATA creations (instruction list may be longer due to auto-created ATAs)
      if ('token' in instr && solanaInstructions.length > 1) {
        ataCount++;
      }
      instructionTypes.push(this.classifyInstruction(instr));
      for (const ix of solanaInstructions) {
        txMessage = appendTransactionMessageInstruction(ix, txMessage) as unknown as typeof txMessage;
      }
    }

    // 5. Compile and encode
    const compiled = compileTransaction(txMessage);
    const serialized = new Uint8Array(txEncoder.encode(compiled));

    // 6. Estimate fee: base fee + ATA rent for each needed ATA
    const estimatedFee = DEFAULT_SOL_TRANSFER_FEE + (BigInt(ataCount) * ATA_RENT_LAMPORTS);

    return {
      chain: 'solana',
      serialized,
      estimatedFee,
      expiresAt: new Date(Date.now() + 60_000),
      metadata: {
        blockhash: blockhashInfo.blockhash,
        lastValidBlockHeight: Number(blockhashInfo.lastValidBlockHeight),
        version: 0,
        instructionCount: request.instructions.length,
        instructionTypes,
        ataCreations: ataCount,
      },
    };
  } catch (error) {
    if (error instanceof ChainError) throw error;
    if (error instanceof WAIaaSError) throw error;
    throw new WAIaaSError('CHAIN_ERROR', {
      message: `Failed to build batch: ${error instanceof Error ? error.message : String(error)}`,
      cause: error instanceof Error ? error : undefined,
    });
  }
}
```

Add private helper method `convertBatchInstruction` that handles each instruction type:
- **TransferRequest** (has `to` + `amount`, no `token`): Use `getTransferSolInstruction` (same as buildTransaction)
- **TokenTransferParams** (has `token` field): Query mint for token program, findAssociatedTokenPda for source/dest, auto-create ATA if needed, getTransferCheckedInstruction (same pattern as buildTokenTransfer)
- **ContractCallParams** (has `programId`): Map accounts to AccountRole, build raw instruction (same pattern as buildContractCall)
- **ApproveParams** (has `spender`): Query mint for token program, findAssociatedTokenPda for owner ATA, getApproveCheckedInstruction (same pattern as buildApprove)

Add private helper `classifyInstruction(instr)` that returns 'TRANSFER' | 'TOKEN_TRANSFER' | 'CONTRACT_CALL' | 'APPROVE' by checking which fields are present on the instruction (since BatchParams.instructions are union types without a `type` discriminator -- distinguish by: has `spender` -> APPROVE, has `token` but no `spender` -> TOKEN_TRANSFER, has `programId` -> CONTRACT_CALL, else -> TRANSFER).

Important implementation notes:
- Use the same `as unknown as typeof txMessage` cast pattern for `appendTransactionMessageInstruction` (Solana Kit v6 brand issue)
- eslint-disable comments for `@typescript-eslint/no-unsafe-argument` and `@typescript-eslint/no-explicit-any` where needed
- Token program detection: query mint account owner field (same as buildTokenTransfer)
- Error handling: ChainError for chain-specific errors, WAIaaSError for framework errors

**REFACTOR:** Extract shared token program detection logic if duplication is excessive.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo build --filter=@waiaas/adapter-solana && pnpm vitest run --project adapter-solana -- solana-batch
```
All buildBatch tests pass. Build succeeds with no type errors.
  </verify>
  <done>
SolanaAdapter.buildBatch converts 2-20 InstructionRequest items into a single atomic Solana transaction. Mixed types (TRANSFER + TOKEN_TRANSFER + CONTRACT_CALL + APPROVE) supported. ATA auto-creation for TOKEN_TRANSFER. Instruction count 2-20 enforced. Tests cover basic batch, mixed types, ATA creation, error cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: DatabasePolicyEngine.evaluateBatch 2-stage policy + tests (TDD)</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
    packages/daemon/src/__tests__/database-policy-engine.test.ts
  </files>
  <action>
**RED phase:** Add tests to existing `packages/daemon/src/__tests__/database-policy-engine.test.ts` in a new `describe('evaluateBatch')` block:

1. **Phase A: TRANSFER whitelist deny** -- batch with 2 TRANSFERs, one to non-whitelisted address. Entire batch denied.
2. **Phase A: TOKEN_TRANSFER ALLOWED_TOKENS deny** -- batch with TOKEN_TRANSFER to non-allowed token. Entire batch denied.
3. **Phase A: CONTRACT_CALL CONTRACT_WHITELIST deny** -- batch with CONTRACT_CALL to non-whitelisted contract. Entire batch denied.
4. **Phase A: APPROVE APPROVED_SPENDERS deny** -- batch with APPROVE to non-approved spender. Entire batch denied.
5. **Phase A: all pass** -- batch where all instructions pass individual policies. Proceeds to Phase B.
6. **Phase B: aggregate SPENDING_LIMIT** -- batch with 3 TRANSFERs (100 + 200 + 300 = 600 lamports), where individual amounts are INSTANT but aggregate is NOTIFY tier.
7. **Phase B: APPROVE_TIER_OVERRIDE max** -- batch with TRANSFER (INSTANT amount) + APPROVE. Final tier = max(INSTANT, APPROVAL) = APPROVAL.
8. **No policies -> INSTANT passthrough** -- batch with no policies configured returns allowed=true, tier=INSTANT.
9. **All-or-Nothing: returns violation details** -- denied batch includes index + type + reason of violating instruction.
10. **Phase B: TOKEN_TRANSFER and APPROVE amounts not counted** -- only TRANSFER.amount and CONTRACT_CALL.value contribute to aggregate.

Test data format: `evaluateBatch(agentId, batchInstructions)` where `batchInstructions` is an array of objects with `{ type, amount, toAddress, tokenAddress?, contractAddress?, selector?, spenderAddress?, approveAmount? }`.

**GREEN phase:** Add `evaluateBatch` method to `DatabasePolicyEngine`:

```typescript
/**
 * Evaluate a batch of instructions using 2-stage policy evaluation.
 *
 * Phase A: Evaluate each instruction individually against its applicable policies.
 *          All-or-Nothing: if any instruction is denied, entire batch is denied.
 *
 * Phase B: Sum native amounts (TRANSFER.amount + CONTRACT_CALL value) and evaluate
 *          aggregate against SPENDING_LIMIT. If batch contains APPROVE, apply
 *          APPROVE_TIER_OVERRIDE and take max(amount tier, approve tier).
 *
 * @param agentId - Agent whose policies to evaluate
 * @param instructions - Array of instruction parameters (same shape as TransactionParam)
 * @returns PolicyEvaluation with final tier or denial with violation details
 */
async evaluateBatch(
  agentId: string,
  instructions: TransactionParam[],
): Promise<PolicyEvaluation> {
  // Step 1: Load policies (reuse existing query logic)
  const rows = await this.db
    .select()
    .from(policies)
    .where(
      and(
        or(eq(policies.agentId, agentId), isNull(policies.agentId)),
        eq(policies.enabled, true),
      ),
    )
    .orderBy(desc(policies.priority))
    .all();

  if (rows.length === 0) {
    return { allowed: true, tier: 'INSTANT' };
  }

  const resolved = this.resolveOverrides(rows as PolicyRow[], agentId);

  // Phase A: Evaluate each instruction individually
  const violations: Array<{ index: number; type: string; reason: string }> = [];

  for (let i = 0; i < instructions.length; i++) {
    const instr = instructions[i];
    const result = this.evaluateInstructionPolicies(resolved, instr);
    if (result !== null && !result.allowed) {
      violations.push({
        index: i,
        type: instr.type,
        reason: result.reason ?? 'Policy violation',
      });
    }
  }

  // All-or-Nothing: 1 violation = entire batch denied
  if (violations.length > 0) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: `Batch policy violation: ${violations.length} instruction(s) denied. ` +
        violations.map(v => `[${v.index}] ${v.type}: ${v.reason}`).join('; '),
    };
  }

  // Phase B: Aggregate amount for SPENDING_LIMIT
  let totalNativeAmount = 0n;
  for (const instr of instructions) {
    if (instr.type === 'TRANSFER') {
      totalNativeAmount += BigInt(instr.amount);
    } else if (instr.type === 'CONTRACT_CALL') {
      // value field (native token attached to contract call)
      // For batch, this would be in the amount field if applicable
      totalNativeAmount += 0n; // CONTRACT_CALL in batch: value defaults to 0 (Solana has no native value attachment in CPI)
    }
    // TOKEN_TRANSFER and APPROVE: 0 (no native amount)
  }

  // Evaluate aggregate against SPENDING_LIMIT
  const amountTier = this.evaluateSpendingLimit(resolved, totalNativeAmount.toString());
  let finalTier = amountTier ? amountTier.tier as PolicyTier : 'INSTANT' as PolicyTier;

  // If batch contains APPROVE, apply APPROVE_TIER_OVERRIDE
  const hasApprove = instructions.some(i => i.type === 'APPROVE');
  if (hasApprove) {
    // Get approve tier (reuse existing evaluateApproveTierOverride logic)
    const dummyApproveParam: TransactionParam = { type: 'APPROVE', amount: '0', toAddress: '', chain: '' };
    const approveTierResult = this.evaluateApproveTierOverride(resolved, dummyApproveParam);
    const approveTier = approveTierResult ? approveTierResult.tier as PolicyTier : 'APPROVAL' as PolicyTier;

    // Final tier = max(amount tier, approve tier)
    const tierOrder: PolicyTier[] = ['INSTANT', 'NOTIFY', 'DELAY', 'APPROVAL'];
    const amountIdx = tierOrder.indexOf(finalTier);
    const approveIdx = tierOrder.indexOf(approveTier);
    finalTier = tierOrder[Math.max(amountIdx, approveIdx)] as PolicyTier;
  }

  return {
    allowed: true,
    tier: finalTier,
  };
}
```

Add private helper `evaluateInstructionPolicies(resolved, instr)` that runs applicable policies per instruction type:
- **TRANSFER**: evaluateWhitelist(resolved, instr.toAddress)
- **TOKEN_TRANSFER**: evaluateWhitelist + evaluateAllowedTokens
- **CONTRACT_CALL**: evaluateContractWhitelist + evaluateMethodWhitelist (METHOD_WHITELIST optional, returns null if not applicable)
- **APPROVE**: evaluateApprovedSpenders + evaluateApproveAmountLimit

This method returns `PolicyEvaluation | null` (null = passed, non-null with allowed=false = denied).

Note: Do NOT evaluate SPENDING_LIMIT per-instruction (that's Phase B aggregate). Do NOT evaluate APPROVE_TIER_OVERRIDE per-instruction (that's Phase B).

**REFACTOR:** Ensure evaluateBatch shares as much code as possible with existing evaluate() through the private evaluation methods.
  </action>
  <verify>
```bash
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo build --filter=@waiaas/daemon && pnpm vitest run --project daemon -- database-policy-engine
```
All evaluateBatch tests pass. Existing policy engine tests still pass. Build succeeds.
  </verify>
  <done>
DatabasePolicyEngine.evaluateBatch performs 2-stage evaluation: Phase A evaluates each instruction against its type-specific policies with All-or-Nothing denial, Phase B sums native amounts for aggregate SPENDING_LIMIT and resolves max(amount tier, approve tier) when APPROVE is present. 10+ batch policy tests pass. Existing evaluate() behavior unchanged.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo build` succeeds across all packages (no type errors)
2. `pnpm vitest run --project adapter-solana -- solana-batch` -- all buildBatch tests pass
3. `pnpm vitest run --project daemon -- database-policy-engine` -- all evaluateBatch tests pass, existing tests pass
4. `pnpm vitest run` -- full test suite passes (no regressions in existing tests)
5. SolanaAdapter.buildBatch no longer throws 'Not implemented' stub error
6. EVM adapter.buildBatch still throws BATCH_NOT_SUPPORTED (no change needed, already implemented in Phase 77)
</verification>

<success_criteria>
- SolanaAdapter.buildBatch builds atomic Solana transaction from 2-20 mixed instruction types
- ATA auto-creation for TOKEN_TRANSFER recipients within batch
- DatabasePolicyEngine.evaluateBatch: Phase A individual + Phase B aggregate with All-or-Nothing
- Aggregate SPENDING_LIMIT uses sum of TRANSFER.amount only (TOKEN_TRANSFER/APPROVE = 0)
- APPROVE in batch triggers max(amount tier, APPROVE_TIER_OVERRIDE tier) resolution
- EVM batch still returns BATCH_NOT_SUPPORTED (no code change, already working)
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/80-batch-transactions/80-01-SUMMARY.md`
</output>
