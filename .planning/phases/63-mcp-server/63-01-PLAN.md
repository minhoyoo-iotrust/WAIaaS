---
phase: 63-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp/package.json
  - packages/mcp/tsconfig.json
  - packages/mcp/vitest.config.ts
  - packages/mcp/src/index.ts
  - packages/mcp/src/server.ts
  - packages/mcp/src/session-manager.ts
  - packages/mcp/src/api-client.ts
  - packages/mcp/src/tools/send-token.ts
  - packages/mcp/src/tools/get-balance.ts
  - packages/mcp/src/tools/get-address.ts
  - packages/mcp/src/tools/list-transactions.ts
  - packages/mcp/src/tools/get-transaction.ts
  - packages/mcp/src/tools/get-nonce.ts
  - packages/mcp/src/resources/wallet-balance.ts
  - packages/mcp/src/resources/wallet-address.ts
  - packages/mcp/src/resources/system-status.ts
  - packages/mcp/src/__tests__/tools.test.ts
  - packages/mcp/src/__tests__/resources.test.ts
  - packages/mcp/src/__tests__/api-client.test.ts
autonomous: true

must_haves:
  truths:
    - "MCP server connects via stdio transport and lists 6 tools and 3 resources"
    - "send_token tool sends TRANSFER request to daemon and returns transaction result"
    - "get_balance, get_address, get_nonce tools query daemon and return JSON content"
    - "list_transactions tool supports cursor/limit params for pagination"
    - "get_transaction tool retrieves single transaction by ID"
    - "waiaas://wallet/balance, waiaas://wallet/address, waiaas://system/status resources return data"
    - "SessionManager loads token from file or env, decodes JWT exp, and schedules renewal at 60% TTL"
    - "SessionManager renews token via PUT /v1/sessions/:id/renew and updates file + memory"
    - "ApiClient wraps all daemon HTTP calls with auth header from SessionManager.getToken()"
    - "All internal logging uses console.error (never console.log) to prevent stdio stdout corruption"
  artifacts:
    - path: "packages/mcp/package.json"
      provides: "@waiaas/mcp package with @modelcontextprotocol/sdk dependency"
      contains: "@waiaas/mcp"
    - path: "packages/mcp/src/index.ts"
      provides: "MCP server entrypoint with stdio transport"
      exports: []
    - path: "packages/mcp/src/server.ts"
      provides: "createMcpServer factory registering 6 tools + 3 resources"
      exports: ["createMcpServer"]
    - path: "packages/mcp/src/session-manager.ts"
      provides: "SessionManager class with getToken/start/dispose/getState"
      exports: ["SessionManager"]
    - path: "packages/mcp/src/api-client.ts"
      provides: "ApiClient wrapping fetch with auth from SessionManager"
      exports: ["ApiClient"]
  key_links:
    - from: "packages/mcp/src/index.ts"
      to: "packages/mcp/src/server.ts"
      via: "createMcpServer(apiClient)"
      pattern: "createMcpServer"
    - from: "packages/mcp/src/server.ts"
      to: "packages/mcp/src/tools/*.ts"
      via: "registerXxx(server, apiClient)"
      pattern: "register"
    - from: "packages/mcp/src/api-client.ts"
      to: "packages/mcp/src/session-manager.ts"
      via: "sessionManager.getToken()"
      pattern: "getToken"
    - from: "packages/mcp/src/index.ts"
      to: "@modelcontextprotocol/sdk"
      via: "StdioServerTransport"
      pattern: "StdioServerTransport"
---

<objective>
Create the @waiaas/mcp package with 6 MCP tools, 3 MCP resources, ApiClient, SessionManager (core token load + renewal scheduling), and stdio transport entrypoint.

Purpose: Enable Claude Desktop and other MCP clients to interact with WAIaaS daemon wallet operations through the Model Context Protocol, with automatic session token management.

Output: packages/mcp/ with working MCP server, 6 tools, 3 resources, SessionManager with renewal, and ~60 tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-typescript-sdk/61-01-SUMMARY.md
@.planning/phases/61-typescript-sdk/61-02-SUMMARY.md
@packages/sdk/src/client.ts
@packages/sdk/src/internal/http.ts
@packages/sdk/src/error.ts
@packages/sdk/src/types.ts
@packages/sdk/package.json
@packages/sdk/tsconfig.json
@packages/sdk/vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold @waiaas/mcp package + SessionManager + ApiClient</name>
  <files>
    packages/mcp/package.json
    packages/mcp/tsconfig.json
    packages/mcp/vitest.config.ts
    packages/mcp/src/index.ts
    packages/mcp/src/session-manager.ts
    packages/mcp/src/api-client.ts
    packages/mcp/src/server.ts
  </files>
  <action>
**1. Create packages/mcp/package.json:**
```json
{
  "name": "@waiaas/mcp",
  "version": "0.0.0",
  "type": "module",
  "bin": { "waiaas-mcp": "./dist/index.js" },
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": { ".": { "import": "./dist/index.js", "types": "./dist/index.d.ts" } },
  "files": ["dist"],
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "test": "vitest run",
    "lint": "eslint src/",
    "typecheck": "tsc --noEmit",
    "clean": "rm -rf dist"
  },
  "engines": { "node": ">=22.0.0" },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.0"
  },
  "devDependencies": {
    "vitest": "^3.0.0"
  }
}
```
Note: @modelcontextprotocol/sdk as runtime dependency (MCP server needs it). Zero dependency on @waiaas/core -- types are standalone like the SDK pattern. Zod comes as peer from @modelcontextprotocol/sdk (it re-exports zod).

Run `pnpm install` after creating package.json to resolve workspace dependencies.

**2. Create tsconfig.json** extending ../../tsconfig.base.json (same pattern as packages/sdk).

**3. Create vitest.config.ts** same pattern as packages/sdk (globals: true, passWithNoTests: true).

**4. Create src/session-manager.ts -- SessionManager class:**

Following design from Phase 37 (SM-01 through SM-14) and Phase 38 (SMGI-D01 through SMGI-D04):

```typescript
// SessionManager: manages MCP session token lifecycle
// Composition pattern -- independent from MCP SDK (SM-01)
// 4 public methods: getToken, getState, start, dispose (SM-02, SMGI-D01)

export type SessionState = 'active' | 'expired' | 'error';

export interface SessionManagerOptions {
  baseUrl: string;          // daemon base URL
  dataDir?: string;         // for mcp-token file
  envToken?: string;        // from WAIAAS_SESSION_TOKEN env var
  renewalRatio?: number;    // default 0.6 (60% of TTL)
}
```

Internal state (SM-03): token, sessionId, expiresAt, expiresIn, renewalCount, maxRenewals (start Infinity, lazy from server), timer (NodeJS.Timeout | null), isRenewing (boolean), state (SessionState).

**loadToken()** (SM-04, SM-05): 8-step load strategy:
1. If dataDir, try readMcpToken (file > env var priority per SM-04)
2. Else use envToken
3. If no token found, set state='error', return
4. Decode JWT using base64url payload parsing (same pattern as SDK client.ts extractSessionId) -- no jose dependency needed since we only need to read exp claim without signature verification
5. Validate exp range defensively (C-03): exp must be > now-10years and < now+1year
6. Extract sessionId from JWT payload
7. If exp < now, set state='expired' (token already expired)
8. Else set state='active'

**scheduleRenewal()** (SM-09): Calculate next renewal time = now + (expiresAt - now) * renewalRatio. Use setTimeout (no safeSetTimeout needed for typical TTL < 24h in practice; add safeSetTimeout wrapper if delay > 2^31-1 ms per SM-08). On timer fire, call renew().

**renew()** (SM-10):
1. Set isRenewing = true
2. PUT /v1/sessions/:sessionId/renew with Bearer token
3. On success: writeMcpToken (file-first, H-02 defense) -> update memory (token, sessionId, expiresAt, renewalCount, maxRenewals from response)
4. scheduleRenewal() for next cycle
5. Set isRenewing = false
6. On failure: call handleRenewalError()

**writeMcpToken**: Write token to dataDir/mcp-token file. Use fs.writeFile with atomic write pattern (write to .tmp then rename).

**readMcpToken**: Read token from dataDir/mcp-token file.

**getToken()** (SM-14): Return current token string. During renewal, returns old token (concurrency safe). If state='expired'/'error', return null.

**getState()**: Return current SessionState.

**start()**: Call loadToken(), if active call scheduleRenewal(). Log to stderr.

**dispose()**: Clear timer, set state to 'expired'.

**CRITICAL: All logging via console.error** (SMGI-D04). Prefix: `[waiaas-mcp:session]`. Never use console.log -- stdout is stdio JSON-RPC transport.

**5. Create src/api-client.ts -- ApiClient class:**

Following design from Phase 38 (SMGI-01):

```typescript
// ApiClient: wraps all daemon HTTP calls, gets token from SessionManager
export type ApiResult<T> =
  | { ok: true; data: T }
  | { ok: false; error: { code: string; message: string; retryable: boolean; hint?: string } }
  | { ok: false; expired: true; message: string }
  | { ok: false; networkError: true; message: string };
```

Methods: get<T>(path), post<T>(path, body), request<T>(method, path, body?).

request() flow (SMGI-01 7-step):
1. Get token from sessionManager.getToken()
2. If null, return expired result
3. Call fetch with Bearer token + User-Agent header
4. If 401, try handle401 (50ms wait, re-check token, return expired if still null)
5. If 503 and kill switch, return killSwitch result
6. If !ok, parse error body, return error result
7. If ok, return { ok: true, data }
8. On network error (TypeError), return networkError result

User-Agent: `@waiaas/mcp/0.0.0`

**6. Create src/server.ts -- createMcpServer factory:**

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
// Import register functions from tools/ and resources/
export function createMcpServer(apiClient: ApiClient): McpServer {
  const server = new McpServer({
    name: 'waiaas-wallet',
    version: '0.0.0',
  });
  // Register 6 tools + 3 resources via DI
  registerSendToken(server, apiClient);
  registerGetBalance(server, apiClient);
  registerGetAddress(server, apiClient);
  registerListTransactions(server, apiClient);
  registerGetTransaction(server, apiClient);
  registerGetNonce(server, apiClient);
  registerWalletBalance(server, apiClient);
  registerWalletAddress(server, apiClient);
  registerSystemStatus(server, apiClient);
  return server;
}
```

**7. Create src/index.ts -- entrypoint:**

```typescript
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { createMcpServer } from './server.js';
import { SessionManager } from './session-manager.js';
import { ApiClient } from './api-client.js';

const BASE_URL = process.env.WAIAAS_BASE_URL ?? 'http://127.0.0.1:3100';
const DATA_DIR = process.env.WAIAAS_DATA_DIR;
const ENV_TOKEN = process.env.WAIAAS_SESSION_TOKEN;

async function main() {
  const sessionManager = new SessionManager({
    baseUrl: BASE_URL,
    dataDir: DATA_DIR,
    envToken: ENV_TOKEN,
  });

  await sessionManager.start(); // eager init (design decision)

  const apiClient = new ApiClient(sessionManager, BASE_URL);
  const server = createMcpServer(apiClient);
  const transport = new StdioServerTransport();

  await server.connect(transport);
  console.error('[waiaas-mcp] Server started on stdio transport');

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    console.error('[waiaas-mcp] SIGTERM received, shutting down');
    sessionManager.dispose();
    await server.close();
    process.exit(0);
  });
  process.on('SIGINT', async () => {
    sessionManager.dispose();
    await server.close();
    process.exit(0);
  });
}

main().catch((err) => {
  console.error('[waiaas-mcp] Fatal error:', err);
  process.exit(1);
});
```

Degraded mode (SMGI-03): If sessionManager.start() fails to load token, log warning but continue -- MCP server still starts, tools return session_expired message.
  </action>
  <verify>
    - `pnpm typecheck --filter @waiaas/mcp` passes
    - `ls packages/mcp/src/` shows index.ts, server.ts, session-manager.ts, api-client.ts
  </verify>
  <done>
    @waiaas/mcp package scaffolded with SessionManager (token load + renewal + dispose), ApiClient (auth proxy with ApiResult discriminated union), server factory, and stdio entrypoint. All logging via console.error. Degraded mode supported.
  </done>
</task>

<task type="auto">
  <name>Task 2: 6 MCP tools + 3 MCP resources + toToolResult/toResourceResult + tests</name>
  <files>
    packages/mcp/src/tools/send-token.ts
    packages/mcp/src/tools/get-balance.ts
    packages/mcp/src/tools/get-address.ts
    packages/mcp/src/tools/list-transactions.ts
    packages/mcp/src/tools/get-transaction.ts
    packages/mcp/src/tools/get-nonce.ts
    packages/mcp/src/resources/wallet-balance.ts
    packages/mcp/src/resources/wallet-address.ts
    packages/mcp/src/resources/system-status.ts
    packages/mcp/src/__tests__/tools.test.ts
    packages/mcp/src/__tests__/resources.test.ts
    packages/mcp/src/__tests__/api-client.test.ts
  </files>
  <action>
**Helper functions (add to api-client.ts or a separate utils.ts):**

**toToolResult(result: ApiResult<T>)** (SMGI-04, H-04 isError avoidance):
- If result.ok: return `{ content: [{ type: 'text', text: JSON.stringify(result.data) }] }`
- If result.expired: return `{ content: [{ type: 'text', text: JSON.stringify({ session_expired: true, message: result.message, action: 'Run waiaas mcp setup to get a new token' }) }] }` -- NO isError (H-04: prevents Claude Desktop from disconnecting)
- If result.networkError: return `{ content: [{ type: 'text', text: JSON.stringify({ network_error: true, message: result.message }) }] }` -- NO isError
- If result.error: return `{ content: [{ type: 'text', text: JSON.stringify({ error: true, ...result.error }) }], isError: true }` -- isError only for actual API errors

**toResourceResult(uri: string, result: ApiResult<T>):**
- If result.ok: return `{ contents: [{ uri, text: JSON.stringify(result.data), mimeType: 'application/json' }] }`
- If expired/networkError: return contents with informational message (no error throw)
- If result.error: return contents with error info

**6 Tool Handlers** (each in its own file, registerXxx(server, apiClient) pattern):

1. **send-token.ts**: `registerSendToken(server, apiClient)`
   - Tool name: `send_token`
   - Description: 'Send SOL or tokens from the agent wallet to a destination address. Amount is in smallest unit (lamports for SOL). Returns transaction ID and status.'
   - Input schema (using zod from MCP SDK): `{ to: z.string(), amount: z.string(), memo: z.string().optional() }`
   - Handler: `apiClient.post('/v1/transactions/send', { to, amount, memo })` -> toToolResult()

2. **get-balance.ts**: `registerGetBalance(server, apiClient)`
   - Tool name: `get_balance`
   - Description: 'Get the current balance of the agent wallet.'
   - Input: `{}` (no params)
   - Handler: `apiClient.get('/v1/wallet/balance')` -> toToolResult()

3. **get-address.ts**: `registerGetAddress(server, apiClient)`
   - Tool name: `get_address`
   - Description: 'Get the public address of the agent wallet.'
   - Input: `{}` (no params)
   - Handler: `apiClient.get('/v1/wallet/address')` -> toToolResult()

4. **list-transactions.ts**: `registerListTransactions(server, apiClient)`
   - Tool name: `list_transactions`
   - Description: 'List transaction history with cursor-based pagination.'
   - Input: `{ limit: z.number().optional(), cursor: z.string().optional() }`
   - Handler: build query string, `apiClient.get('/v1/transactions?...')` -> toToolResult()

5. **get-transaction.ts**: `registerGetTransaction(server, apiClient)`
   - Tool name: `get_transaction`
   - Description: 'Get details of a specific transaction by ID.'
   - Input: `{ transaction_id: z.string() }`
   - Handler: `apiClient.get('/v1/transactions/${transaction_id}')` -> toToolResult()

6. **get-nonce.ts**: `registerGetNonce(server, apiClient)`
   - Tool name: `get_nonce`
   - Description: 'Get a nonce for owner wallet signature verification.'
   - Input: `{}` (no params)
   - Handler: `apiClient.get('/v1/nonce')` -> toToolResult()
   - Note: nonce endpoint may not require auth -- use apiClient.getPublic() or pass no-auth flag

**3 Resource Handlers** (each in its own file):

1. **wallet-balance.ts**: `registerWalletBalance(server, apiClient)`
   - URI: `waiaas://wallet/balance`
   - Name: 'Wallet Balance'
   - Description: 'Current balance of the agent wallet'
   - mimeType: 'application/json'
   - Handler: `apiClient.get('/v1/wallet/balance')` -> toResourceResult()

2. **wallet-address.ts**: `registerWalletAddress(server, apiClient)`
   - URI: `waiaas://wallet/address`
   - Name: 'Wallet Address'
   - Description: 'Public address of the agent wallet'
   - Handler: `apiClient.get('/v1/wallet/address')` -> toResourceResult()

3. **system-status.ts**: `registerSystemStatus(server, apiClient)`
   - URI: `waiaas://system/status`
   - Name: 'System Status'
   - Description: 'WAIaaS daemon system status'
   - Handler: `apiClient.get('/v1/admin/status')` -> toResourceResult()
   - Note: admin/status may need masterAuth. If so, use the session token anyway and handle error gracefully. The resource exists for informational purposes.

**Tests (~60 tests across 3 files):**

**__tests__/api-client.test.ts** (~20 tests):
- Mock fetch via vi.stubGlobal('fetch', vi.fn())
- Test ApiClient.get() success -> { ok: true, data }
- Test ApiClient.post() success
- Test 401 response -> { ok: false, expired: true }
- Test 500 response -> { ok: false, error: { code, message, retryable: true } }
- Test 503 response with kill_switch_active -> kill switch result
- Test network error (TypeError) -> { ok: false, networkError: true }
- Test token is null (expired session) -> expired result without fetch call
- Test toToolResult with each ApiResult variant (ok, error, expired, networkError)
- Test toResourceResult with each ApiResult variant

**__tests__/tools.test.ts** (~25 tests):
- Create mock ApiClient that returns predetermined ApiResult values
- For each tool (6 tools): test success case, test error case
- Test send_token with params passed correctly
- Test list_transactions with query params
- Test get_transaction with transaction_id
- Test toToolResult isError behavior (only set on actual API errors, NOT on expired/networkError per H-04)

**__tests__/resources.test.ts** (~15 tests):
- Mock ApiClient
- For each resource (3): test success case, test expired case, test error case
- Verify URI and mimeType in response
- Verify toResourceResult format

Run `pnpm test --filter @waiaas/mcp` to verify all tests pass.
  </action>
  <verify>
    - `pnpm test --filter @waiaas/mcp` passes with ~60 tests
    - `pnpm typecheck --filter @waiaas/mcp` passes
    - `ls packages/mcp/src/tools/` shows 6 .ts files
    - `ls packages/mcp/src/resources/` shows 3 .ts files
  </verify>
  <done>
    6 MCP tools (send_token, get_balance, get_address, list_transactions, get_transaction, get_nonce) and 3 MCP resources (waiaas://wallet/balance, waiaas://wallet/address, waiaas://system/status) registered. ApiClient proxies all calls through SessionManager.getToken(). toToolResult avoids isError on session_expired/networkError (H-04 Claude Desktop disconnect prevention). ~60 tests passing.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck --filter @waiaas/mcp` passes (no TypeScript errors)
2. `pnpm test --filter @waiaas/mcp` shows ~60 tests passing
3. `ls packages/mcp/src/tools/*.ts | wc -l` = 6
4. `ls packages/mcp/src/resources/*.ts | wc -l` = 3
5. `grep -r 'console.log' packages/mcp/src/ --include='*.ts' | grep -v test` returns 0 results (no stdout pollution)
6. packages/mcp/src/index.ts uses StdioServerTransport
7. SessionManager has getToken/getState/start/dispose public methods
8. ApiClient returns ApiResult discriminated union (ok/error/expired/networkError)
</verification>

<success_criteria>
- @waiaas/mcp package exists in monorepo with dependencies resolved
- MCP server registers 6 tools matching MCP-01 requirement
- MCP server registers 3 resources matching MCP-02 requirement
- SessionManager loads token from file or env var and schedules renewal at 60% TTL (MCP-03)
- SessionManager renewal calls PUT /v1/sessions/:id/renew and updates token
- ApiClient injects auth header from SessionManager on every request
- toToolResult avoids isError on expired/networkError (H-04 pattern)
- All logging goes to stderr (SMGI-D04)
- ~60 tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/63-mcp-server/63-01-SUMMARY.md`
</output>
