---
phase: 79-contract-call-approve
plan: 02
type: tdd
wave: 2
depends_on: ["79-01"]
files_modified:
  - packages/adapters/solana/src/adapter.ts
  - packages/adapters/solana/src/__tests__/solana-approve.test.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
autonomous: true

must_haves:
  truths:
    - "SolanaAdapter.buildApprove builds SPL ApproveChecked instruction with delegate + amount + decimals"
    - "APPROVED_SPENDERS policy denies APPROVE when no policy configured (APPROVE_DISABLED)"
    - "APPROVED_SPENDERS policy denies APPROVE when spender not in approved list (SPENDER_NOT_APPROVED)"
    - "APPROVE_AMOUNT_LIMIT with block_unlimited=true denies MAX_UINT256 amount (UNLIMITED_APPROVE_BLOCKED)"
    - "APPROVE_AMOUNT_LIMIT with maxAmount denies amounts exceeding limit (APPROVE_AMOUNT_EXCEEDED)"
    - "APPROVE_TIER_OVERRIDE forces specified tier; without it defaults to APPROVAL tier"
    - "EVM buildApprove already works (Phase 77) -- no changes needed"
  artifacts:
    - path: "packages/adapters/solana/src/adapter.ts"
      provides: "SolanaAdapter.buildApprove real implementation (SPL ApproveChecked)"
      contains: "buildApprove"
    - path: "packages/adapters/solana/src/__tests__/solana-approve.test.ts"
      provides: "Solana approve tests"
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateApprovedSpenders + evaluateApproveAmountLimit + evaluateApproveTierOverride"
      contains: "evaluateApprovedSpenders"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "APPROVED_SPENDERS + APPROVE_AMOUNT_LIMIT + APPROVE_TIER_OVERRIDE policy tests"
  key_links:
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "packages/core/src/errors/error-codes.ts"
      via: "APPROVE_DISABLED, SPENDER_NOT_APPROVED, UNLIMITED_APPROVE_BLOCKED, APPROVE_AMOUNT_EXCEEDED error codes"
      pattern: "APPROVE_DISABLED|SPENDER_NOT_APPROVED|UNLIMITED_APPROVE_BLOCKED|APPROVE_AMOUNT_EXCEEDED"
    - from: "packages/adapters/solana/src/adapter.ts"
      to: "@solana-program/token"
      via: "getApproveCheckedInstruction for SPL delegate approval"
      pattern: "getApproveCheckedInstruction|ApproveChecked"
---

<objective>
Implement SolanaAdapter.buildApprove (SPL ApproveChecked) and add APPROVED_SPENDERS + APPROVE_AMOUNT_LIMIT + APPROVE_TIER_OVERRIDE policy evaluation in DatabasePolicyEngine.

Purpose: Enable agents to request token approvals with strict policy controls -- spender whitelist, amount limits, unlimited approve blocking, and forced Owner approval tier.
Output: Working Solana buildApprove, 3 new approve policy evaluations, tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/79-contract-call-approve/79-01-SUMMARY.md
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/schemas/policy.schema.ts
@packages/core/src/errors/error-codes.ts
@packages/adapters/solana/src/adapter.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SolanaAdapter.buildApprove with SPL ApproveChecked + tests</name>
  <files>
    packages/adapters/solana/src/adapter.ts
    packages/adapters/solana/src/__tests__/solana-approve.test.ts
  </files>
  <action>
  **SolanaAdapter buildApprove (replace stub):**

  In `packages/adapters/solana/src/adapter.ts`, replace the buildApprove stub with a real implementation:

  1. Import `getApproveCheckedInstruction` from `@solana-program/token`. This function builds a SPL Token ApproveChecked instruction that approves a delegate (spender) to transfer up to `amount` tokens from the owner's token account.
     - Check if `@solana-program/token` exports `getApproveCheckedInstruction`. If not available, use `getApproveInstruction` instead. The `Checked` variant requires decimals for on-chain verification which is safer.

  2. Get RPC via `this.getRpc()`.

  3. Query mint account to determine token program (SPL Token or Token-2022), same pattern as buildTokenTransfer:
     ```ts
     const mintAccountInfo = await rpc.getAccountInfo(mintAddr, { encoding: 'base64' }).send();
     // Determine tokenProgramId from mintOwner
     ```

  4. Compute the owner's ATA (Associated Token Account) using `findAssociatedTokenPda`:
     ```ts
     const [ownerAta] = await findAssociatedTokenPda({
       owner: from,
       tokenProgram: address(tokenProgramId),
       mint: mintAddr,
     });
     ```
     This is the token account being approved (source of tokens the delegate can transfer).

  5. Build the ApproveChecked instruction:
     ```ts
     const instruction = getApproveCheckedInstruction({
       source: ownerAta,          // token account to approve
       mint: mintAddr,            // token mint
       delegate: address(request.spender),  // spender/delegate
       owner: createNoopSigner(from),       // current owner (signer)
       amount: request.amount,    // amount to approve
       decimals: request.token.decimals,    // for on-chain verification
     }, { programAddress: address(tokenProgramId) });
     ```

  6. Build transaction message using pipe pattern (same as buildTokenTransfer):
     ```ts
     const { value: blockhashInfo } = await rpc.getLatestBlockhash().send();
     let txMessage = pipe(
       createTransactionMessage({ version: 0 }),
       (tx) => setTransactionMessageFeePayer(from, tx),
       (tx) => setTransactionMessageLifetimeUsingBlockhash({ ... }, tx),
     );
     txMessage = appendTransactionMessageInstruction(instruction, txMessage) as unknown as typeof txMessage;
     ```

  7. Compile and encode: `compileTransaction(txMessage)` -> `txEncoder.encode(compiled)`.

  8. Return UnsignedTransaction:
     ```ts
     return {
       chain: 'solana',
       serialized,
       estimatedFee: DEFAULT_SOL_TRANSFER_FEE,
       expiresAt: new Date(Date.now() + 60_000),
       metadata: {
         blockhash: blockhashInfo.blockhash,
         lastValidBlockHeight: Number(blockhashInfo.lastValidBlockHeight),
         version: 0,
         tokenProgram: tokenProgramId,
         tokenAddress: request.token.address,
         spender: request.spender,
         approveAmount: request.amount,
       },
     };
     ```

  9. Error handling: same pattern as buildTokenTransfer.

  **Tests:**

  Create `packages/adapters/solana/src/__tests__/solana-approve.test.ts`:

  1. Test: buildApprove builds tx with delegate + amount + decimals (mock RPC for getAccountInfo, getLatestBlockhash).
  2. Test: buildApprove detects Token-2022 program from mint owner.
  3. Test: buildApprove includes correct metadata (tokenAddress, spender, approveAmount).
  4. Test: buildApprove throws TOKEN_ACCOUNT_NOT_FOUND for non-existent mint.
  5. Test: buildApprove with amount=0n (revoke) builds valid transaction.

  Follow the mocking patterns from `solana-token-transfer.test.ts` (mock `@solana/kit`, `@solana-program/token`).

  Verify: `pnpm --filter @waiaas/adapter-solana test` passes.
  </action>
  <verify>
  pnpm turbo build
  pnpm --filter @waiaas/adapter-solana test
  </verify>
  <done>
  SolanaAdapter.buildApprove builds SPL ApproveChecked instruction with delegate, amount, decimals, and correct token program.
  Metadata includes tokenAddress, spender, approveAmount for audit trail.
  5+ Solana approve tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: APPROVED_SPENDERS + APPROVE_AMOUNT_LIMIT + APPROVE_TIER_OVERRIDE policy evaluation</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
    packages/daemon/src/__tests__/database-policy-engine.test.ts
  </files>
  <action>
  **DatabasePolicyEngine extensions for approve policies:**

  In `packages/daemon/src/pipeline/database-policy-engine.ts`:

  1. Add new interfaces (alongside existing ones):
     ```ts
     interface ApprovedSpendersRules {
       spenders: Array<{ address: string; name?: string; maxAmount?: string }>;
     }

     interface ApproveAmountLimitRules {
       maxAmount?: string;
       blockUnlimited: boolean;
     }

     interface ApproveTierOverrideRules {
       tier: string;  // PolicyTier value
     }
     ```

  2. Add `spenderAddress?: string` and `approveAmount?: string` optional fields to the `TransactionParam` interface:
     ```ts
     interface TransactionParam {
       type: string;
       amount: string;
       toAddress: string;
       chain: string;
       tokenAddress?: string;
       contractAddress?: string;  // from 79-01
       selector?: string;         // from 79-01
       /** Spender address for APPROVED_SPENDERS evaluation (APPROVE only). */
       spenderAddress?: string;
       /** Approve amount in raw units for APPROVE_AMOUNT_LIMIT evaluation (APPROVE only). */
       approveAmount?: string;
     }
     ```

  3. Add `evaluateApprovedSpenders()` private method:
     - Only applies to `APPROVE` transaction type. For non-APPROVE, return null.
     - If transaction type is `APPROVE` and no `APPROVED_SPENDERS` policy exists:
       -> deny with reason `'Token approvals disabled: no APPROVED_SPENDERS policy configured'` (APPROVE_DISABLED).
     - If `APPROVED_SPENDERS` policy exists, check if `transaction.spenderAddress` is in `rules.spenders[].address`:
       -> If found: return null (continue evaluation).
       -> If not found: deny with reason `'Spender not in approved list: {address}'` (SPENDER_NOT_APPROVED).
     - Case-insensitive comparison (EVM addresses).

  4. Add `evaluateApproveAmountLimit()` private method:
     - Only applies to `APPROVE` transaction type. For non-APPROVE, return null.
     - If no `APPROVE_AMOUNT_LIMIT` policy exists: check unlimited by default.
       -> The design doc says `block_unlimited=true` by default. Since no policy means we have no explicit config, treat as block_unlimited=true. Check if approve amount equals MAX_UINT256 (EVM: `2n**256n - 1n`) or MAX_U64 (Solana: `2n**64n - 1n`):
       -> If amount >= MAX_UINT256/2 or MAX_U64/2: deny with reason `'Unlimited token approval is blocked'` (UNLIMITED_APPROVE_BLOCKED).
       -> Otherwise: return null.
     - If `APPROVE_AMOUNT_LIMIT` policy exists:
       -> If `rules.blockUnlimited === true` and amount >= threshold: deny UNLIMITED_APPROVE_BLOCKED.
       -> If `rules.maxAmount` is set and `BigInt(transaction.approveAmount) > BigInt(rules.maxAmount)`: deny with reason `'Approve amount exceeds limit'` (APPROVE_AMOUNT_EXCEEDED).
       -> Otherwise: return null.
     - Define thresholds:
       ```ts
       const MAX_UINT256 = 2n ** 256n - 1n;
       const UNLIMITED_THRESHOLD = MAX_UINT256 / 2n;
       ```

  5. Add `evaluateApproveTierOverride()` private method:
     - Only applies to `APPROVE` transaction type. For non-APPROVE, return null.
     - If no `APPROVE_TIER_OVERRIDE` policy exists:
       -> Return `{ allowed: true, tier: 'APPROVAL' }` (default: Owner approval required).
     - If policy exists:
       -> Return `{ allowed: true, tier: rules.tier }` (use configured tier).
     - This method returns a FINAL result (overrides SPENDING_LIMIT tier for APPROVE transactions).

  6. Update the `evaluate()` method chain to add steps 4e, 4f, 4g AFTER METHOD_WHITELIST and BEFORE SPENDING_LIMIT:
     ```ts
     // Step 4d: Evaluate METHOD_WHITELIST (from 79-01)
     // ... (existing)

     // Step 4e: Evaluate APPROVED_SPENDERS (approve spender whitelist)
     const approvedSpendersResult = this.evaluateApprovedSpenders(resolved, transaction);
     if (approvedSpendersResult !== null) {
       return approvedSpendersResult;
     }

     // Step 4f: Evaluate APPROVE_AMOUNT_LIMIT (unlimited approve block + amount cap)
     const approveAmountResult = this.evaluateApproveAmountLimit(resolved, transaction);
     if (approveAmountResult !== null) {
       return approveAmountResult;
     }

     // Step 4g: Evaluate APPROVE_TIER_OVERRIDE (forced tier for APPROVE transactions)
     const approveTierResult = this.evaluateApproveTierOverride(resolved, transaction);
     if (approveTierResult !== null) {
       return approveTierResult;  // This is a FINAL result, skips SPENDING_LIMIT
     }

     // Step 5: Evaluate SPENDING_LIMIT (tier classification)
     ```
     Note: For APPROVE transactions, the evaluation chain is:
     WHITELIST -> ALLOWED_TOKENS(skip) -> CONTRACT_WHITELIST(skip) -> METHOD_WHITELIST(skip) -> APPROVED_SPENDERS -> APPROVE_AMOUNT_LIMIT -> APPROVE_TIER_OVERRIDE.
     If APPROVE_TIER_OVERRIDE returns a result, it skips SPENDING_LIMIT entirely (approve has its own tier logic).

  7. Update `evaluateAndReserve()` raw SQL path similarly -- add the 3 approve evaluation steps.

  **Tests:**

  In `packages/daemon/src/__tests__/database-policy-engine.test.ts`, add a new `describe('APPROVED_SPENDERS + APPROVE_AMOUNT_LIMIT + APPROVE_TIER_OVERRIDE')` block:

  1. Test: APPROVE with no APPROVED_SPENDERS policy -> deny (APPROVE_DISABLED).
  2. Test: APPROVE with APPROVED_SPENDERS + spender in list -> allow (continue evaluation).
  3. Test: APPROVE with APPROVED_SPENDERS + spender NOT in list -> deny (SPENDER_NOT_APPROVED).
  4. Test: APPROVE with large amount (~MAX_UINT256) + no APPROVE_AMOUNT_LIMIT -> deny (UNLIMITED_APPROVE_BLOCKED, default block).
  5. Test: APPROVE with APPROVE_AMOUNT_LIMIT (blockUnlimited=true) + unlimited amount -> deny (UNLIMITED_APPROVE_BLOCKED).
  6. Test: APPROVE with APPROVE_AMOUNT_LIMIT (blockUnlimited=false) + unlimited amount -> allow.
  7. Test: APPROVE with APPROVE_AMOUNT_LIMIT (maxAmount='1000000') + amount=2000000 -> deny (APPROVE_AMOUNT_EXCEEDED).
  8. Test: APPROVE with APPROVE_AMOUNT_LIMIT (maxAmount='1000000') + amount=500000 -> allow.
  9. Test: APPROVE with no APPROVE_TIER_OVERRIDE -> default APPROVAL tier.
  10. Test: APPROVE with APPROVE_TIER_OVERRIDE (tier=INSTANT) -> INSTANT tier.
  11. Test: APPROVE with APPROVE_TIER_OVERRIDE (tier=NOTIFY) -> NOTIFY tier.
  12. Test: Non-APPROVE type (TRANSFER) is NOT affected by approve policies.
  13. Test: Case-insensitive spender address comparison.

  Follow existing test patterns.

  Verify: `pnpm --filter @waiaas/daemon test` passes.
  </action>
  <verify>
  pnpm turbo build
  pnpm --filter @waiaas/daemon test
  </verify>
  <done>
  DatabasePolicyEngine evaluates APPROVED_SPENDERS (default deny for APPROVE), APPROVE_AMOUNT_LIMIT (unlimited block + max amount), APPROVE_TIER_OVERRIDE (forced tier, defaults to APPROVAL).
  Both evaluate() and evaluateAndReserve() paths include the 3 new approve evaluation steps.
  13+ new policy engine tests pass covering all approve policy scenarios.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo build` -- monorepo builds clean (all packages)
2. `pnpm --filter @waiaas/adapter-solana test` -- Solana adapter tests pass including buildApprove
3. `pnpm --filter @waiaas/daemon test` -- daemon tests pass including APPROVED_SPENDERS + APPROVE_AMOUNT_LIMIT + APPROVE_TIER_OVERRIDE
4. No regressions: existing tests for buildTransaction, buildTokenTransfer, EVM buildApprove, WHITELIST, ALLOWED_TOKENS, CONTRACT_WHITELIST, METHOD_WHITELIST, SPENDING_LIMIT still pass
5. EVM buildApprove unchanged (already implemented in Phase 77) -- existing tests still pass
</verification>

<success_criteria>
- SolanaAdapter.buildApprove builds SPL ApproveChecked with delegate + amount + decimals
- APPROVED_SPENDERS default deny: no policy = APPROVE_DISABLED
- APPROVED_SPENDERS whitelist: spender in list = allow, not in list = deny
- APPROVE_AMOUNT_LIMIT: block_unlimited=true blocks MAX_UINT256 amounts, maxAmount caps approve
- APPROVE_TIER_OVERRIDE: configured tier used, defaults to APPROVAL
- APPROVE tier evaluation skips SPENDING_LIMIT (independent tier logic)
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/79-contract-call-approve/79-02-SUMMARY.md`
</output>
