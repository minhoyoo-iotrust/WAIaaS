---
phase: 79-contract-call-approve
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/adapters/evm/src/adapter.ts
  - packages/adapters/evm/src/__tests__/evm-adapter.test.ts
  - packages/adapters/solana/src/adapter.ts
  - packages/adapters/solana/src/__tests__/solana-contract-call.test.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
  - packages/daemon/src/__tests__/database-policy-engine.test.ts
autonomous: true

must_haves:
  truths:
    - "EvmAdapter.buildContractCall builds EIP-1559 tx with calldata targeting contract address, 1.2x gas margin"
    - "SolanaAdapter.buildContractCall builds tx message with programId + instructionData + accounts instruction"
    - "CONTRACT_WHITELIST policy denies CONTRACT_CALL when no policy configured (CONTRACT_CALL_DISABLED)"
    - "CONTRACT_WHITELIST policy denies CONTRACT_CALL when contract address not in whitelist (CONTRACT_NOT_WHITELISTED)"
    - "METHOD_WHITELIST policy denies CONTRACT_CALL when function selector not in allowed list (METHOD_NOT_WHITELISTED)"
    - "CONTRACT_WHITELIST + METHOD_WHITELIST pass when contract and method are whitelisted"
  artifacts:
    - path: "packages/adapters/evm/src/adapter.ts"
      provides: "EvmAdapter.buildContractCall real implementation"
      contains: "buildContractCall"
    - path: "packages/adapters/solana/src/adapter.ts"
      provides: "SolanaAdapter.buildContractCall real implementation"
      contains: "buildContractCall"
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "evaluateContractWhitelist + evaluateMethodWhitelist methods"
      contains: "evaluateContractWhitelist"
    - path: "packages/adapters/solana/src/__tests__/solana-contract-call.test.ts"
      provides: "Solana contract call tests"
    - path: "packages/daemon/src/__tests__/database-policy-engine.test.ts"
      provides: "CONTRACT_WHITELIST + METHOD_WHITELIST policy tests"
  key_links:
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "packages/core/src/errors/error-codes.ts"
      via: "CONTRACT_CALL_DISABLED, CONTRACT_NOT_WHITELISTED, METHOD_NOT_WHITELISTED error codes"
      pattern: "CONTRACT_CALL_DISABLED|CONTRACT_NOT_WHITELISTED|METHOD_NOT_WHITELISTED"
    - from: "packages/adapters/evm/src/adapter.ts"
      to: "packages/core/src/interfaces/chain-adapter.types.ts"
      via: "ContractCallParams interface"
      pattern: "ContractCallParams"
---

<objective>
Implement buildContractCall on both EVM and Solana adapters, and add CONTRACT_WHITELIST + METHOD_WHITELIST policy evaluation in DatabasePolicyEngine.

Purpose: Enable agents to call whitelisted smart contracts with method-level restrictions, following the default-deny principle (opt-in whitelist).
Output: Working buildContractCall on both adapters, CONTRACT_WHITELIST + METHOD_WHITELIST policy evaluation, tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-evm-adapter/77-02-SUMMARY.md
@.planning/phases/78-token-transfer-asset-query/78-01-SUMMARY.md
@packages/core/src/interfaces/chain-adapter.types.ts
@packages/core/src/interfaces/IChainAdapter.ts
@packages/core/src/schemas/policy.schema.ts
@packages/core/src/errors/error-codes.ts
@packages/adapters/evm/src/adapter.ts
@packages/adapters/solana/src/adapter.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: buildContractCall on EVM + Solana adapters + adapter tests</name>
  <files>
    packages/adapters/evm/src/adapter.ts
    packages/adapters/evm/src/__tests__/evm-adapter.test.ts
    packages/adapters/solana/src/adapter.ts
    packages/adapters/solana/src/__tests__/solana-contract-call.test.ts
  </files>
  <action>
  **EVM buildContractCall (replace stub):**

  In `packages/adapters/evm/src/adapter.ts`, replace the buildContractCall stub with a real implementation:

  1. Validate that `request.calldata` exists and is a valid hex string (`0x` prefix + at least 8 hex chars for 4-byte selector), OR `request.programId` exists (Solana-only, throw error for EVM).
  2. Get client via `this.getClient()`.
  3. Get nonce: `client.getTransactionCount({ address: fromAddr })`.
  4. Get EIP-1559 fee data: `client.estimateFeesPerGas()`.
  5. Estimate gas with 1.2x safety margin:
     ```ts
     const estimatedGas = await client.estimateGas({
       account: fromAddr,
       to: request.to as `0x${string}`,
       data: request.calldata as `0x${string}`,
       value: request.value ?? 0n,
     });
     const gasLimit = (estimatedGas * GAS_SAFETY_NUMERATOR) / GAS_SAFETY_DENOMINATOR;
     ```
  6. Build EIP-1559 tx with `type: 'eip1559'`, serialize via `serializeTransaction`, convert to bytes.
  7. Return UnsignedTransaction with metadata including:
     - `selector`: first 10 chars of calldata (0x + 4-byte function selector)
     - `contractAddress`: request.to
     - `value`: request.value ?? 0n
     - `type`: 'eip1559'
     - `nonce`, `chainId`, `maxFeePerGas`, `maxPriorityFeePerGas`, `gasLimit`
  8. Error handling: catch errors, rethrow ChainError/WAIaaSError, map unknown errors via `this.mapError()`.

  Follow the exact pattern from buildTransaction and buildTokenTransfer (EIP-1559 build/serialize pipeline).

  **Solana buildContractCall (replace stub):**

  In `packages/adapters/solana/src/adapter.ts`, replace the buildContractCall stub with a real implementation:

  1. Get RPC via `this.getRpc()`.
  2. Validate request has `programId`, `instructionData`, and `accounts` (throw ChainError INVALID_INSTRUCTION if missing).
  3. Convert `request.accounts` to Solana instruction account format:
     - Map `isSigner` + `isWritable` to AccountRole (import from `@solana/kit`):
       - `isSigner && isWritable` -> `AccountRole.WRITABLE_SIGNER`
       - `isSigner && !isWritable` -> `AccountRole.READONLY_SIGNER`
       - `!isSigner && isWritable` -> `AccountRole.WRITABLE`
       - `!isSigner && !isWritable` -> `AccountRole.READONLY`
     - Use `address()` for each account's pubkey.
  4. Build the instruction:
     ```ts
     const instruction = {
       programAddress: address(request.programId!),
       accounts: mappedAccounts,
       data: new Uint8Array(Buffer.from(request.instructionData as string, 'base64')),
     };
     ```
     Note: `instructionData` in ContractCallParams is `Uint8Array` type, but from REST API it arrives as base64 string. Check if it's already a Uint8Array or string and handle both.
  5. Get latest blockhash, build transaction message using pipe pattern (same as buildTokenTransfer):
     ```ts
     let txMessage = pipe(
       createTransactionMessage({ version: 0 }),
       (tx) => setTransactionMessageFeePayer(address(request.from), tx),
       (tx) => setTransactionMessageLifetimeUsingBlockhash({ ... }, tx),
     );
     txMessage = appendTransactionMessageInstruction(instruction, txMessage) as unknown as typeof txMessage;
     ```
  6. Compile and encode: `compileTransaction(txMessage)` -> `txEncoder.encode(compiled)`.
  7. Return UnsignedTransaction with metadata: `programId`, `blockhash`, `lastValidBlockHeight`, `version: 0`.
  8. Error handling: same pattern as buildTokenTransfer.

  **Tests:**

  Update `packages/adapters/evm/src/__tests__/evm-adapter.test.ts`:
  - Replace the existing "buildContractCall throws not implemented" test with real tests.
  - Add test: buildContractCall with valid calldata returns UnsignedTransaction with correct metadata (selector, contractAddress).
  - Add test: buildContractCall includes 1.2x gas safety margin.
  - Mock `client.estimateGas`, `client.getTransactionCount`, `client.estimateFeesPerGas` as in existing buildTransaction tests.

  Create `packages/adapters/solana/src/__tests__/solana-contract-call.test.ts`:
  - Add test: buildContractCall builds tx with programId + accounts + instructionData.
  - Add test: buildContractCall throws INVALID_INSTRUCTION for missing programId.
  - Add test: buildContractCall maps account roles correctly.
  - Mock RPC calls (getLatestBlockhash) as in existing solana-token-transfer.test.ts.

  Verify: `pnpm turbo build` passes, `pnpm --filter @waiaas/adapter-evm test` passes, `pnpm --filter @waiaas/adapter-solana test` passes.
  </action>
  <verify>
  pnpm turbo build
  pnpm --filter @waiaas/adapter-evm test
  pnpm --filter @waiaas/adapter-solana test
  </verify>
  <done>
  EvmAdapter.buildContractCall builds EIP-1559 tx targeting contract address with calldata, 1.2x gas margin, metadata with selector/contractAddress.
  SolanaAdapter.buildContractCall builds tx message with programId instruction, AccountRole mapping, base64 instructionData.
  All adapter tests pass including new buildContractCall tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: CONTRACT_WHITELIST + METHOD_WHITELIST policy evaluation in DatabasePolicyEngine</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
    packages/daemon/src/__tests__/database-policy-engine.test.ts
  </files>
  <action>
  **DatabasePolicyEngine extensions:**

  In `packages/daemon/src/pipeline/database-policy-engine.ts`:

  1. Add new interfaces at the top (alongside existing ones):
     ```ts
     interface ContractWhitelistRules {
       contracts: Array<{ address: string; name?: string }>;
     }

     interface MethodWhitelistRules {
       methods: Array<{ contractAddress: string; selectors: string[] }>;
     }
     ```

  2. Add `contractAddress?: string` and `selector?: string` optional fields to the `TransactionParam` interface:
     ```ts
     interface TransactionParam {
       type: string;
       amount: string;
       toAddress: string;
       chain: string;
       tokenAddress?: string;
       /** Contract address for CONTRACT_WHITELIST evaluation (CONTRACT_CALL only). */
       contractAddress?: string;
       /** Function selector (4-byte hex, e.g. '0x12345678') for METHOD_WHITELIST evaluation (CONTRACT_CALL only). */
       selector?: string;
     }
     ```

  3. Add `evaluateContractWhitelist()` private method between evaluateAllowedTokens and evaluateSpendingLimit:
     - Only applies to `CONTRACT_CALL` transaction type. For non-CONTRACT_CALL, return null.
     - If transaction type is `CONTRACT_CALL` and no `CONTRACT_WHITELIST` policy exists:
       -> deny with reason `'Contract calls disabled: no CONTRACT_WHITELIST policy configured'` (maps to CONTRACT_CALL_DISABLED error code).
     - If `CONTRACT_WHITELIST` policy exists, check if `transaction.contractAddress` (or `transaction.toAddress` as fallback) is in `rules.contracts[].address`:
       -> If found: return null (continue evaluation).
       -> If not found: deny with reason `'Contract not whitelisted: {address}'` (maps to CONTRACT_NOT_WHITELISTED).
     - Case-insensitive comparison (EVM address compat).

  4. Add `evaluateMethodWhitelist()` private method after evaluateContractWhitelist:
     - Only applies to `CONTRACT_CALL` transaction type. For non-CONTRACT_CALL, return null.
     - If no `METHOD_WHITELIST` policy exists: return null (method restriction is optional).
     - If `METHOD_WHITELIST` policy exists, find matching entry for `transaction.contractAddress`:
       -> If no entry for this contract: return null (no method restriction for this contract).
       -> If entry found, check if `transaction.selector` is in `entry.selectors`:
         -> If found: return null (method allowed).
         -> If not found: deny with reason `'Method not whitelisted: {selector} on contract {address}'` (maps to METHOD_NOT_WHITELISTED).
     - Case-insensitive comparison for selectors (EVM).

  5. Update the `evaluate()` method chain to add steps 4c and 4d:
     ```ts
     // Step 4b: Evaluate ALLOWED_TOKENS
     // ... (existing)

     // Step 4c: Evaluate CONTRACT_WHITELIST (contract call whitelist)
     const contractWhitelistResult = this.evaluateContractWhitelist(resolved, transaction);
     if (contractWhitelistResult !== null) {
       return contractWhitelistResult;
     }

     // Step 4d: Evaluate METHOD_WHITELIST (method-level restriction)
     const methodWhitelistResult = this.evaluateMethodWhitelist(resolved, transaction);
     if (methodWhitelistResult !== null) {
       return methodWhitelistResult;
     }

     // Step 5: Evaluate SPENDING_LIMIT
     ```

  6. Update `evaluateAndReserve()` raw SQL transaction path similarly -- add CONTRACT_WHITELIST and METHOD_WHITELIST evaluation between ALLOWED_TOKENS and SPENDING_LIMIT.

  **Tests:**

  In `packages/daemon/src/__tests__/database-policy-engine.test.ts`, add a new `describe('CONTRACT_WHITELIST + METHOD_WHITELIST')` block:

  1. Test: CONTRACT_CALL with no CONTRACT_WHITELIST policy -> deny (CONTRACT_CALL_DISABLED).
  2. Test: CONTRACT_CALL with CONTRACT_WHITELIST + contract in list -> allow (continue to SPENDING_LIMIT).
  3. Test: CONTRACT_CALL with CONTRACT_WHITELIST + contract NOT in list -> deny (CONTRACT_NOT_WHITELISTED).
  4. Test: CONTRACT_CALL with CONTRACT_WHITELIST (pass) + METHOD_WHITELIST (selector in list) -> allow.
  5. Test: CONTRACT_CALL with CONTRACT_WHITELIST (pass) + METHOD_WHITELIST (selector NOT in list) -> deny (METHOD_NOT_WHITELISTED).
  6. Test: CONTRACT_CALL with CONTRACT_WHITELIST (pass) + METHOD_WHITELIST (no entry for this contract) -> allow (no restriction).
  7. Test: Non-CONTRACT_CALL type (TRANSFER) is NOT affected by CONTRACT_WHITELIST.
  8. Test: Case-insensitive address comparison for CONTRACT_WHITELIST.

  Follow the existing test patterns in the file (insert policy rows, call evaluate(), assert result).

  Verify: `pnpm --filter @waiaas/daemon test` passes.
  </action>
  <verify>
  pnpm turbo build
  pnpm --filter @waiaas/daemon test
  </verify>
  <done>
  DatabasePolicyEngine evaluates CONTRACT_WHITELIST (default deny for CONTRACT_CALL, opt-in whitelist) and METHOD_WHITELIST (optional method-level restriction).
  Both evaluate() and evaluateAndReserve() paths include the new evaluation steps.
  8+ new policy engine tests pass covering all CONTRACT_WHITELIST/METHOD_WHITELIST scenarios.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo build` -- monorepo builds clean (all packages)
2. `pnpm --filter @waiaas/adapter-evm test` -- EVM adapter tests pass including buildContractCall
3. `pnpm --filter @waiaas/adapter-solana test` -- Solana adapter tests pass including buildContractCall
4. `pnpm --filter @waiaas/daemon test` -- daemon tests pass including CONTRACT_WHITELIST + METHOD_WHITELIST policy evaluation
5. No regressions: existing tests for buildTransaction, buildTokenTransfer, buildApprove, WHITELIST, ALLOWED_TOKENS, SPENDING_LIMIT still pass
</verification>

<success_criteria>
- EvmAdapter.buildContractCall builds EIP-1559 tx with calldata + 1.2x gas + metadata
- SolanaAdapter.buildContractCall builds tx with programId instruction + AccountRole mapping
- CONTRACT_WHITELIST default deny: no policy = CONTRACT_CALL_DISABLED
- CONTRACT_WHITELIST whitelist: contract in list = allow, not in list = deny
- METHOD_WHITELIST: selector check, optional (no policy = no restriction)
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/79-contract-call-approve/79-01-SUMMARY.md`
</output>
