---
phase: 118-evm-calldata-encoding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/errors/error-codes.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/api/routes/utils.ts
  - packages/daemon/src/api/routes/index.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/api/error-hints.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/utils/encode-calldata with valid ABI + functionName + args returns 200 with calldata hex, selector hex, and functionName"
    - "POST /v1/utils/encode-calldata with invalid functionName returns 400 ABI_ENCODING_FAILED"
    - "POST /v1/utils/encode-calldata without sessionAuth returns 401"
    - "ABI_ENCODING_FAILED is a registered error code in @waiaas/core"
  artifacts:
    - path: "packages/daemon/src/api/routes/utils.ts"
      provides: "encode-calldata route handler"
      exports: ["utilsRoutes"]
    - path: "packages/core/src/errors/error-codes.ts"
      provides: "ABI_ENCODING_FAILED error code"
      contains: "ABI_ENCODING_FAILED"
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "EncodeCalldataRequestSchema, EncodeCalldataResponseSchema"
      contains: "EncodeCalldataRequestSchema"
  key_links:
    - from: "packages/daemon/src/api/routes/utils.ts"
      to: "viem.encodeFunctionData"
      via: "import { encodeFunctionData } from 'viem'"
      pattern: "encodeFunctionData"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/api/routes/utils.ts"
      via: "app.route('/v1', utilsRoutes())"
      pattern: "utilsRoutes"
    - from: "packages/daemon/src/api/server.ts"
      to: "sessionAuth middleware"
      via: "app.use('/v1/utils/*', sessionAuth)"
      pattern: "/v1/utils/\\*"
---

<objective>
POST /v1/utils/encode-calldata REST API endpoint that wraps viem's encodeFunctionData, with ABI_ENCODING_FAILED error code, OpenAPI schemas, and sessionAuth protection.

Purpose: AI agents need to encode EVM function calls into hex calldata without handling ABI encoding libraries themselves. This stateless utility endpoint centralizes encoding, making it consistent and auditable.
Output: Working REST endpoint returning `{ calldata, selector, functionName }` on success, ABI_ENCODING_FAILED on invalid input.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/118-evm-calldata-encoding/118-RESEARCH.md

@packages/daemon/src/api/routes/nonce.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/daemon/src/api/routes/index.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/error-hints.ts
@packages/core/src/errors/error-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ABI_ENCODING_FAILED error code + OpenAPI schemas + utils route</name>
  <files>
    packages/core/src/errors/error-codes.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
    packages/daemon/src/api/routes/utils.ts
    packages/daemon/src/api/error-hints.ts
  </files>
  <action>
1. **Add ABI_ENCODING_FAILED to error-codes.ts** in the TX domain section (after the existing TX domain entries, before POLICY domain):
```typescript
ABI_ENCODING_FAILED: {
  code: 'ABI_ENCODING_FAILED',
  domain: 'TX',
  httpStatus: 400,
  retryable: false,
  message: 'ABI encoding failed',
},
```
Update the TX domain comment count accordingly (e.g., "21" instead of "20").

2. **Add error hint in error-hints.ts** in the TX domain section:
```typescript
ABI_ENCODING_FAILED: 'Check that functionName exists in the provided ABI and args match the expected types. Use z.array(ABI fragment) for the abi parameter.',
```

3. **Add OpenAPI schemas to openapi-schemas.ts** at the end of the file (before the closing line), in a new section:
```typescript
// ---------------------------------------------------------------------------
// Utils: Encode Calldata Schemas
// ---------------------------------------------------------------------------

export const EncodeCalldataRequestSchema = z
  .object({
    abi: z.array(z.record(z.unknown())).describe('ABI fragment array (JSON)'),
    functionName: z.string().describe('Function name to encode'),
    args: z.array(z.any()).optional().default([]).describe('Function arguments'),
  })
  .openapi('EncodeCalldataRequest');

export const EncodeCalldataResponseSchema = z
  .object({
    calldata: z.string().describe('Hex-encoded calldata (0x-prefixed)'),
    selector: z.string().describe('Function selector (first 4 bytes, 0x-prefixed)'),
    functionName: z.string().describe('Encoded function name'),
  })
  .openapi('EncodeCalldataResponse');
```

4. **Create utils.ts route** following the nonce.ts pattern (stateless route, OpenAPIHono):
```typescript
/**
 * Utils routes: stateless utility endpoints.
 *
 * POST /utils/encode-calldata - Encode EVM function call into calldata hex.
 * Wraps viem's encodeFunctionData(). No DB, keystore, or adapter dependencies.
 */

import { OpenAPIHono, createRoute } from '@hono/zod-openapi';
import { encodeFunctionData, type Abi } from 'viem';
import { WAIaaSError } from '@waiaas/core';
import {
  EncodeCalldataRequestSchema,
  EncodeCalldataResponseSchema,
  openApiValidationHook,
  buildErrorResponses,
} from './openapi-schemas.js';

const encodeCalldataRoute = createRoute({
  method: 'post',
  path: '/utils/encode-calldata',
  tags: ['Utils'],
  summary: 'Encode EVM function call into calldata hex',
  request: {
    body: {
      content: {
        'application/json': { schema: EncodeCalldataRequestSchema },
      },
    },
  },
  responses: {
    200: {
      description: 'Encoded calldata',
      content: { 'application/json': { schema: EncodeCalldataResponseSchema } },
    },
    ...buildErrorResponses(['ABI_ENCODING_FAILED']),
  },
});

export function utilsRoutes(): OpenAPIHono {
  const router = new OpenAPIHono({ defaultHook: openApiValidationHook });

  router.openapi(encodeCalldataRoute, (c) => {
    const { abi, functionName, args } = c.req.valid('json');
    try {
      const calldata = encodeFunctionData({
        abi: abi as Abi,
        functionName,
        args: args ?? [],
      });
      const selector = calldata.slice(0, 10); // first 4 bytes = function selector
      return c.json({ calldata, selector, functionName }, 200);
    } catch (err) {
      throw new WAIaaSError('ABI_ENCODING_FAILED', {
        message: err instanceof Error ? err.message : 'ABI encoding failed',
      });
    }
  });

  return router;
}
```

**Important notes:**
- Import `encodeFunctionData` and `Abi` directly from `viem` (NOT from adapter-evm).
- Use `z.array(z.any())` for `args` to allow polymorphic types (strings, numbers, booleans, arrays).
- The `args` field is optional with `default([])` for zero-argument functions.
- Cast `abi` to `Abi` type since viem needs it typed but we accept `z.record(z.unknown())[]` from JSON.
- The route handler is synchronous (no async needed) since `encodeFunctionData` is a pure function.
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build --filter=@waiaas/core --filter=@waiaas/daemon` to verify TypeScript compilation succeeds. Confirm ABI_ENCODING_FAILED is in the compiled output.
  </verify>
  <done>
ABI_ENCODING_FAILED exists in error-codes.ts, EncodeCalldataRequest/Response schemas exist in openapi-schemas.ts, utils.ts exports utilsRoutes() with the encode-calldata route, error hint is registered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route registration in server.ts + barrel export + tests</name>
  <files>
    packages/daemon/src/api/routes/index.ts
    packages/daemon/src/api/server.ts
  </files>
  <action>
1. **Add barrel export to routes/index.ts:**
```typescript
export { utilsRoutes } from './utils.js';
```

2. **Register utils route in server.ts:**

Add import at the top (alongside other route imports):
```typescript
import { utilsRoutes } from './routes/utils.js';
```

Add sessionAuth for `/v1/utils/*` inside the existing `if (deps.jwtSecretManager && deps.db)` block, after the existing `app.use('/v1/transactions/*', sessionAuth)` line:
```typescript
app.use('/v1/utils/*', sessionAuth);
```

Register the route AFTER the nonce route registration (since utils is stateless like nonce, but with auth):
```typescript
// Register utils routes (sessionAuth required -- stateless utilities)
app.route('/v1', utilsRoutes());
```

Place this right after `app.route('/v1', nonceRoutes());` line.

**Important:** The utils route registration is OUTSIDE any deps-check block because it has no deps. The sessionAuth middleware is registered INSIDE the jwtSecretManager+db block.

3. **Verify the full integration** by running existing tests to confirm no regressions. Then write a focused test or curl command:
```bash
# Build and run tests
cd /Users/minho.yoo/dev/wallet/WAIaaS
npx turbo build --filter=@waiaas/core --filter=@waiaas/daemon
npx turbo test --filter=@waiaas/daemon
```
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && npx turbo build --filter=@waiaas/daemon` succeeds without TypeScript errors. Run `npx turbo test --filter=@waiaas/daemon` to verify no regressions in existing tests.
  </verify>
  <done>
utils.ts is exported from routes/index.ts, server.ts registers sessionAuth on /v1/utils/* and mounts utilsRoutes(), daemon build succeeds, existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build --filter=@waiaas/core --filter=@waiaas/daemon` succeeds
2. `npx turbo test --filter=@waiaas/daemon` passes (no regressions)
3. Grep confirms: `grep -r "ABI_ENCODING_FAILED" packages/core/src/errors/error-codes.ts` returns match
4. Grep confirms: `grep -r "utilsRoutes" packages/daemon/src/api/server.ts` returns match
5. Grep confirms: `grep -r "EncodeCalldataRequestSchema" packages/daemon/src/api/routes/openapi-schemas.ts` returns match
</verification>

<success_criteria>
- ABI_ENCODING_FAILED error code registered in @waiaas/core with domain TX, httpStatus 400
- POST /v1/utils/encode-calldata route exists with OpenAPI schema validation
- Route uses viem encodeFunctionData directly (not via adapter-evm)
- sessionAuth middleware registered on /v1/utils/* path
- Response includes calldata (hex), selector (hex), functionName
- Invalid ABI/function/args -> ABI_ENCODING_FAILED 400 error
- All existing daemon tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/118-evm-calldata-encoding/118-01-SUMMARY.md`
</output>
