---
phase: 14-test-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/v0.4/41-test-levels-matrix-coverage.md
autonomous: true

must_haves:
  truths:
    - "6개 테스트 레벨(Unit/Integration/E2E/Chain Integration/Security/Platform)의 범위, 실행 환경, 실행 빈도, 속도 목표가 각각 구분되어 읽을 수 있다"
    - "9개 모듈별 테스트 레벨 적용 매트릭스에서 어떤 모듈에 어떤 레벨이 적용되는지 O/X로 확인할 수 있다"
    - "패키지별 커버리지 목표 수치가 Tier(Critical/High/Normal/Low)와 함께 표시되고, 각 수치의 근거가 설명되어 있다"
    - "@waiaas/daemon은 모듈(디렉토리) 단위로 세분화된 커버리지 목표가 있다"
  artifacts:
    - path: "docs/v0.4/41-test-levels-matrix-coverage.md"
      provides: "테스트 레벨 정의, 모듈 매트릭스, 커버리지 목표"
      contains: "## 테스트 레벨 정의"
  key_links:
    - from: "docs/v0.4/41-test-levels-matrix-coverage.md"
      to: ".planning/phases/14-test-foundation/14-RESEARCH.md"
      via: "Jest 30 + @swc/jest 기반 설정 패턴 참조"
      pattern: "Jest 30"
---

<objective>
Phase 14의 첫 번째 산출물로서, WAIaaS 전체 테스트 전략의 구조적 뼈대를 확정한다. 6개 테스트 레벨을 정의하고, 9개 모듈별 적용 매트릭스를 작성하며, 보안 위험도 기반 커버리지 목표를 설정한다.

Purpose: 이후 Phase 15~18에서 도메인별 시나리오를 작성할 때, "어떤 레벨에서, 어떤 빈도로, 어떤 커버리지 목표로" 테스트할지 참조하는 기준 문서가 된다.
Output: `docs/v0.4/41-test-levels-matrix-coverage.md` — 테스트 레벨 정의서, 모듈 매트릭스, 커버리지 목표 테이블
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-test-foundation/14-CONTEXT.md
@.planning/phases/14-test-foundation/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 6개 테스트 레벨 정의 및 실행 전략</name>
  <files>docs/v0.4/41-test-levels-matrix-coverage.md</files>
  <action>
`docs/v0.4/41-test-levels-matrix-coverage.md` 파일을 생성한다. 문서 번호는 41 (v0.2의 40번 이후 연속).

**섹션 1: 테스트 레벨 정의**

6개 테스트 레벨 각각에 대해 다음을 정의한다:

| Level | Scope | Environment | Frequency | Mock 범위 | 속도 목표 |
|-------|-------|-------------|-----------|----------|----------|
| Unit | 단일 함수/클래스 | Node.js + @swc/jest | 매 커밋 | 모든 외부 의존성 mock | 패키지당 <10s |
| Integration | 모듈 간 연동 (DB 포함) | Node.js + 실제 SQLite (tmpdir) | 매 PR | 외부 서비스만 mock (RPC, 알림) | 패키지당 <30s |
| E2E | API 엔드포인트 전체 흐름 | Node.js + Hono test client + mock chain | 매 PR | 블록체인만 mock | 전체 <2min |
| Chain Integration | 실제 블록체인 네트워크 | Devnet/Testnet | nightly/릴리스 | mock 없음 | 전체 <10min |
| Security | 공격 시나리오 재현 | Node.js + Unit 환경 | 매 PR | Unit과 동일 | 전체 <1min |
| Platform | CLI/Docker/Desktop 동작 | 각 플랫폼 환경 | 릴리스 | 환경에 따라 다름 | N/A |

각 레벨에 대해 2-3줄의 설명 문단을 작성하여 "이 레벨에서 무엇을 검증하고, 무엇을 검증하지 않는지"를 명확히 한다.

**속도 vs 충실도 최적화 전략** (Claude's Discretion 영역):
- Unit: `--maxWorkers=75%`로 CPU 활용 극대화, 모든 외부 의존성 mock으로 I/O 제거
- Integration: `--runInBand` 권장 (SQLite 파일 잠금 방지), 또는 테스트별 독립 tmpdir
- E2E: `--detectOpenHandles`로 리소스 누수 방지, Hono 서버 close 확인
- Security: Unit과 동일 환경이나, 공격 벡터별 시나리오 집중 (Phase 15에서 상세화)
- 개발 시: `--bail` 활성으로 빠른 피드백, CI에서: `--bail=1` 비활성

**실행 빈도 피라미드** (Locked Decision):
- 매 커밋: Unit (로컬 watch 모드 + CI)
- 매 PR: Integration, E2E, Security
- nightly/릴리스: Chain Integration, Platform

**테스트 인프라 참조** (Locked Decision):
- 프레임워크: Jest 30 + @swc/jest
- 로컬 개발: Watch 모드 기본
- CI 게이트: 초기 soft gate(경고만) → 안정화 후 hard gate(PR 차단)
- 커버리지 측정: Unit + Integration만 (E2E는 별도 관리)
  </action>
  <verify>
파일이 존재하고 6개 레벨 모두 테이블에 포함되어 있는지 확인:
`grep -c "^| " docs/v0.4/41-test-levels-matrix-coverage.md` 결과가 20줄 이상 (헤더 포함 복수 테이블)
`grep "Unit\|Integration\|E2E\|Chain Integration\|Security\|Platform" docs/v0.4/41-test-levels-matrix-coverage.md | wc -l` 결과가 12줄 이상 (레벨 정의 + 매트릭스 중복)
  </verify>
  <done>6개 테스트 레벨이 각각 범위/환경/빈도/Mock범위/속도목표와 함께 정의되어 있고, 속도 vs 충실도 최적화 전략이 레벨별로 명시되어 있다</done>
</task>

<task type="auto">
  <name>Task 2: 모듈별 테스트 매트릭스 및 커버리지 목표</name>
  <files>docs/v0.4/41-test-levels-matrix-coverage.md</files>
  <action>
Task 1에서 생성한 동일 파일에 섹션 2, 3을 추가한다.

**섹션 2: 모듈별 테스트 레벨 매트릭스**

9개 모듈(7 모노레포 패키지 + Python SDK + Desktop App)에 대해 6개 테스트 레벨 적용 여부를 O/X 매트릭스로 작성:

| Module | Unit | Integration | E2E | Chain Integration | Security | Platform |
|--------|------|-------------|-----|-------------------|----------|----------|
| @waiaas/core | O | O | - | - | O | - |
| @waiaas/daemon | O | O | O | - | O | - |
| @waiaas/adapter-solana | O | O | - | O | - | - |
| @waiaas/adapter-evm | O | - | - | - | - | - |
| @waiaas/cli | - | O | - | - | - | O |
| @waiaas/sdk | O | O | - | - | - | - |
| @waiaas/mcp | O | O | - | - | - | - |
| Python SDK | O | O | - | - | - | - |
| Desktop App (Tauri) | - | - | - | - | - | O |

각 O 셀에 1줄 설명을 추가하여 "이 모듈에서 이 레벨로 무엇을 검증하는지" 명확히 한다. 예: "@waiaas/core Unit: Zod 스키마 검증, Enum 일관성, 순수 유틸리티 함수". X(해당없음)인 경우 "-"로 표시하고 이유는 별도 주석 없이 생략.

**섹션 3: 패키지별 커버리지 목표**

보안 위험도 기반 3-tier 커버리지를 적용한다 (Locked Decision: 보안 critical 90%+, 일반 80%, 유틸리티/CLI 70%).

패키지 수준 테이블:

| Package | Target | Tier | Rationale |
|---------|--------|------|-----------|
| @waiaas/core | 90%+ | Critical | SSoT Enum, Zod 스키마, 인터페이스 정의. 모든 패키지의 기반 |
| @waiaas/daemon | 하위 모듈별 차등 | Critical~Normal | 보안 모듈과 유틸리티 혼재 |
| @waiaas/adapter-solana | 80%+ | High | RPC 의존 높음. Mock 한계 인정하되 핵심 로직 검증 |
| @waiaas/adapter-evm | 50%+ | Low | Stub만 존재. 모든 메소드 CHAIN_NOT_SUPPORTED throw 확인 |
| @waiaas/cli | 70%+ | Normal | 프로세스 spawn 기반 통합 테스트 위주 |
| @waiaas/sdk | 80%+ | High | 공개 인터페이스, 타입 안정성 |
| @waiaas/mcp | 70%+ | Normal | SDK 위의 얇은 레이어 |
| Python SDK | 80%+ | High | httpx + Pydantic v2, 별도 레포 |
| Desktop App (Tauri) | 제외 | - | UI는 수동 QA 중심 |

@waiaas/daemon 모듈별 세분화 (Claude's Discretion — 패키지+모듈 혼합):

| daemon Sub-Module | Target | Rationale |
|-------------------|--------|-----------|
| infrastructure/keystore/ | 95%+ | AES-256-GCM, Argon2id 등 자금 보호 최전선 |
| services/session-service | 90%+ | JWT 인증 핵심, 세션 만료/무효화 |
| services/policy-engine | 90%+ | 4-tier 정책 평가, TOCTOU 방지 |
| services/transaction-service | 90%+ | 6단계 파이프라인, 자금 이동 |
| server/middleware/ | 85%+ | sessionAuth, ownerAuth, rate-limit, host-guard |
| server/routes/ | 80%+ | API 핸들러, 요청/응답 검증 |
| infrastructure/database/ | 80%+ | Drizzle ORM 쿼리, 마이그레이션 |
| infrastructure/notifications/ | 80%+ | 알림 채널 연동 (완전 Mock) |
| lifecycle/ | 75%+ | 프로세스 관리, 시그널 핸들링 |

각 커버리지 수치에 "왜 이 수치인가" 근거를 1-2줄로 명시한다. 근거는 보안 위험도와 모듈의 실패 시 영향도를 기반으로 한다.

**커버리지 측정 방법:**
- Jest 30의 v8 coverage provider 사용 (기본)
- coverageThreshold: 루트 jest.config.ts에서 glob 패턴으로 패키지별/모듈별 임계값 설정
- Jest projects에서 per-project coverageThreshold 제한 존재하므로 루트에서 관리 (Pitfall #2 대응)

**CI 게이트 전략** (Locked Decision):
- Phase 1 (초기): soft gate — 커버리지 미달 시 경고 출력하되 PR은 통과
- Phase 2 (안정화 후): hard gate — 커버리지 미달 시 PR 차단
- 전환 시점: 각 패키지의 커버리지가 목표의 80% 이상에 안정적으로 도달한 후
  </action>
  <verify>
매트릭스 테이블 확인:
`grep "@waiaas" docs/v0.4/41-test-levels-matrix-coverage.md | wc -l` 결과가 14줄 이상 (패키지 테이블 + daemon 서브모듈 테이블)
`grep "90%\|80%\|70%\|95%\|85%\|75%\|50%" docs/v0.4/41-test-levels-matrix-coverage.md | wc -l` 결과가 10줄 이상
  </verify>
  <done>9개 모듈 x 6개 레벨 매트릭스가 O/X로 표시되어 있고, 패키지별 커버리지 목표가 Tier/근거와 함께 정의되어 있으며, @waiaas/daemon은 9개 서브모듈로 세분화되어 있다</done>
</task>

</tasks>

<verification>
1. `docs/v0.4/41-test-levels-matrix-coverage.md` 파일이 존재한다
2. 6개 테스트 레벨(Unit/Integration/E2E/Chain Integration/Security/Platform) 모두 정의 섹션에 포함
3. 9개 모듈 x 6개 레벨 매트릭스 테이블이 존재
4. 패키지별 커버리지 목표 테이블이 존재 (9개 패키지 + Desktop 제외)
5. @waiaas/daemon 서브모듈 커버리지 테이블이 존재 (9개 서브모듈)
6. CI 게이트 전략(soft → hard)이 기술되어 있음
7. 속도 vs 충실도 최적화 전략이 레벨별로 기술되어 있음
</verification>

<success_criteria>
- TLVL-01 충족: 6개 레벨의 범위/환경/빈도/속도목표가 구분 가능
- TLVL-02 충족: 9개 모듈별 레벨 적용 매트릭스 O/X 확인 가능
- TLVL-03 충족: 패키지별 커버리지 수치 + 근거 명시
- Phase 15~18에서 "어떤 레벨, 어떤 커버리지"를 참조할 수 있는 기준 문서 완성
</success_criteria>

<output>
After completion, create `.planning/phases/14-test-foundation/14-01-SUMMARY.md`
</output>
