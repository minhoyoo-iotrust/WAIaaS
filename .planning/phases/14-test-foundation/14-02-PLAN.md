---
phase: 14-test-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/v0.4/42-mock-boundaries-interfaces-contracts.md
autonomous: true

must_haves:
  truths:
    - "5개 외부 의존성(블록체인 RPC, 알림 채널, 파일시스템, 시간, Owner 서명)의 Mock 방식이 Unit/Integration/E2E 레벨별로 조회 가능하다"
    - "기존 4개 인터페이스(IChainAdapter, INotificationChannel, ILocalKeyStore, IPolicyEngine)의 Mock 구현 가능성과 메소드별 분석이 문서화되어 있다"
    - "IClock 인터페이스는 now(): Date 하나의 메소드로 정의되어 있고, FakeClock의 advance/setTime 메소드가 명세되어 있다"
    - "IOwnerSigner(ISigner) 인터페이스는 address, chain, signMessage(message): Promise<string>으로 정의되어 있고, FakeOwnerSigner의 고정 키쌍 방식이 명세되어 있다"
    - "5개 인터페이스 전체에 대한 Contract Test 전략이 팩토리 함수 기반 공유 스위트 패턴으로 정의되어 있다"
  artifacts:
    - path: "docs/v0.4/42-mock-boundaries-interfaces-contracts.md"
      provides: "Mock 경계 정의, IClock/ISigner 인터페이스 스펙, Contract Test 전략"
      contains: "## Mock 경계 매트릭스"
  key_links:
    - from: "docs/v0.4/42-mock-boundaries-interfaces-contracts.md"
      to: ".planning/phases/14-test-foundation/14-RESEARCH.md"
      via: "인터페이스 인벤토리 및 Contract Test 패턴 참조"
      pattern: "IChainAdapter|IPolicyEngine|INotificationChannel|IClock|ISigner"
    - from: "docs/v0.4/42-mock-boundaries-interfaces-contracts.md"
      to: "docs/v0.2/27-chain-adapter-interface.md"
      via: "IChainAdapter 13개 메소드 참조"
      pattern: "IChainAdapter.*13"
---

<objective>
Phase 14의 두 번째 산출물로서, WAIaaS 테스트에서 외부 의존성을 어떻게 격리할지(Mock 경계), 테스트를 위한 신규 인터페이스(IClock, ISigner)의 스펙, 그리고 모든 인터페이스의 Mock-실제 구현 동작 일치를 보장하는 Contract Test 전략을 확정한다.

Purpose: 구현 단계에서 Mock 클래스, Fake 객체, Contract Test 스위트를 코드로 작성할 때 "무엇을 만들어야 하는지"가 명확한 설계 기준 문서가 된다.
Output: `docs/v0.4/42-mock-boundaries-interfaces-contracts.md` — Mock 경계 매트릭스, 인터페이스 스펙, Contract Test 전략
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-test-foundation/14-CONTEXT.md
@.planning/phases/14-test-foundation/14-RESEARCH.md

# v0.2 설계 문서 (인터페이스 원본 참조)
@docs/v0.2/27-chain-adapter-interface.md
@docs/v0.2/29-api-framework-design.md
@docs/v0.2/30-session-token-protocol.md
@docs/v0.2/33-time-lock-approval-mechanism.md
@docs/v0.2/34-owner-wallet-connection.md
@docs/v0.2/35-notification-architecture.md
@docs/v0.2/26-keystore-spec.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mock 경계 매트릭스 및 기존 인터페이스 Mock 가능성 검증</name>
  <files>docs/v0.4/42-mock-boundaries-interfaces-contracts.md</files>
  <action>
`docs/v0.4/42-mock-boundaries-interfaces-contracts.md` 파일을 생성한다. 문서 번호 42.

**섹션 1: Mock 경계 매트릭스**

5개 외부 의존성에 대해 테스트 레벨별 Mock 방식을 표로 정의한다:

| 외부 의존성 | Unit | Integration | E2E | Chain Integration |
|-------------|------|-------------|-----|-------------------|
| 블록체인 RPC | Mock RPC (canned responses) | Mock RPC (canned responses) | Mock RPC (시나리오 기반) | 실제 Devnet/Testnet |
| 알림 채널 (Telegram/Discord/ntfy.sh) | MockNotificationChannel | MockNotificationChannel | MockNotificationChannel | MockNotificationChannel |
| 파일시스템 (키스토어, config) | memfs (메모리) | tmpdir (실제 FS) | tmpdir (실제 FS) | tmpdir (실제 FS) |
| 시간 (IClock) | FakeClock (DI) | FakeClock 또는 RealClock (DI) | RealClock | RealClock |
| Owner 서명 (IOwnerSigner) | FakeOwnerSigner (DI) | FakeOwnerSigner (DI) | FakeOwnerSigner | 실제 지갑 (수동) |

각 셀에 대해 왜 이 방식인지 1줄 근거를 주석으로 추가한다.

Locked Decisions 반영:
- 블록체인 RPC: Mock-first (Unit/Integration Mock, E2E에서도 Mock, Local Validator는 Chain Integration부터)
- 알림 채널: 완전 Mock (모든 레벨에서 Mock, 실제 채널 호출 절대 없음)
- 시간: DI 인터페이스 (IClock)
- Owner 서명: DI 인터페이스 (ISigner/IOwnerSigner)
- 파일시스템: Unit memfs, Integration tmpdir

**섹션 2: 기존 인터페이스 Mock 가능성 검증 (MOCK-02)**

v0.2에서 정의한 4개 인터페이스 각각에 대해 다음을 분석한다:

**IChainAdapter** (27-chain-adapter-interface.md 참조):
- 13개 메소드 전체 목록: connect, disconnect, isConnected, getHealth, isValidAddress, getBalance, buildTransaction, simulateTransaction, signTransaction, submitTransaction, getTransactionStatus, waitForConfirmation, estimateFee
- Mock 가능성: HIGH — 모든 메소드가 순수 입출력이고 부작용이 DI 가능
- Mock 구현 방식: MockChainAdapter 클래스 (chain/network 설정 가능, canned responses)
- 주의점: signTransaction은 ILocalKeyStore.sign() 내부 호출을 Mock해야 함
- 13개 메소드 각각에 대해 "Mock 시 무엇을 반환할지" 요약 (예: getBalance → 고정 BigInt, buildTransaction → 사전 정의된 UnsignedTransaction)

**IPolicyEngine** (33-time-lock-approval-mechanism.md 참조):
- 1개 메소드: evaluate(request) → PolicyDecision
- Mock 가능성: HIGH — 단일 메소드, 입출력 명확
- Mock 구현 방식: MockPolicyEngine 클래스 (기본 INSTANT, setNextDecision()으로 제어)
- 주의점: DatabasePolicyEngine은 DB 의존이므로 Integration에서 실제 테스트

**INotificationChannel** (35-notification-architecture.md 참조):
- 2개 메소드: send(message), healthCheck() + 3 readonly props (type, name, channelId)
- Mock 가능성: HIGH — HTTP 호출만 Mock
- Mock 구현 방식: MockNotificationChannel (sentMessages 배열로 기록, simulateFailure로 에러 시뮬레이션)
- 주의점: TokenBucketRateLimiter는 별도 Unit 테스트

**ILocalKeyStore** (26-keystore-spec.md 참조):
- 6개 메소드: unlock, lock, sign, getPublicKey, addAgent, exportAgent
- Mock 가능성: MEDIUM — sodium-native C++ 바인딩 의존으로 Unit에서는 인터페이스 Mock 필수
- Mock 구현 방식: MockKeyStore (메모리 Map으로 키 관리, sign은 nacl.sign.detached 사용)
- 주의점: unlock→sign→lock 상태 순서 검증 필요. sign은 lock 상태에서 throw
- Integration에서만 실제 sodium-native 사용
  </action>
  <verify>
파일이 존재하고 핵심 내용 확인:
`grep "IChainAdapter\|IPolicyEngine\|INotificationChannel\|ILocalKeyStore" docs/v0.4/42-mock-boundaries-interfaces-contracts.md | wc -l` 결과가 8줄 이상
`grep "Mock 가능성" docs/v0.4/42-mock-boundaries-interfaces-contracts.md | wc -l` 결과가 4줄 (인터페이스 4개)
  </verify>
  <done>5개 외부 의존성의 레벨별 Mock 방식이 매트릭스로 표시되어 있고, 기존 4개 인터페이스 각각의 Mock 가능성(HIGH/MEDIUM)과 구현 방식이 메소드 수준으로 분석되어 있다</done>
</task>

<task type="auto">
  <name>Task 2: IClock/IOwnerSigner 인터페이스 스펙 및 Contract Test 전략</name>
  <files>docs/v0.4/42-mock-boundaries-interfaces-contracts.md</files>
  <action>
Task 1에서 생성한 동일 파일에 섹션 3, 4를 추가한다.

**섹션 3: 신규 테스트 인터페이스 스펙 (MOCK-03)**

**IClock 인터페이스:**
```typescript
// packages/core/src/interfaces/IClock.ts
export interface IClock {
  /** 현재 시각을 반환한다. */
  now(): Date
}
```
- Locked Decision: now(): Date만 제공. setTimeout/setInterval은 Jest의 useFakeTimers() 사용
- 사용처: SessionService (JWT 만료 검증), PolicyEngine (타임락 쿨다운 계산), TransactionService (트랜잭션 만료 확인), DelayQueueWorker (지연 시간 판단), ApprovalTimeoutWorker (승인 타임아웃)
- 각 사용처별로 IClock이 어떻게 DI되는지 패턴 명시 (생성자 주입, options 객체)

**FakeClock 테스트 구현:**
```typescript
// packages/core/src/testing/FakeClock.ts
export class FakeClock implements IClock {
  private currentTime: Date
  constructor(initialTime?: Date)  // 기본값: 2026-01-01T00:00:00Z
  now(): Date                       // 현재 시각의 복사본 반환 (참조 공유 방지)
  advance(ms: number): void         // 시간을 ms만큼 앞으로 이동
  setTime(time: Date): void         // 특정 시각으로 설정
}
```

**RealClock 운영 구현:**
```typescript
// packages/core/src/infrastructure/RealClock.ts
export class RealClock implements IClock {
  now(): Date { return new Date() }
}
```

**IOwnerSigner 인터페이스** (ISigner → IOwnerSigner로 명명, 파일명은 ISigner.ts 유지):

Research 결과 반영 (Claude's Discretion): Owner 서명만 추상화한다. Agent 서명은 기존 ILocalKeyStore.sign()으로 이미 충족된다.

근거:
- Owner 서명: 외부 지갑(WalletConnect v2)에서 SIWS/SIWE 메시지 서명, ownerAuth 미들웨어에서 검증
- Agent 서명: 로컬 키스토어(sodium guarded memory)에서 트랜잭션 서명, IChainAdapter.signTransaction이 내부 호출
- 두 서명은 용도/키 위치/호출 주체가 완전히 다르므로 하나의 인터페이스로 통합하면 오히려 혼란

```typescript
// packages/core/src/interfaces/ISigner.ts
export interface IOwnerSigner {
  /** Owner 지갑 주소 */
  readonly address: string
  /** Owner 지갑의 체인 타입 */
  readonly chain: 'solana' | 'ethereum'
  /**
   * 메시지에 서명한다.
   * SIWS/SIWE 형식의 메시지를 서명하여 ownerAuth 페이로드에 포함시킨다.
   * @param message - 서명할 메시지 (UTF-8 문자열)
   * @returns 서명 (Base58 for Solana, 0x hex for Ethereum)
   */
  signMessage(message: string): Promise<string>
}
```

**FakeOwnerSigner 테스트 구현:**
```typescript
// packages/core/src/testing/FakeSigner.ts
export class FakeOwnerSigner implements IOwnerSigner {
  readonly address: string          // 고정 시드에서 파생
  readonly chain: 'solana' | 'ethereum'
  constructor(chain?: 'solana' | 'ethereum')  // 기본값: 'solana'
  signMessage(message: string): Promise<string>  // nacl.sign.detached 사용
}
```
- 고정 시드 (0x42 * 32바이트)에서 결정적 키쌍 생성
- 테스트 재현성 보장: 동일 메시지 → 동일 서명
- Solana: Base58 인코딩, Ethereum: 0x hex 인코딩

**섹션 4: Contract Test 전략 (MOCK-04)**

Locked Decision: 전체 5개 인터페이스(IChainAdapter, IPolicyEngine, INotificationChannel, IClock, IOwnerSigner)에 Contract Test 적용.

**패턴: 팩토리 함수 기반 공유 스위트**

각 인터페이스에 대해 Contract Test 공유 함수를 만들고, Mock 구현과 실제 구현 모두가 동일 테스트를 통과하도록 한다.

파일 배치:
```
packages/core/__tests__/contracts/
  ├── chain-adapter.contract.ts       # chainAdapterContractTests(factory, options)
  ├── policy-engine.contract.ts       # policyEngineContractTests(factory)
  ├── notification-channel.contract.ts # notificationChannelContractTests(factory)
  ├── clock.contract.ts               # clockContractTests(factory)
  └── signer.contract.ts              # ownerSignerContractTests(factory)
```

각 Contract Test 공유 함수에 대해:
- 함수 시그니처 (TypeScript)
- 테스트 케이스 목록 (describe/test 구조)
- 실행 대상 (Mock + 실제 구현 조합)

**IChainAdapter Contract Test 상세** (Locked Decision: 13개 메소드 전체):

```
chainAdapterContractTests(factory, options?):
  describe 식별 프로퍼티:
    - chain이 유효한 ChainType
    - network가 유효한 NetworkType
  describe 연결 관리:
    - connect 전 isConnected === false
    - connect 후 isConnected === true (options.skipNetworkTests 아닌 경우)
    - disconnect 후 isConnected === false
  describe 주소 검증:
    - isValidAddress는 boolean 반환
    - 빈 문자열은 false 반환
  describe 잔액 조회:
    - getBalance는 bigint 반환 (skipNetworkTests 아닌 경우)
  describe 트랜잭션 흐름:
    - buildTransaction → UnsignedTransaction 반환
    - estimateFee → bigint 반환
    - signTransaction → SignedTransaction 반환
    - submitTransaction → txHash string 반환
    - getTransactionStatus → TransactionStatus 반환
  describe 에러 처리:
    - 연결 안 된 상태에서 getBalance → CHAIN_NOT_CONNECTED throw
    - 잘못된 주소로 buildTransaction → INVALID_ADDRESS throw
```

실행 대상:
- MockChainAdapter: packages/core/__tests__/contracts/ (Unit, skipNetworkTests: true)
- SolanaAdapter: packages/adapters/solana/__tests__/contracts/ (Chain Integration, skipNetworkTests: false)
- EvmAdapterStub: packages/adapters/evm/__tests__/contracts/ (Unit, 모든 메소드 CHAIN_NOT_SUPPORTED)

**IPolicyEngine Contract Test:**
```
policyEngineContractTests(factory):
  - evaluate가 PolicyDecision 반환
  - PolicyDecision에 allowed, tier 필드 존재
  - 알 수 없는 chain에 대해 에러 또는 INSTANT 반환
```

**INotificationChannel Contract Test:**
```
notificationChannelContractTests(factory):
  - send가 NotificationResult 반환
  - healthCheck가 boolean 반환
  - type, name, channelId readonly props 존재
```

**IClock Contract Test:**
```
clockContractTests(factory):
  - now()가 Date 인스턴스 반환
  - now().getTime()이 유효 (NaN 아님, > 0)
  - 연속 호출 시 시간 역행 없음 (t2 >= t1)
```

**IOwnerSigner Contract Test:**
```
ownerSignerContractTests(factory):
  - address가 비어있지 않은 string
  - chain이 'solana' 또는 'ethereum'
  - signMessage가 비어있지 않은 string 반환 (Promise)
  - 동일 메시지에 동일 서명 반환 (결정적)
  - signMessage 결과가 address로 검증 가능 (서명→검증 쌍)
```

**Contract Test 실행 전략:**
- Unit 레벨: Mock 구현에 대해 실행 (매 커밋)
- Integration 레벨: 실제 구현에 대해 실행 (매 PR)
- 의미: Mock과 실제 구현이 동일 테스트를 통과하면, Mock을 믿고 Unit 테스트 결과를 신뢰할 수 있다
  </action>
  <verify>
인터페이스 스펙 및 Contract Test 확인:
`grep "IClock\|IOwnerSigner\|ISigner" docs/v0.4/42-mock-boundaries-interfaces-contracts.md | wc -l` 결과가 10줄 이상
`grep "Contract Test\|contract" docs/v0.4/42-mock-boundaries-interfaces-contracts.md | wc -l` 결과가 10줄 이상
`grep "FakeClock\|FakeOwnerSigner" docs/v0.4/42-mock-boundaries-interfaces-contracts.md | wc -l` 결과가 4줄 이상
  </verify>
  <done>IClock(now(): Date)과 IOwnerSigner(address, chain, signMessage) 인터페이스 스펙이 TypeScript 코드로 정의되어 있고, FakeClock/FakeOwnerSigner의 테스트 구현 명세가 있으며, 5개 인터페이스 전체에 대한 팩토리 함수 기반 Contract Test 전략이 테스트 케이스 목록 수준으로 상세화되어 있다</done>
</task>

</tasks>

<verification>
1. `docs/v0.4/42-mock-boundaries-interfaces-contracts.md` 파일이 존재한다
2. 5개 외부 의존성 x 4개 테스트 레벨 Mock 매트릭스가 존재
3. 4개 기존 인터페이스의 Mock 가능성 분석(HIGH/MEDIUM)이 메소드 수준으로 존재
4. IClock 인터페이스 TypeScript 스펙 + FakeClock + RealClock 명세
5. IOwnerSigner 인터페이스 TypeScript 스펙 + FakeOwnerSigner 명세
6. Owner-only 범위 결정 근거 (Agent 서명은 ILocalKeyStore로 이미 충족)
7. 5개 인터페이스 각각의 Contract Test 공유 함수 시그니처 + 테스트 케이스 목록
8. IChainAdapter 13개 메소드 전체에 대한 Contract Test describe/test 구조
9. Contract Test 실행 전략 (Unit: Mock, Integration: 실제)
</verification>

<success_criteria>
- MOCK-01 충족: 5개 외부 의존성의 레벨별 Mock 방식 조회 가능
- MOCK-02 충족: 4개 기존 인터페이스 Mock 가능성 검증 완료
- MOCK-03 충족: IClock/IOwnerSigner 인터페이스 스펙 정의 완료
- MOCK-04 충족: 팩토리 함수 기반 Contract Test 전략이 5개 인터페이스에 대해 정의
- 구현 단계에서 Mock 클래스와 Contract Test를 바로 코드로 작성할 수 있는 설계 기준 확립
</success_criteria>

<output>
After completion, create `.planning/phases/14-test-foundation/14-02-SUMMARY.md`
</output>
