---
phase: 148-wc-signing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/wc-signing-bridge.ts
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/api/routes/transactions.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/core/src/errors/error-codes.ts
  - packages/core/src/i18n/en.ts
  - packages/core/src/i18n/ko.ts
autonomous: true

must_haves:
  truths:
    - "APPROVAL 정책 거래 발생 시 WC 세션이 있으면 Owner 지갑에 서명 요청이 자동 전송된다"
    - "EVM은 personal_sign(SIWE 메시지), Solana는 solana_signMessage로 서명 요청이 분기된다"
    - "WC 서명 요청은 fire-and-forget이며 파이프라인을 블로킹하지 않는다"
    - "WC 서명 요청 타임아웃이 ApprovalWorkflow 타임아웃과 동기화된다"
    - "기존 REST API(SIWE/SIWS) 직접 승인 경로가 여전히 동작한다"
  artifacts:
    - path: "packages/daemon/src/services/wc-signing-bridge.ts"
      provides: "WcSigningBridge 클래스 - requestSignature + 서명 메시지 빌더 + 에러 핸들러"
      exports: ["WcSigningBridge"]
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "stage4Wait APPROVAL 분기에 WC fire-and-forget 호출"
      contains: "wcSigningBridge"
  key_links:
    - from: "packages/daemon/src/pipeline/stages.ts"
      to: "packages/daemon/src/services/wc-signing-bridge.ts"
      via: "ctx.wcSigningBridge?.requestSignature() in stage4Wait APPROVAL branch"
      pattern: "wcSigningBridge.*requestSignature"
    - from: "packages/daemon/src/services/wc-signing-bridge.ts"
      to: "packages/daemon/src/services/wc-session-service.ts"
      via: "getSignClient() + getSessionTopic() + getSessionInfo()"
      pattern: "wcSessionService\\.get(SignClient|SessionTopic|SessionInfo)"
    - from: "packages/daemon/src/services/wc-signing-bridge.ts"
      to: "packages/daemon/src/workflow/approval-workflow.ts"
      via: "approve() + reject() on WC response/rejection"
      pattern: "approvalWorkflow\\.(approve|reject)"
---

<objective>
WcSigningBridge 서비스 생성 + stage4Wait APPROVAL 분기에 fire-and-forget WC 서명 요청 연동

Purpose: APPROVAL tier 거래 발생 시 WC 세션이 활성화된 지갑에 대해 Owner 지갑으로 자동 서명 요청을 전송하고, 응답(승인/거부/타임아웃)을 기존 ApprovalWorkflow에 반영하는 브릿지 레이어를 구축한다.
Output: wc-signing-bridge.ts, stages.ts 수정, PipelineContext/TransactionRouteDeps 확장, 데몬 라이프사이클 DI 연결
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/148-wc-signing/148-RESEARCH.md
@.planning/phases/146-wc-infra/146-01-SUMMARY.md
@.planning/phases/147-qr-pairing/147-01-SUMMARY.md

Key source files to reference:
@packages/daemon/src/services/wc-session-service.ts -- WcSessionService 전체 (getSignClient, getSessionTopic, getSessionInfo, CAIP2_CHAIN_IDS)
@packages/daemon/src/workflow/approval-workflow.ts -- approve(txId, sig), reject(txId), processExpiredApprovals, resolveTimeout
@packages/daemon/src/pipeline/stages.ts -- PipelineContext, stage4Wait APPROVAL 분기 (line 538-550)
@packages/daemon/src/api/routes/transactions.ts -- TransactionRouteDeps, PipelineContext 조립 (line 74-90, 330-366)
@packages/daemon/src/api/server.ts -- CreateAppDeps, transactionRoutes 호출 (line 313-330)
@packages/daemon/src/lifecycle/daemon.ts -- DaemonLifecycle, CreateAppDeps 조립
@packages/daemon/src/api/middleware/siwe-verify.ts -- verifySIWE(message, signature, expectedAddress) -> {valid, error}
@packages/daemon/src/api/middleware/owner-auth.ts -- Ed25519 검증 패턴 (sodium-native, decodeBase58)
@packages/daemon/src/api/middleware/address-validation.ts -- decodeBase58 export
</context>

<tasks>

<task type="auto">
  <name>Task 1: WcSigningBridge 서비스 생성</name>
  <files>
    packages/daemon/src/services/wc-signing-bridge.ts
    packages/core/src/errors/error-codes.ts
    packages/core/src/i18n/en.ts
    packages/core/src/i18n/ko.ts
  </files>
  <action>
**새 파일** `packages/daemon/src/services/wc-signing-bridge.ts` 생성:

```typescript
export interface WcSigningBridgeDeps {
  wcSessionService: WcSessionService;
  approvalWorkflow: ApprovalWorkflow;
  sqlite: Database; // better-sqlite3
}
```

**WcSigningBridge 클래스** 구현:

1. **`requestSignature(walletId: string, txId: string, chain: string): Promise<void>`** (public, fire-and-forget용):
   - `wcSessionService.getSignClient()` -> null이면 즉시 return (WC 미초기화)
   - `wcSessionService.getSessionTopic(walletId)` -> null이면 즉시 return (세션 없음)
   - `wcSessionService.getSessionInfo(walletId)` -> null이면 return
   - `buildSignRequest(chain, ownerAddress, txId, chainId)` 호출하여 메시지/메서드/파라미터 구성
   - `approval_channel`을 'walletconnect'로 UPDATE (WHERE tx_id = ? AND approved_at IS NULL AND rejected_at IS NULL)
   - approval 타임아웃 조회: `SELECT expires_at FROM pending_approvals WHERE tx_id = ? AND approved_at IS NULL AND rejected_at IS NULL` -> 현재 시간과의 차이를 초 단위로 계산하여 WC expiry로 사용. 조회 실패 시 300초 기본값.
   - `signClient.request({ topic, chainId, request: { method, params }, expiry: timeoutSeconds })` 호출
   - 성공 시: `handleSignatureResponse(chain, walletId, txId, message, result, ownerAddress)` 호출
   - 실패 시: `handleSignatureError(txId, error)` 호출

2. **`buildSignRequest(chain, ownerAddress, txId, chainId)`** (private):
   - EVM (chain === 'ethereum'):
     - `createSiweMessage()` from `viem/siwe` 사용
     - domain: `'waiaas.local'`
     - uri: `'http://localhost:3000'`
     - nonce: `crypto.randomBytes(16).toString('hex')` (import from 'node:crypto')
     - statement: `'Approve transaction ' + txId`
     - expirationTime: `new Date(Date.now() + 300_000)` (5분 기본, 실제 타임아웃은 expiry에서 관리)
     - version: `'1'`, chainId: `parseInt(chainId.split(':')[1] ?? '1', 10)`
     - address: ownerAddress as `0x${string}`
     - method: `'personal_sign'`
     - params: `['0x' + Buffer.from(siweMessage, 'utf8').toString('hex'), ownerAddress]` -- 순서 중요! [hexMessage, address]
     - return `{ message: siweMessage, method, params }`
   - Solana (chain !== 'ethereum'):
     - message: `'WAIaaS: Approve transaction ' + txId` (결정론적 포맷)
     - base58 인코딩: 기존 `@solana/kit`의 getBase58Encoder를 사용하지 말고, 간단한 Buffer + bs58 변환. 실제로는 WC Solana 스펙에 따라 base58로 인코딩해야 한다. `decodeBase58`의 역변환인 `encodeBase58`가 필요하므로, 직접 구현하거나 `bs58` 패키지 사용. **그러나 의존성 추가를 최소화하기 위해**: Buffer.from(message, 'utf8')를 base58로 인코딩. `address-validation.ts`에서 `bs58` 패키지를 이미 쓰고 있을 수 있으므로 확인 후 재사용. 없으면 간단한 인라인 base58 인코더 작성하거나, 별도 방안 사용. 실제 codebase의 `decodeBase58` 구현을 확인하여 역변환 가능 여부 판단.
     - method: `'solana_signMessage'`
     - params: `{ message: base58EncodedMessage, pubkey: ownerAddress }`
     - return `{ message: plainTextMessage, method, params }`

3. **`handleSignatureResponse(chain, walletId, txId, message, result, ownerAddress)`** (private):
   - EVM:
     - `result`는 `0x`-prefixed hex 서명 문자열
     - `verifySIWE({ message, signature: result, expectedAddress: ownerAddress })` 호출 (import from `../api/middleware/siwe-verify.js`)
     - 검증 성공: `this.deps.approvalWorkflow.approve(txId, result)` 호출
     - 검증 실패: 로그 경고 (서명 검증 실패는 reject하지 않음 -- Owner가 다시 시도 가능)
   - Solana:
     - `result`는 `{ signature: 'base58-string' }` 형태 -- `result.signature ?? result` 로 방어
     - base58 서명을 base64로 변환: `Buffer.from(decodeBase58(sig58)).toString('base64')` (기존 ownerAuth 검증이 base64 서명을 기대)
     - Ed25519 검증 (owner-auth.ts 패턴 재사용):
       ```
       const sodium = loadSodium()
       const signatureBytes = Buffer.from(base64Sig, 'base64')
       const messageBytes = Buffer.from(message, 'utf8')
       const publicKeyBytes = decodeBase58(ownerAddress)
       sodium.crypto_sign_verify_detached(signatureBytes, messageBytes, publicKeyBytes)
       ```
     - 검증 성공: `this.deps.approvalWorkflow.approve(txId, base64Sig)` 호출
     - 검증 실패: 로그 경고

4. **`handleSignatureError(txId, error)`** (private):
   - WC 에러 코드 상수 정의 (파일 상단):
     ```
     const WC_USER_REJECTED = [4001, 5000];
     const WC_REQUEST_EXPIRED = 8000;
     ```
   - `error?.code`가 WC_USER_REJECTED에 포함: `approvalWorkflow.reject(txId)` 호출 + `approval_channel` 업데이트
   - `error?.code`가 WC_REQUEST_EXPIRED이거나 기타 에러: 무시 (기존 approval-expired 워커가 처리). `console.warn` 로그만 출력.

5. **`loadSodium()` 헬퍼** (private 또는 모듈 스코프):
   - `createRequire(import.meta.url)('sodium-native')` -- owner-auth.ts와 동일 패턴

**에러 코드 추가** (error-codes.ts, en.ts, ko.ts):
- `WC_SIGNING_FAILED`: WC 서명 요청 실패 시 내부 로깅용 (실제로 throw하지 않음, 로그 전용)
  - en: `'WalletConnect signing request failed'`
  - ko: `'WalletConnect 서명 요청이 실패했습니다'`

**Import 주의:**
- `viem/siwe`에서 `createSiweMessage` import (이미 siwe-verify.ts에서 `parseSiweMessage`, `validateSiweMessage` import 패턴 존재)
- `verifySIWE` from `../api/middleware/siwe-verify.js`
- `decodeBase58` from `../api/middleware/address-validation.js`
- `WcSessionService` from `./wc-session-service.js`
- `ApprovalWorkflow` from `../workflow/approval-workflow.js`
- `randomBytes` from `node:crypto`
  </action>
  <verify>
- `pnpm build --filter=@waiaas/core` 성공
- `pnpm build --filter=@waiaas/daemon` 성공
- `packages/daemon/src/services/wc-signing-bridge.ts` 파일 존재, WcSigningBridge export
- 에러 코드 WC_SIGNING_FAILED가 error-codes.ts, en.ts, ko.ts에 존재
  </verify>
  <done>
WcSigningBridge 클래스가 requestSignature(walletId, txId, chain) 메서드로 EVM/Solana 분기 서명 요청을 전송하고, 응답 시 verifySIWE/Ed25519 검증 후 approvalWorkflow.approve/reject를 호출하며, 빌드가 성공한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: PipelineContext/stage4Wait WC 연동 + DI 배선</name>
  <files>
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/api/routes/transactions.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/lifecycle/daemon.ts
  </files>
  <action>
**stages.ts 수정:**

1. PipelineContext 인터페이스에 추가:
   ```typescript
   // v1.6.1: WC signing bridge for APPROVAL fire-and-forget
   wcSigningBridge?: WcSigningBridge;
   ```
   `WcSigningBridge` type import: `import type { WcSigningBridge } from '../services/wc-signing-bridge.js';`

2. stage4Wait APPROVAL 분기 수정 (line 538-550):
   기존:
   ```
   if (tier === 'APPROVAL') {
     if (!ctx.approvalWorkflow) { return; }
     ctx.approvalWorkflow.requestApproval(ctx.txId);
     throw new WAIaaSError('PIPELINE_HALTED', { ... });
   }
   ```
   수정:
   ```
   if (tier === 'APPROVAL') {
     if (!ctx.approvalWorkflow) { return; }
     ctx.approvalWorkflow.requestApproval(ctx.txId);

     // v1.6.1: fire-and-forget WC signing request (non-blocking)
     if (ctx.wcSigningBridge) {
       void ctx.wcSigningBridge.requestSignature(
         ctx.walletId,
         ctx.txId,
         ctx.wallet.chain,
       );
     }

     throw new WAIaaSError('PIPELINE_HALTED', {
       message: `Transaction ${ctx.txId} queued for owner approval`,
     });
   }
   ```
   핵심: `void` 접두사로 fire-and-forget. `approvalWorkflow.requestApproval()` 이후, `PIPELINE_HALTED` 이전에 호출.

**transactions.ts 수정:**

1. TransactionRouteDeps에 추가:
   ```typescript
   wcSigningBridge?: WcSigningBridge;
   ```
   type import 추가: `import type { WcSigningBridge } from '../../services/wc-signing-bridge.js';`

2. PipelineContext 조립 (line 337-366) ctx 객체에 추가:
   ```typescript
   wcSigningBridge: deps.wcSigningBridge,
   ```

**server.ts 수정:**

1. CreateAppDeps에 이미 `wcSessionService?: WcSessionService`가 있다. 추가 필요:
   ```typescript
   wcSigningBridge?: WcSigningBridge;
   ```
   type import: `import type { WcSigningBridge } from '../services/wc-signing-bridge.js';`

2. transactionRoutes 호출 부분(line 313-330)에 `wcSigningBridge: deps.wcSigningBridge` 추가.

3. **signTransactionRoutes도 있다면 동일하게 추가** (sign-only 경로는 APPROVAL을 사용하지 않으므로 불필요할 수 있지만, 같은 deps 객체를 사용한다면 추가). 실제 server.ts에서 transactionRoutes가 두 번 호출되는 패턴(원본 + sign-only)이 있으면 두 곳 모두에 추가.

**daemon.ts 수정:**

1. WcSigningBridge import: `import { WcSigningBridge } from '../services/wc-signing-bridge.js';`

2. WcSessionService 초기화 직후(Step 4c-6 영역), WcSigningBridge 인스턴스 생성:
   ```typescript
   let wcSigningBridge: WcSigningBridge | undefined;
   if (wcSessionService && approvalWorkflow && sqlite) {
     wcSigningBridge = new WcSigningBridge({
       wcSessionService,
       approvalWorkflow,
       sqlite,
     });
   }
   ```
   주의: `approvalWorkflow`와 `sqlite`가 이 시점에 이미 생성되어 있어야 한다. daemon.ts의 초기화 순서를 확인하여 적절한 위치에 배치.

3. CreateAppDeps 조립에 `wcSigningBridge` 추가.
  </action>
  <verify>
- `pnpm build` 전체 모노레포 빌드 성공
- `pnpm test --filter=@waiaas/daemon` 기존 테스트 전체 통과 (회귀 없음)
- stages.ts에 `wcSigningBridge` 문자열이 존재 (grep 확인)
- transactions.ts의 TransactionRouteDeps에 `wcSigningBridge` 필드 존재
- server.ts의 CreateAppDeps에 `wcSigningBridge` 필드 존재
- daemon.ts에 WcSigningBridge 생성 코드 존재
  </verify>
  <done>
stage4Wait APPROVAL 분기에서 WC 세션이 있는 지갑에 fire-and-forget 서명 요청이 전송되고, 전체 DI 체인(daemon -> server -> transactions -> pipeline)이 연결되며, 기존 REST 승인 경로가 영향 없이 작동한다.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` -- 전체 모노레포 빌드 성공
2. `pnpm test --filter=@waiaas/daemon` -- 기존 1,569+ 테스트 전체 통과
3. `grep -r 'wcSigningBridge' packages/daemon/src/pipeline/stages.ts` -- stage4Wait에 WC 연동 존재
4. `grep -r 'requestSignature' packages/daemon/src/services/wc-signing-bridge.ts` -- 메서드 존재
5. `grep -r 'WC_SIGNING_FAILED' packages/core/src/errors/error-codes.ts` -- 에러 코드 등록
</verification>

<success_criteria>
- WcSigningBridge 클래스가 EVM(personal_sign/SIWE) + Solana(solana_signMessage) 양쪽 체인의 WC 서명 요청을 지원한다
- stage4Wait APPROVAL 분기에서 fire-and-forget으로 WC 서명 요청이 전송된다 (파이프라인 비블로킹)
- WC 서명 응답 시 기존 ownerAuth 검증(verifySIWE/Ed25519)을 재사용하여 approve/reject를 호출한다
- WC 타임아웃이 pending_approvals.expires_at에서 계산되어 동기화된다
- 전체 DI 체인(daemon -> server -> transactions -> pipeline)이 배선되어 있다
- 기존 REST API 승인 경로와 모든 테스트가 영향 없이 동작한다
</success_criteria>

<output>
After completion, create `.planning/phases/148-wc-signing/148-01-SUMMARY.md`
</output>
