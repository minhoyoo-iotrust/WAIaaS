---
phase: 70-integration-tests
plan: 02
type: execute
wave: 2
depends_on: ["70-01"]
files_modified:
  - packages/admin/src/__tests__/dashboard.test.tsx
  - packages/admin/src/__tests__/agents.test.tsx
  - packages/admin/src/__tests__/sessions.test.tsx
  - packages/admin/src/__tests__/policies.test.tsx
  - packages/admin/src/__tests__/settings.test.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard displays stat cards (Version, Uptime, Agents, Active Sessions, Kill Switch, Status) from API data"
    - "Dashboard polls every 30 seconds via setInterval"
    - "Dashboard shows error banner with Retry button on API failure"
    - "Agents page renders agent list table from API response"
    - "Agents page shows create form and calls POST /v1/agents on submit"
    - "Agent detail view renders agent info (name, chain, publicKey, ownerState)"
    - "Agent edit name calls PUT /v1/agents/:id"
    - "Agent delete opens confirmation modal and calls DELETE /v1/agents/:id"
    - "Sessions page shows agent dropdown and loads sessions on selection"
    - "Sessions page creates session via POST /v1/sessions and shows token modal"
    - "Sessions page revokes session via DELETE /v1/sessions/:id with confirmation"
    - "Policies page renders policy list with tier visualization for SPENDING_LIMIT"
    - "Policies page creates policy via POST /v1/policies with JSON rules"
    - "Policies page deletes policy via DELETE /v1/policies/:id with confirmation"
    - "Settings page shows kill switch state with toggle button"
    - "Settings page opens JWT rotation confirmation modal"
    - "Settings page requires typing 'SHUTDOWN' before daemon shutdown"
  artifacts:
    - path: "packages/admin/src/__tests__/dashboard.test.tsx"
      provides: "3 dashboard tests"
    - path: "packages/admin/src/__tests__/agents.test.tsx"
      provides: "5 agent tests"
    - path: "packages/admin/src/__tests__/sessions.test.tsx"
      provides: "3 session tests"
    - path: "packages/admin/src/__tests__/policies.test.tsx"
      provides: "3 policy tests"
    - path: "packages/admin/src/__tests__/settings.test.tsx"
      provides: "3 settings tests (incl. 1 combined for shutdown confirm pattern)"
  key_links:
    - from: "packages/admin/src/__tests__/dashboard.test.tsx"
      to: "packages/admin/src/pages/dashboard.tsx"
      via: "render(<DashboardPage />) + mock apiGet"
      pattern: "apiGet.*ADMIN_STATUS"
    - from: "packages/admin/src/__tests__/agents.test.tsx"
      to: "packages/admin/src/pages/agents.tsx"
      via: "render(<AgentsPage />) + mock apiGet/apiPost/apiPut/apiDelete"
      pattern: "apiGet.*AGENTS"
    - from: "packages/admin/src/__tests__/settings.test.tsx"
      to: "packages/admin/src/pages/settings.tsx"
      via: "render(<SettingsPage />) + mock apiGet/apiPost"
      pattern: "apiPost.*ADMIN_KILL_SWITCH"
---

<objective>
Implement 14 page tests covering all 5 admin pages: Dashboard (3), Agents (5), Sessions (3), Policies (3), Settings (3). Each test verifies a key user flow by rendering the page component, mocking API calls, and asserting on rendered output and user interactions.

Purpose: Validate all admin page functionality against the E2E scenarios defined in objective v1.3.2, ensuring every page renders correctly and handles CRUD operations.

Output: 5 test files with 14 total page tests, completing the 22-test target (8 from 70-01 + 14 here).
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/70-integration-tests/70-01-PLAN.md

# Source files under test
@packages/admin/src/pages/dashboard.tsx
@packages/admin/src/pages/agents.tsx
@packages/admin/src/pages/sessions.tsx
@packages/admin/src/pages/policies.tsx
@packages/admin/src/pages/settings.tsx
@packages/admin/src/components/layout.tsx
@packages/admin/src/components/table.tsx
@packages/admin/src/components/form.tsx
@packages/admin/src/components/modal.tsx
@packages/admin/src/components/toast.tsx
@packages/admin/src/api/client.ts
@packages/admin/src/api/endpoints.ts
@packages/admin/src/auth/store.ts

# Test infrastructure from 70-01
@packages/admin/vitest.config.ts
@packages/admin/src/__tests__/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Dashboard (3) + Agents (5) + Sessions (3) page tests</name>
  <files>
    packages/admin/src/__tests__/dashboard.test.tsx
    packages/admin/src/__tests__/agents.test.tsx
    packages/admin/src/__tests__/sessions.test.tsx
  </files>
  <action>
**Critical testing pattern for all page tests:**

All page components use `apiGet`/`apiPost`/`apiPut`/`apiDelete` from `../api/client.ts` which internally calls `fetch()`. The test strategy is to mock the `../api/client` module entirely, providing controlled return values for each API call.

Use `vi.mock('../api/client')` at the top of each test file. Then use `vi.mocked(apiGet).mockResolvedValue(...)` to control responses.

Also mock `../components/toast` to capture `showToast` calls. Mock `../auth/store` to provide `masterPassword` signal value (tests need auth state set).

Import `@testing-library/preact` for `render`, `screen`, `fireEvent`, `waitFor`, `cleanup`.

Since the pages use `useSignal` (Preact signals), and `@testing-library/preact` handles Preact rendering, the signals should work as expected.

**IMPORTANT:** Before rendering any page component, set `masterPassword.value = 'test-pw'` so the auth guard doesn't redirect.

For `currentPath` signal used by AgentsPage: import and set `currentPath.value = '/agents'` before rendering.

---

**File 1: packages/admin/src/__tests__/dashboard.test.tsx (3 tests)**

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor, cleanup } from '@testing-library/preact';
import { fireEvent } from '@testing-library/preact';
```

Mock the API client module:
```typescript
vi.mock('../api/client', () => ({
  apiGet: vi.fn(),
  apiPost: vi.fn(),
  apiPut: vi.fn(),
  apiDelete: vi.fn(),
  ApiError: class ApiError extends Error {
    status: number;
    code: string;
    serverMessage: string;
    constructor(status: number, code: string, msg: string) {
      super(`[${status}] ${code}: ${msg}`);
      this.name = 'ApiError';
      this.status = status;
      this.code = code;
      this.serverMessage = msg;
    }
  },
  apiCall: vi.fn(),
}));
```

Mock toast:
```typescript
vi.mock('../components/toast', () => ({
  showToast: vi.fn(),
  ToastContainer: () => null,
}));
```

Import the mocked modules and the page:
```typescript
import { apiGet } from '../api/client';
import DashboardPage from '../pages/dashboard';
```

Test data:
```typescript
const mockStatus = {
  status: 'running',
  version: '0.1.0',
  uptime: 3661,
  agentCount: 3,
  activeSessionCount: 5,
  killSwitchState: 'NORMAL',
  adminTimeout: 900,
  timestamp: Math.floor(Date.now() / 1000),
};
```

beforeEach: `vi.mocked(apiGet).mockResolvedValue(mockStatus);`

afterEach: `cleanup(); vi.clearAllMocks();`

**Test 1: "should display stat cards with API data"**
- Render `<DashboardPage />`
- `await waitFor(() => expect(screen.getByText('0.1.0')).toBeTruthy())`
- Verify `screen.getByText('3')` (agent count)
- Verify `screen.getByText('5')` (active sessions)
- Verify `screen.getByText('NORMAL')` (kill switch)
- Verify `screen.getByText('running')` (status)
- Verify `apiGet` was called with `/v1/admin/status`

**Test 2: "should poll every 30 seconds"**
- Use `vi.useFakeTimers()`
- Render `<DashboardPage />`
- Wait for initial load: `await waitFor(() => expect(apiGet).toHaveBeenCalledTimes(1))`
- Advance 30 seconds: `vi.advanceTimersByTime(30_000)`
- Verify `apiGet` called twice: `expect(apiGet).toHaveBeenCalledTimes(2)`
- Advance another 30 seconds and verify 3 calls
- `vi.useRealTimers()` in cleanup

**Test 3: "should show error banner on API failure with Retry button"**
- Mock apiGet to reject: `vi.mocked(apiGet).mockRejectedValue(new (await import('../api/client')).ApiError(0, 'NETWORK_ERROR', 'fail'))`
- Actually, since ApiError is mocked too, create the error object inline:
  ```typescript
  const { ApiError } = await import('../api/client');
  vi.mocked(apiGet).mockRejectedValueOnce(new ApiError(0, 'NETWORK_ERROR', 'Cannot connect'));
  ```
- Render `<DashboardPage />`
- Wait for error: `await waitFor(() => expect(screen.getByText(/cannot connect/i)).toBeTruthy())`
- Verify Retry button exists: `screen.getByText('Retry')`
- Mock apiGet to succeed for retry, click Retry: `fireEvent.click(screen.getByText('Retry'))`
- Verify data loads after retry

---

**File 2: packages/admin/src/__tests__/agents.test.tsx (5 tests)**

Mock pattern same as dashboard. Also mock `../components/layout` to export `currentPath` signal:

```typescript
vi.mock('../components/layout', async () => {
  const { signal } = await import('@preact/signals');
  return { currentPath: signal('/agents') };
});
```

Mock `../components/copy-button`, `../components/empty-state`, `../components/toast` as simple stubs.

Test data:
```typescript
const mockAgents = {
  items: [
    { id: 'agent-1', name: 'bot-alpha', chain: 'solana', network: 'devnet', publicKey: 'abc123def456', status: 'ACTIVE', createdAt: 1707609600 },
    { id: 'agent-2', name: 'bot-beta', chain: 'solana', network: 'devnet', publicKey: 'xyz789uvw012', status: 'ACTIVE', createdAt: 1707609600 },
  ],
};

const mockAgentDetail = {
  ...mockAgents.items[0],
  ownerAddress: null,
  ownerVerified: null,
  ownerState: 'NONE' as const,
  updatedAt: null,
};
```

**Test 1: "should render agent list table"**
- Mock `apiGet` to resolve with `mockAgents`
- Render `<AgentsPage />`
- Wait for `screen.findByText('bot-alpha')`
- Verify `screen.getByText('bot-beta')` also present
- Verify table headers: 'Name', 'Chain', 'Network'

**Test 2: "should show create form and call POST on submit"**
- Mock `apiGet` to resolve with `mockAgents` (for initial load)
- Mock `apiPost` to resolve with a new agent object
- Render `<AgentsPage />`
- Wait for list to load
- Click "Create Agent" button: `fireEvent.click(screen.getByText('Create Agent'))`
- Find name input (look for input with placeholder "e.g. trading-bot")
- Type name: `fireEvent.input(input, { target: { value: 'new-bot' } })`
- Click "Create" button: `fireEvent.click(screen.getByText('Create'))`
- Wait for `apiPost` to be called with `/v1/agents` and body containing `{ name: 'new-bot' }`

**Test 3: "should render agent detail view"**
- Set `currentPath.value = '/agents/agent-1'` (from mocked layout module)
- Mock `apiGet` to resolve with `mockAgentDetail`
- Render `<AgentsPage />`
- Wait for agent name: `await screen.findByText('bot-alpha')`
- Verify detail fields: 'Chain', 'Network', 'Owner State', 'NONE'

**Test 4: "should edit agent name"**
- Set `currentPath.value = '/agents/agent-1'`
- Mock `apiGet` to resolve with `mockAgentDetail`
- Mock `apiPut` to resolve with `{ ...mockAgentDetail, name: 'renamed-bot' }`
- Render, wait for detail
- Click edit button (the pencil icon button with title "Edit name")
- Find the inline edit input, type new name
- Click "Save" button
- Verify `apiPut` called with `/v1/agents/agent-1` and `{ name: 'renamed-bot' }`

**Test 5: "should delete agent with confirmation modal"**
- Set `currentPath.value = '/agents/agent-1'`
- Mock `apiGet` to resolve with `mockAgentDetail`
- Mock `apiDelete` to resolve
- Render, wait for detail
- Click "Terminate Agent" button
- Wait for modal: `await screen.findByText('Are you sure you want to terminate agent')`
- Click "Terminate" in modal
- Verify `apiDelete` called with `/v1/agents/agent-1`

---

**File 3: packages/admin/src/__tests__/sessions.test.tsx (3 tests)**

Mock pattern same. Test data:
```typescript
const mockAgents = {
  items: [
    { id: 'agent-1', name: 'bot-alpha', chain: 'solana', network: 'devnet', publicKey: 'abc', status: 'ACTIVE', createdAt: 1707609600 },
  ],
};

const mockSessions = [
  { id: 'sess-1', agentId: 'agent-1', status: 'ACTIVE', renewalCount: 0, maxRenewals: 10, expiresAt: 1707696000, absoluteExpiresAt: 1707782400, createdAt: 1707609600, lastRenewedAt: null },
];

const mockCreatedSession = {
  id: 'sess-2', token: 'jwt-token-abc123', expiresAt: 1707696000, agentId: 'agent-1',
};
```

**Test 1: "should load and display sessions for selected agent"**
- Mock `apiGet` to return `mockAgents` first (agents load), then `mockSessions` (sessions for agent)
- Specifically: `vi.mocked(apiGet).mockResolvedValueOnce(mockAgents).mockResolvedValueOnce(mockSessions)`
- Render `<SessionsPage />`
- Wait for agent dropdown to load, select agent-1
- Verify sessions table shows 'ACTIVE' badge and session ID

**Test 2: "should create session and show token modal"**
- Mock `apiGet` for agents, mock `apiPost` to resolve with `mockCreatedSession`
- Mock `apiGet` again for session list refresh
- Render, select agent, click "Create Session"
- Wait for modal: `await screen.findByText(/copy this token/i)`
- Verify token value displayed: `screen.getByText('jwt-token-abc123')`
- Verify `apiPost` called with `/v1/sessions` and `{ agentId: 'agent-1' }`

**Test 3: "should revoke session with confirmation modal"**
- Mock agents + sessions load
- Mock `apiDelete` to resolve
- Render, select agent, wait for sessions table
- Click "Revoke" button on the active session row
- Wait for modal: `await screen.findByText(/are you sure you want to revoke/i)`
- Click "Revoke" in modal
- Verify `apiDelete` called with `/v1/sessions/sess-1`
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/admin test` and verify:
- 3 dashboard tests pass
- 5 agents tests pass
- 3 sessions tests pass
- All 11 tests + 4 auth tests + utility tests from 70-01 pass together
  </verify>
  <done>
11 page tests pass (Dashboard 3 + Agents 5 + Sessions 3). All pages render correctly with mocked API data, create/edit/delete operations trigger correct API calls, modals and error states work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Policies (3) + Settings (3) page tests</name>
  <files>
    packages/admin/src/__tests__/policies.test.tsx
    packages/admin/src/__tests__/settings.test.tsx
  </files>
  <action>
**File 4: packages/admin/src/__tests__/policies.test.tsx (3 tests)**

Mock pattern same as other page tests. Test data:
```typescript
const mockAgents = {
  items: [
    { id: 'agent-1', name: 'bot-alpha', chain: 'solana', network: 'devnet', publicKey: 'abc', status: 'ACTIVE', createdAt: 1707609600 },
  ],
};

const mockPolicies = [
  {
    id: 'policy-1', agentId: null, type: 'SPENDING_LIMIT',
    rules: { instant_max: '1000000', notify_max: '5000000', delay_max: '10000000', delay_seconds: 300, approval_timeout: 3600 },
    priority: 0, enabled: true, createdAt: 1707609600, updatedAt: 1707609600,
  },
  {
    id: 'policy-2', agentId: 'agent-1', type: 'WHITELIST',
    rules: { allowed_addresses: ['addr1'] },
    priority: 1, enabled: true, createdAt: 1707609600, updatedAt: 1707609600,
  },
];
```

**Test 1: "should render policy list with tier visualization for SPENDING_LIMIT"**
- Mock `apiGet` for agents, then for policies
- Render `<PoliciesPage />`
- Wait for policies to load
- Verify SPENDING_LIMIT tier labels appear: 'Instant', 'Notify', 'Delay', 'Approval'
- Verify the 'Whitelist' badge/label appears for the second policy
- Verify 'Global' text for the null agentId policy, agent name for the other

**Test 2: "should create policy via form"**
- Mock agents + policies load
- Mock `apiPost` to resolve
- Render, click "Create Policy" button
- The form should appear with Type dropdown, Agent dropdown, Rules textarea, Priority, Enabled checkbox
- Verify the Rules textarea has default SPENDING_LIMIT JSON
- Click "Create" button
- Verify `apiPost` called with `/v1/policies` and body containing `type: 'SPENDING_LIMIT'`

**Test 3: "should delete policy with confirmation modal"**
- Mock agents + policies load
- Mock `apiDelete` to resolve
- Render, wait for policy table
- Click "Delete" button on one of the policy rows
- Wait for modal: `await screen.findByText(/are you sure you want to delete/i)`
- Click "Delete" in modal
- Verify `apiDelete` called with `/v1/policies/policy-1` (or policy-2)

---

**File 5: packages/admin/src/__tests__/settings.test.tsx (3 tests)**

Test data:
```typescript
const mockKillSwitchNormal = { state: 'NORMAL', activatedAt: null, activatedBy: null };
const mockKillSwitchActivated = { state: 'ACTIVATED', activatedAt: 1707609600, activatedBy: 'admin' };
```

**Test 1: "should display kill switch state and toggle"**
- Mock `apiGet` to return `mockKillSwitchNormal` for initial load
- Render `<SettingsPage />`
- Wait for state: `await screen.findByText('NORMAL')`
- Verify button text is "Activate Kill Switch"
- Mock `apiPost` for activation to resolve
- Mock `apiGet` for re-fetch to return `mockKillSwitchActivated`
- Click "Activate Kill Switch" button
- Verify `apiPost` called with `/v1/admin/kill-switch`

**Test 2: "should open JWT rotation confirmation modal"**
- Mock initial kill switch state load
- Render `<SettingsPage />`
- Wait for page load
- Click "Rotate JWT Secret" button
- Wait for modal: `await screen.findByText(/are you sure you want to rotate/i)`
- Verify modal has "Rotate" confirm button
- Mock `apiPost` for rotation
- Click "Rotate"
- Verify `apiPost` called with `/v1/admin/rotate-secret`

**Test 3: "should require typing SHUTDOWN for daemon shutdown"**
- Mock initial kill switch state load
- Render `<SettingsPage />`
- Wait for page load
- Click "Shutdown Daemon" button
- Wait for modal: `await screen.findByText(/type.*SHUTDOWN.*to confirm/i)`
- Find the text input with placeholder "SHUTDOWN"
- The Shutdown confirm button should be disabled initially (confirmDisabled=true because input != 'SHUTDOWN')
- Type "SHUTDOWN" into the input: `fireEvent.input(input, { target: { value: 'SHUTDOWN' } })`
- Now the confirm button should be enabled
- Mock `apiPost` for shutdown
- Click "Shutdown"
- Verify `apiPost` called with `/v1/admin/shutdown`
  </action>
  <verify>
Run `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm --filter @waiaas/admin test` and verify:
- 3 policies tests pass
- 3 settings tests pass
- Full admin test suite: 4 auth + utility + 14 page = all pass
Then run `pnpm test` from workspace root to verify all tests across all packages pass (target: 806+)
  </verify>
  <done>
All 14 page tests pass (Dashboard 3 + Agents 5 + Sessions 3 + Policies 3 + Settings 3). Combined with 4 auth tests + 4 daemon serving tests from 70-01, the full 22-test target is met. `pnpm test` passes across all packages with 806+ total tests.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @waiaas/admin test` passes: auth (4) + utility + page (14) tests = all green
2. `pnpm --filter @waiaas/daemon test -- --testPathPattern admin-serving` passes: 4 security/serving tests
3. `pnpm test` (workspace root) passes with 806+ total tests (784 existing + 22 new)
4. No import errors, no test infrastructure issues
5. Every E2E scenario from v1.3.2 objective is covered by at least one test
</verification>

<success_criteria>
- 14 page tests pass: Dashboard (3) + Agents (5) + Sessions (3) + Policies (3) + Settings (3)
- Combined with 70-01: total 22 new tests across admin + daemon packages
- `pnpm test` full workspace test suite passes with 806+ tests
- All v1.3.2 E2E scenarios verified
</success_criteria>

<output>
After completion, create `.planning/phases/70-integration-tests/70-02-SUMMARY.md`
</output>
