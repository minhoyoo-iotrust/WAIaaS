---
phase: 200-notification-channel-push-relay-design
plan: 02
type: execute
wave: 2
depends_on: [200-01]
files_modified:
  - internal/design/75-notification-channel-push-relay.md
autonomous: true
requirements: [RELAY-01, RELAY-02, RELAY-03, RELAY-04]

must_haves:
  truths:
    - "IPushProvider 인터페이스와 PushPayload/PushResult 스키마가 확정되어 있다"
    - "PushwooshProvider의 API 인증(api_token + application_code) + 페이로드 매핑(createMessage body)이 설계되어 있다"
    - "FcmProvider의 API 인증(Service Account Key) + 페이로드 매핑(messages:send body)이 설계되어 있다"
    - "ntfy SSE 구독 + 메시지→PushPayload 변환 매핑이 확정되어 있다"
    - "디바이스 토큰 등록 API(POST/DELETE /devices) + DeviceRegistration 스키마가 확정되어 있다"
    - "Push Relay Server config.toml 스키마가 확정되어 있다"
    - "Docker 배포 설계(Dockerfile + docker-compose.yml)가 확정되어 있다"
  artifacts:
    - path: "internal/design/75-notification-channel-push-relay.md"
      provides: "Push Relay Server 설계 (Sections 6-10)"
      contains: "IPushProvider"
  key_links:
    - from: "doc 75 Section 6 (IPushProvider)"
      to: "doc 75 Section 2 (토픽 구조)"
      via: "ntfy 토픽 구독 → PushPayload 변환"
      pattern: "PushPayload"
    - from: "doc 75 Section 8 (ntfy→Push 변환)"
      to: "doc 73 Section 3 (SignRequest 스키마)"
      via: "SignRequest JSON을 Push data 필드에 포함"
      pattern: "sign_request"
    - from: "doc 75 Section 9 (config.toml)"
      to: "doc 75 Section 7 (Provider 설계)"
      via: "프로바이더별 인증 정보 config 키"
      pattern: "relay\\.push"
---

<objective>
Push Relay Server 설계서(doc 75 Sections 6-10) 작성 -- IPushProvider 인터페이스, Pushwoosh/FCM 프로바이더, ntfy→Push 변환, 디바이스 토큰 API, config.toml, Docker 배포 설계를 확정한다.

Purpose: m26-03(Push Relay Server) 구현 시 바로 시작할 수 있는 입력 사양 제공
Output: internal/design/75-notification-channel-push-relay.md Sections 6-10 + 기술 결정 요약
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/objectives/m26-03-push-relay-server.md
@internal/design/73-signing-protocol-v1.md
@internal/design/75-notification-channel-push-relay.md
@.planning/phases/200-notification-channel-push-relay-design/200-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPushProvider + PushwooshProvider + FcmProvider + ntfy SSE 구독 설계</name>
  <files>internal/design/75-notification-channel-push-relay.md</files>
  <action>
doc 75에 Plan 01에서 작성한 Section 5 이후로 다음 섹션들을 추가한다:

**Section 6: Push Relay Server 개요**
- 아키텍처 다이어그램: m26-03 목표 파일의 아키텍처 그림 정제
  - WAIaaS 데몬 → ntfy publish → Push Relay Server → Pushwoosh/FCM → 지갑 앱
- 컴포넌트 목록 (5개): NtfySubscriber, MessageParser, IPushProvider, DeviceRegistry, HTTP Server
- @waiaas/push-relay 패키지 위치: packages/push-relay/ (모노레포 내)
- WAIaaS 데몬과의 관계: 독립 프로세스, ntfy 토픽으로만 연결 (직접 API 호출 없음)
- 운영 주체: 지갑 개발사 (자사 푸시 인증 정보 사용)

**Section 7: IPushProvider 인터페이스 + PushPayload/PushResult (RELAY-01)**
- IPushProvider 인터페이스 TypeScript 정의:
  ```typescript
  interface IPushProvider {
    readonly name: string;
    send(tokens: string[], payload: PushPayload): Promise<PushResult>;
    validateConfig(): Promise<boolean>;
  }
  ```
- PushPayload Zod 스키마:
  ```typescript
  const PushPayloadSchema = z.object({
    title: z.string(),
    body: z.string(),
    data: z.record(z.string()),   // SignRequest/NotificationMessage JSON 등
    category: z.enum(['sign_request', 'notification']),
    priority: z.enum(['high', 'normal']),
  });
  ```
- PushResult Zod 스키마:
  ```typescript
  const PushResultSchema = z.object({
    sent: z.number(),
    failed: z.number(),
    invalidTokens: z.array(z.string()),  // 실패한 토큰 (자동 정리용)
  });
  ```
- 프로바이더 확장 패턴: IPushProvider 구현 클래스 추가만으로 신규 푸시 서비스 지원

**Section 8: PushwooshProvider + FcmProvider 구현 설계 (RELAY-02)**

PushwooshProvider:
- API 엔드포인트: POST https://cp.pushwoosh.com/json/1.3/createMessage
- 인증: API Token + Application Code (config.toml에서 로드)
- PushPayload → Pushwoosh 페이로드 매핑 표:
  - PushPayload.title → content (다국어 객체: {"en": title})
  - PushPayload.body → (content에 포함)
  - PushPayload.data → data (커스텀 JSON)
  - PushPayload.category → ios_root_params.aps.category
  - PushPayload.priority → ios_root_params.aps.content-available (high=1)
  - tokens[] → devices 배열
- 에러 처리: HTTP 4xx/5xx → PushResult.failed++, 200+status_code!=200 → 개별 에러 로깅
- API 응답 파싱: response.status_code, response.status_message

FcmProvider:
- API 엔드포인트: POST https://fcm.googleapis.com/v1/projects/{project_id}/messages:send
- 인증: Google Service Account Key JSON → OAuth2 access_token 획득 (google-auth-library 또는 직접 JWT 생성)
- PushPayload → FCM 페이로드 매핑 표:
  - PushPayload.title → notification.title
  - PushPayload.body → notification.body
  - PushPayload.data → data (문자열 키-값)
  - PushPayload.priority → android.priority ("high"/"normal")
  - tokens[i] → message.token (FCM은 1건씩 전송, 배치는 sendAll deprecation 대비)
- 에러 처리: 404 NOT_FOUND → invalidTokens에 추가, 429 → 재시도 백오프, 5xx → 재시도 1회
- access_token 캐시: 만료 5분 전 갱신

**Section 9: ntfy SSE 구독 + 메시지→PushPayload 변환 (RELAY-03)**
- NtfySubscriber 클래스:
  ```typescript
  class NtfySubscriber {
    subscribe(topics: string[], onMessage: (topic: string, message: NtfyMessage) => void): void;
    close(): void;
  }
  ```
- 구독 대상 토픽 계산: wallet_ids × 2 (sign + notify 토픽)
  - `{topic_prefix}-sign-{walletId}` → 서명 요청
  - `{topic_prefix}-notify-{walletId}` → 일반 알림
- SSE 구독: GET {ntfy_server}/{topic1},{topic2},.../sse (ntfy 다중 토픽 구독, 콤마 구분)
- 재연결 정책: 지수 백오프 (1s/2s/4s/8s, 최대 60s), heartbeat 미수신 60s 시 재연결
- MessageParser:
  - ntfy JSON → topic 분기:
    - waiaas-sign-* → category: 'sign_request', priority: 'high'
    - waiaas-notify-* → category: 'notification', priority: metadata 기반 또는 기본 'normal'
  - sign_request 변환: title="Transaction Approval", body=displayMessage, data={전체 SignRequest JSON}
  - notification 변환: title=NotificationMessage.title, body=NotificationMessage.body, data={전체 NotificationMessage JSON}
- 변환 매핑 표: ntfy 메시지 유형 × PushPayload 필드
  </action>
  <verify>
grep으로 doc 75에 "IPushProvider", "PushPayload", "PushResult", "PushwooshProvider", "FcmProvider", "NtfySubscriber", "MessageParser" 키워드 존재 확인.
Section 6, 7, 8, 9 헤딩이 모두 존재하는지 grep 확인.
  </verify>
  <done>
doc 75에 Section 6(Relay 개요), Section 7(IPushProvider + 스키마), Section 8(Pushwoosh/FCM 매핑), Section 9(ntfy 구독 + 변환) 작성 완료. RELAY-01, RELAY-02, RELAY-03 충족.
  </done>
</task>

<task type="auto">
  <name>Task 2: 디바이스 토큰 API + config.toml + Docker 배포 + 기술 결정 요약</name>
  <files>internal/design/75-notification-channel-push-relay.md</files>
  <action>
doc 75에 다음 섹션들을 추가하여 문서를 완성한다:

**Section 10: 디바이스 토큰 등록 API (RELAY-04 일부)**
- DeviceRegistrationSchema Zod 정의:
  ```typescript
  const DeviceRegistrationSchema = z.object({
    walletId: z.string(),
    pushToken: z.string(),
    platform: z.enum(['ios', 'android']),
  });
  ```
- API 엔드포인트 2개:
  - POST /devices: 디바이스 토큰 등록 (walletId + pushToken + platform)
    - 요청 Body: DeviceRegistration JSON
    - 응답: 201 Created (신규) 또는 200 OK (upsert)
    - 중복 pushToken: upsert (walletId/platform 업데이트)
  - DELETE /devices/:token: 디바이스 토큰 해제
    - 응답: 204 No Content
    - 존재하지 않는 토큰: 204 (멱등)
- SQLite 스키마 (relay.db):
  ```sql
  CREATE TABLE devices (
    push_token TEXT PRIMARY KEY,
    wallet_id TEXT NOT NULL,
    platform TEXT NOT NULL CHECK(platform IN ('ios', 'android')),
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
  );
  CREATE INDEX idx_devices_wallet_id ON devices(wallet_id);
  ```
- invalidTokens 자동 정리: Push 전송 후 PushResult.invalidTokens에 포함된 토큰을 DB에서 자동 삭제
- Hono HTTP 서버: 기존 WAIaaS 패턴과 동일한 OpenAPIHono 사용

**Section 11: config.toml 스키마 (RELAY-04 일부)**
- Push Relay Server 전용 config.toml (WAIaaS 데몬과 별도):
  - WAIaaS flat-key 정책 미적용 (별도 패키지이므로 중첩 섹션 사용)
- RelayConfigSchema Zod 정의:
  ```typescript
  const RelayConfigSchema = z.object({
    relay: z.object({
      ntfy_server: z.string().url().default('https://ntfy.sh'),
      topic_prefix: z.string().default('waiaas'),
      wallet_ids: z.array(z.string()),
    }),
    relay_push: z.object({
      provider: z.enum(['pushwoosh', 'fcm']),
    }),
    relay_push_pushwoosh: z.object({
      api_token: z.string(),
      application_code: z.string(),
    }).optional(),
    relay_push_fcm: z.object({
      project_id: z.string(),
      service_account_key_path: z.string(),
    }).optional(),
    relay_server: z.object({
      port: z.number().default(3100),
      host: z.string().default('0.0.0.0'),
    }),
  });
  ```
- TOML 구조 예시 (pushwoosh + fcm 각각)
- 검증 규칙: provider가 "pushwoosh"이면 relay_push_pushwoosh 필수, "fcm"이면 relay_push_fcm 필수
- config.example.toml 제공 (모든 옵션 주석 포함)

**Section 12: Docker 배포 설계 (RELAY-04 일부)**
- Dockerfile:
  - 기반 이미지: node:22-alpine
  - 멀티스테이지 빌드 (build → production)
  - EXPOSE 3100 (디바이스 API)
  - VOLUME /data (relay.db), /config (config.toml)
  - 환경변수 오버라이드: RELAY_NTFY_SERVER, RELAY_PUSH_PROVIDER 등
- docker-compose.yml:
  - push-relay 서비스 + volumes(data, config) + 포트 매핑
  - 선택적 ntfy 서비스 (self-hosted ntfy 동시 배포 시)
- 배포 가이드 개요: config.toml 작성 → docker-compose up -d → POST /devices로 토큰 등록

**Section 13: 기술 결정 요약**
- 알림 채널 설계 결정 (4개, m26-02 목표 파일의 결정 사항):
  1. 토픽 분리(sign vs notify)
  2. 알림 대상(sdk_ntfy 지갑만)
  3. 카테고리 필터링(config 기반)
  4. 기존 알림 병행(추가 채널)
- Push Relay Server 설계 결정 (6개, m26-03 목표 파일의 결정 사항):
  1. 프레임워크(Hono)
  2. 디바이스 저장소(SQLite)
  3. 기본 프로바이더(Pushwoosh + FCM)
  4. ntfy 구독 방식(SSE)
  5. 배포 방식(Docker)
  6. 운영 주체(지갑 개발사)
- 문서 메타데이터: 문서 번호 75, 생성일, 선행 문서(73, 74, 35), 범위
  </action>
  <verify>
grep으로 doc 75에 "DeviceRegistrationSchema", "config.toml", "Dockerfile", "docker-compose", "RelayConfigSchema" 키워드 존재 확인.
Section 10, 11, 12, 13 헤딩이 모두 존재하는지 grep 확인.
전체 문서에 Section 1-13 모두 존재하는지 확인.
  </verify>
  <done>
doc 75에 Section 10(디바이스 API + SQLite), Section 11(config.toml 스키마), Section 12(Docker 배포), Section 13(기술 결정 10개) 작성 완료. RELAY-04 충족. doc 75 전체 13개 섹션 완성으로 m26-02/m26-03 구현 입력 사양 확정.
  </done>
</task>

</tasks>

<verification>
1. doc 75 파일이 internal/design/75-notification-channel-push-relay.md에 존재
2. Section 1-13 헤딩이 모두 존재 (빈 섹션 없음)
3. IPushProvider 인터페이스 + PushPayload/PushResult Zod 스키마 정의 존재
4. PushwooshProvider API 인증(api_token, application_code) + 페이로드 매핑 표 존재
5. FcmProvider API 인증(Service Account Key) + 페이로드 매핑 표 존재
6. NtfySubscriber SSE 구독 + 재연결 정책 + MessageParser 변환 매핑 존재
7. DeviceRegistrationSchema + POST/DELETE /devices API 정의 존재
8. config.toml RelayConfigSchema + TOML 예시 존재
9. Dockerfile + docker-compose.yml 설계 존재
10. 기술 결정 10개(알림 4 + Relay 6) 정리 완료
</verification>

<success_criteria>
- RELAY-01: IPushProvider 인터페이스 + PushPayload/PushResult 스키마가 Section 7에 확정
- RELAY-02: PushwooshProvider + FcmProvider 구현 설계가 Section 8에 확정
- RELAY-03: ntfy SSE 구독 + 메시지→PushPayload 변환이 Section 9에 확정
- RELAY-04: 디바이스 토큰 API(Section 10) + config.toml(Section 11) + Docker(Section 12) 확정
- 모든 인터페이스가 TypeScript/Zod 코드 레벨로 명시되어 m26-03에서 바로 구현 가능
</success_criteria>

<output>
After completion, create `.planning/phases/200-notification-channel-push-relay-design/200-02-SUMMARY.md`
</output>
