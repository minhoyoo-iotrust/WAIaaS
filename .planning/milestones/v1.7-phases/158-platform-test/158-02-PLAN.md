---
phase: 158-platform-test
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/__tests__/platform/docker.platform.test.ts
  - packages/daemon/src/__tests__/platform/telegram-bot.platform.test.ts
autonomous: true

must_haves:
  truths:
    - "Dockerfile 멀티스테이지 빌드가 builder + runner 2단계로 구성되어 production 이미지에 devDependencies가 포함되지 않는다"
    - "컨테이너가 non-root 사용자(waiaas:1001)로 실행된다"
    - "HEALTHCHECK가 /health 엔드포인트로 헬스 체크를 수행한다"
    - "Docker Secrets _FILE 패턴이 entrypoint.sh에서 환경변수로 정상 변환된다"
    - "Telegram Bot 롱폴링이 시작/정지/재시작을 정상 처리한다"
    - "Telegram Bot 10개 명령어가 2-Tier 인증을 거쳐 올바른 응답을 반환한다"
    - "Telegram Bot 콜백 쿼리(approve/reject/killswitch/newsession)가 인증 후 정상 처리된다"
    - "Telegram Bot이 그레이스풀 셧다운 시 폴링을 정지한다"
  artifacts:
    - path: "packages/daemon/src/__tests__/platform/docker.platform.test.ts"
      provides: "PLAT-02 Docker 플랫폼 테스트 18건"
      min_lines: 300
    - path: "packages/daemon/src/__tests__/platform/telegram-bot.platform.test.ts"
      provides: "PLAT-03 Telegram Bot 플랫폼 테스트 34건"
      min_lines: 500
  key_links:
    - from: "docker.platform.test.ts"
      to: "Dockerfile"
      via: "Dockerfile 파싱 + docker-compose.yml 파싱으로 구조 검증"
      pattern: "FROM.*AS|USER waiaas|HEALTHCHECK"
    - from: "docker.platform.test.ts"
      to: "docker/entrypoint.sh"
      via: "entrypoint.sh file_env 함수 로직 검증"
      pattern: "file_env|_FILE"
    - from: "telegram-bot.platform.test.ts"
      to: "packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts"
      via: "TelegramBotService 인스턴스 생성 + MockApi로 명령어/콜백 테스트"
      pattern: "TelegramBotService|handleUpdate|pollLoop"
    - from: "telegram-bot.platform.test.ts"
      to: "packages/daemon/src/infrastructure/telegram/telegram-auth.ts"
      via: "TelegramAuth 2-Tier 인증 검증"
      pattern: "checkPermission|ADMIN|READONLY|PENDING"
---

<objective>
Docker 플랫폼 테스트 18건 + Telegram Bot 플랫폼 테스트 34건을 작성하여 배포 타겟별 품질을 검증한다.

Purpose: Docker 컨테이너 배포(멀티스테이지 빌드, non-root, secrets, healthcheck)와 Telegram Bot(롱폴링, 10개 명령어, 콜백, 인증, i18n, 셧다운)이 프로덕션 환경에서 안정적으로 동작함을 증명한다.
Output: 2개 플랫폼 테스트 파일 (packages/daemon/src/__tests__/platform/)
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@objectives/v1.7-quality-cicd.md (Section 5: 플랫폼 테스트 - Docker 18건, Telegram 34건)
@Dockerfile (멀티스테이지 빌드 구조)
@docker-compose.yml (서비스 구성)
@docker-compose.secrets.yml (Docker Secrets 오버라이드)
@docker/entrypoint.sh (file_env 함수, PID 1 exec)
@packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts (TelegramBotService)
@packages/daemon/src/infrastructure/telegram/telegram-api.ts (TelegramApi)
@packages/daemon/src/infrastructure/telegram/telegram-auth.ts (TelegramAuth 2-Tier)
@packages/daemon/src/infrastructure/telegram/telegram-keyboard.ts (키보드 빌더)
@packages/daemon/src/infrastructure/telegram/telegram-types.ts (타입 정의)
@packages/daemon/src/__tests__/telegram-bot-service.test.ts (기존 단위 테스트 - 중복 방지 참조)
@packages/daemon/src/__tests__/telegram-bot-auth.test.ts (기존 인증 테스트 - 중복 방지 참조)
@packages/daemon/src/__tests__/telegram-bot-advanced.test.ts (기존 고급 테스트 - 중복 방지)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker 플랫폼 테스트 18건</name>
  <files>
    packages/daemon/src/__tests__/platform/docker.platform.test.ts
  </files>
  <action>
packages/daemon/src/__tests__/platform/ 디렉토리를 생성하고 Docker 플랫폼 테스트를 작성한다.

Docker 테스트는 실제 Docker를 빌드/실행하지 않는다. 대신 Dockerfile, docker-compose.yml, docker-compose.secrets.yml, entrypoint.sh를 파싱하여 구조적 정합성을 검증한다. 이는 CI에서 Docker 없이도 실행 가능해야 하기 때문이다.

**Build 2건**:
- PLAT-02-BUILD-01: Dockerfile이 2-stage 빌드(builder + runner)로 구성 확인. 'FROM node:22-slim AS builder'와 'FROM node:22-slim AS runner' 두 스테이지 존재. builder에서 pnpm install --frozen-lockfile, runner에서 pnpm install --frozen-lockfile --prod 사용.
- PLAT-02-BUILD-02: runner 스테이지에 devDependencies가 포함되지 않음 확인. --prod 플래그 존재. COPY --from=builder로 dist 디렉토리만 복사 (src 디렉토리 미포함).

Dockerfile을 readFileSync로 읽고 정규식/문자열 매칭으로 검증. path.resolve(__dirname, '../../../../..', 'Dockerfile') 또는 프로젝트 루트 기준.

**Compose 2건**:
- PLAT-02-COMPOSE-01: docker-compose.yml에 waiaas-daemon 서비스 존재, 포트 매핑 "127.0.0.1:3100:3100", restart: unless-stopped 확인
- PLAT-02-COMPOSE-02: docker-compose.yml healthcheck에 "curl -f http://localhost:3100/health" 포함, interval=30s, retries=3 확인

yaml 파서(js-yaml) 대신 readFileSync + 정규식 매칭으로 간단하게 검증한다 (외부 의존성 최소화).

**Volume 2건**:
- PLAT-02-VOL-01: docker-compose.yml에 waiaas-data 네임드 볼륨이 /data에 마운트 확인
- PLAT-02-VOL-02: Dockerfile에 WAIAAS_DATA_DIR=/data 환경변수 설정 확인

**Env 2건**:
- PLAT-02-ENV-01: Dockerfile에 NODE_ENV=production, WAIAAS_DAEMON_HOSTNAME=0.0.0.0, WAIAAS_DATA_DIR=/data 환경변수 확인
- PLAT-02-ENV-02: docker-compose.yml에 env_file .env (required: false) 설정 확인

**Hostname 1건**:
- PLAT-02-HOST-01: WAIAAS_DAEMON_HOSTNAME=0.0.0.0 (Dockerfile)으로 컨테이너 외부 접속 허용 확인. 로컬 CLI는 127.0.0.1이지만 Docker는 0.0.0.0이어야 함.

**Grace 2건**:
- PLAT-02-GRACE-01: entrypoint.sh에 exec 키워드 존재 확인 (PID 1 = node, 시그널 직접 수신)
- PLAT-02-GRACE-02: Dockerfile ENTRYPOINT가 entrypoint.sh를 실행하고, entrypoint.sh가 'node ... start --data-dir' 명령어로 데몬 시작 확인

**Secrets 2건**:
- PLAT-02-SEC-01: entrypoint.sh의 file_env 함수가 WAIAAS_MASTER_PASSWORD, WAIAAS_TELEGRAM_BOT_TOKEN, WAIAAS_NOTIFICATIONS_TELEGRAM_BOT_TOKEN 3개를 처리 확인
- PLAT-02-SEC-02: docker-compose.secrets.yml에 waiaas_master_password + waiaas_telegram_bot_token 시크릿 정의, /run/secrets/ 경로 마운트 확인

**Healthcheck 2건**:
- PLAT-02-HC-01: Dockerfile HEALTHCHECK 지시어에 interval=30s, timeout=5s, start-period=10s, retries=3 설정 확인
- PLAT-02-HC-02: docker-compose.yml healthcheck와 Dockerfile HEALTHCHECK가 동일한 /health 엔드포인트 사용 확인

**Non-root 2건**:
- PLAT-02-NONROOT-01: Dockerfile에 'USER waiaas' 지시어 존재, 'useradd -u 1001 -g waiaas' 확인
- PLAT-02-NONROOT-02: Dockerfile에 /data 디렉토리 생성 후 'chown -R waiaas:waiaas /data /app' 확인

**Auto-init 1건**:
- PLAT-02-AUTOINIT-01: entrypoint.sh가 'waiaas start --data-dir' 실행하므로, start 명령어가 init 미실행 디렉토리에서도 데몬 시작 가능한지 검증 (DaemonLifecycle._startInternal에서 dataDir 미존재 시 mkdirSync 호출 확인)

모든 파일 경로는 프로젝트 루트 기준으로 resolve. `path.resolve(__dirname, '../../../../../')` 또는 `process.cwd()` 사용. import { readFileSync } from 'node:fs' + import { resolve, join } from 'node:path'.
  </action>
  <verify>
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/__tests__/platform/docker.platform.test.ts --reporter=verbose 2>&1 | tail -30
18건 테스트 모두 통과 확인.
  </verify>
  <done>
Docker 플랫폼 테스트 18건(build 2 + compose 2 + volume 2 + env 2 + hostname 1 + grace 2 + secrets 2 + healthcheck 2 + non-root 2 + auto-init 1)이 모두 통과한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Telegram Bot 플랫폼 테스트 34건</name>
  <files>
    packages/daemon/src/__tests__/platform/telegram-bot.platform.test.ts
  </files>
  <action>
Telegram Bot 플랫폼 테스트를 작성한다. 기존 telegram-bot-service.test.ts, telegram-bot-auth.test.ts, telegram-bot-advanced.test.ts와 중복되지 않도록 "플랫폼 관점"(배포 환경에서의 안정성, 에러 복구, 전체 흐름)에 집중한다.

테스트 인프라: 기존 패턴을 따른다.
- createDatabase(':memory:') + pushSchema()로 인메모리 DB 생성
- MockApi = { getUpdates: vi.fn(), sendMessage: vi.fn(), answerCallbackQuery: vi.fn() }
- TelegramBotService 인스턴스 생성 (sqlite, api, locale, killSwitchService 등 옵션)
- makeUpdate(chatId, text, updateId, username) 헬퍼로 TelegramUpdate 생성
- makeCallbackUpdate(chatId, data, callbackQueryId, updateId) 헬퍼 추가

**Polling 5건**:
- PLAT-03-POLL-01: start() 호출 -> isRunning = true, getUpdates가 호출됨 (폴링 시작 확인)
- PLAT-03-POLL-02: stop() 호출 -> isRunning = false, 폴링 루프 종료 확인
- PLAT-03-POLL-03: getUpdates 네트워크 에러 -> 지수 백오프 (1s -> 2s -> 4s), retryCount 증가 확인
- PLAT-03-POLL-04: getUpdates 성공 후 백오프 리셋 (1s로 복귀, retryCount = 0)
- PLAT-03-POLL-05: getUpdates 401/409 에러 -> 폴링 즉시 중단 (running = false), "fatal API error" 패턴

기존 단위 테스트에서 폴링 기본 동작은 커버됨. 여기서는 에러 시나리오에 집중.
getUpdates mock을 제어하여 에러/성공 시퀀스를 시뮬레이션. vi.useFakeTimers()로 백오프 대기 건너뛰기.

**Commands 10건**:
TelegramBotService의 private 메서드는 직접 호출 불가. 대신 폴링 시뮬레이션(getUpdates가 update 배열을 반환하고, handleUpdate 내부에서 처리됨)으로 테스트.
또는 (update as any)를 사용하여 handleUpdate를 간접 호출하는 패턴 (기존 테스트 참조).

각 명령에 대해 적절한 사용자 권한을 DB에 미리 INSERT한다.

- PLAT-03-CMD-01: /start (미등록 사용자) -> telegram_users에 INSERT, bot_welcome 메시지 전송
- PLAT-03-CMD-02: /start (이미 등록) -> bot_already_registered 메시지
- PLAT-03-CMD-03: /help (READONLY 사용자) -> bot_help 메시지 전송
- PLAT-03-CMD-04: /status (READONLY 사용자) -> 업타임, Kill Switch 상태, 월렛/세션 수 포함 메시지
- PLAT-03-CMD-05: /wallets (READONLY 사용자, 월렛 2개) -> 월렛 목록 메시지
- PLAT-03-CMD-06: /wallets (READONLY 사용자, 월렛 0개) -> bot_wallets_empty 메시지
- PLAT-03-CMD-07: /pending (ADMIN 사용자, 승인 대기 1건) -> approve/reject 인라인 키보드와 함께 메시지
- PLAT-03-CMD-08: /pending (ADMIN 사용자, 승인 대기 0건) -> bot_pending_empty 메시지
- PLAT-03-CMD-09: /approve {txId} (ADMIN 사용자) -> pending_approvals.approved_at 갱신, transactions.status = 'EXECUTING', audit_log INSERT
- PLAT-03-CMD-10: /reject {txId} (ADMIN 사용자) -> pending_approvals.rejected_at 갱신, transactions.status = 'CANCELLED', audit_log INSERT

명령어 테스트에서 DB 상태 사전 준비:
- READONLY/ADMIN 사용자를 telegram_users에 INSERT
- /approve, /reject 테스트용으로 wallets + transactions + pending_approvals 레코드를 INSERT
- DB 스키마가 pushSchema()로 생성되므로 테이블명은 실제 스키마와 일치

**Callbacks 7건**:
콜백 쿼리 = 인라인 키보드 버튼 클릭. callback_query.data 파싱으로 라우팅.

- PLAT-03-CB-01: approve:{txId} 콜백 -> handleApprove 실행, answerCallbackQuery 호출 확인
- PLAT-03-CB-02: reject:{txId} 콜백 -> handleReject 실행, answerCallbackQuery 호출 확인
- PLAT-03-CB-03: killswitch:confirm 콜백 -> Kill Switch 활성화, answerCallbackQuery 호출
- PLAT-03-CB-04: killswitch:cancel 콜백 -> bot_killswitch_cancelled 메시지, answerCallbackQuery 호출
- PLAT-03-CB-05: newsession:{walletId} 콜백 -> 세션 생성, JWT 토큰 발급 메시지 (jwtSecretManager 필요하므로 mock 또는 실제 JwtSecretManager 사용)
- PLAT-03-CB-06: 미인증 사용자의 콜백 -> answerCallbackQuery에 거부 메시지
- PLAT-03-CB-07: 알 수 없는 callback_data -> 무시 (에러 없음)

콜백 테스트를 위한 makeCallbackUpdate 헬퍼:
```ts
function makeCallbackUpdate(chatId: number, data: string, cbId = 'cb-1', updateId = 1): TelegramUpdate {
  return { update_id: updateId, callback_query: { id: cbId, from: { id: chatId, is_bot: false, first_name: 'Test' }, data } };
}
```

**Auth 4건**:
TelegramAuth 클래스를 직접 테스트하되, "플랫폼 관점"에서 권한 에스컬레이션 시나리오를 검증.

- PLAT-03-AUTH-01: PENDING 사용자가 /status 호출 -> pending_approval 거부
- PLAT-03-AUTH-02: READONLY 사용자가 /approve 호출 -> admin_only 거부
- PLAT-03-AUTH-03: 미등록 사용자가 /wallets 호출 -> not_registered 거부
- PLAT-03-AUTH-04: ADMIN 사용자가 모든 명령어 접근 가능 확인 (10개 명령어 루프)

**Format 2건**:
- PLAT-03-FMT-01: MarkdownV2 escapeMarkdownV2 함수가 특수 문자 전체를 이스케이프 (_*[]()~`>#+-.=|{}.!\\ 각각)
- PLAT-03-FMT-02: /status 명령어 응답에 MarkdownV2 parse_mode 사용 확인 (sendMessage 호출 인자 검증)

**callback_data 2건**:
- PLAT-03-CBD-01: callback_data 접두사 라우팅: 'approve:', 'reject:', 'killswitch:', 'newsession:' 4가지가 올바른 핸들러로 분기
- PLAT-03-CBD-02: callback_data에 콜론(:) 이후 txId/walletId가 정상 파싱됨 (예: 'approve:abc-123' -> txId='abc-123')

**Direct approve 2건**:
- PLAT-03-DIR-01: /approve {txId} 직접 명령어 (인라인 키보드 없이) -> 정상 승인 처리
- PLAT-03-DIR-02: /reject {txId} 직접 명령어 -> 정상 거부 처리

**Shutdown 2건**:
- PLAT-03-SHUT-01: stop() 호출 후 running = false, 폴링 루프 다음 반복에서 종료
- PLAT-03-SHUT-02: DaemonLifecycle.shutdown()에서 telegramBotService.stop() 호출 패턴 확인 (daemon.ts 소스 코드에서 this.telegramBotService.stop() 호출 존재 검증, 또는 shutdown 시 isRunning 변화 검증)

**newsession 콜백(CB-05) JwtSecretManager 처리**:
JwtSecretManager가 필요한 /newsession 콜백 테스트는 jwtSecretManager 옵션 없이 TelegramBotService를 생성하여 "wallet not found" 폴백 메시지를 검증하거나, JwtSecretManager를 실제 생성(인메모리 DB에서)하여 전체 흐름을 테스트한다. 후자가 더 완전하므로 별도 describe 블록에서 JwtSecretManager를 초기화하여 테스트한다.

각 describe 블록에서 beforeEach로 fresh DB + MockApi + TelegramBotService 생성.
afterEach에서 service.stop() + db.close().
  </action>
  <verify>
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/__tests__/platform/telegram-bot.platform.test.ts --reporter=verbose 2>&1 | tail -50
34건 테스트 모두 통과 확인.
  </verify>
  <done>
Telegram Bot 플랫폼 테스트 34건(polling 5 + commands 10 + callbacks 7 + auth 4 + format 2 + callback_data 2 + direct approve 2 + shutdown 2)이 모두 통과한다.
  </done>
</task>

</tasks>

<verification>
cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run packages/daemon/src/__tests__/platform/ --reporter=verbose 2>&1 | grep -E "(Tests|PASS|FAIL)" | head -10

기대 결과:
- 2개 테스트 파일 모두 PASS
- Docker 18건 + Telegram Bot 34건 = 총 52건 테스트 통과
</verification>

<success_criteria>
1. packages/daemon/src/__tests__/platform/ 디렉토리에 2개 테스트 파일이 존재한다
2. vitest run으로 52건 모두 PASS한다
3. 기존 telegram-bot-service.test.ts, telegram-bot-auth.test.ts 등 기존 테스트가 깨지지 않는다
4. Docker 테스트가 Docker 없이도 실행 가능하다 (파일 파싱 기반)
5. Telegram Bot 테스트가 인메모리 DB + MockApi로 외부 의존 없이 실행된다
</success_criteria>

<output>
After completion, create `.planning/phases/158-platform-test/158-02-SUMMARY.md`
</output>
