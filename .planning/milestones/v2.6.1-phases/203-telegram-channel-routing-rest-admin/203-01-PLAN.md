---
phase: 203-telegram-channel-routing-rest-admin
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts
  - packages/daemon/src/services/signing-sdk/channels/index.ts
  - packages/daemon/src/services/signing-sdk/index.ts
  - packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts
  - packages/daemon/src/__tests__/telegram-signing-channel.test.ts
autonomous: true
requirements: [CHAN-03, CHAN-04]

must_haves:
  truths:
    - "TelegramSigningChannel sends a Telegram message with universal link inline button when a SignRequest is created"
    - "Telegram bot receives /sign_response command with base64url-encoded SignResponse and delegates to SignResponseHandler"
    - "TelegramSigningChannel implements ISigningChannel interface for consistent channel abstraction"
  artifacts:
    - path: "packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts"
      provides: "TelegramSigningChannel class implementing ISigningChannel"
      exports: ["TelegramSigningChannel"]
    - path: "packages/daemon/src/__tests__/telegram-signing-channel.test.ts"
      provides: "Unit tests for TelegramSigningChannel"
      min_lines: 80
  key_links:
    - from: "packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts"
      to: "packages/daemon/src/infrastructure/telegram/telegram-api.ts"
      via: "TelegramApi.sendMessage with inline_keyboard"
      pattern: "sendMessage.*reply_markup"
    - from: "packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts"
      to: "packages/daemon/src/services/signing-sdk/sign-response-handler.ts"
      via: "/sign_response command handler delegates to SignResponseHandler.handle()"
      pattern: "signResponseHandler.*handle"
---

<objective>
TelegramSigningChannel 구현: Telegram 인라인 버튼으로 SignRequest를 전송하고, /sign_response 명령어로 SignResponse를 수신하여 트랜잭션을 처리

Purpose: NtfySigningChannel과 동일한 ISigningChannel 인터페이스로 Telegram 기반 서명 채널을 구현하여, 지갑 앱 없이도 Telegram Bot을 통해 트랜잭션 승인이 가능하게 함
Output: TelegramSigningChannel 클래스 + Telegram Bot /sign_response 명령어 핸들러
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/202-signing-protocol-daemon-sdk-ntfy/202-04-SUMMARY.md

@packages/daemon/src/services/signing-sdk/channels/ntfy-signing-channel.ts
@packages/daemon/src/services/signing-sdk/channels/index.ts
@packages/daemon/src/services/signing-sdk/index.ts
@packages/daemon/src/services/signing-sdk/sign-request-builder.ts
@packages/daemon/src/services/signing-sdk/sign-response-handler.ts
@packages/daemon/src/infrastructure/telegram/telegram-api.ts
@packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts
@packages/daemon/src/infrastructure/telegram/telegram-types.ts
@packages/daemon/src/infrastructure/telegram/telegram-keyboard.ts
@packages/core/src/schemas/signing-protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TelegramSigningChannel 클래스 구현</name>
  <files>
    packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts
    packages/daemon/src/services/signing-sdk/channels/index.ts
    packages/daemon/src/services/signing-sdk/index.ts
  </files>
  <action>
Create `TelegramSigningChannel` class in `packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts` implementing ISigningChannel interface. Follow the NtfySigningChannel pattern.

**Constructor dependencies:**
- `signRequestBuilder: SignRequestBuilder`
- `signResponseHandler: SignResponseHandler`
- `settingsService: SettingsService`
- `telegramApi: TelegramApi` (from `../../infrastructure/telegram/telegram-api.js`)

**`sendRequest(params: SendRequestParams): Promise<SendRequestResult>`:**
1. Call `signRequestBuilder.buildRequest(params)` to get `{ request, universalLinkUrl, requestTopic }`
2. Call `signResponseHandler.registerRequest(request)` for later matching
3. Get admin chat_id from `settingsService.get('notifications.telegram_chat_id')`
4. Send Telegram message via `telegramApi.sendMessage()` with:
   - Text: display message formatted with MarkdownV2 (escape special chars using the existing `escapeMarkdownV2` from telegram-bot-service.ts -- import it)
   - `reply_markup`: inline keyboard with one button: `{ text: 'Open in Wallet', url: universalLinkUrl }` (this is the universal link inline button per CHAN-03)
5. Return `{ requestId: request.requestId, requestTopic, responseTopic: '' }` (Telegram channel doesn't use ntfy topics -- response comes via /sign_response command)

Note: Unlike NtfySigningChannel, TelegramSigningChannel does NOT subscribe to a response topic. The response arrives via the /sign_response Telegram bot command (Task 2). This is a one-way push; no SSE subscription needed.

**`shutdown(): void`:** No-op (no active subscriptions to clean up).

**Export:** Add to `channels/index.ts` alongside NtfySigningChannel.

Also update `packages/daemon/src/services/signing-sdk/index.ts` to export TelegramSigningChannel.
  </action>
  <verify>
`pnpm turbo run typecheck --filter=@waiaas/daemon` passes with no errors.
`grep -c "TelegramSigningChannel" packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts` shows the class exists.
  </verify>
  <done>TelegramSigningChannel class exports sendRequest() that sends Telegram message with universal link inline button and shutdown(), implements ISigningChannel, and is exported from channels/index.ts and signing-sdk/index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Telegram Bot /sign_response 명령어 + 단위 테스트</name>
  <files>
    packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts
    packages/daemon/src/__tests__/telegram-signing-channel.test.ts
  </files>
  <action>
**Part A: Add /sign_response command to TelegramBotService**

Modify `TelegramBotService` in `packages/daemon/src/infrastructure/telegram/telegram-bot-service.ts`:

1. Add optional `signResponseHandler?: SignResponseHandler` to `TelegramBotServiceOptions` interface. Import `SignResponseHandler` type from `../../services/signing-sdk/sign-response-handler.js`.
2. Store as `private signResponseHandler?: SignResponseHandler` in the class.
3. Add `/sign_response` case to the `handleMessage` switch statement (before the `default` case). The command format is: `/sign_response {base64url-encoded-SignResponse}`.
4. Create `private async handleSignResponse(chatId: number, encodedResponse?: string): Promise<void>`:
   - If `!this.signResponseHandler`: send error message "Signing SDK is not enabled" and return.
   - If `!encodedResponse`: send error message "Usage: /sign_response {encoded_response}" and return.
   - Try: decode base64url string to JSON, parse with `SignResponseSchema` from `@waiaas/core`, call `this.signResponseHandler.handle(signResponse)`.
   - On success: send confirmation message "Sign response processed: {action}" (approve/reject).
   - On error (WAIaaSError or parse error): send error message with the error description.
5. Auth: `/sign_response` requires ADMIN permission level. Add it to the auth check mapping in `TelegramAuth` if needed, or handle it the same way as `/approve` and `/reject`.

**Part B: Unit tests**

Create `packages/daemon/src/__tests__/telegram-signing-channel.test.ts`:

1. Tests for TelegramSigningChannel:
   - sendRequest() calls signRequestBuilder.buildRequest() and returns requestId
   - sendRequest() sends Telegram message via telegramApi.sendMessage() with inline_keyboard containing universal link
   - sendRequest() registers request with signResponseHandler
   - sendRequest() handles missing telegram chat_id gracefully (throws error)
   - shutdown() is callable without error

2. Tests for /sign_response command integration:
   - Valid base64url SignResponse is decoded and passed to signResponseHandler.handle()
   - Missing encoded response returns usage message
   - Invalid base64url returns error message
   - signResponseHandler not configured returns "not enabled" message

Use the same mock pattern as existing telegram-bot-service.test.ts (mock TelegramApi, mock SQLite database).
  </action>
  <verify>
`pnpm turbo run test --filter=@waiaas/daemon -- --testPathPattern="telegram-signing-channel" --no-coverage` passes.
`pnpm turbo run typecheck --filter=@waiaas/daemon` passes.
  </verify>
  <done>/sign_response command in TelegramBotService decodes base64url SignResponse, delegates to SignResponseHandler, and sends confirmation/error. TelegramSigningChannel has 8+ unit tests covering send, response handling, and error cases.</done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` -- no type errors
2. `pnpm turbo run test --filter=@waiaas/daemon -- --testPathPattern="telegram-signing" --no-coverage` -- all tests pass
3. `pnpm turbo run test --filter=@waiaas/daemon -- --testPathPattern="telegram-bot" --no-coverage` -- existing tests still pass (no regression from /sign_response addition)
</verification>

<success_criteria>
- TelegramSigningChannel.sendRequest() sends Telegram message with universal link inline button
- TelegramBotService handles /sign_response command with base64url-encoded SignResponse
- Both classes integrate with existing SignRequestBuilder/SignResponseHandler
- 8+ new unit tests pass
- No regression in existing telegram-bot tests
</success_criteria>

<output>
After completion, create `.planning/phases/203-telegram-channel-routing-rest-admin/203-01-SUMMARY.md`
</output>
