---
phase: 204-signing-sdk-daemon-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/pipeline/stages.ts
  - packages/daemon/src/api/server.ts
  - packages/daemon/src/api/routes/transactions.ts
autonomous: true
requirements: [PROTO-01, PROTO-03, CHAN-01, CHAN-02, CHAN-03, CHAN-05, CHAN-06, CHAN-07, WALLET-01]

must_haves:
  truths:
    - "signing_sdk.enabled=true 시 SignRequestBuilder, SignResponseHandler, WalletLinkRegistry, NtfySigningChannel, TelegramSigningChannel, ApprovalChannelRouter가 daemon.ts에서 인스턴스화된다"
    - "signing_sdk.enabled=false 시 signing SDK 클래스가 인스턴스화되지 않는다"
    - "PENDING_APPROVAL 트랜잭션에서 ApprovalChannelRouter.route()가 호출되어 올바른 채널로 라우팅된다"
    - "ApprovalChannelRouter가 shutdown 시 정리된다"
  artifacts:
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "Step 4c-8: Signing SDK lifecycle wiring"
      contains: "SignRequestBuilder|SignResponseHandler|WalletLinkRegistry|NtfySigningChannel|TelegramSigningChannel|ApprovalChannelRouter"
    - path: "packages/daemon/src/pipeline/stages.ts"
      provides: "ApprovalChannelRouter integration in stage4Wait"
      contains: "approvalChannelRouter"
    - path: "packages/daemon/src/api/server.ts"
      provides: "approvalChannelRouter in CreateAppDeps"
      contains: "approvalChannelRouter"
    - path: "packages/daemon/src/api/routes/transactions.ts"
      provides: "approvalChannelRouter passed to PipelineContext"
      contains: "approvalChannelRouter"
  key_links:
    - from: "daemon.ts Step 4c-8"
      to: "ApprovalChannelRouter constructor"
      via: "instantiation with ntfyChannel + telegramChannel"
      pattern: "new ApprovalChannelRouter"
    - from: "daemon.ts Step 5 createApp()"
      to: "CreateAppDeps"
      via: "approvalChannelRouter field"
      pattern: "approvalChannelRouter.*this\\.approvalChannelRouter"
    - from: "stage4Wait APPROVAL branch"
      to: "ApprovalChannelRouter.route()"
      via: "ctx.approvalChannelRouter?.route()"
      pattern: "approvalChannelRouter.*route"
---

<objective>
Wire all signing SDK classes into daemon.ts lifecycle and connect ApprovalChannelRouter to the APPROVAL pipeline branch.

Purpose: Close GAP-1 (10 requirements) and complete the runtime path for PENDING_APPROVAL transactions to reach SDK signing channels. Without this wiring, all signing SDK code is dead code that never executes in production.

Output: daemon.ts with Step 4c-8 (Signing SDK), PipelineContext with approvalChannelRouter, stage4Wait routing to ApprovalChannelRouter, shutdown cleanup.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/v2.6.1-MILESTONE-AUDIT.md
@.planning/phases/202-signing-protocol-daemon-sdk-ntfy/202-04-SUMMARY.md
@.planning/phases/203-telegram-channel-routing-rest-admin/203-03-SUMMARY.md
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/pipeline/stages.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/routes/transactions.ts
@packages/daemon/src/services/signing-sdk/index.ts
@packages/daemon/src/services/signing-sdk/approval-channel-router.ts
@packages/daemon/src/services/signing-sdk/sign-request-builder.ts
@packages/daemon/src/services/signing-sdk/sign-response-handler.ts
@packages/daemon/src/services/signing-sdk/wallet-link-registry.ts
@packages/daemon/src/services/signing-sdk/channels/ntfy-signing-channel.ts
@packages/daemon/src/services/signing-sdk/channels/telegram-signing-channel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instantiate signing SDK classes in daemon.ts lifecycle + shutdown cleanup</name>
  <files>packages/daemon/src/lifecycle/daemon.ts</files>
  <action>
  Add a new Step 4c-8 to daemon.ts after Step 4c-7 (WcSigningBridge) and before Step 4e (Price Oracle). This step instantiates all signing SDK classes when `signing_sdk.enabled === 'true'`.

  **1. Add private fields** to DaemonLifecycle class (after the wcSigningBridge field, around line 143):
  ```typescript
  private approvalChannelRouter: import('../services/signing-sdk/approval-channel-router.js').ApprovalChannelRouter | null = null;
  ```

  **2. Add Step 4c-8 block** (after Step 4c-7, before Step 4e):
  ```
  // Step 4c-8: Signing SDK lifecycle (fail-soft)
  ```

  Inside the try/catch block:
  - Check `this._settingsService?.get('signing_sdk.enabled') === 'true'`
  - If enabled:
    a. Dynamic import: `const { SignRequestBuilder, SignResponseHandler, WalletLinkRegistry, NtfySigningChannel, TelegramSigningChannel, ApprovalChannelRouter } = await import('../services/signing-sdk/index.js');`
    b. Create WalletLinkRegistry: `const walletLinkRegistry = new WalletLinkRegistry(this._settingsService!);`
    c. Create SignRequestBuilder: `const signRequestBuilder = new SignRequestBuilder({ settingsService: this._settingsService!, walletLinkRegistry });`
    d. Create SignResponseHandler: `const signResponseHandler = new SignResponseHandler({ sqlite: this.sqlite! });`
    e. Create NtfySigningChannel: `const ntfyChannel = new NtfySigningChannel({ signRequestBuilder, signResponseHandler, settingsService: this._settingsService! });`
    f. Conditionally create TelegramSigningChannel (only if Telegram bot is running and has an API instance):
       - Check `this.telegramBotService` exists
       - If exists, import TelegramApi and create the channel:
         ```typescript
         const { TelegramApi } = await import('../infrastructure/telegram/index.js');
         const botToken = (this._settingsService ? (this._settingsService.get('telegram.bot_token') || this._settingsService.get('notifications.telegram_bot_token')) : null) || this._config!.telegram.bot_token;
         const signingTelegramApi = new TelegramApi(botToken);
         const telegramChannel = new TelegramSigningChannel({ signRequestBuilder, signResponseHandler, settingsService: this._settingsService!, telegramApi: signingTelegramApi });
         ```
       - IMPORTANT: Reuse the same bot_token resolution logic from Step 4c-5 (telegram section). TelegramSigningChannel needs its own TelegramApi instance because it sends messages independently.
    g. Create ApprovalChannelRouter: `this.approvalChannelRouter = new ApprovalChannelRouter({ sqlite: this.sqlite!, settingsService: this._settingsService!, ntfyChannel, telegramChannel });`
    h. Wire signResponseHandler into TelegramBotService if it exists:
       - This is handled in Plan 204-02 (Task 1) since it requires modifying TelegramBotService to accept late-binding signResponseHandler. For now, just create the classes.
    i. Log: `console.debug('Step 4c-8: Signing SDK initialized (ApprovalChannelRouter + channels)');`
  - If disabled:
    - Log: `console.debug('Step 4c-8: Signing SDK disabled');`
  - Wrap in try/catch with `console.warn('Step 4c-8 (fail-soft): Signing SDK init warning:', err);`

  **3. Add ApprovalChannelRouter to createApp() call** in Step 5 (add to the deps object passed to createApp, around line 788):
  ```typescript
  approvalChannelRouter: this.approvalChannelRouter ?? undefined,
  ```

  **4. Add shutdown cleanup** in the shutdown() method: After the TelegramBotService stop (around line 984), before WcSessionService stop, add:
  ```typescript
  // Stop ApprovalChannelRouter (shuts down signing channels)
  if (this.approvalChannelRouter) {
    this.approvalChannelRouter.shutdown();
    this.approvalChannelRouter = null;
  }
  ```

  **Pattern Reference:** Follow the exact same fail-soft try/catch pattern used by Step 4c-7 (WcSigningBridge). Use dynamic import for signing-sdk module (same as other services in daemon.ts). The telegramChannel creation should be conditional on Telegram bot being available.

  **Avoid:** Do not create a `TelegramApi` instance if Telegram bot is not enabled (no bot_token). The `telegramChannel` parameter to ApprovalChannelRouter is optional and will be undefined if Telegram is not configured.
  </action>
  <verify>
  1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes with no errors
  2. `pnpm turbo run test --filter=@waiaas/daemon` passes (existing tests should not break)
  3. Grep daemon.ts for "Step 4c-8" confirms the new section exists
  4. Grep daemon.ts for "ApprovalChannelRouter" confirms instantiation and shutdown
  </verify>
  <done>
  daemon.ts Step 4c-8 instantiates all 6 signing SDK classes when enabled, passes ApprovalChannelRouter to createApp(), and cleans up on shutdown. All existing daemon tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ApprovalChannelRouter to PipelineContext + stage4Wait + transaction routes</name>
  <files>
    packages/daemon/src/pipeline/stages.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/api/routes/transactions.ts
  </files>
  <action>
  Wire ApprovalChannelRouter through the full request path: CreateAppDeps -> TransactionRouteDeps -> PipelineContext -> stage4Wait.

  **1. packages/daemon/src/pipeline/stages.ts:**

  a. Add import at top (after WcSigningBridge import or in the import section):
  ```typescript
  import type { ApprovalChannelRouter } from '../services/signing-sdk/approval-channel-router.js';
  ```

  b. Add to PipelineContext interface (after `wcSigningBridge?: WcSigningBridge;`, around line 103):
  ```typescript
  // v2.6.1: signing SDK channel router for APPROVAL fire-and-forget
  approvalChannelRouter?: ApprovalChannelRouter;
  ```

  c. In `stage4Wait` function, in the APPROVAL branch (after the wcSigningBridge block, around line 556), add fire-and-forget channel routing:
  ```typescript
  // v2.6.1: fire-and-forget SDK signing channel routing (non-blocking)
  if (ctx.approvalChannelRouter) {
    void ctx.approvalChannelRouter.route(ctx.walletId, {
      walletId: ctx.walletId,
      txId: ctx.txId,
      chain: ctx.wallet.chain as 'solana' | 'evm',
      network: ctx.resolvedNetwork,
      type: (ctx.request as any).type ?? 'TRANSFER',
      from: ctx.wallet.publicKey,
      to: getRequestTo(ctx.request),
      amount: getRequestAmount(ctx.request),
      policyTier: 'APPROVAL',
    });
  }
  ```
  IMPORTANT: This follows the exact same fire-and-forget pattern as `ctx.wcSigningBridge.requestSignature()` on the lines above. Use `void` to make it non-blocking. The `getRequestTo` and `getRequestAmount` helper functions already exist in stages.ts.

  **2. packages/daemon/src/api/server.ts:**

  a. Add import at top:
  ```typescript
  import type { ApprovalChannelRouter } from '../services/signing-sdk/approval-channel-router.js';
  ```

  b. Add to `CreateAppDeps` interface (after `wcSigningBridge?: WcSigningBridge;`, around line 117):
  ```typescript
  approvalChannelRouter?: ApprovalChannelRouter;
  ```

  c. Pass to transaction routes (find where deps are spread to the transaction router). Look for `deps.wcSigningBridge` in the `transactionsApp` setup and add `approvalChannelRouter: deps.approvalChannelRouter` in the same object.

  **3. packages/daemon/src/api/routes/transactions.ts:**

  a. Add import at top:
  ```typescript
  import type { ApprovalChannelRouter } from '../../services/signing-sdk/approval-channel-router.js';
  ```

  b. Add to the route's deps interface (after `wcSigningBridge?: WcSigningBridge;`, around line 91):
  ```typescript
  approvalChannelRouter?: ApprovalChannelRouter;
  ```

  c. Add to PipelineContext construction in the POST handler (after `wcSigningBridge: deps.wcSigningBridge,`, around line 371):
  ```typescript
  approvalChannelRouter: deps.approvalChannelRouter,
  ```

  **Pattern:** Follow the exact same pattern used for `wcSigningBridge` in all 3 files. It was added in v1.6.1 with the same optional deps -> pipeline context -> fire-and-forget pattern.
  </action>
  <verify>
  1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes with no errors
  2. `pnpm turbo run test --filter=@waiaas/daemon` passes (existing tests should not break)
  3. Grep stages.ts for "approvalChannelRouter" confirms it appears in PipelineContext and stage4Wait
  4. Grep server.ts for "approvalChannelRouter" confirms it appears in CreateAppDeps
  5. Grep transactions.ts for "approvalChannelRouter" confirms it appears in deps and ctx construction
  </verify>
  <done>
  ApprovalChannelRouter is wired through CreateAppDeps -> TransactionRouteDeps -> PipelineContext -> stage4Wait APPROVAL branch with fire-and-forget channel routing (matching wcSigningBridge pattern). All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` -- no type errors
2. `pnpm turbo run test --filter=@waiaas/daemon` -- all existing tests pass
3. daemon.ts has Step 4c-8 with all 6 signing SDK classes
4. daemon.ts shutdown cleans up ApprovalChannelRouter
5. PipelineContext has approvalChannelRouter field
6. stage4Wait APPROVAL branch calls approvalChannelRouter.route() fire-and-forget
7. CreateAppDeps and transaction routes pass approvalChannelRouter through
</verification>

<success_criteria>
- All 6 signing SDK classes are instantiated in daemon.ts when signing_sdk.enabled=true
- ApprovalChannelRouter is passed through the full request path to stage4Wait
- PENDING_APPROVAL transactions trigger ApprovalChannelRouter.route() fire-and-forget
- Shutdown cleans up ApprovalChannelRouter and its channels
- All existing daemon tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/204-signing-sdk-daemon-lifecycle/204-01-SUMMARY.md`
</output>
