---
phase: 202-signing-protocol-daemon-sdk-ntfy
plan: 02
type: execute
wave: 2
depends_on: ["202-01"]
files_modified:
  - packages/daemon/src/services/signing-sdk/sign-request-builder.ts
  - packages/daemon/src/services/signing-sdk/sign-response-handler.ts
  - packages/daemon/src/__tests__/sign-request-builder.test.ts
  - packages/daemon/src/__tests__/sign-response-handler.test.ts
autonomous: true
requirements:
  - PROTO-01
  - PROTO-03
  - PROTO-04
  - PROTO-05

must_haves:
  truths:
    - "PENDING_APPROVAL 트랜잭션에서 SignRequest가 생성되어 유니버셜 링크 URL로 인코딩된다"
    - "유효한 SignResponse 수신 시 requestId 매칭, 만료 체크, 서명 검증 후 트랜잭션이 approve된다"
    - "만료된 요청(expiresAt 초과)에 대해 SIGN_REQUEST_EXPIRED 에러가 반환된다"
    - "잘못된 서명값에 대해 INVALID_SIGNATURE 에러가 반환된다"
    - "reject 응답 수신 시 트랜잭션이 CANCELLED 상태로 변경된다"
  artifacts:
    - path: "packages/daemon/src/services/signing-sdk/sign-request-builder.ts"
      provides: "SignRequestBuilder 클래스 (PENDING_APPROVAL TX -> SignRequest 생성)"
      exports: ["SignRequestBuilder"]
    - path: "packages/daemon/src/services/signing-sdk/sign-response-handler.ts"
      provides: "SignResponseHandler 클래스 (SignResponse 파싱+검증+실행)"
      exports: ["SignResponseHandler"]
  key_links:
    - from: "packages/daemon/src/services/signing-sdk/sign-request-builder.ts"
      to: "packages/daemon/src/services/signing-sdk/wallet-link-registry.ts"
      via: "WalletLinkRegistry.buildSignUrl()"
      pattern: "walletLinkRegistry.*buildSignUrl"
    - from: "packages/daemon/src/services/signing-sdk/sign-response-handler.ts"
      to: "packages/daemon/src/infrastructure/settings/settings-service.ts"
      via: "SettingsService.get('signing_sdk.request_expiry_min')"
      pattern: "settings.*get.*signing_sdk"
    - from: "packages/daemon/src/services/signing-sdk/sign-request-builder.ts"
      to: "packages/core/src/schemas/signing-protocol.ts"
      via: "SignRequestSchema, encodeSignRequest"
      pattern: "import.*SignRequest.*@waiaas/core"
---

<objective>
데몬 측 SignRequestBuilder + SignResponseHandler 구현

Purpose: PENDING_APPROVAL 트랜잭션에서 SignRequest를 생성하고, 지갑 앱의 SignResponse를 수신하여 서명 검증 후 트랜잭션을 approve/reject하는 데몬 핵심 로직을 구현한다.
Output: 2개 서비스 클래스 + 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/202-signing-protocol-daemon-sdk-ntfy/202-01-SUMMARY.md
@internal/objectives/m26-01-wallet-signing-sdk.md
@internal/design/73-signing-protocol-v1.md
@internal/design/74-wallet-sdk-daemon-components.md
@packages/core/src/errors/error-codes.ts
@packages/core/src/schemas/signing-protocol.ts
@packages/daemon/src/services/signing-sdk/wallet-link-registry.ts
@packages/daemon/src/infrastructure/settings/settings-service.ts
@packages/daemon/src/infrastructure/database/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SignRequestBuilder 구현</name>
  <files>
    packages/daemon/src/services/signing-sdk/sign-request-builder.ts
    packages/daemon/src/__tests__/sign-request-builder.test.ts
  </files>
  <action>
1. `packages/daemon/src/services/signing-sdk/sign-request-builder.ts` 생성:

   **의존성:**
   - @waiaas/core: SignRequest, SignRequestSchema, encodeSignRequest, buildUniversalLinkUrl, WAIaaSError
   - WalletLinkRegistry (같은 디렉토리)
   - SettingsService (signing_sdk.* 키 조회)
   - UUID v7 생성: packages/daemon/src/infrastructure/database/id.ts의 generateId() 재사용

   **SignRequestBuilder 클래스:**
   ```typescript
   constructor(opts: {
     settingsService: SettingsService;
     walletLinkRegistry: WalletLinkRegistry;
   })
   ```

   **buildRequest(params) 메서드:**
   입력: `{ txId: string, chain: 'solana'|'evm', network: string, type: string, from: string, to: string, amount?: string, symbol?: string, policyTier: 'APPROVAL'|'DELAY', walletName?: string }`

   로직:
   1. `signing_sdk.enabled` 확인 -> false면 WAIaaSError('SIGNING_SDK_DISABLED') throw (Plan 202-01에서 등록한 에러 코드)
   2. walletName 결정: 입력 walletName || settingsService.get('signing_sdk.preferred_wallet') || 에러
   3. WalletLinkRegistry.getWallet(walletName)으로 지갑 설정 조회
   4. requestId 생성 (UUID v7)
   5. 서명 메시지 텍스트 생성 (doc 73 Section 5 템플릿):
      ```
      WAIaaS Transaction Approval

      Transaction: {txId}
      Type: {type}
      From: {from}
      To: {to}
      Amount: {amount} {symbol}    // amount/symbol 있을 때만
      Network: {network}
      Policy Tier: {policyTier}

      Approve this transaction by signing this message.
      Timestamp: {ISO 8601 현재시각}
      Nonce: {requestId}
      ```
   6. displayMessage 생성 (사람 읽기용 간결 버전)
   7. expiresAt 계산: settingsService.get('signing_sdk.request_expiry_min')분 후 ISO 8601
   8. responseChannel 결정:
      - settingsService.get('signing_sdk.preferred_channel') == 'ntfy':
        - responseTopic: `{ntfy_response_topic_prefix}-{requestId}`
        - serverUrl: settingsService.get('notifications.ntfy_server') (기존 ntfy 설정 재사용)
      - 'telegram':
        - botUsername: 별도 Telegram 설정에서 가져옴 (Telegram은 Phase 203 범위이나 스키마는 지원)
   9. SignRequest 객체 조립 + SignRequestSchema.parse()로 검증
   10. 유니버셜 링크 URL 생성: WalletLinkRegistry.buildSignUrl(walletName, request)

   **반환:**
   ```typescript
   { request: SignRequest, universalLinkUrl: string, requestTopic: string }
   ```
   - requestTopic: `{ntfy_request_topic_prefix}-{walletId}` (ntfy 채널 publish용)

   **buildSigningMessage(metadata, network, requestId) 메서드** (private):
   doc 73 Section 5 템플릿대로 서명 메시지 텍스트 생성. amount/symbol이 없으면 해당 줄 생략.

2. **테스트** (`sign-request-builder.test.ts`):
   - TRANSFER 트랜잭션에서 SignRequest 생성 성공 (유니버셜 링크 URL 포함)
   - TOKEN_TRANSFER (amount + symbol 포함) 메시지 포맷 검증
   - CONTRACT_CALL (amount 없음) 메시지 포맷 검증 -- "Amount:" 줄 없음 확인
   - signing_sdk.enabled=false 시 SIGNING_SDK_DISABLED 에러
   - preferred_wallet 미설정 + walletName 미지정 시 에러
   - expiresAt가 request_expiry_min 설정값 반영 확인
   - SettingsService와 WalletLinkRegistry는 mock/stub 사용
  </action>
  <verify>
  `pnpm turbo run typecheck --filter=@waiaas/daemon` 통과.
  `pnpm vitest run packages/daemon/src/__tests__/sign-request-builder.test.ts` 모든 테스트 통과.
  </verify>
  <done>
  - SignRequestBuilder.buildRequest()가 PENDING_APPROVAL TX 정보에서 유효한 SignRequest + 유니버셜 링크 URL 생성
  - 서명 메시지가 doc 73 Section 5 템플릿 형식을 따름
  - signing_sdk.enabled=false 시 SIGNING_SDK_DISABLED 에러 반환
  - expiresAt가 signing_sdk.request_expiry_min 설정에 따라 계산
  </done>
</task>

<task type="auto">
  <name>Task 2: SignResponseHandler 구현</name>
  <files>
    packages/daemon/src/services/signing-sdk/sign-response-handler.ts
    packages/daemon/src/__tests__/sign-response-handler.test.ts
  </files>
  <action>
1. `packages/daemon/src/services/signing-sdk/sign-response-handler.ts` 생성:

   **의존성:**
   - @waiaas/core: SignResponse, SignResponseSchema, SignRequest, WAIaaSError
   - SettingsService, DB access (pending_approvals, transactions 테이블 접근)
   - ownerAuth 서명 검증 로직 재사용 (기존 SIWE/SIWS 검증 패턴 참조)

   **설계 결정: ApprovalWorkflow 우회 (의도적)**
   SignResponseHandler는 기존 ApprovalWorkflow를 우회하여 pending_approvals/transactions 테이블을 직접 업데이트한다.
   이는 의도적인 설계로, Telegram bot 승인 패턴과 동일한 접근이다.
   이유: SignResponseHandler는 이미 서명 검증(SIWE/SIWS)을 자체 수행하므로 ApprovalWorkflow의 검증 단계를 중복 실행할 필요가 없다.
   ApprovalWorkflow는 REST API / WalletConnect 등 외부 승인 경로에서 사용되며, signing-sdk는 자체 암호학적 검증이 내장된 별도 승인 경로이다.

   **SignResponseHandler 클래스:**
   ```typescript
   constructor(opts: {
     db: BetterSQLite3Database<typeof schema>;
   })
   ```

   **내부 저장소:**
   - `pendingRequests: Map<string, { request: SignRequest, createdAt: Date }>` -- requestId -> SignRequest 매핑 (메모리 저장, 데몬 재시작 시 소실됨은 OK -- 1회성 요청이므로)

   **registerRequest(request: SignRequest): void**
   - pendingRequests에 저장. 만료 타이머 설정 (expiresAt 시각에 자동 삭제)

   **handle(signResponse: SignResponse): Promise<{ action: 'approved' | 'rejected', txId: string }>**
   1. SignResponseSchema.parse(signResponse) -- Zod 검증, 실패 시 WAIaaSError('INVALID_SIGN_RESPONSE')
   2. pendingRequests에서 requestId로 원본 SignRequest 조회 -- 없으면 WAIaaSError('SIGN_REQUEST_NOT_FOUND')
   3. 만료 확인: `new Date() > new Date(request.expiresAt)` -> WAIaaSError('SIGN_REQUEST_EXPIRED')
   4. action == 'approve' 분기:
      a. signature 필드 필수 확인 -- 없으면 WAIaaSError('INVALID_SIGN_RESPONSE', { message: 'Missing signature for approve action' })
      b. signerAddress가 해당 지갑의 ownerAddress와 일치 확인 -- DB에서 wallets 테이블 조회. 불일치 시 WAIaaSError('SIGNER_ADDRESS_MISMATCH')
      c. 서명 검증:
         - chain == 'evm': viem의 verifyMessage({ address: signerAddress, message: request.message, signature }) 사용
         - chain == 'solana': tweetnacl의 nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes) 사용
         - 검증 실패: WAIaaSError('INVALID_SIGNATURE') (기존 AUTH 도메인 에러 코드 재사용)
      d. 검증 성공: pending_approvals 레코드 업데이트 (approved_at, owner_signature, approval_channel='signing_sdk')
         -- 직접 DB 업데이트 (ApprovalWorkflow 우회, 위 설계 결정 참조)
      e. 트랜잭션 상태를 EXECUTING으로 전환 (기존 approve 패턴 참조)
      f. pendingRequests에서 삭제
      g. return { action: 'approved', txId: request.metadata.txId }
   5. action == 'reject' 분기:
      a. signerAddress 일치 확인 (서명 검증은 optional -- reject 시 서명 없어도 허용하되, 있으면 검증)
      b. 트랜잭션 상태를 CANCELLED로 전환
         -- 직접 DB 업데이트 (ApprovalWorkflow 우회, 위 설계 결정 참조)
      c. pending_approvals 레코드 업데이트 (rejected_at, approval_channel='signing_sdk')
      d. pendingRequests에서 삭제
      e. return { action: 'rejected', txId: request.metadata.txId }
   6. 이미 처리된 requestId 재수신 시: WAIaaSError('SIGN_REQUEST_ALREADY_PROCESSED')

   **참고:**
   - EVM 서명 검증은 viem의 verifyMessage 사용 (패키지에 이미 viem 의존성 있음)
   - Solana 서명 검증은 기존 ownerAuth 패턴 참조 (@solana/kit 또는 tweetnacl 사용)
   - pending_approvals/transactions 테이블의 직접 업데이트 수행 (Drizzle ORM 사용)
   - 모든 WAIaaSError 코드는 Plan 202-01에서 error-codes.ts에 등록 완료

2. **테스트** (`sign-response-handler.test.ts`):
   - 유효한 approve 응답: requestId 매칭 + 서명 검증 성공 -> { action: 'approved', txId } 반환
   - 유효한 reject 응답: -> { action: 'rejected', txId } 반환
   - SIGN_REQUEST_NOT_FOUND: 존재하지 않는 requestId
   - SIGN_REQUEST_EXPIRED: expiresAt 초과 (Date.now mock으로 미래 시각 설정)
   - INVALID_SIGNATURE: 잘못된 서명값 (EVM 케이스)
   - SIGNER_ADDRESS_MISMATCH: signerAddress != ownerAddress
   - INVALID_SIGN_RESPONSE: Zod 검증 실패 (필수 필드 누락)
   - SIGN_REQUEST_ALREADY_PROCESSED: 동일 requestId 중복 응답
   - approve 시 signature 누락 -> INVALID_SIGN_RESPONSE 에러
   - 서명 검증은 mock/stub (viem.verifyMessage, nacl.sign.detached.verify)
   - DB 조작은 in-memory SQLite 또는 mock
  </action>
  <verify>
  `pnpm turbo run typecheck --filter=@waiaas/daemon` 통과.
  `pnpm vitest run packages/daemon/src/__tests__/sign-response-handler.test.ts` 모든 테스트 통과.
  </verify>
  <done>
  - SignResponseHandler.handle()이 approve/reject 응답을 처리하여 트랜잭션 상태 변경
  - ApprovalWorkflow를 의도적으로 우회하여 직접 DB 업데이트 (Telegram bot 패턴과 동일, 자체 서명 검증 내장)
  - 만료 요청에 SIGN_REQUEST_EXPIRED (408) 반환
  - 잘못된 서명에 INVALID_SIGNATURE (401) 반환
  - requestId 불일치에 SIGN_REQUEST_NOT_FOUND (404) 반환
  - signerAddress 불일치에 SIGNER_ADDRESS_MISMATCH (403) 반환
  - 중복 응답에 SIGN_REQUEST_ALREADY_PROCESSED (409) 반환
  - 잘못된 응답 형식에 INVALID_SIGN_RESPONSE (400) 반환
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` -- 타입 체크 통과 (모든 WAIaaSError 코드가 ErrorCode 타입에 존재)
2. `pnpm turbo run test --filter=@waiaas/daemon` -- 기존 + 신규 테스트 전체 통과
3. SignRequestBuilder가 doc 73 Section 5 서명 메시지 포맷을 정확히 따르는지 테스트로 검증
4. SignResponseHandler의 7가지 에러 코드 (doc 73 Section 11)가 모두 테스트됨
5. SignResponseHandler의 ApprovalWorkflow 우회가 의도적 설계임을 코드 주석 + 테스트로 문서화
</verification>

<success_criteria>
- SignRequestBuilder.buildRequest()가 PENDING_APPROVAL 트랜잭션에서 올바른 SignRequest + 유니버셜 링크 URL 생성
- SignResponseHandler.handle()이 approve/reject 응답을 정확히 처리
- 5가지 에러 시나리오(만료, 잘못된 서명, requestId 불일치, signer 불일치, 중복)가 모두 올바른 에러 코드로 처리
- 전체 테스트 스위트 통과
</success_criteria>

<output>
After completion, create `.planning/phases/202-signing-protocol-daemon-sdk-ntfy/202-02-SUMMARY.md`
</output>
