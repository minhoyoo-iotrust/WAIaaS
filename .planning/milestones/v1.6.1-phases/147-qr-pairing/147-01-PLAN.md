---
phase: 147-qr-pairing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/wc-session-service.ts
  - packages/daemon/src/api/routes/wc.ts
  - packages/daemon/src/api/routes/openapi-schemas.ts
  - packages/daemon/src/api/server.ts
  - packages/core/src/errors/error-codes.ts
  - packages/core/src/i18n/en.ts
  - packages/daemon/src/__tests__/wc-pairing.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /v1/wallets/:id/wc/pair 호출 시 WC pairing URI와 QR 코드 base64가 반환된다"
    - "GET /v1/wallets/:id/wc/session 호출 시 현재 WC 세션 상태가 반환된다"
    - "DELETE /v1/wallets/:id/wc/session 호출 시 WC 세션이 해제된다"
    - "GET /v1/wallets/:id/wc/pair/status 호출 시 페어링 진행 상태가 반환된다"
    - "외부 지갑이 QR을 스캔하면 approval()이 resolve되어 세션이 DB에 저장된다"
    - "기존 세션이 있으면 새 페어링 요청이 거부된다 (단일 세션 정책)"
    - "SignClient가 null이면 WC 관련 API가 503을 반환한다"
  artifacts:
    - path: "packages/daemon/src/services/wc-session-service.ts"
      provides: "createPairing, getSessionInfo, disconnectSession, getSession 메서드"
      contains: "createPairing"
    - path: "packages/daemon/src/api/routes/wc.ts"
      provides: "4개 REST 엔드포인트 (pair, session GET, session DELETE, pair/status)"
      exports: ["wcRoutes"]
    - path: "packages/daemon/src/api/routes/openapi-schemas.ts"
      provides: "WC 관련 Zod 스키마 (PairingResponse, SessionResponse 등)"
      contains: "WcPairingResponseSchema"
    - path: "packages/daemon/src/__tests__/wc-pairing.test.ts"
      provides: "WcSessionService createPairing/disconnect/getSession 단위 테스트"
  key_links:
    - from: "packages/daemon/src/api/routes/wc.ts"
      to: "packages/daemon/src/services/wc-session-service.ts"
      via: "wcRoutes deps.wcSessionService"
      pattern: "wcSessionService\\.createPairing"
    - from: "packages/daemon/src/api/server.ts"
      to: "packages/daemon/src/api/routes/wc.ts"
      via: "app.route('/v1', wcRoutes(...))"
      pattern: "wcRoutes"
    - from: "packages/daemon/src/services/wc-session-service.ts"
      to: "wc_sessions DB table"
      via: "INSERT/SELECT/DELETE SQL"
      pattern: "wc_sessions"
---

<objective>
WcSessionService에 페어링/세션 관리 메서드를 추가하고, REST API 4개 엔드포인트를 구현하여 WC 페어링 생성, 세션 조회, 세션 해제, 페어링 상태 폴링이 가능하게 한다.

Purpose: Phase 147의 핵심 백엔드 -- Owner가 외부 지갑으로 QR 스캔하여 WC 세션을 성립/관리할 수 있는 REST API 인프라
Output: WcSessionService 확장 + wc.ts 라우트 파일 + OpenAPI 스키마 + 테스트
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/146-wc-infra/146-01-SUMMARY.md
@.planning/phases/146-wc-infra/146-02-SUMMARY.md
@.planning/phases/147-qr-pairing/147-RESEARCH.md

@packages/daemon/src/services/wc-session-service.ts
@packages/daemon/src/api/server.ts
@packages/daemon/src/api/routes/wallets.ts
@packages/daemon/src/api/routes/openapi-schemas.ts
@packages/core/src/errors/error-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WcSessionService 페어링/세션 관리 메서드 추가 + CAIP-2 상수</name>
  <files>
    packages/daemon/src/services/wc-session-service.ts
    packages/core/src/errors/error-codes.ts
    packages/core/src/i18n/en.ts
  </files>
  <action>
**WcSessionService에 5개 메서드 추가** (`packages/daemon/src/services/wc-session-service.ts`):

1. **CAIP-2 상수 맵 추가** (파일 상단, WcSessionService 클래스 외부):
```typescript
/** CAIP-2 chain identifiers for WalletConnect v2 */
export const CAIP2_CHAIN_IDS: Record<string, string> = {
  // Solana
  'mainnet': 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
  'devnet': 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
  'testnet': 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
  // EVM (eip155:{chainId})
  'ethereum-mainnet': 'eip155:1',
  'ethereum-sepolia': 'eip155:11155111',
  'polygon-mainnet': 'eip155:137',
  'polygon-amoy': 'eip155:80002',
  'arbitrum-mainnet': 'eip155:42161',
  'arbitrum-sepolia': 'eip155:421614',
  'optimism-mainnet': 'eip155:10',
  'optimism-sepolia': 'eip155:11155420',
  'base-mainnet': 'eip155:8453',
  'base-sepolia': 'eip155:84532',
};
```

2. **`import QRCode from 'qrcode'`** 추가 (qrcode는 이미 daemon 의존성에 있음)

3. **PairingResult 인터페이스** 정의:
```typescript
export interface PairingResult {
  uri: string;
  qrDataUrl: string;
  expiresAt: number;
}

export interface WcSessionInfo {
  walletId: string;
  topic: string;
  peerName: string | null;
  peerUrl: string | null;
  chainId: string;
  ownerAddress: string;
  expiry: number;
  createdAt: number;
}

export type PairingStatus = 'pending' | 'connected' | 'expired' | 'none';
```

4. **private 필드 추가:**
   - `private pendingPairing: Map<string, { expiresAt: number; uri: string }> = new Map()` -- 진행 중인 페어링 추적

5. **`createPairing(walletId, network, chain)` 메서드:**
   - signClient null 체크 -> throw WAIaaSError('WC_NOT_CONFIGURED')
   - `this.hasActiveSession(walletId)` 체크 -> throw WAIaaSError('WC_SESSION_EXISTS')
   - `this.pendingPairing.has(walletId)` 체크 -> 기존 pending 반환 (중복 방지)
   - CAIP2_CHAIN_IDS에서 network로 chainId 조회 -> 없으면 chain === 'solana' ? 'solana:...' : 'eip155:...' 추론
   - namespace 결정: chainId.split(':')[0] ('eip155' or 'solana')
   - methods: solana면 ['solana_signTransaction', 'solana_signMessage'], eip155면 ['eth_sendTransaction', 'personal_sign', 'eth_signTypedData_v4']
   - events: solana면 [], eip155면 ['chainChanged', 'accountsChanged']
   - `const { uri, approval } = await signClient.connect({ requiredNamespaces: { [namespace]: { chains: [chainId], methods, events } } })`
   - uri 없으면 throw Error('Failed to generate pairing URI')
   - `const qrDataUrl = await QRCode.toDataURL(uri, { width: 300, margin: 2, errorCorrectionLevel: 'M' })`
   - expiresAt = Math.floor(Date.now() / 1000) + 300 (5분)
   - pendingPairing.set(walletId, { expiresAt, uri })
   - `this.waitForApproval(walletId, chainId, approval)` 호출 (비동기, await 하지 않음)
   - return { uri, qrDataUrl, expiresAt }

6. **`private waitForApproval(walletId, chainId, approval)` 메서드:**
   - 5분 타임아웃으로 approval() 대기: `Promise.race([approval(), timeout(300_000)])`
   - 성공 시: session.topic, session.peer.metadata, session.namespaces에서 owner address 추출
   - owner address 추출: session.namespaces의 첫 번째 namespace의 accounts[0]에서 CAIP-10 포맷 파싱 (e.g., "eip155:1:0xabc..." -> "0xabc...")
   - wc_sessions INSERT: wallet_id, topic, peer_meta (JSON.stringify(session.peer.metadata)), chain_id, owner_address, namespaces (JSON.stringify(session.namespaces)), expiry (session.expiry), created_at
   - sessionMap.set(walletId, topic)
   - pendingPairing.delete(walletId)
   - 실패/타임아웃 시: pendingPairing.delete(walletId), 에러 로그만 출력 (throw 하지 않음)

7. **`getSessionInfo(walletId)` 메서드:**
   - wc_sessions에서 wallet_id로 SELECT
   - 결과를 WcSessionInfo로 변환하여 반환, 없으면 null

8. **`getPairingStatus(walletId)` 메서드:**
   - hasActiveSession -> 'connected'
   - pendingPairing.has(walletId) && Date.now()/1000 < expiresAt -> 'pending'
   - pendingPairing.has(walletId) && expired -> delete, 'expired'
   - else -> 'none'

9. **`disconnectSession(walletId)` 메서드:**
   - signClient null 체크 -> throw WAIaaSError('WC_NOT_CONFIGURED')
   - topic = sessionMap에서 walletId로 조회 -> 없으면 throw WAIaaSError('WC_SESSION_NOT_FOUND')
   - `await signClient.disconnect({ topic, reason: { code: 6000, message: 'User disconnected' } })`
   - `this.handleSessionDelete(topic)` 호출하여 DB + 메모리 정리

10. **`getSessionTopic(walletId)` public 메서드 추가** (기존 private가 아닌 public으로):
    - return this.sessionMap.get(walletId) ?? null

**에러 코드 추가** (`packages/core/src/errors/error-codes.ts`):
- `WC_NOT_CONFIGURED`: domain 'SYSTEM', httpStatus 503, retryable false, message 'WalletConnect is not configured'
- `WC_SESSION_EXISTS`: domain 'WALLET', httpStatus 409, retryable false, message 'Wallet already has an active WC session'
- `WC_SESSION_NOT_FOUND`: domain 'WALLET', httpStatus 404, retryable false, message 'No active WC session for this wallet'

**i18n 추가** (`packages/core/src/i18n/en.ts`):
- WC_NOT_CONFIGURED, WC_SESSION_EXISTS, WC_SESSION_NOT_FOUND에 대한 영어 메시지 추가 (기존 패턴 따름)
  </action>
  <verify>
- `pnpm build --filter=@waiaas/core` 성공
- `pnpm build --filter=@waiaas/daemon` 성공 (import 관계 확인)
- `pnpm test --filter=@waiaas/daemon -- --run wc-session-service` 기존 7개 테스트 여전히 통과
  </verify>
  <done>
WcSessionService에 createPairing/waitForApproval/getSessionInfo/getPairingStatus/disconnectSession 메서드가 존재하고, CAIP2_CHAIN_IDS 상수가 export되며, 에러 코드 3개가 core에 등록되었다.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST API 라우트 + server.ts 등록 + OpenAPI 스키마 + 테스트</name>
  <files>
    packages/daemon/src/api/routes/wc.ts
    packages/daemon/src/api/routes/openapi-schemas.ts
    packages/daemon/src/api/server.ts
    packages/daemon/src/__tests__/wc-pairing.test.ts
  </files>
  <action>
**OpenAPI 스키마 추가** (`packages/daemon/src/api/routes/openapi-schemas.ts`):

파일 끝에 WC 관련 스키마 추가:

```typescript
// ---------------------------------------------------------------------------
// WalletConnect Pairing & Session Schemas
// ---------------------------------------------------------------------------

export const WcPairingResponseSchema = z.object({
  uri: z.string(),
  qrCode: z.string(), // data:image/png;base64,...
  expiresAt: z.number().int(),
}).openapi('WcPairingResponse');

export const WcSessionResponseSchema = z.object({
  walletId: z.string(),
  topic: z.string(),
  peerName: z.string().nullable(),
  peerUrl: z.string().nullable(),
  chainId: z.string(),
  ownerAddress: z.string(),
  expiry: z.number().int(),
  createdAt: z.number().int(),
}).openapi('WcSessionResponse');

export const WcPairingStatusResponseSchema = z.object({
  status: z.enum(['pending', 'connected', 'expired', 'none']),
  session: WcSessionResponseSchema.nullable().optional(),
}).openapi('WcPairingStatusResponse');

export const WcDisconnectResponseSchema = z.object({
  disconnected: z.boolean(),
}).openapi('WcDisconnectResponse');
```

**REST API 라우트 파일 생성** (`packages/daemon/src/api/routes/wc.ts`):

기존 wallets.ts 패턴을 따라 OpenAPIHono + createRoute로 구현. 4개 엔드포인트:

1. **POST /wallets/{id}/wc/pair** (masterAuth):
   - params: z.object({ id: z.string().uuid() })
   - 핸들러: wcSessionService.createPairing(id, wallet.defaultNetwork ?? wallet.network, wallet.chain) 호출
   - 반환: { uri, qrCode: qrDataUrl, expiresAt } (200)
   - wallet 존재 확인: db에서 wallets 테이블 조회 -> 없으면 WAIaaSError('WALLET_NOT_FOUND')
   - WC 미설정: 503 WC_NOT_CONFIGURED
   - 기존 세션: 409 WC_SESSION_EXISTS

2. **GET /wallets/{id}/wc/session** (masterAuth):
   - params: z.object({ id: z.string().uuid() })
   - 핸들러: wcSessionService.getSessionInfo(id) 호출
   - 세션 있으면 200 + WcSessionResponseSchema, 없으면 404 WC_SESSION_NOT_FOUND

3. **DELETE /wallets/{id}/wc/session** (masterAuth):
   - params: z.object({ id: z.string().uuid() })
   - 핸들러: wcSessionService.disconnectSession(id) 호출
   - 200 + { disconnected: true }

4. **GET /wallets/{id}/wc/pair/status** (masterAuth):
   - params: z.object({ id: z.string().uuid() })
   - 핸들러: wcSessionService.getPairingStatus(id) 호출
   - status가 'connected'면 getSessionInfo(id) 결과도 포함
   - 200 + { status, session }

WcRouteDeps 인터페이스:
```typescript
export interface WcRouteDeps {
  db: BetterSQLite3Database<typeof schema>;
  wcSessionService?: WcSessionService;
}
```

export function wcRoutes(deps: WcRouteDeps): OpenAPIHono

**server.ts 수정:**

1. import 추가: `import { wcRoutes } from './routes/wc.js';`
2. masterAuth 등록 추가 (기존 wallets/:id 패턴 근처에):
   - `app.use('/v1/wallets/:id/wc/*', masterAuth)` 추가 (masterPasswordHash 블록 내부)
3. 라우트 등록 추가 (walletCrudRoutes 등록 근처에):
```typescript
if (deps.db && deps.wcSessionService) {
  app.route('/v1', wcRoutes({
    db: deps.db,
    wcSessionService: deps.wcSessionService,
  }));
}
```

주의: masterAuth 미들웨어에서 `/v1/wallets/:id` 패턴의 sub-path skip 로직에 `/wc/` 경로를 추가하여 WC 라우트가 자체 masterAuth를 사용하도록 설정. 기존 skip 조건에 `|| c.req.path.includes('/wc/')` 추가.

**테스트 작성** (`packages/daemon/src/__tests__/wc-pairing.test.ts`):

WcSessionService 메서드 단위 테스트 (실제 SignClient는 사용하지 않고, signClient를 mock):

1. `createPairing - signClient null이면 에러` -- getSignClient() returns null일 때 WC_NOT_CONFIGURED
2. `createPairing - 기존 세션 있으면 에러` -- sessionMap에 walletId 존재 시 WC_SESSION_EXISTS
3. `createPairing - pending pairing 있으면 기존 URI 반환` -- pendingPairing에서 기존 값 반환
4. `getPairingStatus - none` -- 아무 상태 없을 때
5. `getPairingStatus - pending` -- pendingPairing에 미만료 항목 존재
6. `getPairingStatus - expired` -- pendingPairing에 만료 항목 -> expired + 삭제
7. `getSessionInfo - 세션 있을 때` -- wc_sessions에 INSERT 후 조회
8. `getSessionInfo - 세션 없을 때 null` -- 빈 테이블
9. `disconnectSession - signClient null이면 에러` -- WC_NOT_CONFIGURED
10. `disconnectSession - 세션 없으면 에러` -- WC_SESSION_NOT_FOUND
11. `CAIP2_CHAIN_IDS 상수 검증` -- solana devnet, ethereum-sepolia 값 확인

테스트에서 WcSessionService private 멤버 접근은 기존 패턴대로 `(service as any)` 캐스팅 사용. DB는 in-memory SQLite + DDL 직접 실행.
  </action>
  <verify>
- `pnpm build --filter=@waiaas/daemon` 성공
- `pnpm test --filter=@waiaas/daemon -- --run wc-pairing` 11개 테스트 통과
- `pnpm test --filter=@waiaas/daemon` 전체 테스트 통과 (기존 1,551개 + 신규)
  </verify>
  <done>
REST API 4개 엔드포인트(pair, session GET, session DELETE, pair/status)가 masterAuth 보호 하에 동작하고, OpenAPI 스키마가 등록되고, 11개 단위 테스트가 통과한다.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` 전체 모노레포 빌드 성공
2. `pnpm test --filter=@waiaas/daemon` 전체 테스트 통과
3. `curl -X POST http://127.0.0.1:3100/v1/wallets/{id}/wc/pair -H 'X-Master-Password: ...'` -> 200 (uri, qrCode, expiresAt)
4. `curl http://127.0.0.1:3100/v1/wallets/{id}/wc/pair/status -H 'X-Master-Password: ...'` -> 200 (status: pending)
5. `curl http://127.0.0.1:3100/v1/wallets/{id}/wc/session -H 'X-Master-Password: ...'` -> 404 (세션 미성립 시)
6. `curl -X DELETE http://127.0.0.1:3100/v1/wallets/{id}/wc/session -H 'X-Master-Password: ...'` -> 200 (세션 해제)
</verification>

<success_criteria>
- WcSessionService에 createPairing, getSessionInfo, getPairingStatus, disconnectSession 메서드가 존재
- REST API 4개 엔드포인트가 OpenAPI 스키마와 함께 등록
- 단일 WC 세션 정책이 코드 수준에서 적용 (기존 세션 있으면 409)
- SignClient null 시 503 반환 (fail-soft)
- approval()은 비동기 처리 (HTTP 응답은 URI/QR만 즉시 반환)
- 전체 테스트 통과, 빌드 성공
</success_criteria>

<output>
After completion, create `.planning/phases/147-qr-pairing/147-01-SUMMARY.md`
</output>
