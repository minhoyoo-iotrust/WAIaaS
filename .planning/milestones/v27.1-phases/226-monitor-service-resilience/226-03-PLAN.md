---
phase: 226-monitor-service-resilience
plan: 03
type: tdd
wave: 2
depends_on: [226-01]
files_modified:
  - packages/daemon/src/services/incoming/incoming-tx-workers.ts
  - packages/daemon/src/services/incoming/__tests__/incoming-tx-workers.test.ts
autonomous: true
requirements: [STO-03, STO-05]

must_haves:
  truths:
    - "Confirmation upgrade worker queries DETECTED transactions and upgrades to CONFIRMED based on chain-specific block thresholds"
    - "Retention policy worker deletes incoming_transactions records older than configurable incoming_retention_days"
    - "Gap recovery function loads cursor from incoming_tx_cursors and polls subscriber for missed blocks"
    - "Cursor is updated after each successful flush to track last processed position"
    - "Solana confirmation checks getTransaction(finalized) -- if found, status -> CONFIRMED"
    - "EVM confirmation uses current block - tx block >= network threshold (e.g., 12 for mainnet, 1 for testnet)"
  artifacts:
    - path: "packages/daemon/src/services/incoming/incoming-tx-workers.ts"
      provides: "Worker handler factories for confirmation, retention, gap recovery, and cursor management"
      exports: ["createConfirmationWorkerHandler", "createRetentionWorkerHandler", "createGapRecoveryHandler", "updateCursor", "loadCursor", "EVM_CONFIRMATION_THRESHOLDS"]
    - path: "packages/daemon/src/services/incoming/__tests__/incoming-tx-workers.test.ts"
      provides: "Unit tests for all worker handlers"
      min_lines: 120
  key_links:
    - from: "packages/daemon/src/services/incoming/incoming-tx-workers.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "Drizzle queries on incomingTransactions and incomingTxCursors tables"
      pattern: "incomingTransactions|incomingTxCursors"
    - from: "packages/daemon/src/services/incoming/incoming-tx-workers.ts"
      to: "packages/daemon/src/lifecycle/workers.ts"
      via: "Handler functions designed for BackgroundWorkers.register() interval pattern"
      pattern: "handler.*=>|async.*=>.*flush|async.*=>.*confirm"
---

<objective>
Implement the background worker handler factories for incoming transaction lifecycle management: (1) confirmation upgrade worker that transitions DETECTED -> CONFIRMED, (2) retention policy worker that auto-deletes old records, (3) gap recovery handler for filling missed transactions after reconnection, and (4) cursor management utilities for tracking processing position.

Purpose: Raw transaction detection (DETECTED status) needs confirmation verification before the transaction is considered final. Old records need cleanup to prevent unbounded DB growth. After a WebSocket disconnect, the gap between last-known cursor and current chain state must be recovered.

Output: Worker handler factories + cursor utilities + comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/224-core-types-db-foundation/224-02-SUMMARY.md
@.planning/phases/226-monitor-service-resilience/226-RESEARCH.md

Key references:
- DB schema: packages/daemon/src/infrastructure/database/schema.ts (incomingTransactions, incomingTxCursors)
- BackgroundWorkers: packages/daemon/src/lifecycle/workers.ts (register pattern)
- SolanaIncomingSubscriber.pollAll(): packages/adapters/solana/src/solana-incoming-subscriber.ts
- EvmIncomingSubscriber.pollAll(): packages/adapters/evm/src/evm-incoming-subscriber.ts
- IChainSubscriber: packages/core/src/interfaces/IChainSubscriber.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker handler factories + cursor utilities</name>
  <files>
    packages/daemon/src/services/incoming/incoming-tx-workers.ts
  </files>
  <action>
Create `packages/daemon/src/services/incoming/incoming-tx-workers.ts`:

```typescript
import type { Database } from 'better-sqlite3';
import type { BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import { eq, and, lt } from 'drizzle-orm';
import * as schema from '../../infrastructure/database/schema.js';
```

**1. EVM Confirmation Thresholds:**

```typescript
export const EVM_CONFIRMATION_THRESHOLDS: Record<string, number> = {
  mainnet: 12,
  sepolia: 1,
  'polygon-mainnet': 128,
  'polygon-amoy': 1,
  'arbitrum-mainnet': 1,
  'arbitrum-sepolia': 1,
  'base-mainnet': 12,
  'base-sepolia': 1,
};

export const DEFAULT_EVM_CONFIRMATIONS = 12;
export const SOLANA_CONFIRMATION = 'finalized'; // commitment level
```

**2. `createConfirmationWorkerHandler(deps)` factory:**

Parameters:
- `db: BetterSQLite3Database<typeof schema>` -- Drizzle ORM for queries
- `sqlite: Database` -- raw sqlite for Solana getTransaction check
- `getBlockNumber?: (chain: string, network: string) => Promise<bigint>` -- for EVM block number lookup
- `checkSolanaFinalized?: (txHash: string, rpcUrl: string) => Promise<boolean>` -- for Solana confirmation

Returns `async () => void` handler for BackgroundWorkers.

Logic:
- Query all records with `status = 'DETECTED'` from incomingTransactions (use Drizzle `eq()`)
- Group by chain
- **Solana:** For each Solana DETECTED tx, call `checkSolanaFinalized(tx.txHash, rpcUrl)`. If true, UPDATE status to 'CONFIRMED' and set `confirmed_at = Math.floor(Date.now() / 1000)`.
- **EVM:** Get current block number for each network via `getBlockNumber(chain, network)`. For each EVM DETECTED tx, compute `confirmations = currentBlock - BigInt(tx.blockNumber ?? 0)`. If `confirmations >= threshold`, UPDATE to 'CONFIRMED'.
- Wrap per-tx operations in try/catch for per-record error isolation.

**3. `createRetentionWorkerHandler(deps)` factory:**

Parameters:
- `sqlite: Database`
- `getRetentionDays: () => number` -- function to read current setting (for hot-reload)

Returns `async () => void` handler.

Logic:
- `const cutoff = Math.floor(Date.now() / 1000) - getRetentionDays() * 86400`
- `sqlite.prepare('DELETE FROM incoming_transactions WHERE detected_at < ?').run(cutoff)`
- Log count of deleted rows if > 0

**4. `createGapRecoveryHandler(deps)` factory:**

Parameters:
- `sqlite: Database`
- `subscribers: Map<string, { subscriber: { pollAll: () => Promise<void> } }>` -- connection key -> subscriber
  (This receives the multiplexer's connection entries so it can call pollAll() for recovery)

Returns `async (chain: string, network: string, walletIds: string[]) => Promise<void>`.

Logic:
- Load cursor from incoming_tx_cursors for each wallet
- The actual recovery is done by calling `subscriber.pollAll()` on the relevant subscriber -- it polls from where it left off
- Update cursor after recovery

**5. Cursor utilities:**

```typescript
export function updateCursor(sqlite: Database, walletId: string, chain: string, network: string, cursor: string): void
```
- INSERT OR REPLACE into incoming_tx_cursors (id generated, wallet_id, chain, network, last_cursor, updated_at)

```typescript
export function loadCursor(sqlite: Database, walletId: string, chain: string, network: string): string | null
```
- SELECT last_cursor FROM incoming_tx_cursors WHERE wallet_id = ? AND chain = ? AND network = ?

Update `packages/daemon/src/services/incoming/index.ts`:
- Add re-exports for all exported functions and constants
  </action>
  <verify>
    pnpm turbo run typecheck --filter=@waiaas/daemon
  </verify>
  <done>
    All worker factories and cursor utilities compile and are exported from index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for worker handlers and cursor utilities</name>
  <files>
    packages/daemon/src/services/incoming/__tests__/incoming-tx-workers.test.ts
  </files>
  <action>
Create tests using vitest with mock DB objects.

**Mock setup:**
- Mock Drizzle DB with `.select().from().where()` chain returning test data
- Mock raw sqlite with `prepare().run()`, `prepare().get()`, `prepare().all()` for cursor and retention queries
- Factory helper `makeDetectedTx(chain, overrides)` returning DB row format

**Test cases:**

1. **Confirmation worker - Solana:**
   - DETECTED Solana tx + checkSolanaFinalized returns true -> status updated to CONFIRMED
   - checkSolanaFinalized returns false -> status stays DETECTED
   - checkSolanaFinalized throws -> error isolated, other txs still processed

2. **Confirmation worker - EVM:**
   - DETECTED EVM tx at block 100, current block 112, mainnet (threshold 12) -> CONFIRMED
   - DETECTED EVM tx at block 100, current block 110, mainnet (threshold 12) -> still DETECTED
   - Unknown network uses DEFAULT_EVM_CONFIRMATIONS (12)

3. **Retention worker:**
   - Records older than retention_days deleted
   - getRetentionDays() hot-reload: changing from 30 to 7 days adjusts cutoff
   - Empty table -> no error, 0 deletions

4. **Cursor utilities:**
   - updateCursor() inserts new cursor row
   - updateCursor() replaces existing cursor for same wallet+chain+network
   - loadCursor() returns cursor value when exists
   - loadCursor() returns null when no cursor exists

5. **Gap recovery handler:**
   - Calls pollAll() on the correct subscriber for the given chain:network
   - Missing subscriber for chain:network -> no error (graceful skip)
  </action>
  <verify>
    pnpm vitest run packages/daemon/src/services/incoming/__tests__/incoming-tx-workers.test.ts
  </verify>
  <done>
    All tests pass covering confirmation upgrades (Solana + EVM), retention policy, cursor management, gap recovery
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
2. `pnpm vitest run packages/daemon/src/services/incoming/__tests__/incoming-tx-workers.test.ts` -- all tests pass
3. `pnpm turbo run lint --filter=@waiaas/daemon` passes
4. All worker handler factories and cursor utilities are importable from index.ts
</verification>

<success_criteria>
- Confirmation worker correctly transitions DETECTED -> CONFIRMED for both Solana (finalized check) and EVM (block threshold check)
- Retention worker deletes records older than configurable days
- Cursor load/update functions read/write incoming_tx_cursors table correctly
- Gap recovery handler calls pollAll() on the appropriate subscriber
- Per-record error isolation ensures one failure does not block others
</success_criteria>

<output>
After completion, create `.planning/phases/226-monitor-service-resilience/226-03-SUMMARY.md`
</output>
