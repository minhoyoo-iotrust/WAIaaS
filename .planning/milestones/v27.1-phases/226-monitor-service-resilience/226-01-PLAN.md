---
phase: 226-monitor-service-resilience
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/services/incoming/incoming-tx-queue.ts
  - packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts
  - packages/daemon/src/services/incoming/index.ts
autonomous: true
requirements: [STO-02, STO-04]

must_haves:
  truths:
    - "IncomingTxQueue.push() deduplicates by txHash:walletId composite key using Map"
    - "IncomingTxQueue.flush() extracts up to MAX_BATCH (100) items and inserts via SQLite transaction with ON CONFLICT DO NOTHING"
    - "Queue enforces MAX_QUEUE_SIZE (10,000) by dropping oldest entries on overflow"
    - "flush() returns only actually-inserted records (not ON CONFLICT skipped)"
    - "Queue size is 0 after flush() when queue has <= MAX_BATCH items"
  artifacts:
    - path: "packages/daemon/src/services/incoming/incoming-tx-queue.ts"
      provides: "IncomingTxQueue class with push/flush/size/drain"
      exports: ["IncomingTxQueue"]
    - path: "packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts"
      provides: "Unit tests for queue dedup, batch flush, overflow protection, ON CONFLICT"
      min_lines: 100
    - path: "packages/daemon/src/services/incoming/index.ts"
      provides: "Barrel re-exports for incoming service module"
  key_links:
    - from: "packages/daemon/src/services/incoming/incoming-tx-queue.ts"
      to: "better-sqlite3 Database"
      via: "sqlite.prepare() / sqlite.transaction() in flush()"
      pattern: "sqlite\\.prepare|sqlite\\.transaction"
    - from: "packages/daemon/src/services/incoming/incoming-tx-queue.ts"
      to: "packages/core/src/interfaces/chain-subscriber.types.ts"
      via: "IncomingTransaction type import"
      pattern: "import.*IncomingTransaction.*from.*@waiaas/core"
---

<objective>
Implement IncomingTxQueue: the memory buffer that collects incoming transactions from chain subscriber callbacks and batch-flushes them to SQLite in 5-second intervals. This is the write-side protection layer that prevents SQLITE_BUSY contention from concurrent WebSocket callbacks.

Purpose: Without buffering, multiple WebSocket subscription callbacks would race to write to SQLite simultaneously. The queue provides Map-based in-memory deduplication (txHash:walletId composite key), bounded memory (MAX_QUEUE_SIZE), and transactional batch INSERT with ON CONFLICT DO NOTHING for DB-level safety.

Output: IncomingTxQueue class + comprehensive tests + barrel exports.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/224-core-types-db-foundation/224-01-SUMMARY.md
@.planning/phases/224-core-types-db-foundation/224-02-SUMMARY.md
@.planning/phases/226-monitor-service-resilience/226-RESEARCH.md

Key references:
- IncomingTransaction interface: packages/core/src/interfaces/chain-subscriber.types.ts (13 fields)
- DB schema: packages/daemon/src/infrastructure/database/migrate.ts (v21 incoming_transactions table, 12 columns + 4 indexes)
- Drizzle schema: packages/daemon/src/infrastructure/database/schema.ts (incomingTransactions table)
- generateId: packages/daemon/src/infrastructure/database/id.ts (UUID v7)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IncomingTxQueue class with Map dedup + batch flush</name>
  <files>
    packages/daemon/src/services/incoming/incoming-tx-queue.ts
    packages/daemon/src/services/incoming/index.ts
  </files>
  <action>
Create `packages/daemon/src/services/incoming/incoming-tx-queue.ts`:

```typescript
import type { Database } from 'better-sqlite3';
import type { IncomingTransaction } from '@waiaas/core';
```

Class `IncomingTxQueue` with:

1. **Private state:**
   - `queue = new Map<string, IncomingTransaction>()` -- key is `${txHash}:${walletId}`
   - `MAX_BATCH = 100` (const)
   - `MAX_QUEUE_SIZE = 10_000` (const)

2. **`get size(): number`** -- returns `this.queue.size`

3. **`push(tx: IncomingTransaction): void`** -- synchronous, O(1):
   - If `queue.size >= MAX_QUEUE_SIZE`, delete the first key (oldest entry) and log `console.warn('IncomingTxQueue overflow: dropping oldest entry')`
   - Compute key = `${tx.txHash}:${tx.walletId}`
   - If key not in queue, set it. If already present, skip (dedup).

4. **`flush(sqlite: Database): IncomingTransaction[]`** -- batch insert:
   - If queue is empty, return `[]`
   - Extract up to MAX_BATCH items from queue. Use `for...of` with break at MAX_BATCH. Delete each extracted key from the Map.
   - Prepare INSERT statement: `INSERT INTO incoming_transactions (id, wallet_id, chain, network, tx_hash, from_address, to_address, amount, token_address, decimals, status, is_suspicious, detected_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(tx_hash, wallet_id) DO NOTHING`
   - Use `sqlite.transaction((batch) => { ... })` to insert all rows atomically
   - Track which rows were actually inserted by checking `stmt.run().changes > 0`
   - Return only the actually-inserted IncomingTransaction items (not ON CONFLICT skipped ones)
   - Note: `id` should be generated via the `generateId` import from `../../infrastructure/database/id.js`

5. **`drain(sqlite: Database): IncomingTransaction[]`** -- flush everything (for shutdown):
   - Call flush() in a loop until queue is empty, collecting all inserted items
   - Return accumulated results

Create `packages/daemon/src/services/incoming/index.ts`:
- Re-export `IncomingTxQueue` from `./incoming-tx-queue.js`
  </action>
  <verify>
    pnpm turbo run typecheck --filter=@waiaas/daemon
  </verify>
  <done>
    IncomingTxQueue class compiles with push(), flush(), drain(), size, and index.ts re-exports it
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for IncomingTxQueue</name>
  <files>
    packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts
  </files>
  <action>
Create `packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts`:

Use vitest. Create a mock better-sqlite3 Database object with mock `prepare()` and `transaction()` methods. The mock should track calls so tests can verify INSERT SQL and parameter values.

Helper: `makeTx(overrides?: Partial<IncomingTransaction>): IncomingTransaction` factory that returns a valid IncomingTransaction with defaults (id, walletId, chain: 'solana', network: 'mainnet', txHash: random, fromAddress, toAddress, amount: '1000000', tokenAddress: null, decimals: 9, status: 'DETECTED', isSuspicious: false, detectedAt: Math.floor(Date.now()/1000)).

**Test cases (RED -> GREEN -> REFACTOR):**

1. **Dedup tests:**
   - push() same txHash:walletId twice -> size is 1
   - push() same txHash but different walletId -> size is 2
   - push() different txHash same walletId -> size is 2

2. **Flush tests:**
   - flush() empty queue returns []
   - flush() with 3 items -> calls sqlite.transaction, returns 3 items, queue size is 0
   - flush() with 150 items -> returns first 100 (MAX_BATCH), queue size is 50

3. **ON CONFLICT tests:**
   - flush() when stmt.run().changes === 0 for some items -> returned array excludes those items
   - Verify INSERT SQL contains ON CONFLICT(tx_hash, wallet_id) DO NOTHING

4. **Overflow tests:**
   - push() 10,001 items -> size is 10,000 (oldest dropped)
   - Verify console.warn called with overflow message

5. **drain() tests:**
   - drain() with 250 items -> returns all 250, queue is empty
   - drain() empty queue -> returns []

6. **Thread safety tests:**
   - push() during flush() -- since JS is single-threaded, verify flush() extracts only items present at call time

Mock the `generateId` function to return predictable IDs for assertions.
  </action>
  <verify>
    pnpm vitest run packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts
  </verify>
  <done>
    All tests pass covering dedup, flush batching, ON CONFLICT filtering, overflow protection, and drain
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes with 0 errors
2. `pnpm vitest run packages/daemon/src/services/incoming/__tests__/incoming-tx-queue.test.ts` -- all tests pass
3. `pnpm turbo run lint --filter=@waiaas/daemon` passes
4. IncomingTxQueue is importable from `packages/daemon/src/services/incoming/index.ts`
</verification>

<success_criteria>
- IncomingTxQueue.push() deduplicates by txHash:walletId composite key
- IncomingTxQueue.flush() batch inserts up to 100 items atomically with ON CONFLICT DO NOTHING
- Queue bounded at 10,000 entries with oldest-first eviction
- drain() empties entire queue in multiple flush cycles
- All tests pass with mock SQLite
</success_criteria>

<output>
After completion, create `.planning/phases/226-monitor-service-resilience/226-01-SUMMARY.md`
</output>
