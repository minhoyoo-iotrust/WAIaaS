---
phase: 226-monitor-service-resilience
plan: 04
type: execute
wave: 3
depends_on: [226-01, 226-02, 226-03]
files_modified:
  - packages/daemon/src/services/incoming/safety-rules.ts
  - packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
  - packages/daemon/src/services/incoming/__tests__/safety-rules.test.ts
  - packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/infrastructure/settings/hot-reload.ts
  - packages/daemon/src/infrastructure/settings/setting-keys.ts
autonomous: true
requirements: [EVT-01, EVT-03, EVT-04, EVT-05, CFG-04]

must_haves:
  truths:
    - "DustAttackRule flags transactions with USD value below configurable threshold"
    - "UnknownTokenRule flags token transfers with unregistered token addresses"
    - "LargeAmountRule flags transactions exceeding configurable multiplier of average incoming USD"
    - "EventBus emits transaction:incoming after flush and transaction:incoming:suspicious for flagged transactions"
    - "KillSwitch SUSPENDED/LOCKED state suppresses notification delivery but DB records are always written"
    - "Per-wallet per-event-type notification cooldown prevents spam"
    - "DaemonLifecycle Step 4c-9 initializes IncomingTxMonitorService with fail-soft try/catch pattern"
    - "IncomingTxMonitorService.stop() performs final queue drain before destroying subscriptions"
  artifacts:
    - path: "packages/daemon/src/services/incoming/safety-rules.ts"
      provides: "IIncomingSafetyRule interface + 3 implementations (DustAttackRule, UnknownTokenRule, LargeAmountRule)"
      exports: ["IIncomingSafetyRule", "SafetyRuleContext", "DustAttackRule", "UnknownTokenRule", "LargeAmountRule", "SuspiciousReason"]
    - path: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      provides: "IncomingTxMonitorService orchestrator with start/stop/updateConfig/syncSubscriptions"
      exports: ["IncomingTxMonitorService", "IncomingTxMonitorConfig"]
    - path: "packages/daemon/src/services/incoming/__tests__/safety-rules.test.ts"
      provides: "Unit tests for all 3 safety rules"
      min_lines: 60
    - path: "packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts"
      provides: "Unit tests for orchestrator lifecycle, event emission, KillSwitch suppression, cooldown"
      min_lines: 100
  key_links:
    - from: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      to: "packages/daemon/src/services/incoming/incoming-tx-queue.ts"
      via: "queue.push() in onTransaction callback, queue.flush() in worker handler"
      pattern: "queue\\.push|queue\\.flush|queue\\.drain"
    - from: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      to: "packages/daemon/src/services/incoming/subscription-multiplexer.ts"
      via: "multiplexer.addWallet/removeWallet for subscription management"
      pattern: "multiplexer\\.addWallet|multiplexer\\.removeWallet"
    - from: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      to: "packages/core/src/events/event-types.ts"
      via: "EventBus.emit('transaction:incoming') and EventBus.emit('transaction:incoming:suspicious')"
      pattern: "eventBus\\.emit.*transaction:incoming"
    - from: "packages/daemon/src/lifecycle/daemon.ts"
      to: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      via: "Step 4c-9 fail-soft initialization"
      pattern: "Step 4c-9|IncomingTxMonitorService"
---

<objective>
Implement the IncomingTxMonitorService orchestrator that wires together IncomingTxQueue, SubscriptionMultiplexer, background workers, safety rules, and DaemonLifecycle integration. Also implement the 3 safety rule classes (DustAttackRule, UnknownTokenRule, LargeAmountRule) that flag suspicious incoming transactions.

Purpose: This is the top-level service that coordinates all incoming transaction monitoring components. It registers 6 BackgroundWorkers, evaluates safety rules during flush, manages notification cooldowns, respects KillSwitch state for notification suppression, and integrates with DaemonLifecycle for fail-soft startup and graceful shutdown.

Output: Safety rules + orchestrator service + DaemonLifecycle integration + comprehensive tests.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/226-monitor-service-resilience/226-01-PLAN.md
@.planning/phases/226-monitor-service-resilience/226-02-PLAN.md
@.planning/phases/226-monitor-service-resilience/226-03-PLAN.md
@.planning/phases/226-monitor-service-resilience/226-RESEARCH.md

Key references:
- IncomingTxQueue: packages/daemon/src/services/incoming/incoming-tx-queue.ts (from 226-01)
- SubscriptionMultiplexer: packages/daemon/src/services/incoming/subscription-multiplexer.ts (from 226-02)
- Worker handlers: packages/daemon/src/services/incoming/incoming-tx-workers.ts (from 226-03)
- BackgroundWorkers: packages/daemon/src/lifecycle/workers.ts
- DaemonLifecycle: packages/daemon/src/lifecycle/daemon.ts (Step 4c-4 pattern)
- KillSwitchService: packages/daemon/src/services/kill-switch-service.ts
- NotificationService: packages/daemon/src/notifications/notification-service.ts
- EventBus: packages/core/src/events/event-types.ts (WaiaasEventMap)
- BalanceMonitorService pattern: packages/daemon/src/services/monitoring/balance-monitor-service.ts
- HotReloadOrchestrator: packages/daemon/src/infrastructure/settings/hot-reload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create safety rules + IncomingTxMonitorService + tests</name>
  <files>
    packages/daemon/src/services/incoming/safety-rules.ts
    packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
    packages/daemon/src/services/incoming/__tests__/safety-rules.test.ts
    packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts
  </files>
  <action>
**A. Create `packages/daemon/src/services/incoming/safety-rules.ts`:**

Types:
```typescript
export type SuspiciousReason = 'dust' | 'unknownToken' | 'largeAmount';

export interface SafetyRuleContext {
  dustThresholdUsd: number;        // from incoming.suspicious_dust_usd setting
  amountMultiplier: number;        // from incoming.suspicious_amount_multiplier setting
  isRegisteredToken: boolean;      // from token registry lookup
  usdPrice: number | null;         // from PriceOracle (null if unavailable)
  avgIncomingUsd: number | null;   // average incoming USD for this wallet (null if no history)
  decimals: number;                // token decimals
}

export interface IIncomingSafetyRule {
  readonly name: SuspiciousReason;
  check(tx: IncomingTransaction, context: SafetyRuleContext): boolean;
}
```

3 implementations per research section code examples:

1. **DustAttackRule:** `amountUsd = Number(tx.amount) * usdPrice / 10^decimals`. Return `amountUsd < dustThresholdUsd`. If `usdPrice === null`, return false (safe default).

2. **UnknownTokenRule:** If `tx.tokenAddress === null` (native transfer), return false. Otherwise return `!ctx.isRegisteredToken`.

3. **LargeAmountRule:** `amountUsd = Number(tx.amount) * usdPrice / 10^decimals`. Return `amountUsd > avgIncomingUsd * amountMultiplier`. If either usdPrice or avgIncomingUsd is null, return false.

**B. Create `packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts`:**

```typescript
export interface IncomingTxMonitorConfig {
  enabled: boolean;
  pollIntervalSec: number;       // default 30
  retentionDays: number;         // default 90
  dustThresholdUsd: number;      // default 0.01
  amountMultiplier: number;      // default 10
  cooldownMinutes: number;       // default 5 (notification cooldown per wallet:eventType)
}
```

**Class `IncomingTxMonitorService`:**

Constructor deps:
- `sqlite: Database`
- `db: BetterSQLite3Database<typeof schema>`
- `workers: BackgroundWorkers`
- `eventBus: EventBus`
- `killSwitchService?: KillSwitchService | null`
- `notificationService?: NotificationService | null`
- `subscriberFactory: SubscriberFactory` (creates IChainSubscriber per chain:network)
- `config: IncomingTxMonitorConfig`

Internal state:
- `queue: IncomingTxQueue`
- `multiplexer: SubscriptionMultiplexer`
- `safetyRules: IIncomingSafetyRule[]` -- initialized with all 3 rules
- `notifyCooldown: Map<string, number>` -- key `${walletId}:${eventType}` -> lastNotifiedAt (epoch seconds)
- `config: IncomingTxMonitorConfig`

**`start()` method:**
1. Create IncomingTxQueue
2. Create SubscriptionMultiplexer with:
   - `onTransaction: (tx) => queue.push(tx)` -- synchronous, O(1)
   - `onGapRecovery` from 226-03 gap recovery handler
3. Load wallet list (wallets with monitor_incoming = 1) from DB
4. For each wallet, call `multiplexer.addWallet(chain, network, walletId, publicKey)`
5. Register 6 BackgroundWorkers:
   - `incoming-tx-flush` (5_000ms): flush queue, evaluate safety rules on inserted txs, emit events, send notifications
   - `incoming-tx-retention` (3_600_000ms): retention worker from 226-03
   - `incoming-tx-confirm-solana` (30_000ms): confirmation worker for Solana from 226-03
   - `incoming-tx-confirm-evm` (30_000ms): confirmation worker for EVM from 226-03
   - `incoming-tx-poll-solana` (config.pollIntervalSec * 1000): call solana subscriber pollAll() if in POLLING_FALLBACK state
   - `incoming-tx-poll-evm` (config.pollIntervalSec * 1000): call EVM subscriber pollAll()

**Flush handler logic (the core flush worker):**
```
const inserted = queue.flush(sqlite);
for (const tx of inserted) {
  // 1. Evaluate safety rules
  const context = buildSafetyRuleContext(tx); // uses PriceOracle, token registry
  const suspiciousReasons = safetyRules
    .filter(rule => rule.check(tx, context))
    .map(rule => rule.name);

  const isSuspicious = suspiciousReasons.length > 0;
  if (isSuspicious) {
    // UPDATE incoming_transactions SET is_suspicious = 1 WHERE id = tx.id
    sqlite.prepare('UPDATE incoming_transactions SET is_suspicious = 1 WHERE id = ?').run(tx.id);
  }

  // 2. Emit events (always, regardless of KillSwitch)
  eventBus.emit('transaction:incoming', { ...tx, timestamp: tx.detectedAt });
  if (isSuspicious) {
    eventBus.emit('transaction:incoming:suspicious', { ...tx, suspiciousReasons, timestamp: tx.detectedAt });
  }

  // 3. Send notifications (suppressed by KillSwitch, subject to cooldown)
  const killState = killSwitchService?.getState();
  if (killState?.state === 'ACTIVE') {
    const eventType = isSuspicious ? 'INCOMING_TX_SUSPICIOUS' : 'INCOMING_TX_DETECTED';
    if (!isCooldownActive(tx.walletId, eventType)) {
      notificationService?.notify(eventType as any, tx.walletId, { txHash: tx.txHash, amount: tx.amount, chain: tx.chain });
      recordCooldown(tx.walletId, eventType);
    }
  }

  // 4. Update cursor
  updateCursor(sqlite, tx.walletId, tx.chain, tx.network, tx.txHash);
}
```

**Cooldown logic:**
- `isCooldownActive(walletId, eventType)`: check if `now - lastNotified < cooldownMinutes * 60`
- `recordCooldown(walletId, eventType)`: set `notifyCooldown.set(key, now)`

**`stop()` method:**
1. `queue.drain(sqlite)` -- final flush of all remaining items
2. `multiplexer.stopAll()` -- tear down all subscriber connections
3. Clear notifyCooldown Map

**`updateConfig(partial: Partial<IncomingTxMonitorConfig>)`:**
- Merge into this.config. Used by HotReloadOrchestrator.

**`syncSubscriptions()`:**
- Re-read wallets with monitor_incoming=1 from DB
- Compare with multiplexer's current subscriptions
- Add new wallets, remove stale wallets

Update `packages/daemon/src/services/incoming/index.ts`:
- Add re-exports for safety rules and IncomingTxMonitorService

**C. Create safety rules tests** (`safety-rules.test.ts`):

Test each rule with edge cases:
- DustAttackRule: below threshold (true), above threshold (false), null usdPrice (false)
- UnknownTokenRule: token tx + unregistered (true), token tx + registered (false), native tx (false)
- LargeAmountRule: above multiplier * avg (true), below (false), null avg (false), null price (false)

**D. Create orchestrator tests** (`incoming-tx-monitor-service.test.ts`):

Mock all deps (queue, multiplexer, workers, eventBus, killSwitch, notification):

1. start() loads wallets and adds them to multiplexer
2. Flush handler emits transaction:incoming for each inserted tx
3. Flush handler emits transaction:incoming:suspicious for flagged txs
4. KillSwitch SUSPENDED -> notifications NOT sent, events still emitted, DB records written
5. KillSwitch ACTIVE -> notifications sent
6. Cooldown: second notification for same wallet:eventType within cooldown window -> suppressed
7. stop() calls queue.drain() then multiplexer.stopAll()
  </action>
  <verify>
    pnpm vitest run packages/daemon/src/services/incoming/__tests__/safety-rules.test.ts && pnpm vitest run packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts
  </verify>
  <done>
    Safety rules and orchestrator tests all pass. EventBus events, KillSwitch suppression, cooldown, and stop() drain verified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate IncomingTxMonitorService into DaemonLifecycle</name>
  <files>
    packages/daemon/src/infrastructure/settings/setting-keys.ts
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/infrastructure/settings/hot-reload.ts
  </files>
  <action>
**A. Register `incoming.*` keys in setting-keys.ts:**

Add `'incoming'` to the `SETTING_CATEGORIES` array. Then append the following 7 setting definitions to the `SETTING_DEFINITIONS` array (after the `signing_sdk` entries):

```typescript
  // --- incoming category (Incoming TX monitor settings) ---
  { key: 'incoming.enabled', category: 'incoming', configPath: 'incoming.enabled', defaultValue: 'false', isCredential: false },
  { key: 'incoming.poll_interval', category: 'incoming', configPath: 'incoming.poll_interval', defaultValue: '30', isCredential: false },
  { key: 'incoming.retention_days', category: 'incoming', configPath: 'incoming.retention_days', defaultValue: '90', isCredential: false },
  { key: 'incoming.suspicious_dust_usd', category: 'incoming', configPath: 'incoming.suspicious_dust_usd', defaultValue: '0.01', isCredential: false },
  { key: 'incoming.suspicious_amount_multiplier', category: 'incoming', configPath: 'incoming.suspicious_amount_multiplier', defaultValue: '10', isCredential: false },
  { key: 'incoming.cooldown_minutes', category: 'incoming', configPath: 'incoming.cooldown_minutes', defaultValue: '5', isCredential: false },
  { key: 'incoming.wss_url', category: 'incoming', configPath: 'incoming.wss_url', defaultValue: '', isCredential: false },
```

This ensures SettingsService.get('incoming.*') calls in Step 4c-9 and HotReloadOrchestrator work correctly without throwing WAIaaSError for unregistered keys. Phase 227 will add config.toml schema support, env var mapping, and Admin UI forms for these keys; the setting-keys.ts registration must exist first.

**B. DaemonLifecycle (daemon.ts):**

1. Add private field: `private incomingTxMonitorService: IncomingTxMonitorService | null = null;`

2. Add import (type-only for the class, dynamic import at usage):
```typescript
import type { IncomingTxMonitorService } from '../services/incoming/incoming-tx-monitor-service.js';
```

3. **Step 4c-9 initialization** -- add after Step 4c-8 (Signing SDK), before Step 5 (HTTP):

Following the exact pattern of Step 4c-4 (BalanceMonitorService):

```typescript
// ------------------------------------------------------------------
// Step 4c-9: IncomingTxMonitorService initialization (fail-soft)
// ------------------------------------------------------------------
try {
  if (this.sqlite && this.adapterPool && this._settingsService) {
    const incoming_enabled = this._settingsService.get('incoming.enabled');
    if (incoming_enabled === 'true') {
      const { IncomingTxMonitorService } = await import('../services/incoming/incoming-tx-monitor-service.js');
      // Build config from SettingsService
      const ss = this._settingsService;
      const monitorConfig = {
        enabled: true,
        pollIntervalSec: parseInt(ss.get('incoming.poll_interval') || '30', 10),
        retentionDays: parseInt(ss.get('incoming.retention_days') || '90', 10),
        dustThresholdUsd: parseFloat(ss.get('incoming.suspicious_dust_usd') || '0.01'),
        amountMultiplier: parseFloat(ss.get('incoming.suspicious_amount_multiplier') || '10'),
        cooldownMinutes: parseInt(ss.get('incoming.cooldown_minutes') || '5', 10),
      };
      // subscriberFactory creates chain-specific subscribers using adapterPool for RPC URLs
      const subscriberFactory = async (chain: string, network: string) => {
        const ss = this._settingsService!;
        if (chain === 'solana') {
          const rpcKey = `rpc.solana_${network}`;
          const rpcUrl = ss.get(rpcKey);
          // WSS URL: derive from RPC URL (replace https:// with wss://)
          const wssUrl = rpcUrl.replace(/^https:\/\//, 'wss://');
          const { SolanaIncomingSubscriber } = await import('@waiaas/adapters-solana');
          return new SolanaIncomingSubscriber(rpcUrl, wssUrl);
        }
        // EVM chains: ethereum, polygon, arbitrum, optimism, base
        const rpcKey = `rpc.evm_${chain}_${network.replace(/-/g, '_')}`;
        const rpcUrl = ss.get(rpcKey);
        const { EvmIncomingSubscriber } = await import('@waiaas/adapters-evm');
        return new EvmIncomingSubscriber(rpcUrl);
      };
      this.incomingTxMonitorService = new IncomingTxMonitorService({
        sqlite: this.sqlite,
        db: this.drizzleDb!,
        workers: this.workers,
        eventBus: this.eventBus,
        killSwitchService: this.killSwitchService,
        notificationService: this.notificationService,
        subscriberFactory,
        config: monitorConfig,
      });
      await this.incomingTxMonitorService.start();
      console.debug('Step 4c-9: Incoming TX monitor started');
    } else {
      console.debug('Step 4c-9: Incoming TX monitor disabled');
    }
  }
} catch (err) {
  console.warn('Step 4c-9 (fail-soft): Incoming TX monitor init warning:', err);
  this.incomingTxMonitorService = null;
}
```

4. **Shutdown step** -- add in the shutdown sequence, after Step 6a (before EventBus cleanup):
```typescript
// Stop IncomingTxMonitorService (final flush + destroy subscribers)
if (this.incomingTxMonitorService) {
  await this.incomingTxMonitorService.stop();
  this.incomingTxMonitorService = null;
}
```

5. **Pass to HotReloadOrchestrator** -- in the section where HotReloadOrchestrator is created, add `incomingTxMonitorService: this.incomingTxMonitorService` to the deps.

**C. HotReloadOrchestrator (hot-reload.ts):**

1. Add to `HotReloadDeps` interface:
```typescript
incomingTxMonitorService?: { updateConfig: (config: Partial<any>) => void } | null;
```
(Use duck-typed interface to avoid circular imports)

2. Add key prefix constant:
```typescript
const INCOMING_KEYS_PREFIX = 'incoming.';
```

3. In `handleChangedKeys()`, add detection + reload:
```typescript
const hasIncomingChanges = changedKeys.some((k) => k.startsWith(INCOMING_KEYS_PREFIX));

if (hasIncomingChanges) {
  try {
    this.reloadIncomingMonitor();
  } catch (err) {
    console.warn('Hot-reload incoming monitor failed:', err);
  }
}
```

4. Add `reloadIncomingMonitor()` private method:
```typescript
private reloadIncomingMonitor(): void {
  const svc = this.deps.incomingTxMonitorService;
  if (!svc) return;
  const ss = this.deps.settingsService;
  svc.updateConfig({
    enabled: ss.get('incoming.enabled') === 'true',
    pollIntervalSec: parseInt(ss.get('incoming.poll_interval') || '30', 10),
    retentionDays: parseInt(ss.get('incoming.retention_days') || '90', 10),
    dustThresholdUsd: parseFloat(ss.get('incoming.suspicious_dust_usd') || '0.01'),
    amountMultiplier: parseFloat(ss.get('incoming.suspicious_amount_multiplier') || '10'),
    cooldownMinutes: parseInt(ss.get('incoming.cooldown_minutes') || '5', 10),
  });
  console.log('Hot-reload: Incoming TX monitor config updated');
}
```
  </action>
  <verify>
    pnpm turbo run typecheck --filter=@waiaas/daemon && pnpm turbo run lint --filter=@waiaas/daemon
  </verify>
  <done>
    DaemonLifecycle Step 4c-9 initializes IncomingTxMonitorService with fail-soft pattern, shutdown performs stop(), HotReloadOrchestrator handles incoming.* key changes
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
2. `pnpm vitest run packages/daemon/src/services/incoming/__tests__/` -- all tests pass
3. `pnpm turbo run lint --filter=@waiaas/daemon` passes
4. DaemonLifecycle has Step 4c-9 with try/catch fail-soft pattern
5. Shutdown sequence stops IncomingTxMonitorService before EventBus cleanup
6. HotReloadOrchestrator handles incoming.* key prefix
</verification>

<success_criteria>
- 3 safety rules correctly flag dust, unknown token, and large amount transactions
- IncomingTxMonitorService orchestrates queue + multiplexer + workers + events + notifications
- EventBus emits transaction:incoming and transaction:incoming:suspicious
- KillSwitch SUSPENDED/LOCKED suppresses notifications, not DB writes or events
- Notification cooldown prevents spam within configured window
- DaemonLifecycle Step 4c-9 uses fail-soft pattern (try/catch, null fallback)
- Graceful shutdown drains queue before destroying connections
</success_criteria>

<output>
After completion, create `.planning/phases/226-monitor-service-resilience/226-04-SUMMARY.md`
</output>
