---
phase: 230-integration-wiring-fixes
plan: 02
type: execute
wave: 2
depends_on: [230-01]
files_modified:
  - packages/daemon/src/services/incoming/__tests__/integration-wiring.test.ts
autonomous: true
requirements: [SUB-02, SUB-03, SUB-04, SUB-05, STO-02, STO-03, STO-05, CFG-04]
gap_closure: true

must_haves:
  truths:
    - "Integration test proves monitor's 6 workers are registered to the same BackgroundWorkers instance passed via deps"
    - "Integration test proves polling worker handlers invoke subscriber.pollAll() for both solana and ethereum chains"
    - "Integration test proves onGapRecovery invokes createGapRecoveryHandler which calls subscriber.pollAll()"
    - "All new tests pass alongside existing test suites"
  artifacts:
    - path: "packages/daemon/src/services/incoming/__tests__/integration-wiring.test.ts"
      provides: "Integration tests for BUG-1, BUG-2, BUG-3 fixes"
      min_lines: 100
  key_links:
    - from: "integration-wiring.test.ts"
      to: "IncomingTxMonitorService"
      via: "imports and instantiates with mock deps, verifies worker registration and handler behavior"
      pattern: "IncomingTxMonitorService"
---

<objective>
Create integration tests that verify the 3 bug fixes from Plan 01 work correctly when components are wired together.

Purpose: The audit found these bugs because individual unit tests passed but the cross-component wiring was broken. These integration tests prevent regression by testing the exact wiring paths: shared BackgroundWorkers instance, polling worker handlers calling pollAll(), and gap recovery callback invoking createGapRecoveryHandler.
Output: New integration test file with tests covering all 3 bug fixes.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/230-integration-wiring-fixes/230-01-SUMMARY.md
@packages/daemon/src/services/incoming/__tests__/integration-pitfall.test.ts
@packages/daemon/src/services/incoming/__tests__/integration-resilience.test.ts
@packages/daemon/src/services/incoming/__tests__/incoming-tx-monitor-service.test.ts
@packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
@packages/daemon/src/services/incoming/subscription-multiplexer.ts
@packages/daemon/src/services/incoming/incoming-tx-workers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration-wiring.test.ts with tests for BUG-1, BUG-2, BUG-3 fixes</name>
  <files>
    packages/daemon/src/services/incoming/__tests__/integration-wiring.test.ts
  </files>
  <action>
Create a new test file at `packages/daemon/src/services/incoming/__tests__/integration-wiring.test.ts`.

Follow the exact test patterns from existing integration test files (`integration-pitfall.test.ts`, `integration-resilience.test.ts`):
- Mock `generateId` via `vi.mock('../../../infrastructure/database/id.js', ...)`
- Use `createMockSqlite()` that returns empty `[]` from `prepare().all()` (wallet loading)
- Use mock subscriber factory that returns subscribers with `pollAll: vi.fn()`, `connect: vi.fn()`, `subscribe: vi.fn()`, `unsubscribe: vi.fn()`, `waitForDisconnect: vi.fn()`, `destroy: vi.fn()`
- Use mock workers, eventBus, killSwitch, notificationService (copy patterns from existing tests)

**Test Group 1: BUG-1 BackgroundWorkers Instance Sharing**

Test: "monitor service registers workers to the provided BackgroundWorkers instance"
- Create a mock BackgroundWorkers with `register: vi.fn()`, `startAll: vi.fn()`, `stopAll: vi.fn()`
- Create IncomingTxMonitorService with this mock workers instance
- Call `service.start()`
- Assert `workers.register` was called exactly 6 times
- Assert the names: 'incoming-tx-flush', 'incoming-tx-retention', 'incoming-tx-confirm-solana', 'incoming-tx-confirm-evm', 'incoming-tx-poll-solana', 'incoming-tx-poll-evm'
- This proves that if daemon passes its shared BackgroundWorkers, all 6 workers get registered to it

Test: "all registered worker handlers are callable functions"
- Create IncomingTxMonitorService, call start()
- Extract the handler functions from `workers.register.mock.calls`
- For each of the 6 handlers, assert `typeof handler === 'function'`
- Call each handler and assert it does not throw

**Test Group 2: BUG-2 Polling Worker Handlers**

Test: "Solana polling worker calls pollAll() on solana subscribers"
- Create IncomingTxMonitorService with a subscriberFactory that returns a mock subscriber with `pollAll: vi.fn()`
- Call start() with sqlite returning one wallet `{ id: 'w1', chain: 'solana', network: 'mainnet', public_key: 'pk1' }`
- Extract Worker 5 ('incoming-tx-poll-solana') handler from workers.register.mock.calls
- Call the handler
- Assert `subscriber.pollAll()` was called

Test: "EVM polling worker calls pollAll() on ethereum subscribers"
- Same setup but with wallet `{ chain: 'ethereum', network: 'mainnet' }`
- Extract Worker 6 ('incoming-tx-poll-evm') handler
- Call the handler
- Assert `subscriber.pollAll()` was called

Test: "polling worker handles subscriber.pollAll() errors gracefully"
- Setup subscriber with `pollAll: vi.fn().mockRejectedValue(new Error('RPC timeout'))`
- Extract polling worker handler and call it
- Assert no exception is thrown (error is caught and logged)
- Use `vi.spyOn(console, 'warn')` to verify warning is logged

**Test Group 3: BUG-3 Gap Recovery Wiring**

Test: "onGapRecovery invokes createGapRecoveryHandler which calls subscriber.pollAll()"
- Create IncomingTxMonitorService with subscriberFactory returning mock subscriber
- Call start() with sqlite returning a wallet `{ chain: 'solana', network: 'mainnet', ... }`
- Access the multiplexer's onGapRecovery callback (via `(service as any).multiplexer.deps.onGapRecovery` -- the deps field is stored on SubscriptionMultiplexer as `this.deps`)
- OR: Better approach -- access through the multiplexer's internal state by triggering a simulated reconnect scenario. But since we just need to test the callback, extract it from the constructor.
- Actually the simplest approach: the `onGapRecovery` is the callback passed to SubscriptionMultiplexer constructor. We can test it by accessing `(service as any).multiplexer` and examining its deps.
- Call `onGapRecovery('solana', 'mainnet', ['w1'])`
- Assert `subscriber.pollAll()` was called (via createGapRecoveryHandler which calls `entry.subscriber.pollAll()`)

Test: "onGapRecovery handles missing chain:network gracefully"
- Setup with only solana subscribers
- Call onGapRecovery for 'ethereum', 'mainnet' (no subscriber exists for this key)
- Assert no error is thrown (createGapRecoveryHandler gracefully skips missing entries)

**Important test implementation notes:**
- The `SubscriptionMultiplexer` stores `deps` as `private readonly deps`. To access `onGapRecovery`, use `(service as any).multiplexer` to get the multiplexer, then test indirectly.
- Since the multiplexer's `deps` is private, the cleanest approach is: after `service.start()` with a wallet, get the multiplexer via `(service as any).multiplexer`, then use the NEW `getSubscriberEntries()` method to verify subscribers exist, and manually invoke the gap recovery path.
- Alternatively, the `onGapRecovery` callback closure accesses `this.multiplexer` (the service's own field). We can test end-to-end by:
  1. Starting the service (wallet gets subscribed via multiplexer.addWallet)
  2. Getting the gap recovery callback: The multiplexer is created with onGapRecovery as a dep. We can access it via `(multiplexer as any).deps.onGapRecovery`.
  3. Calling it and verifying pollAll() was invoked.
  </action>
  <verify>
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- integration-wiring`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- incoming`
    All tests pass (new and existing).
  </verify>
  <done>
    1. `integration-wiring.test.ts` exists with tests covering all 3 bug fixes
    2. BUG-1 tests verify workers register to provided instance (6 registrations)
    3. BUG-2 tests verify polling workers invoke subscriber.pollAll() for solana and ethereum
    4. BUG-3 tests verify onGapRecovery wires through createGapRecoveryHandler to subscriber.pollAll()
    5. All tests pass alongside existing test suites
  </done>
</task>

</tasks>

<verification>
1. `pnpm vitest run --project daemon -- integration-wiring` -- all new tests pass
2. `pnpm vitest run --project daemon -- incoming` -- all incoming tests pass (existing + new)
3. `pnpm turbo run typecheck --filter=@waiaas/daemon` -- no type errors
4. Test count: at least 7 new tests covering the 3 bug fixes
</verification>

<success_criteria>
- New integration test file with 7+ tests covering BUG-1, BUG-2, BUG-3
- All new tests pass
- All existing tests continue to pass
- No typecheck errors
</success_criteria>

<output>
After completion, create `.planning/phases/230-integration-wiring-fixes/230-02-SUMMARY.md`
</output>
