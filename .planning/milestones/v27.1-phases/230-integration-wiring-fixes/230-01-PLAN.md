---
phase: 230-integration-wiring-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/daemon/src/lifecycle/daemon.ts
  - packages/daemon/src/services/incoming/subscription-multiplexer.ts
  - packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
autonomous: true
requirements: [SUB-02, SUB-03, SUB-04, SUB-05, STO-02, STO-03, STO-05, CFG-04]
gap_closure: true

must_haves:
  truths:
    - "IncomingTxMonitorService's 6 workers are registered to the daemon's shared BackgroundWorkers instance and start via startAll()"
    - "Polling worker 5 (Solana) calls subscriber.pollAll() via multiplexer getSubscribersForChain('solana')"
    - "Polling worker 6 (EVM) calls subscriber.pollAll() via multiplexer getSubscribersForChain('ethereum') -- the ONLY EVM detection path"
    - "onGapRecovery callback wires createGapRecoveryHandler via multiplexer.getSubscriberEntries()"
    - "All existing unit and integration tests pass without modification"
  artifacts:
    - path: "packages/daemon/src/lifecycle/daemon.ts"
      provides: "BackgroundWorkers created BEFORE Step 4c-9; removed from Step 6"
      contains: "this.workers = new BackgroundWorkers()"
    - path: "packages/daemon/src/services/incoming/subscription-multiplexer.ts"
      provides: "Two accessor methods for subscriber access"
      exports: ["getSubscribersForChain", "getSubscriberEntries"]
    - path: "packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts"
      provides: "Filled polling worker handlers + wired gap recovery callback"
      contains: "createGapRecoveryHandler"
  key_links:
    - from: "daemon.ts Step 4c-9"
      to: "this.workers (BackgroundWorkers)"
      via: "same shared instance passed to IncomingTxMonitorService"
      pattern: "workers: this\\.workers"
    - from: "incoming-tx-monitor-service.ts Worker 5/6"
      to: "SubscriptionMultiplexer.getSubscribersForChain()"
      via: "polling worker handlers call multiplexer accessor"
      pattern: "getSubscribersForChain"
    - from: "incoming-tx-monitor-service.ts onGapRecovery"
      to: "createGapRecoveryHandler + multiplexer.getSubscriberEntries()"
      via: "closure captures this.multiplexer, invokes handler"
      pattern: "createGapRecoveryHandler"
---

<objective>
Fix 3 cross-phase integration bugs (BUG-1 BackgroundWorkers orphan, BUG-2 empty polling workers, BUG-3 gap recovery stub) by wiring existing, tested components together at the daemon lifecycle level.

Purpose: All individual components are implemented and unit-tested. These are purely wiring fixes -- connecting existing pieces so the 8 partial requirements become satisfied and 3 broken E2E flows are restored.
Output: 3 modified source files with all integration wiring complete.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/230-integration-wiring-fixes/230-RESEARCH.md
@packages/daemon/src/lifecycle/daemon.ts
@packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
@packages/daemon/src/services/incoming/subscription-multiplexer.ts
@packages/daemon/src/services/incoming/incoming-tx-workers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix BUG-1 BackgroundWorkers + BUG-2 multiplexer accessor + BUG-3 gap recovery wiring</name>
  <files>
    packages/daemon/src/lifecycle/daemon.ts
    packages/daemon/src/services/incoming/subscription-multiplexer.ts
    packages/daemon/src/services/incoming/incoming-tx-monitor-service.ts
  </files>
  <action>
**BUG-1: daemon.ts -- Move BackgroundWorkers creation before Step 4c-9**

1. In `daemon.ts`, find Step 4c-9 (around line 788). BEFORE the `try` block that starts Step 4c-9, add:
   ```typescript
   // Pre-create BackgroundWorkers so Step 4c-9 (incoming monitor) can register its workers.
   // startAll() is still called in Step 6 after all workers are registered.
   if (!this.workers) {
     this.workers = new BackgroundWorkers();
   }
   ```

2. In Step 4c-9 (line 791), the `workers: this.workers ?? new BackgroundWorkers()` will now always use `this.workers` (no orphan).

3. In Step 6 (around line 996), REMOVE the line `this.workers = new BackgroundWorkers();`. The workers instance already exists. Keep all the daemon worker registrations (wal-checkpoint, session-cleanup, delay-expired, approval-expired, version-check) and the `this.workers.startAll()` call. The startAll() now starts ALL workers -- both daemon's own workers AND the monitor's 6 workers.

**CRITICAL: Do NOT call startAll() twice.** It must be called exactly once at Step 6 after ALL registrations are complete. The monitor's `start()` method calls `registerWorkers()` which calls `this.workers.register(...)` 6 times. These register calls happen at Step 4c-9. Then Step 6 registers daemon's own workers and calls startAll(). All workers start.

**BUG-2: subscription-multiplexer.ts -- Add accessor methods**

4. In `SubscriptionMultiplexer` class (after the `getActiveConnections()` method, around line 201), add TWO accessor methods:

   ```typescript
   /**
    * Get subscriber entries for gap recovery.
    * Returns a read-only view compatible with createGapRecoveryHandler deps.
    *
    * Note: pollAll() is not part of IChainSubscriber interface but
    * exists on both SolanaIncomingSubscriber and EvmIncomingSubscriber.
    * The returned type uses structural typing to express this.
    */
   getSubscriberEntries(): Map<string, { subscriber: { pollAll: () => Promise<void> } }> {
     return this.connections as unknown as Map<
       string,
       { subscriber: { pollAll: () => Promise<void> } }
     >;
   }

   /**
    * Get subscribers for a specific chain prefix (e.g., "solana", "ethereum").
    * Used by polling workers to iterate chain-specific subscribers.
    */
   getSubscribersForChain(chainPrefix: string): Array<{
     key: string;
     subscriber: IChainSubscriber;
   }> {
     const result: Array<{
       key: string;
       subscriber: IChainSubscriber;
     }> = [];
     for (const [key, entry] of this.connections) {
       if (key.startsWith(`${chainPrefix}:`)) {
         result.push({ key, subscriber: entry.subscriber });
       }
     }
     return result;
   }
   ```

**BUG-2: incoming-tx-monitor-service.ts -- Fill polling worker handlers**

5. Replace Worker 5 handler (lines 440-444) with:
   ```typescript
   handler: async () => {
     const entries = this.multiplexer.getSubscribersForChain('solana');
     for (const { subscriber } of entries) {
       try {
         await (subscriber as unknown as { pollAll(): Promise<void> }).pollAll();
       } catch (err) {
         console.warn('Solana polling worker error:', err);
       }
     }
   },
   ```

6. Replace Worker 6 handler (lines 450-453) with:
   ```typescript
   handler: async () => {
     const entries = this.multiplexer.getSubscribersForChain('ethereum');
     for (const { subscriber } of entries) {
       try {
         await (subscriber as unknown as { pollAll(): Promise<void> }).pollAll();
       } catch (err) {
         console.warn('EVM polling worker error:', err);
       }
     }
   },
   ```

**BUG-3: incoming-tx-monitor-service.ts -- Wire gap recovery**

7. Add `createGapRecoveryHandler` to the existing import from `./incoming-tx-workers.js` (line 30-34):
   ```typescript
   import {
     createConfirmationWorkerHandler,
     createRetentionWorkerHandler,
     createGapRecoveryHandler,
     updateCursor,
   } from './incoming-tx-workers.js';
   ```

8. Replace the `onGapRecovery` callback (lines 124-136) in the `start()` method:
   ```typescript
   onGapRecovery: async (
     chain: string,
     network: string,
     walletIds: string[],
   ) => {
     // Wire to createGapRecoveryHandler using multiplexer's subscriber access.
     // this.multiplexer is captured via closure on 'this' -- safe because
     // onGapRecovery is never called during construction (only on reconnect).
     const handler = createGapRecoveryHandler({
       subscribers: this.multiplexer.getSubscriberEntries(),
     });
     await handler(chain, network, walletIds);
   },
   ```
  </action>
  <verify>
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/daemon`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run lint --filter=@waiaas/daemon`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- incoming-tx-monitor-service`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- subscription-multiplexer`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- integration-pitfall`
    Run: `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm vitest run --project daemon -- integration-resilience`
    All must pass.
  </verify>
  <done>
    1. daemon.ts: `this.workers` is created before Step 4c-9 and Step 6 no longer creates a new instance -- `this.workers ?? new BackgroundWorkers()` always uses the shared instance.
    2. subscription-multiplexer.ts: `getSubscriberEntries()` returns connections Map typed for gap recovery deps; `getSubscribersForChain(prefix)` returns filtered subscriber array.
    3. incoming-tx-monitor-service.ts: Worker 5/6 handlers call subscriber.pollAll() via multiplexer; onGapRecovery wired to createGapRecoveryHandler.
    4. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck` -- no type errors in daemon package
2. `pnpm turbo run lint` -- no lint errors
3. All existing tests pass (unit + integration):
   - incoming-tx-monitor-service.test.ts
   - incoming-tx-workers.test.ts
   - incoming-tx-queue.test.ts
   - subscription-multiplexer.test.ts
   - integration-pitfall.test.ts
   - integration-resilience.test.ts
4. Code inspection confirms:
   - daemon.ts: `this.workers` created before Step 4c-9, not re-created in Step 6
   - subscription-multiplexer.ts: two new public methods exported
   - incoming-tx-monitor-service.ts: Worker 5/6 handlers non-empty, createGapRecoveryHandler imported and wired
</verification>

<success_criteria>
- BUG-1 FIXED: BackgroundWorkers instance shared between daemon and monitor service
- BUG-2 FIXED: Polling workers call subscriber.pollAll() via multiplexer
- BUG-3 FIXED: onGapRecovery wired to createGapRecoveryHandler
- All existing tests pass
- No typecheck or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/230-integration-wiring-fixes/230-01-SUMMARY.md`
</output>
