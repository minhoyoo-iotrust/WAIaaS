---
phase: 222-design-critical-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/design/76-incoming-transaction-monitoring.md
autonomous: true
requirements:
  - GAP-1
  - GAP-4

must_haves:
  truths:
    - "IChainSubscriber 인터페이스가 6개 메서드(subscribe, unsubscribe, subscribedWallets, connect, waitForDisconnect, destroy)를 포함한다"
    - "SolanaIncomingSubscriber에 connect()/waitForDisconnect() 구현이 명세되어 있다"
    - "EvmIncomingSubscriber에 no-op connect()/waitForDisconnect() 구현이 명세되어 있다"
    - "§2.6 flush 후 이벤트가 개별 TX마다 IncomingTxEvent 페이로드로 발행된다"
    - "WaiaasEventMap에 'incoming:flush:complete' 내부 이벤트가 정의되어 있다"
  artifacts:
    - path: "docs/design/76-incoming-transaction-monitoring.md"
      provides: "GAP-1, GAP-4 수정된 설계 문서"
      contains: "connect(): Promise<void>"
  key_links:
    - from: "§1.4 IChainSubscriber"
      to: "§5.2 reconnectLoop"
      via: "connect()/waitForDisconnect() 메서드 호출"
      pattern: "subscriber.connect\\(\\)"
    - from: "§2.6 flush 이벤트"
      to: "§6.1 WaiaasEventMap"
      via: "eventBus.emit('transaction:incoming', IncomingTxEvent)"
      pattern: "transaction:incoming.*IncomingTxEvent"
---

<objective>
IChainSubscriber 인터페이스에 connect()/waitForDisconnect() 메서드를 추가하고, eventBus.emit 타입 충돌을 해결한다.

Purpose: §5.2 reconnectLoop이 호출하는 connect()/waitForDisconnect()가 IChainSubscriber에 정의되지 않은 GAP-1 문제와, §2.6 flush 이벤트 페이로드가 §6.1 IncomingTxEvent 타입과 불일치하는 GAP-4 문제를 수정하여 인터페이스/타입 계층의 일관성을 확보한다.
Output: docs/design/76-incoming-transaction-monitoring.md 내 §1.4, §3.7, §4.7, §2.6, §6.1 섹션이 수정됨
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/222-design-critical-fix/222-RESEARCH.md
@docs/design/76-incoming-transaction-monitoring.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: IChainSubscriber 인터페이스에 connect()/waitForDisconnect() 추가 + 구현체 반영</name>
  <files>docs/design/76-incoming-transaction-monitoring.md</files>
  <action>
GAP-1 수정: IChainSubscriber 인터페이스(§1.4)와 두 구현체(§3.7, §4.7)를 수정한다.

**§1.4 IChainSubscriber (L91-127 부근):**
기존 4개 메서드(subscribe, unsubscribe, subscribedWallets, destroy) 사이에 connect()와 waitForDisconnect()를 추가하여 6개 메서드로 확장한다. destroy() 바로 위에 추가:

```typescript
  /**
   * WebSocket 연결 시작. 폴링 전용 구현체는 즉시 resolve (no-op).
   * reconnectLoop(§5.2)에서 호출.
   */
  connect(): Promise<void>;

  /**
   * WebSocket 연결 끊김 대기. 연결 중단 시 resolve.
   * 폴링 전용 구현체는 never-resolving Promise 반환.
   * reconnectLoop(§5.2)에서 호출.
   */
  waitForDisconnect(): Promise<void>;
```

**§3.7 SolanaIncomingSubscriber (L631-702 부근):**
`destroy()` 메서드 위에 다음 2개 메서드를 추가:

```typescript
  async connect(): Promise<void> {
    // WebSocket 연결 시작: wsUrl에 연결 후 구독 중인 모든 지갑에 대해
    // logsSubscribe({ mentions }) 재등록
    // 실패 시 throw → reconnectLoop가 catch하여 재시도
  }

  async waitForDisconnect(): Promise<void> {
    // WebSocket 연결 종료 시 resolve하는 Promise 반환
    // AbortController.signal 또는 WebSocket 'close' 이벤트로 감지
    return new Promise((resolve) => {
      this.ws?.addEventListener('close', () => resolve(), { once: true });
    });
  }
```

**§4.7 EvmIncomingSubscriber (L925-1013 부근):**
`destroy()` 메서드 위에 다음 2개 no-op 메서드를 추가:

```typescript
  /** 폴링 전용: no-op (즉시 resolve) */
  async connect(): Promise<void> {
    // EVM은 폴링 우선(D-06) — WebSocket 연결 불필요
  }

  /** 폴링 전용: never-resolving Promise (폴링 모드에서 reconnectLoop 블록 방지) */
  async waitForDisconnect(): Promise<void> {
    // 영원히 resolve하지 않음 — reconnectLoop가 EVM에 대해서는
    // connect() 즉시 성공 → waitForDisconnect()에서 무한 대기
    // → WebSocket 실패/폴링 전환이 필요 없는 구조
    return new Promise(() => {});
  }
```

주의: 인터페이스 메서드가 6개를 초과하지 않도록 한다. connect, waitForDisconnect 외 다른 메서드를 추가하지 않는다.
  </action>
  <verify>
docs/design/76-incoming-transaction-monitoring.md에서 다음을 확인:
1. §1.4 IChainSubscriber 블록에 connect(), waitForDisconnect() 시그니처가 존재
2. §3.7 SolanaIncomingSubscriber에 connect(), waitForDisconnect() 구현이 존재
3. §4.7 EvmIncomingSubscriber에 no-op connect(), waitForDisconnect() 구현이 존재
4. §5.2 reconnectLoop의 subscriber.connect() / subscriber.waitForDisconnect() 호출이 §1.4 인터페이스와 일치
5. 인터페이스 메서드가 정확히 6개 (subscribe, unsubscribe, subscribedWallets, connect, waitForDisconnect, destroy)
  </verify>
  <done>IChainSubscriber가 6메서드 인터페이스로 확장되고, Solana/EVM 구현체 모두 connect()/waitForDisconnect()를 포함하여 §5.2 reconnectLoop과 일관됨</done>
</task>

<task type="auto">
  <name>Task 2: eventBus.emit 타입 통일 + WaiaasEventMap 내부 이벤트 추가</name>
  <files>docs/design/76-incoming-transaction-monitoring.md</files>
  <action>
GAP-4 수정: §2.6 flush 이벤트와 §6.1 WaiaasEventMap의 타입 불일치를 해결한다.

**§2.6 flush 패턴 (L276-318 부근):**
기존 `flush()` 메서드의 반환 타입을 `number`에서 `IncomingTransaction[]`로 변경하고, BackgroundWorkers 등록 코드를 수정한다.

기존:
```typescript
flush(sqlite: Database): number {
  // ... return insertMany(batch);
```

수정 후:
```typescript
flush(sqlite: Database): IncomingTransaction[] {
  if (this.queue.length === 0) return [];
  const batch = this.queue.splice(0, this.MAX_BATCH);
  // ... INSERT 로직 ...
  return insertedTxs; // 실제 삽입된 TX 목록 반환 (ON CONFLICT로 무시된 것 제외)
}
```

BackgroundWorkers 등록 코드를 다음으로 교체:
```typescript
workers.register('incoming-tx-flush', {
  interval: 5_000, // 5초마다
  handler: () => {
    const inserted = incomingTxQueue.flush(sqlite);

    // 개별 TX에 대해 이벤트 발행 (§6.1 IncomingTxEvent 타입 일치)
    for (const tx of inserted) {
      eventBus.emit('transaction:incoming', {
        walletId: tx.walletId,
        txHash: tx.txHash,
        fromAddress: tx.fromAddress,
        amount: tx.amount,
        tokenAddress: tx.tokenAddress,
        chain: tx.chain,
        network: tx.network,
        detectedAt: tx.detectedAt,
      } satisfies IncomingTxEvent);
    }

    // 내부 오케스트레이션용 집계 이벤트 (옵저버빌리티/로깅)
    if (inserted.length > 0) {
      eventBus.emit('incoming:flush:complete', { count: inserted.length });
    }
  },
});
```

**§6.1 WaiaasEventMap (L1389-1393 부근):**
WaiaasEventMap에 내부 이벤트 타입을 추가한다.

기존:
```typescript
export interface WaiaasEventMap {
  // ... 기존 이벤트 ...
  'transaction:incoming': IncomingTxEvent;
  'transaction:incoming:suspicious': IncomingSuspiciousTxEvent;
}
```

수정 후:
```typescript
export interface WaiaasEventMap {
  // ... 기존 이벤트 ...
  'transaction:incoming': IncomingTxEvent;
  'transaction:incoming:suspicious': IncomingSuspiciousTxEvent;

  // 내부 오케스트레이션 이벤트 (알림 트리거 아님)
  'incoming:flush:complete': { count: number };
}
```

주의사항:
- `'transaction:incoming'` 이벤트명은 변경하지 않는다 (알림 트리거용).
- flush의 `{ count }` 집계는 별도 이벤트명(`'incoming:flush:complete'`)으로 분리.
- §6.4 알림 연동이 `'transaction:incoming'` 을 리스닝하므로 이 이벤트명은 유지해야 한다.
  </action>
  <verify>
docs/design/76-incoming-transaction-monitoring.md에서 다음을 확인:
1. §2.6의 eventBus.emit이 `'transaction:incoming'`에 IncomingTxEvent 페이로드를 개별 TX마다 발행
2. §2.6에 `'incoming:flush:complete'` 집계 이벤트가 별도로 발행
3. §6.1 WaiaasEventMap에 `'incoming:flush:complete': { count: number }` 타입이 추가
4. §2.6의 flush 반환 타입이 `IncomingTransaction[]`
5. `'transaction:incoming'` 이벤트의 페이로드 타입이 §6.1의 IncomingTxEvent와 정확히 일치
  </verify>
  <done>§2.6 flush 이벤트가 개별 TX마다 IncomingTxEvent를 발행하고, 집계 이벤트가 'incoming:flush:complete'로 분리되어 §6.1 WaiaasEventMap과 완전히 일치함</done>
</task>

</tasks>

<verification>
GAP-1 검증:
- §1.4 IChainSubscriber에 connect(), waitForDisconnect() 시그니처 존재 확인
- §3.7 SolanaIncomingSubscriber에 WebSocket 연결 시작/종료 대기 구현 존재 확인
- §4.7 EvmIncomingSubscriber에 no-op 구현 존재 확인
- §5.2 reconnectLoop의 subscriber.connect()/waitForDisconnect() 호출이 §1.4와 일치 확인

GAP-4 검증:
- §2.6 flush 후 이벤트 페이로드 필드가 §6.1 IncomingTxEvent 필드와 1:1 대응 확인
- §6.1 WaiaasEventMap에 'incoming:flush:complete' 추가 확인
- §2.6의 flush 반환 타입이 IncomingTransaction[] 확인
</verification>

<success_criteria>
1. IChainSubscriber 인터페이스가 정확히 6개 메서드를 가진다
2. SolanaIncomingSubscriber/EvmIncomingSubscriber 모두 connect()/waitForDisconnect()를 구현한다
3. §5.2 reconnectLoop이 호출하는 메서드가 §1.4 인터페이스에 모두 존재한다
4. §2.6 eventBus.emit('transaction:incoming') 페이로드가 §6.1 IncomingTxEvent와 타입 일치한다
5. WaiaasEventMap에 'incoming:flush:complete' 내부 이벤트가 추가되었다
</success_criteria>

<output>
After completion, create `.planning/phases/222-design-critical-fix/222-01-SUMMARY.md`
</output>
