---
phase: 233-db-migration-schema-policy
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/schemas/policy.schema.ts
  - packages/daemon/src/pipeline/database-policy-engine.ts
autonomous: true
requirements:
  - PLCY-01
  - PLCY-02
  - PLCY-03
  - PLCY-04

must_haves:
  truths:
    - "ALLOWED_TOKENS policy rules accept optional assetId field per token entry"
    - "Scenario 1: Policy assetId + TX assetId -> exact CAIP-19 string match"
    - "Scenario 2: Policy assetId + TX address only -> extract address from policy assetId, compare lowercase"
    - "Scenario 3: Policy address only + TX assetId -> extract address from TX assetId, compare lowercase"
    - "Scenario 4: Policy address only + TX address only -> current behavior (unchanged)"
    - "EVM addresses normalized to lowercase for comparison (PLCY-04)"
    - "Existing ALLOWED_TOKENS policies without assetId work identically"
  artifacts:
    - path: "packages/core/src/schemas/policy.schema.ts"
      provides: "AllowedTokensRulesSchema with optional assetId per token"
      contains: "assetId"
    - path: "packages/daemon/src/pipeline/database-policy-engine.ts"
      provides: "4-scenario evaluateAllowedTokens matching + updated TransactionParam and AllowedTokensRules"
      contains: "parseCaip19"
  key_links:
    - from: "packages/daemon/src/pipeline/database-policy-engine.ts"
      to: "@waiaas/core parseCaip19()"
      via: "import for address extraction from CAIP-19 in scenarios 2 and 3"
      pattern: "parseCaip19\\("
    - from: "packages/core/src/schemas/policy.schema.ts"
      to: "@waiaas/core caip/caip19.ts"
      via: "imports Caip19Schema for assetId validation"
      pattern: "Caip19Schema\\.optional"
---

<objective>
Extend ALLOWED_TOKENS policy rules to accept optional assetId per token entry and implement the 4-scenario policy matching matrix in evaluateAllowedTokens(), enabling chain-aware token policy enforcement.

Purpose: Allow policy administrators to use CAIP-19 identifiers in ALLOWED_TOKENS rules, enabling disambiguation of same-address tokens on different chains (e.g., USDC on Ethereum vs Polygon). All 4 combinations of assetId/address-only must match correctly for backward compatibility.

Output: Updated AllowedTokensRulesSchema, updated AllowedTokensRules interface, 4-scenario evaluateAllowedTokens() implementation.
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/233-db-migration-schema-policy/233-RESEARCH.md
@packages/core/src/schemas/policy.schema.ts
@packages/daemon/src/pipeline/database-policy-engine.ts
@packages/core/src/caip/caip19.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AllowedTokensRulesSchema assetId extension</name>
  <files>
    packages/core/src/schemas/policy.schema.ts
  </files>
  <action>
**Import addition:**

Add import for Caip19Schema at the top of the file:
```typescript
import { Caip19Schema } from '../caip/index.js';
```

**AllowedTokensRulesSchema update (line 23-29):**

Add optional `assetId` field to the token entry object within the `tokens` array:
```typescript
/** ALLOWED_TOKENS: rules.tokens array (mint/contract addresses + optional CAIP-19). */
const AllowedTokensRulesSchema = z.object({
  tokens: z.array(z.object({
    address: z.string().min(1),
    symbol: z.string().min(1).max(10).optional(),
    chain: ChainTypeEnum.optional(),
    assetId: Caip19Schema.optional(),
  })).min(1, 'At least one token required'),
});
```

**Key constraint:** `address` remains required even when `assetId` is present. This ensures backward compatibility and allows the address-only path to always work. The `assetId` provides additional chain-level specificity when needed.

**No other changes needed in this file.** The `CreatePolicyRequestSchema` superRefine already delegates to `AllowedTokensRulesSchema` for validation, so the new field is automatically accepted in policy creation/update requests.
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/core` to verify the import resolves and types are correct. Verify that `AllowedTokensRulesSchema` includes `assetId: Caip19Schema.optional()` in its tokens array entry.
  </verify>
  <done>
AllowedTokensRulesSchema accepts optional assetId (validated as CAIP-19 format) per token entry. Existing policy rules without assetId continue to validate. CreatePolicyRequestSchema automatically inherits the change.
  </done>
</task>

<task type="auto">
  <name>Task 2: 4-scenario evaluateAllowedTokens + TransactionParam.assetId in policy engine</name>
  <files>
    packages/daemon/src/pipeline/database-policy-engine.ts
  </files>
  <action>
**Import addition at the top:**

Add import for `parseCaip19` from `@waiaas/core`:
```typescript
import { parseCaip19 } from '@waiaas/core';
```
Add this to the existing `@waiaas/core` import statement if one exists, or create a new import line.

**TransactionParam interface update (line ~111):**

Add optional `assetId` field to the local `TransactionParam` interface:
```typescript
interface TransactionParam {
  type: string;
  amount: string;
  toAddress: string;
  chain: string;
  network?: string;
  tokenAddress?: string;
  assetId?: string;       // NEW: CAIP-19 from transaction request token.assetId
  contractAddress?: string;
  selector?: string;
  spenderAddress?: string;
  approveAmount?: string;
}
```

**AllowedTokensRules interface update (line ~67-69):**

Add optional `assetId` to the token entry type:
```typescript
interface AllowedTokensRules {
  tokens: Array<{ address: string; assetId?: string }>;
}
```

**evaluateAllowedTokens method rewrite (lines ~892-939):**

Replace the existing implementation with the 4-scenario matching matrix. The method signature stays the same.

```typescript
private evaluateAllowedTokens(
  resolved: PolicyRow[],
  transaction: TransactionParam,
): PolicyEvaluation | null {
  // Only evaluate for TOKEN_TRANSFER transactions
  if (transaction.type !== 'TOKEN_TRANSFER') return null;

  const allowedTokensPolicy = resolved.find((p) => p.type === 'ALLOWED_TOKENS');

  // No ALLOWED_TOKENS policy -> check toggle, then deny (default deny)
  if (!allowedTokensPolicy) {
    if (this.settingsService?.get('policy.default_deny_tokens') === 'false') {
      return null; // default-allow mode: skip token whitelist check
    }
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: 'Token transfer not allowed: no ALLOWED_TOKENS policy configured',
    };
  }

  // Parse rules.tokens array
  const rules: AllowedTokensRules = JSON.parse(allowedTokensPolicy.rules);
  const txTokenAddress = transaction.tokenAddress;
  const txAssetId = transaction.assetId;

  if (!txTokenAddress && !txAssetId) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: 'Token transfer missing token address',
    };
  }

  // 4-scenario matching matrix (PLCY-03)
  const isAllowed = rules.tokens.some((policyToken) => {
    // Scenario 1: Both have assetId -> exact CAIP-19 string match
    // CAIP-19 strings are already normalized (EVM lowercase by tokenAssetId, Solana preserved)
    if (policyToken.assetId && txAssetId) {
      return policyToken.assetId === txAssetId;
    }

    // Scenario 2: Policy has assetId, TX has address only
    if (policyToken.assetId && txTokenAddress) {
      try {
        const policyAddr = parseCaip19(policyToken.assetId).assetReference;
        return policyAddr.toLowerCase() === txTokenAddress.toLowerCase();
      } catch {
        return false; // Invalid policy assetId -> no match
      }
    }

    // Scenario 3: Policy has address only, TX has assetId
    if (!policyToken.assetId && txAssetId) {
      try {
        const txAddr = parseCaip19(txAssetId).assetReference;
        return policyToken.address.toLowerCase() === txAddr.toLowerCase();
      } catch {
        return false; // Invalid TX assetId -> no match
      }
    }

    // Scenario 4: Both address only -> current behavior (case-insensitive)
    return policyToken.address.toLowerCase() === (txTokenAddress ?? '').toLowerCase();
  });

  if (!isAllowed) {
    return {
      allowed: false,
      tier: 'INSTANT',
      reason: `Token not in allowed list: ${txAssetId ?? txTokenAddress}`,
    };
  }

  return null; // Token is allowed, continue evaluation
}
```

**Key design decisions:**
- Scenario 1 uses exact string comparison (`===`) because CAIP-19 strings are already normalized: `tokenAssetId()` lowercases EVM addresses and preserves Solana base58 (PLCY-04).
- Scenarios 2 and 3 use `toLowerCase()` for extracted addresses to handle EVM checksummed address edge cases (PLCY-04).
- Each scenario has try/catch around `parseCaip19()` so invalid CAIP-19 strings don't crash the evaluator -- they simply don't match.
- Scenario 4 is unchanged from the original implementation.
- The denial reason includes `txAssetId` when available for better diagnostics.
  </action>
  <verify>
Run `pnpm turbo run typecheck --filter=@waiaas/daemon` to verify type correctness. Run `pnpm turbo run test --filter=@waiaas/daemon -- --grep "policy"` to verify existing policy evaluation tests pass. Manually verify all 4 scenarios are present in the `evaluateAllowedTokens()` method with correct matching logic.
  </verify>
  <done>
AllowedTokensRules interface includes optional assetId per token entry. TransactionParam includes optional assetId field. evaluateAllowedTokens implements all 4 scenarios of the matching matrix. EVM addresses are lowercased for comparison (PLCY-04). Existing policies without assetId use Scenario 4 (unchanged behavior). parseCaip19 errors are caught gracefully.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck --filter=@waiaas/core` passes
2. `pnpm turbo run typecheck --filter=@waiaas/daemon` passes
3. `pnpm turbo run test --filter=@waiaas/daemon -- --grep "policy"` passes
4. AllowedTokensRulesSchema has `assetId: Caip19Schema.optional()` in token entries
5. AllowedTokensRules interface has `assetId?: string` in token entries
6. TransactionParam has `assetId?: string` field
7. evaluateAllowedTokens has all 4 scenarios with comments identifying each
8. parseCaip19 errors handled gracefully in scenarios 2 and 3
9. Denial reason includes assetId when available
</verification>

<success_criteria>
- ALLOWED_TOKENS policy rules accept optional assetId per token entry (PLCY-01)
- Policy evaluation with assetId compares chain+network+address via CAIP-19 string matching (PLCY-02)
- All 4 scenarios of the matching matrix work correctly (PLCY-03)
- EVM addresses are normalized to lowercase for CAIP-19 comparison (PLCY-04)
- Existing ALLOWED_TOKENS policies without assetId continue to work identically (Scenario 4)
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/233-db-migration-schema-policy/233-03-SUMMARY.md`
</output>
