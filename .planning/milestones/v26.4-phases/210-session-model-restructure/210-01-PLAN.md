---
phase: 210-session-model-restructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/errors/error-codes.ts
  - packages/core/src/schemas/session.schema.ts
  - packages/daemon/src/infrastructure/database/schema.ts
  - packages/daemon/src/infrastructure/database/migrate.ts
  - packages/daemon/src/__tests__/schema-compatibility.test.ts
autonomous: true
requirements: [SESS-07, SESS-08, SESS-09]

must_haves:
  truths:
    - "DB v19 마이그레이션이 session_wallets 테이블을 생성한다"
    - "기존 sessions.wallet_id 데이터가 session_wallets로 무손실 이관된다"
    - "이관 후 모든 세션에 is_default=1 행이 정확히 1개 존재한다"
    - "wallet_id가 NULL인 비정상 세션은 스킵되고 크래시하지 않는다"
    - "4개 신규 에러 코드가 @waiaas/core에서 export된다"
    - "Drizzle 스키마에 sessionWallets 테이블이 정의되고 sessions에서 walletId가 제거된다"
  artifacts:
    - path: "packages/daemon/src/infrastructure/database/schema.ts"
      provides: "sessionWallets Drizzle table definition, sessions without walletId"
      contains: "sessionWallets"
    - path: "packages/daemon/src/infrastructure/database/migrate.ts"
      provides: "v19 migration (session_wallets + data migration + column drop)"
      contains: "version: 19"
    - path: "packages/core/src/errors/error-codes.ts"
      provides: "4 new error codes"
      contains: "WALLET_ACCESS_DENIED"
    - path: "packages/core/src/schemas/session.schema.ts"
      provides: "CreateSessionRequestSchema with walletIds/walletId"
      contains: "walletIds"
  key_links:
    - from: "packages/daemon/src/infrastructure/database/migrate.ts"
      to: "packages/daemon/src/infrastructure/database/schema.ts"
      via: "LATEST_SCHEMA_VERSION sync"
      pattern: "LATEST_SCHEMA_VERSION.*=.*19"
---

<objective>
DB v19 마이그레이션으로 session_wallets junction 테이블을 생성하고 기존 데이터를 이관하며, Drizzle 스키마를 동기화하고, 4개 신규 에러 코드를 추가한다.

Purpose: 세션 1:N 모델의 기반 인프라를 구축하여 Plan 02/03이 서비스 레이어와 API를 구현할 수 있는 토대를 만든다.
Output: v19 마이그레이션, 갱신된 Drizzle 스키마, 4개 에러 코드, 갱신된 CreateSessionRequestSchema
</objective>

<execution_context>
@/Users/minho.yoo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/minho.yoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/objectives/m26-04-multi-wallet-session.md
@packages/daemon/src/infrastructure/database/schema.ts
@packages/daemon/src/infrastructure/database/migrate.ts
@packages/core/src/errors/error-codes.ts
@packages/core/src/schemas/session.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: 4개 신규 에러 코드 + CreateSessionRequestSchema 확장</name>
  <files>
    packages/core/src/errors/error-codes.ts
    packages/core/src/schemas/session.schema.ts
  </files>
  <action>
1. `packages/core/src/errors/error-codes.ts`의 SESSION domain 블록 끝(현재 SESSION_RENEWAL_MISMATCH 뒤)에 4개 에러 코드를 추가한다:

```typescript
WALLET_ACCESS_DENIED: {
  code: 'WALLET_ACCESS_DENIED',
  domain: 'SESSION',
  httpStatus: 403,
  retryable: false,
  message: 'Wallet not accessible from this session',
},
WALLET_ALREADY_LINKED: {
  code: 'WALLET_ALREADY_LINKED',
  domain: 'SESSION',
  httpStatus: 409,
  retryable: false,
  message: 'Wallet already linked to this session',
},
CANNOT_REMOVE_DEFAULT_WALLET: {
  code: 'CANNOT_REMOVE_DEFAULT_WALLET',
  domain: 'SESSION',
  httpStatus: 400,
  retryable: false,
  message: 'Cannot remove default wallet (change default first)',
},
SESSION_REQUIRES_WALLET: {
  code: 'SESSION_REQUIRES_WALLET',
  domain: 'SESSION',
  httpStatus: 400,
  retryable: false,
  message: 'Session must have at least one wallet',
},
```

SESSION domain 카운트 주석이 있으면 (8) -> (12)로 업데이트한다.

2. `packages/core/src/schemas/session.schema.ts`의 CreateSessionRequestSchema를 확장한다. walletIds(복수)를 추가하고 walletId(단수)를 optional로 변경하여 하위 호환을 유지한다:

```typescript
export const CreateSessionRequestSchema = z.object({
  walletId: z.string().uuid().optional(),
  walletIds: z.array(z.string().uuid()).min(1).optional(),
  defaultWalletId: z.string().uuid().optional(),
  ttl: z.number().int().min(300).max(604800).optional(),
  constraints: z.record(z.unknown()).nullable().optional(),
}).refine(
  (data) => data.walletId !== undefined || (data.walletIds !== undefined && data.walletIds.length > 0),
  { message: 'Either walletId or walletIds must be provided' },
);
```

타입도 업데이트: `export type CreateSessionRequest = z.infer<typeof CreateSessionRequestSchema>;`
  </action>
  <verify>
`cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/core` 가 통과한다.
`grep -c 'WALLET_ACCESS_DENIED\|WALLET_ALREADY_LINKED\|CANNOT_REMOVE_DEFAULT_WALLET\|SESSION_REQUIRES_WALLET' packages/core/src/errors/error-codes.ts` 가 4를 반환한다.
  </verify>
  <done>
4개 신규 에러 코드가 ERROR_CODES에 존재하고, CreateSessionRequestSchema가 walletId(단수, optional) + walletIds(복수, optional) + defaultWalletId(optional)를 지원하며, 둘 중 하나는 반드시 제공되어야 하는 refine 검증이 동작한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: DB v19 마이그레이션 + Drizzle 스키마 동기화 + 테스트</name>
  <files>
    packages/daemon/src/infrastructure/database/schema.ts
    packages/daemon/src/infrastructure/database/migrate.ts
    packages/daemon/src/__tests__/schema-compatibility.test.ts
  </files>
  <action>
1. **Drizzle 스키마 변경** (`schema.ts`):

a. `sessions` 테이블에서 `walletId` 컬럼과 관련 인덱스(`idx_sessions_wallet_id`)를 **제거**한다. sessions 테이블 정의의 3번째 필드(walletId)를 삭제하고, 테이블 extra 배열에서 `index('idx_sessions_wallet_id').on(table.walletId)` 를 삭제한다.

b. 새로운 `sessionWallets` junction 테이블을 sessions 정의 바로 뒤에 추가한다:

```typescript
export const sessionWallets = sqliteTable(
  'session_wallets',
  {
    sessionId: text('session_id')
      .notNull()
      .references(() => sessions.id, { onDelete: 'cascade' }),
    walletId: text('wallet_id')
      .notNull()
      .references(() => wallets.id, { onDelete: 'cascade' }),
    isDefault: integer('is_default', { mode: 'boolean' }).notNull().default(false),
    createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  },
  (table) => [
    index('idx_session_wallets_session').on(table.sessionId),
    index('idx_session_wallets_wallet').on(table.walletId),
  ],
);
```

c. 파일 상단 주석의 테이블 수를 14 -> 15로, 설명에 session_wallets를 추가한다.

2. **v19 마이그레이션** (`migrate.ts`):

a. `LATEST_SCHEMA_VERSION`을 18 -> 19로 변경한다.

b. sessions DDL (`getCreateTableStatements()`)에서:
   - `wallet_id TEXT NOT NULL REFERENCES wallets(id) ON DELETE CASCADE,` 줄을 제거한다.
   - sessions 테이블 뒤에 session_wallets CREATE TABLE 문을 추가한다:

```sql
CREATE TABLE IF NOT EXISTS session_wallets (
  session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  wallet_id TEXT NOT NULL REFERENCES wallets(id) ON DELETE CASCADE,
  is_default INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  PRIMARY KEY (session_id, wallet_id)
)
```

c. `getCreateIndexStatements()`에서:
   - `idx_sessions_wallet_id` 인덱스 문을 제거한다.
   - session_wallets 인덱스 2개를 추가한다:
   ```sql
   'CREATE INDEX IF NOT EXISTS idx_session_wallets_session ON session_wallets(session_id)',
   'CREATE INDEX IF NOT EXISTS idx_session_wallets_wallet ON session_wallets(wallet_id)',
   ```

d. 새 마이그레이션 v19를 추가한다. `managesOwnTransaction: true` (12-step 테이블 재생성 필요 - sessions에서 wallet_id 컬럼 제거):

```typescript
MIGRATIONS.push({
  version: 19,
  description: 'Create session_wallets junction table, migrate sessions.wallet_id, drop wallet_id column',
  managesOwnTransaction: true,
  up: (sqlite) => {
    sqlite.exec('BEGIN');
    try {
      // Step 1: Create session_wallets table
      sqlite.exec(`CREATE TABLE session_wallets (
  session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  wallet_id TEXT NOT NULL REFERENCES wallets(id) ON DELETE CASCADE,
  is_default INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  PRIMARY KEY (session_id, wallet_id)
)`);
      sqlite.exec('CREATE INDEX idx_session_wallets_session ON session_wallets(session_id)');
      sqlite.exec('CREATE INDEX idx_session_wallets_wallet ON session_wallets(wallet_id)');

      // Step 2: Migrate existing sessions.wallet_id -> session_wallets (is_default = 1)
      // wallet_id가 NULL인 비정상 세션은 스킵 (WHERE wallet_id IS NOT NULL)
      sqlite.exec(`INSERT INTO session_wallets (session_id, wallet_id, is_default, created_at)
  SELECT id, wallet_id, 1, CAST(strftime('%s', 'now') AS INTEGER)
  FROM sessions
  WHERE wallet_id IS NOT NULL`);

      // Step 3: Recreate sessions table without wallet_id column (12-step)
      sqlite.exec(`CREATE TABLE sessions_new (
  id TEXT PRIMARY KEY,
  token_hash TEXT NOT NULL,
  expires_at INTEGER NOT NULL,
  constraints TEXT,
  usage_stats TEXT,
  revoked_at INTEGER,
  renewal_count INTEGER NOT NULL DEFAULT 0,
  max_renewals INTEGER NOT NULL DEFAULT 30,
  last_renewed_at INTEGER,
  absolute_expires_at INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  source TEXT NOT NULL DEFAULT 'api'
)`);

      // Step 4: Copy data (excluding wallet_id)
      sqlite.exec(`INSERT INTO sessions_new (id, token_hash, expires_at, constraints, usage_stats, revoked_at, renewal_count, max_renewals, last_renewed_at, absolute_expires_at, created_at, source)
  SELECT id, token_hash, expires_at, constraints, usage_stats, revoked_at, renewal_count, max_renewals, last_renewed_at, absolute_expires_at, created_at, source
  FROM sessions`);

      // Step 5: Drop old sessions table
      sqlite.exec('DROP TABLE sessions');

      // Step 6: Rename new table
      sqlite.exec('ALTER TABLE sessions_new RENAME TO sessions');

      // Step 7: Recreate sessions indexes (without wallet_id index)
      sqlite.exec('CREATE INDEX idx_sessions_expires_at ON sessions(expires_at)');
      sqlite.exec('CREATE INDEX idx_sessions_token_hash ON sessions(token_hash)');

      // Step 8: Recreate transactions table to fix FK reference to sessions
      // (sessions was dropped+renamed, need FK reconnection)
      // transactions references sessions(id) ON DELETE SET NULL
      sqlite.exec(`CREATE TABLE transactions_new (
  id TEXT PRIMARY KEY,
  wallet_id TEXT NOT NULL REFERENCES wallets(id) ON DELETE RESTRICT,
  session_id TEXT REFERENCES sessions(id) ON DELETE SET NULL,
  chain TEXT NOT NULL,
  tx_hash TEXT,
  type TEXT NOT NULL CHECK (type IN (${inList(TRANSACTION_TYPES)})),
  amount TEXT,
  to_address TEXT,
  token_mint TEXT,
  contract_address TEXT,
  method_signature TEXT,
  spender_address TEXT,
  approved_amount TEXT,
  parent_id TEXT REFERENCES transactions_new(id) ON DELETE CASCADE,
  batch_index INTEGER,
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN (${inList(TRANSACTION_STATUSES)})),
  tier TEXT CHECK (tier IS NULL OR tier IN (${inList(POLICY_TIERS)})),
  queued_at INTEGER,
  executed_at INTEGER,
  created_at INTEGER NOT NULL,
  reserved_amount TEXT,
  amount_usd REAL,
  reserved_amount_usd REAL,
  error TEXT,
  metadata TEXT,
  network TEXT CHECK (network IS NULL OR network IN (${inList(NETWORK_TYPES)}))
)`);

      sqlite.exec(`INSERT INTO transactions_new (id, wallet_id, session_id, chain, tx_hash, type, amount, to_address, token_mint, contract_address, method_signature, spender_address, approved_amount, parent_id, batch_index, status, tier, queued_at, executed_at, created_at, reserved_amount, amount_usd, reserved_amount_usd, error, metadata, network)
  SELECT id, wallet_id, session_id, chain, tx_hash, type, amount, to_address, token_mint, contract_address, method_signature, spender_address, approved_amount, parent_id, batch_index, status, tier, queued_at, executed_at, created_at, reserved_amount, amount_usd, reserved_amount_usd, error, metadata, network FROM transactions`);
      sqlite.exec('DROP TABLE transactions');
      sqlite.exec('ALTER TABLE transactions_new RENAME TO transactions');

      // Recreate transactions indexes
      sqlite.exec('CREATE INDEX idx_transactions_wallet_status ON transactions(wallet_id, status)');
      sqlite.exec('CREATE INDEX idx_transactions_session_id ON transactions(session_id)');
      sqlite.exec('CREATE UNIQUE INDEX idx_transactions_tx_hash ON transactions(tx_hash)');
      sqlite.exec('CREATE INDEX idx_transactions_queued_at ON transactions(queued_at)');
      sqlite.exec('CREATE INDEX idx_transactions_created_at ON transactions(created_at)');
      sqlite.exec('CREATE INDEX idx_transactions_type ON transactions(type)');
      sqlite.exec('CREATE INDEX idx_transactions_contract_address ON transactions(contract_address)');
      sqlite.exec('CREATE INDEX idx_transactions_parent_id ON transactions(parent_id)');

      sqlite.exec('COMMIT');
    } catch (err) {
      sqlite.exec('ROLLBACK');
      throw err;
    }

    // Re-enable foreign keys and verify integrity
    sqlite.pragma('foreign_keys = ON');
    const fkErrors = sqlite.pragma('foreign_key_check') as unknown[];
    if (fkErrors.length > 0) {
      throw new Error(`FK integrity violation after v19: ${JSON.stringify(fkErrors)}`);
    }
  },
});
```

**주의**: `inList` 헬퍼와 `TRANSACTION_TYPES`, `TRANSACTION_STATUSES`, `POLICY_TIERS`, `NETWORK_TYPES`는 이미 migrate.ts 상단에 import 되어 있다.

3. **스키마 호환성 테스트 업데이트** (`schema-compatibility.test.ts`):
기존 테스트에서 `LATEST_SCHEMA_VERSION`이 18로 하드코딩된 곳이 있으면 19로 업데이트한다. 마이그레이션 v19 데이터 이관 검증 테스트를 추가한다:
- 세션 100개 생성 -> 마이그레이션 -> session_wallets 행 수 = 세션 수 assert
- 이관 후 모든 세션에 is_default=1 행이 정확히 1개 assert
- wallet_id가 NULL인 비정상 세션 -> 마이그레이션 시 스킵, 크래시 없음 assert
- 마이그레이션 후 sessions 테이블에 wallet_id 컬럼이 없음 assert

4. **Drizzle schema.ts 코드 동기화 주의사항**:
- 파일 상단의 테이블 수 주석 업데이트 (14 tables -> 15 tables, session_wallets 추가)
- sessions export에서 walletId 제거 시, 이 필드를 참조하는 다른 파일에서 컴파일 에러가 발생할 것이다. **이 Plan에서는 schema와 migration만 변경하고, 컴파일 에러는 Plan 02에서 수정한다.** 따라서 typecheck는 daemon 패키지가 아닌 core 패키지만 확인한다.
  </action>
  <verify>
1. `cd /Users/minho.yoo/dev/wallet/WAIaaS && pnpm turbo run typecheck --filter=@waiaas/core` 통과
2. `pnpm vitest run packages/daemon/src/__tests__/schema-compatibility.test.ts` 통과
3. `grep 'LATEST_SCHEMA_VERSION' packages/daemon/src/infrastructure/database/migrate.ts` 에서 19 확인
4. `grep 'session_wallets' packages/daemon/src/infrastructure/database/schema.ts` 에서 결과 있음
5. `grep -c 'wallet_id' packages/daemon/src/infrastructure/database/schema.ts` 에서 sessions 테이블의 walletId가 제거되었지만 다른 테이블(transactions, wallets 등)의 walletId는 유지됨 확인
  </verify>
  <done>
LATEST_SCHEMA_VERSION=19이고, v19 마이그레이션이 (1) session_wallets 테이블 생성 (2) 기존 sessions.wallet_id를 session_wallets로 이관 (3) sessions에서 wallet_id 컬럼 제거를 수행한다. Drizzle schema.ts에 sessionWallets 테이블이 정의되고 sessions에서 walletId가 제거되었다. 스키마 호환성 테스트가 통과한다.
  </done>
</task>

</tasks>

<verification>
1. Core 패키지 typecheck 통과: `pnpm turbo run typecheck --filter=@waiaas/core`
2. 마이그레이션 테스트 통과: `pnpm vitest run packages/daemon/src/__tests__/schema-compatibility.test.ts`
3. `LATEST_SCHEMA_VERSION`이 19
4. `ERROR_CODES`에 4개 신규 에러 코드 존재
5. `CreateSessionRequestSchema`가 walletIds/walletId 둘 다 지원
6. Drizzle `sessionWallets` 테이블 정의 존재, `sessions`에서 walletId 제거
</verification>

<success_criteria>
- DB v19 마이그레이션이 in-memory DB에서 성공적으로 실행되고 FK integrity check 통과
- 기존 session 데이터가 session_wallets로 이관되어 is_default=1 불변량 보장
- 4개 신규 에러 코드가 @waiaas/core에서 import 가능
- CreateSessionRequestSchema가 walletIds 복수와 walletId 단수를 모두 허용
</success_criteria>

<output>
After completion, create `.planning/phases/210-session-model-restructure/210-01-SUMMARY.md`
</output>
